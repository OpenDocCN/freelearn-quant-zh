- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Modeling Volatility with GARCH Class Models
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GARCH 类模型对波动性建模
- en: In *Chapter 6*, *Time Series Analysis and Forecasting*, we looked at various
    approaches to modeling time series. However, models such as **ARIMA** (**Autoregressive
    Integrated Moving Average**) cannot account for volatility that is not constant
    over time (heteroskedastic). We have already explained that some transformations
    (such as log or Box-Cox transformations) can be used to adjust for modest changes
    in volatility, but we would like to go a step further and model it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第六章*，*时间序列分析与预测*中，我们探讨了多种时间序列建模方法。然而，像**ARIMA**（**自回归积分滑动平均**）这样的模型无法解释随时间变化的非恒定波动性（异方差性）。我们已经解释过，一些变换（如对数变换或
    Box-Cox 变换）可以用于调整轻微的波动性变化，但我们希望更进一步，对其进行建模。
- en: In this chapter, we focus on **conditional heteroskedasticity**, which is a
    phenomenon caused when an increase in volatility is correlated with a further
    increase in volatility. An example might help to understand this concept. Imagine
    the price of an asset going down significantly due to some breaking news related
    to the company. Such a sudden price drop could trigger certain risk management
    tools of investment funds, which start selling the stocks as a result of the previous
    decrease in price. This could result in the price plummeting even further. Conditional
    heteroskedasticity was also clearly visible in the *Investigating stylized facts
    of asset returns* recipe, in which we showed that returns exhibit volatility clustering.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们专注于**条件异方差性**，这是一种当波动性增加时，与波动性的进一步增加相关联的现象。一个例子可能有助于理解这一概念。假设由于某些与公司相关的突发新闻，某项资产的价格大幅下跌。这种突然的价格下跌可能会触发某些投资基金的风险管理工具，导致它们开始卖出股票，以应对前期价格下跌。这可能会导致价格进一步暴跌。条件异方差性在*研究资产回报的风格化事实*这一章节中也表现得十分明显，我们展示了回报率呈现波动性聚集现象。
- en: We would like to briefly explain the motivation for this chapter. Volatility
    is an incredibly important concept in finance. It is synonymous with risk and
    has many applications in quantitative finance. Firstly, it is used in options
    pricing, as the Black-Scholes model relies on the volatility of the underlying
    asset. Secondly, volatility has a significant impact on risk management, where
    it is used to calculate metrics such as the **Value-at-Risk** (**VaR**) of a portfolio,
    the Sharpe ratio, and many more. Thirdly, volatility is also present in trading.
    Normally, traders make decisions based on predictions of the assets’ prices either
    rising or falling. However, we can also trade based on predicting whether there
    will be movement in any direction, that is, whether there will be volatility.
    **Volatility trading** is particularly appealing when certain world events (for
    example, pandemics) are driving markets to move erratically. An example of a product
    interesting to volatility traders might be the **Volatility Index** (**VIX**),
    which is based on the movements of the S&P 500 index.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想简要说明本章的动机。波动性是金融中一个极其重要的概念，它与风险同义，并在量化金融中有广泛应用。首先，它在期权定价中至关重要，因为布莱克-斯科尔斯模型依赖于标的资产的波动性。其次，波动性对风险管理有重大影响，它被用来计算投资组合的**风险价值**（**VaR**）、夏普比率等多个指标。第三，波动性也出现在交易中。通常，交易者基于对资产价格上升或下降的预测来做决策。然而，我们也可以根据预测是否存在任何方向的波动来进行交易，即是否会有波动性。**波动性交易**在某些全球事件（例如疫情）导致市场剧烈波动时尤为吸引人。对于波动性交易者来说，一个可能感兴趣的产品是**波动性指数**（**VIX**），它基于标普500指数的波动。
- en: By the end of the chapter, we will have covered a selection of GARCH (Generalized
    AutoregressiveConditional Heteroskedasticity) models—both univariate and multivariate—which
    are some of the most popular ways of modeling and forecasting volatility. Knowing
    the basics, it is quite simple to implement more advanced models. We have already
    mentioned the importance of volatility in finance. By knowing how to model it,
    we can use such forecasts to replace the previously used naïve ones in many practical
    use cases in the fields of risk management or derivatives valuation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将介绍一系列 GARCH（广义自回归条件异方差）模型——包括单变量和多变量模型——它们是建模和预测波动性最流行的方法之一。掌握了基础知识后，实施更高级的模型变得相当简单。我们已经提到过波动性在金融中的重要性，通过了解如何对其进行建模，我们可以使用这些预测来替代许多实际应用中，风险管理或衍生品估值中之前使用的简单预测。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Modeling stock returns’ volatility with ARCH models
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ARCH模型对股票收益波动性建模
- en: Modeling stock returns’ volatility with GARCH models
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GARCH模型对股票收益波动性建模
- en: Forecasting volatility using GARCH models
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GARCH模型预测波动性
- en: Multivariate volatility forecasting with the CCC-GARCH model
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CCC-GARCH模型进行多元波动性预测
- en: Forecasting the conditional covariance matrix using DCC-GARCH
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DCC-GARCH预测条件协方差矩阵
- en: Modeling stock returns’ volatility with ARCH models
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ARCH模型对股票收益波动性建模
- en: In this recipe, we approach the problem of modeling the conditional volatility
    of stock returns with the **Autoregressive Conditional Heteroskedasticity** (**ARCH**)
    model.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本篇中，我们通过**自回归条件异方差**（**ARCH**）模型来研究股票收益条件波动性的建模问题。
- en: 'To put it simply, the ARCH model expresses the variance of the error term as
    a function of past errors. To be a bit more precise, it assumes that the variance
    of the errors follows an autoregressive model. The entire logic of the ARCH method
    can be represented by the following equations:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，ARCH模型将误差项的方差表示为过去误差的函数。更准确地说，它假设误差的方差遵循自回归模型。ARCH方法的整个逻辑可以通过以下方程表示：
- en: '![](../Images/B18112_09_001.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_001.png)'
- en: '![](../Images/B18112_09_002.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_002.png)'
- en: '![](../Images/B18112_09_003.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_003.png)'
- en: The first equation represents the return series as a combination of the expected
    return μ and the unexpected return ![](../Images/B18112_09_004.png). ![](../Images/B18112_09_005.png)
    has white noise properties—the conditional mean equal to zero and the time-varying
    conditional variance ![](../Images/B18112_09_006.png).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方程将收益序列表示为期望收益μ和意外收益的组合！[](../Images/B18112_09_004.png)。！[](../Images/B18112_09_005.png)具有白噪声特性——条件均值为零，并且具有时变的条件方差！[](../Images/B18112_09_006.png)。
- en: Error terms are serially uncorrelated but do not need to be serially independent,
    as they can exhibit conditional heteroskedasticity.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 误差项是序列无相关的，但不需要是序列独立的，因为它们可能表现出条件异方差性。
- en: '![](../Images/B18112_09_007.png) is also known as the mean-corrected return,
    error term, innovations, or—most commonly—residuals.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/B18112_09_007.png)也被称为均值修正收益、误差项、创新或——最常见的——残差。'
- en: 'In general, ARCH (and GARCH) models should only be fitted to the residuals
    of some other model applied to the original time series. When estimating volatility
    models, we can assume different specifications of the mean process, for example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，ARCH（以及GARCH）模型应仅对应用于原始时间序列的其他模型的残差进行拟合。在估计波动性模型时，我们可以假设均值过程的不同规格，例如：
- en: A zero-mean process—this implies that the returns are only described by the
    residuals, for example, ![](../Images/B18112_09_008.png)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零均值过程——这意味着收益仅由残差描述，例如！[](../Images/B18112_09_008.png)
- en: A constant mean process (![](../Images/B18112_09_009.png))
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个常数均值过程（！[](../Images/B18112_09_009.png)）
- en: Mean estimated using linear models such as AR, ARMA, ARIMA, or the more recent
    heterogeneous autoregressive (HAR) process
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线性模型（如AR、ARMA、ARIMA或更新的异质自回归（HAR）过程）估计均值
- en: In the second equation, we represent the error series in terms of a stochastic
    component ![](../Images/B18112_09_010.png) and a conditional standard deviation
    ![](../Images/B18112_09_011.png), which governs the typical size of the residuals.
    The stochastic component can also be interpreted as standardized residuals.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个方程中，我们将误差序列表示为一个随机成分！[](../Images/B18112_09_010.png)和一个条件标准差！[](../Images/B18112_09_011.png)，后者控制残差的典型大小。随机成分也可以解释为标准化残差。
- en: 'The third equation presents the ARCH formula, where ![](../Images/B18112_09_012.png)
    and ![](../Images/B18112_09_013.png). Some important points about the ARCH model
    include:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个方程展示了ARCH公式，其中！[](../Images/B18112_09_012.png)和！[](../Images/B18112_09_013.png)。关于ARCH模型的一些重要点包括：
- en: The ARCH model explicitly recognizes the difference between the unconditional
    and the conditional variance of the time series.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARCH模型明确识别了时间序列的无条件方差和条件方差之间的差异。
- en: It models the conditional variance as a function of past residuals (errors)
    from a mean process.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将条件方差建模为过去残差（误差）的函数，这些残差来自均值过程。
- en: It assumes the unconditional variance to be constant over time.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它假设无条件方差在时间上是恒定的。
- en: The ARCH model can be estimated using the ordinary least squares (OLS) method.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用普通最小二乘法（OLS）方法估计ARCH模型。
- en: We must specify the number of prior residuals (*q*) in the model—similarly to
    the AR model.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须在模型中指定先前残差的数量（*q*）——类似于AR模型。
- en: The residuals should look like observations of a discrete white noise—zero-mean
    and stationary (no trends or seasonal effects, that is, no evident serial correlation).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 残差应呈现出离散白噪声的观察形式——零均值且平稳（没有趋势或季节性效应，即没有明显的序列相关性）。
- en: In the original ARCH notation, as well as in the `arch` library in Python, the
    lag hyperparameter is denoted with *p*. However, we use *q* as the corresponding
    symbol, in line with the GARCH notation introduced in the next recipe.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始ARCH符号中，以及在Python的`arch`库中，滞后超参数用*p*表示。然而，我们使用*q*作为相应的符号，与接下来介绍的GARCH符号一致。
- en: The biggest strength of the ARCH model is that the volatility estimates it produces
    exhibit excess kurtosis (fat tails as compared to Normal distribution), which
    is in line with the empirical observations about stock returns. Naturally, there
    are also weaknesses. The first one is that the model assumes the same effects
    of positive and negative volatility shocks, which is simply not the case. Secondly,
    it does not explain variations in volatility. That is why the model is likely
    to over-forecast volatility, as it is slow to respond to large, isolated shocks
    in the returns series.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ARCH模型的最大优点是，它所生成的波动率估计呈现出过度峰度（相比正态分布有更胖的尾部），这与股票回报的经验观察一致。当然，它也有缺点。第一个缺点是，该模型假设正负波动冲击的效应相同，但实际上并非如此。其次，它没有解释波动率的变化。这也是为什么该模型可能会过度预测波动率，因为它对回报序列中大规模孤立冲击的响应较慢。
- en: In this recipe, we fit the ARCH(1) model to Google’s daily stock returns from
    the years 2015 to 2021.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将ARCH(1)模型拟合到2015至2021年间谷歌的每日股票回报数据。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following steps to fit the ARCH(1) model:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来拟合ARCH(1)模型：
- en: 'Import the libraries:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入库：
- en: '[PRE0]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Specify the risky asset and the time horizon:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定风险资产和时间跨度：
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Download data from Yahoo Finance:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Yahoo Finance下载数据：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Calculate the daily returns:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每日回报：
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Running the code generates the following plot:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码后生成以下图表：
- en: '![](../Images/B18112_09_01.png)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_01.png)'
- en: 'Figure 9.1: Google’s simple returns from the years 2015 to 2021'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.1：2015至2021年间谷歌的简单回报
- en: In the plot, we can observe a few sudden spikes and clear examples of volatility
    clustering.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在图表中，我们可以观察到一些突如其来的尖峰和明显的波动率聚集现象。
- en: 'Specify the ARCH model:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定ARCH模型：
- en: '[PRE4]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Estimate the model and print the summary:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 估计模型并打印摘要：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running the code returns the following summary:'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码后返回以下摘要：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Plot the residuals and the conditional volatility:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制残差和条件波动率：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running the code results in the following plots:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码后生成以下图表：
- en: '![](../Images/B18112_09_02.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_02.png)'
- en: 'Figure 9.2: Standardized residuals and the annualized conditional volatility
    of the fitted ARCH model'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：标准化残差和拟合ARCH模型的年化条件波动率
- en: We can observe some standardized residuals that are large (in magnitude) and
    correspond to highly volatile periods.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到一些标准化残差值较大（绝对值大），并且对应于高波动期。
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *Steps 2* to *4*, we downloaded Google’s daily stock prices and calculated
    simple returns. When working with ARCH/GARCH models, convergence warnings are
    likely to occur in the case of very small numbers. This is caused by instabilities
    in the underlying optimization algorithms of the `scipy` library. To overcome
    this issue, we multiplied the returns by 100 to express them as percentages.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*到*4*中，我们下载了谷歌的每日股票价格并计算了简单回报。在使用ARCH/GARCH模型时，当数值非常小的时候，可能会出现收敛警告。这是由于`scipy`库中底层优化算法的不稳定性。为了解决这个问题，我们将回报乘以100，转化为百分比表示。
- en: In *Step 5*, we defined the ARCH(1) model. For the mean model, we selected the
    zero-mean approach, which is suitable for many liquid financial assets. Another
    viable choice here could be a constant mean. We can use those approaches as opposed
    to, for example, ARMA models because the serial dependence of the return series
    might be very limited.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们定义了ARCH(1)模型。对于均值模型，我们选择了零均值方法，这对于许多流动性较高的金融资产是适用的。另一个可行的选择是常数均值。我们可以选择这些方法，而不是例如ARMA模型，因为回报序列的序列依赖性可能非常有限。
- en: 'In *Step 6*, we fitted the model using the `fit` method. Additionally, we passed
    `disp="off"` to the `fit` method to suppress output from the optimization steps.
    To fit the model using the `arch` library, we had to take similar steps to the
    familiar `scikit-learn` approach: we first defined the model and then fitted it
    to the data. One difference would be the fact that with `arch`, we had to provide
    the data object while creating the instance of the model, instead of passing it
    to the `fit` method as we would have done in `scikit-learn`. Then, we printed
    the model’s summary by using the `summary` method.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们使用`fit`方法拟合了模型。此外，我们将`disp="off"`传递给`fit`方法，以抑制优化步骤中的输出。为了使用`arch`库拟合模型，我们需要采取与熟悉的`scikit-learn`方法类似的步骤：我们首先定义模型，然后将其拟合到数据上。一个区别是，在`arch`中，我们在创建模型实例时就必须提供数据对象，而不是像在`scikit-learn`中那样将数据传递给`fit`方法。然后，我们使用`summary`方法打印了模型的摘要。
- en: In *Step 7*, we also inspected the standardized residuals and the conditional
    volatility series by plotting them. The standardized residuals were computed by
    dividing the residuals by the conditional volatility. We passed `annualize="D"`
    to the `plot` method in order to annualize the conditional volatility series from
    daily data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7*中，我们还通过绘制图形检查了标准化残差和条件波动率序列。标准化残差是通过将残差除以条件波动率来计算的。我们将`annualize="D"`传递给`plot`方法，以便将条件波动率序列从日数据年化。
- en: There’s more...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'A few more noteworthy points about ARCH models:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 关于ARCH模型的几点注意事项：
- en: Selecting the zero-mean process is useful when working on residuals from a separately
    estimated model.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择零均值过程在处理来自单独估计模型的残差时非常有用。
- en: To detect ARCH effects, we can look at the correlogram of the squared residuals
    from a certain model (such as the ARIMA model). We need to make sure that the
    mean of these residuals is equal to zero. We can use the Partial Autocorrelation
    Function (PACF) plot to infer the value of *q*, similarly to the approach used
    in the case of the AR model (please refer to the *Modeling time series with ARIMA
    class models* recipe for more details).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了检测ARCH效应，我们可以观察某个模型（如ARIMA模型）残差平方的自相关图。我们需要确保这些残差的均值为零。我们可以使用偏自相关函数（PACF）图来推断*q*的值，这与AR模型的处理方法类似（更多细节请参阅*使用ARIMA类模型建模时间序列*的相关内容）。
- en: To test the validity of the model, we can inspect whether the standardized residuals
    and squared standardized residuals exhibit no serial autocorrelation (for example,
    using the Ljung-Box or Box-Pierce test with the `acorr_ljungbox` function from
    `statsmodels`). Alternatively, we can employ the **Lagrange Multiplier test**
    (the LM test, also known as Engle’s Test for Autoregressive Conditional Heteroscedasticity)
    to make sure that the model captures all ARCH effects. To do so, we can use the
    `het_arch` function from `statsmodels`.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了检验模型的有效性，我们可以检查标准化残差和标准化残差的平方是否没有序列自相关（例如，使用`statsmodels`中的`acorr_ljungbox`函数，进行Ljung-Box或Box-Pierce检验）。或者，我们可以使用**拉格朗日乘子检验**（LM检验，也称为恩格尔自回归条件异方差性检验）来确保模型捕捉到所有ARCH效应。为此，我们可以使用`statsmodels`中的`het_arch`函数。
- en: 'In the following snippet, we test the residuals of the ARCH model with the
    LM test:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们使用LM检验对ARCH模型的残差进行检验：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running the code returns the following tuple:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会返回以下元组：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first two values in the tuple are the LM test statistic and its corresponding
    p-value. The latter two are the f-statistic for the F test (an alternative approach
    to testing for ARCH effects) and its corresponding p-value. We can see that both
    p-values are below the customary significance level of 0.05, which leads us to
    reject the null hypothesis stating that the residuals are homoskedastic. This
    means that the ARCH(1) model fails to capture all ARCH effects in the residuals.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 元组中的前两个值是LM检验统计量及其对应的p值。后两个是F检验的f统计量（另一种检测ARCH效应的方法）及其对应的p值。我们可以看到，这两个p值都低于常见的显著性水平0.05，这使我们能够拒绝原假设，即残差是同方差的。这意味着ARCH(1)模型未能捕捉到残差中的所有ARCH效应。
- en: The documentation of the `het_arch` function suggests that if the residuals
    are coming from a regression model, we should correct for the number of estimated
    parameters in that model. For example, if the residuals were coming from an ARMA(2,
    1) model, we should pass an additional argument to the `het_arch` function, `ddof
    = 3`, where `ddof` stands for the degrees of freedom.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`het_arch`函数的文档建议，如果残差来自回归模型，则应修正该模型中估计的参数数量。例如，如果残差来自ARMA(2, 1)模型，则应将额外的参数`ddof
    = 3`传递给`het_arch`函数，其中`ddof`表示自由度。'
- en: See also
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'Additional resources are available here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有更多资源：
- en: 'Engle, R. F. 1982., “Autoregressive conditional heteroscedasticity with estimates
    of the variance of United Kingdom inflation,” *Econometrica*, 50(4): 987-1007'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Engle, R. F. 1982年，“具有英国通货膨胀方差估计的自回归条件异方差模型”，*Econometrica*，50(4): 987-1007'
- en: Modeling stock returns’ volatility with GARCH models
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GARCH模型对股票收益的波动性进行建模
- en: In this recipe, we present how to work with an extension of the ARCH model,
    namely the **Generalized Autoregressive Conditional Heteroskedasticity** (**GARCH**)
    model. GARCH can be considered an ARMA model applied to the variance of a time
    series—the AR component was already expressed in the ARCH model, while GARCH additionally
    adds the moving average part.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们展示了如何使用ARCH模型的扩展——**广义自回归条件异方差**（**GARCH**）模型。GARCH可以看作是应用于时间序列方差的ARMA模型——ARCH模型已经表达了AR部分，而GARCH则额外加入了移动平均部分。
- en: 'The equation of the GARCH model can be presented as:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: GARCH模型的方程可以表示为：
- en: '![](../Images/B18112_09_001.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_001.png)'
- en: '![](../Images/B18112_09_002.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_002.png)'
- en: '![](../Images/B18112_09_016.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_016.png)'
- en: 'While the interpretation is very similar to the ARCH model presented in the
    previous recipe, the difference lies in the last equation, where we can observe
    an additional component. Parameters are constrained to meet the following: ![](../Images/B18112_09_017.png),
    and ![](../Images/B18112_09_018.png).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其解释与前述ARCH模型非常相似，但不同之处在于最后一个方程，其中可以看到一个额外的组件。参数受到约束，以满足以下条件：![](../Images/B18112_09_017.png)，并且![](../Images/B18112_09_018.png)。
- en: In the GARCH model, there are additional constraints on coefficients. For example,
    in the case of a GARCH(1,1) model, ![](../Images/B18112_09_019.png) must be less
    than 1\. Otherwise, the model is unstable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在GARCH模型中，系数有额外的约束。例如，在GARCH(1,1)模型中，![](../Images/B18112_09_019.png)必须小于1。否则，模型将不稳定。
- en: 'The two hyperparameters of the GARCH model can be described as:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: GARCH模型的两个超参数可以描述为：
- en: '*p:* The number of lag variances'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*p:* 滞后方差的数量'
- en: '*q:* The number of lag residual errors from a mean process'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*q:* 来自均值过程的滞后残差误差的数量'
- en: A GARCH(0, *q*) model is equivalent to an ARCH(q) model.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: GARCH(0, *q*)模型等价于ARCH(q)模型。
- en: One way of inferring the lag orders for ARCH/GARCH models is to use the squared
    residuals from a model used to predict the mean of the original time series. As
    the residuals are centered around zero, their squares correspond to their variance.
    We can inspect the ACF/PACF plots of the squared residuals in order to identify
    patterns in the autocorrelation of the series’ variance (similarly to what we
    have done to identify the orders of an ARMA/ARIMA model).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 推断ARCH/GARCH模型的滞后阶数的一种方法是使用来自预测原始时间序列均值的模型的平方残差。由于残差围绕零中心分布，它们的平方对应于它们的方差。我们可以检查平方残差的ACF/PACF图，以识别序列方差自相关的模式（类似于我们在识别ARMA/ARIMA模型阶数时所做的）。
- en: In general, the GARCH model shares the strengths and weaknesses of the ARCH
    model, with the difference that it better captures the effects of past shocks.
    Please see the *There’s more...* section to learn about some extensions of the
    GARCH model that account for the original model’s shortcomings.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，GARCH模型继承了ARCH模型的优点和缺点，不同之处在于它更好地捕捉到过去冲击的影响。请参见*更多内容*部分，了解一些弥补原始模型缺点的GARCH模型扩展。
- en: In this recipe, we apply the GARCH(1,1) model to the same data as in the previous
    recipe, in order to clearly highlight the difference between the two modeling
    approaches.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将GARCH(1,1)模型应用于与之前教程相同的数据，以清晰地突出两种建模方法之间的差异。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到……
- en: 'Execute the following steps to estimate the GARCH(1,1) model in Python:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在Python中估计GARCH(1,1)模型：
- en: 'Specify the GARCH model:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定GARCH模型：
- en: '[PRE10]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Estimate the model and print the summary:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 估计模型并打印摘要：
- en: '[PRE11]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running the code returns the following summary:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码后返回以下摘要：
- en: '[PRE12]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: According to *Market Risk Analysis*, the usual range of values of the parameters
    in a stable market would be ![](../Images/B18112_09_020.png) and ![](../Images/B18112_09_021.png).
    However, we should keep in mind that while these ranges will most likely not strictly
    apply, they already give us some idea of what kinds of values we should be expecting.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据 *市场风险分析*，在稳定市场中，参数的常见取值范围为 ![](../Images/B18112_09_020.png) 和 ![](../Images/B18112_09_021.png)。然而，我们应该记住，尽管这些范围不太可能严格适用，但它们已经为我们提供了一些我们应期望的值的线索。
- en: We can see that, compared to the ARCH model, the log-likelihood increased, which
    means that the GARCH model fits the data better. However, we should be cautious
    when drawing such conclusions. The log-likelihood will most likely increase every
    time we add more predictors (as we have done with GARCH). In case the number of
    predictors changes, we should run a likelihood-ratio test in order to compare
    the goodness-of-fit criteria of two nested regression models.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到，与 ARCH 模型相比，log-likelihood 增加了，这意味着 GARCH 模型更好地拟合了数据。然而，我们在得出这样的结论时应谨慎。每当我们增加更多预测变量时（如我们在
    GARCH 中所做的），log-likelihood 很可能会增加。如果预测变量的数量发生变化，我们应进行似然比检验，以比较两个嵌套回归模型的拟合优度标准。
- en: 'Plot the residuals and the conditional volatility:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制残差和条件波动率：
- en: '[PRE13]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the plots below, we can observe the effect of including the extra component
    (lagged conditional volatility) into the model specification:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下图中，我们可以观察到将额外的成分（滞后的条件波动率）纳入模型规范后的效果：
- en: '![](../Images/B18112_09_03.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_03.png)'
- en: 'Figure 9.3: Standardized residuals and the annualized conditional volatility
    of the fitted GARCH model'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：拟合的 GARCH 模型的标准化残差和年化条件波动率
- en: When using ARCH, the conditional volatility series exhibits many spikes, and
    then immediately returns to a low level. In the case of GARCH, as the model also
    includes lagged conditional volatility, it takes more time to return to the level
    observed before the spike.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ARCH 时，条件波动率序列会出现许多峰值，然后立即回落到较低水平。在 GARCH 的情况下，由于模型还包括滞后的条件波动率，因此它需要更多的时间才能回到峰值前观察到的水平。
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we used the same data as in the previous one to compare the
    results of the ARCH and GARCH models. For more information on downloading data,
    please refer to *Steps 1* to *4* in the *Modeling stock returns’ volatility with
    ARCH models* recipe.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中，我们使用了与之前相同的数据来比较 ARCH 和 GARCH 模型的结果。有关下载数据的更多信息，请参阅 *建模股票收益波动率（ARCH 模型）*
    中的 *步骤 1* 至 *4*。
- en: 'Due to the convenience of the `arch` library, it was very easy to adjust the
    code used previously to fit the ARCH model. To estimate the GARCH model, we had
    to specify the type of volatility model we wanted to use and set an additional
    argument: `q=1`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `arch` 库的便利性，调整先前用于拟合 ARCH 模型的代码变得非常容易。为了估计 GARCH 模型，我们必须指定想要使用的波动率模型类型，并设置一个额外的参数：`q=1`。
- en: For comparison’s sake, we left the mean process as a zero-mean process.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较，我们将均值过程保持为零均值过程。
- en: There’s more...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this chapter, we have already used two models to explain and potentially
    forecast the conditional volatility of a time series. However, there are numerous
    extensions of the GARCH model, as well as different configurations with which
    we can experiment in order to find the best-fitting model.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经使用了两个模型来解释并可能预测时间序列的条件波动率。然而，GARCH 模型有许多扩展版本，以及不同的配置，供我们实验以找到最适合的数据模型。
- en: In the GARCH framework, aside from the hyperparameters (such as *p* and *q*,
    in the case of the vanilla GARCH model), we can modify the models described next.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GARCH 框架中，除了超参数（例如在普通 GARCH 模型中 *p* 和 *q*），我们还可以修改接下来描述的模型。
- en: Conditional mean model
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件均值模型
- en: 'As explained before, we apply the GARCH class models to residuals obtained
    after fitting another model to the series. Some popular choices for the mean model
    are:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将 GARCH 类模型应用于在拟合其他模型之后获得的残差。均值模型的一些流行选择包括：
- en: Zero-mean
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零均值
- en: Constant mean
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常数均值
- en: Any variant of the ARIMA model (including potential seasonality adjustment,
    as well as external regressors)—some popular choices in the literature are ARMA
    or even AR models
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARIMA 模型的任何变体（包括可能的季节性调整，以及外部回归变量）——文献中一些流行的选择包括 ARMA 甚至 AR 模型
- en: Regression models
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归模型
- en: We should be aware of one thing when modeling the conditional mean. For example,
    we may first fit an ARMA model to our time series and then fit a GARCH model to
    the residuals of the first model. However, this is not the preferred way. That
    is because, in general, the ARMA estimates will be inconsistent (or consistent
    but inefficient, in the case when there are only AR terms and no MA terms), which
    will also impact the following GARCH estimates. The inconsistency arises because
    the first model (ARMA/ARIMA) assumes conditional homoskedasticity, while we are
    explicitly modeling conditional heteroskedasticity with the GARCH model in the
    second step. That is why the preferred way is to estimate both models simultaneously,
    for example, using the `arch` library (or the `rugarch` package for R).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在建模条件均值时，我们需要注意一件事。例如，我们可能先对时间序列拟合ARMA模型，然后对第一个模型的残差拟合GARCH模型。然而，这并不是首选方法。因为通常情况下，ARMA估计值是不一致的（或者在仅有AR项而没有MA项的情况下，即使一致也不高效），这也会影响后续的GARCH估计。由于第一个模型（ARMA/ARIMA）假设条件同方差性，而我们在第二步中用GARCH模型显式建模条件异方差性，因此不一致性会出现。正因为如此，首选方法是同时估计两个模型，例如使用`arch`库（或者R的`rugarch`包）。
- en: Conditional volatility model
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件波动性模型
- en: 'There are numerous extensions to the GARCH framework. Some popular models include:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: GARCH框架有许多扩展。以下是一些常见的模型：
- en: 'GJR-GARCH: A variant of the GARCH model that takes into account the asymmetry
    of the returns (negative returns tend to have a stronger impact on volatility
    than positive ones)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GJR-GARCH：GARCH模型的一种变体，考虑了回报的非对称性（负回报对波动性的影响通常比正回报更强）
- en: 'EGARCH: Exponential GARCH'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EGARCH：指数GARCH
- en: 'TGARCH: Threshold GARCH'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TGARCH：阈值GARCH
- en: 'FIGARCH: Fractionally integrated GARCH, used with non-stationary data'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FIGARCH：分数积分GARCH，用于非平稳数据
- en: 'GARCH-MIDAS: In this class of models, volatility is decomposed into a short-term
    GARCH component and a long-term component driven by an additional explanatory
    variable'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GARCH-MIDAS：在这一类模型中，波动性被分解为短期GARCH成分和由额外解释变量驱动的长期成分
- en: Multivariate GARCH models, such as CCC-/DCC-GARCH
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多元GARCH模型，例如CCC-/DCC-GARCH
- en: The first three models use slightly different approaches to introduce asymmetry
    into the conditional volatility specification. This is in line with the belief
    that negative shocks have a stronger impact on volatility than positive shocks.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前三种模型使用略微不同的方法将非对称性引入条件波动性规范。这与负面冲击对波动性的影响通常强于正面冲击的观点一致。
- en: Distribution of errors
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 误差分布
- en: In the *Investigating stylized facts of asset returns* recipe, we saw that the
    distribution of returns is not Normal (skewed, with heavy tails). That is why
    distributions other than Gaussian might be more fitting for errors in the GARCH
    model.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在*资产回报的样式化事实研究*一节中，我们看到回报的分布并非正态分布（偏斜，且具有重尾）。因此，除了高斯分布外，其他分布可能更适合GARCH模型中的误差。
- en: 'Some possible choices are:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可能的选择包括：
- en: Student’s t-distribution
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学生t分布
- en: Skew-t distribution (Hansen, 1994)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏斜t分布（Hansen, 1994年）
- en: Generalized Error Distribution (GED)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广义误差分布（GED）
- en: Skewed Generalized Error Distribution (SGED)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏斜广义误差分布（SGED）
- en: The `arch` library not only provides most of the models and distributions mentioned
    above, but it also allows for the use of your own volatility models/distributions
    of errors (as long as they fit into a predefined format). For more information
    on this, please refer to the excellent documentation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`arch`库不仅提供了上述大部分模型和分布，它还允许使用自定义的波动性模型/误差分布（只要它们符合预定义格式）。有关更多信息，请参考出色的文档。'
- en: See also
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Additional resources are available here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 额外资源可在此处获得：
- en: Alexander, C. 2008\. *Market Risk Analysis, Practical Financial Econometrics*
    (Vol. 2). John Wiley & Sons.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alexander, C. 2008年。*市场风险分析，实用金融计量经济学*（第2卷）。约翰·威利父子公司。
- en: 'Bollerslev, T., 1986\. “Generalized Autoregressive Conditional Heteroskedasticity.
    *Journal of Econometrics*, 31, (3): 307–327\. : [https://doi.org/10.1016/0304-4076(86)90063-1](https://doi.org/10.1016/0304-4076(86)90063-1)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bollerslev, T., 1986年。“广义自回归条件异方差模型。*计量经济学杂志*，31（3）：307–327。：[https://doi.org/10.1016/0304-4076(86)90063-1](https://doi.org/10.1016/0304-4076(86)90063-1)
- en: 'Glosten, L. R., Jagannathan, R., and Runkle, D. E., 1993\. “On the relation
    between the expected value and the volatility of the nominal excess return on
    stocks,” *The Journal of Finance*, 48 (5): 1779–1801: https://doi.org/10.1111/j.1540-6261.1993.tb05128.x'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Glosten, L. R., Jagannathan, R., and Runkle, D. E., 1993\. “股票的名义超额收益与波动率的关系，”*金融学报*，48
    (5): 1779–1801: https://doi.org/10.1111/j.1540-6261.1993.tb05128.x'
- en: 'Hansen, B. E., 1994\. “Autoregressive conditional density estimation,” *International
    Economic Review*, 35(3): 705–730: https://doi.org/10.2307/2527081'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Hansen, B. E., 1994\. “自回归条件密度估计，”*国际经济评论*，35(3): 705–730: https://doi.org/10.2307/2527081'
- en: Documentation of the `arch` library—[https://arch.readthedocs.io/en/latest/index.html](https://arch.readthedocs.io/en/latest/index.html)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arch` 库的文档—[https://arch.readthedocs.io/en/latest/index.html](https://arch.readthedocs.io/en/latest/index.html)'
- en: Forecasting volatility using GARCH models
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GARCH模型预测波动率
- en: In the previous recipes, we have seen how to fit ARCH/GARCH models to a return
    series. However, the most interesting/relevant case of using ARCH class models
    would be to forecast the future values of the volatility.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的案例中，我们已经看到了如何将ARCH/GARCH模型拟合到收益序列。然而，使用ARCH类模型最有趣/相关的情况是预测波动率的未来值。
- en: 'There are three approaches to forecasting volatility using GARCH class models:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GARCH类模型预测波动率有三种方法：
- en: Analytical — due to the inherent structure of ARCH class models, analytical
    forecasts are always available for the one step-ahead forecast. Multi-step analytical
    forecasts can be obtained using a forward recursion; however, that is only possible
    for models that are linear in the square of the residuals (such as GARCH or Heterogeneous
    ARCH).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析法——由于ARCH类模型的固有结构，分析预测总是可用的，适用于一步前的预测。多步分析预测可以通过前向递归获得；然而，这仅适用于残差平方线性模型（如GARCH或异质ARCH模型）。
- en: Simulation—simulation-based forecasts use the structure of an ARCH class model
    to forward simulate possible volatility paths using the assumed distribution of
    residuals. In other words, they use random number generators (assuming specific
    distributions) to draw the standardized residuals. This approach creates *x* possible
    volatility paths and then produces the average as the final forecast. Simulation-based
    forecasts are always available for any horizon. As the number of simulations increases
    toward infinity, the simulation-based forecasts will converge to the analytical
    forecasts.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟法——基于模拟的预测使用ARCH类模型的结构，通过假设的残差分布向前模拟可能的波动率路径。换句话说，它们使用随机数生成器（假设特定分布）来抽取标准化残差。该方法创建了*x*条可能的波动率路径，然后将其平均作为最终预测。基于模拟的预测总是适用于任何时间范围。随着模拟次数向无穷增加，基于模拟的预测将趋近于分析预测。
- en: Bootstrap (also known as the Filtered Historical Simulation)—those forecasts
    are very similar to the simulation-based forecasts with the difference that they
    generate (to be precise, draw with replacement) the standardized residuals using
    the actual input data and the estimated parameters. This approach requires a minimal
    amount of in-sample data to use prior to producing the forecasts.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自助法（也称为过滤历史模拟法）——这些预测与基于模拟的预测非常相似，不同之处在于它们使用实际输入数据和估计参数生成（准确来说，是有放回抽样）标准化的残差。该方法在生成预测之前，所需的样本内数据量极少。
- en: Due to the specification of ARCH class models, the first out-of-sample forecast
    will always be fixed, regardless of which approach we use.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ARCH类模型的规格，第一次的样本外预测将始终是固定的，无论我们使用哪种方法。
- en: In this recipe, we fit a GARCH(1,1) model with Student’s t distributed residuals
    to Microsoft’s stock returns from the years 2015 to 2020\. Then, we create 3-step
    ahead forecasts for each day of 2021.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本案例中，我们将2015至2020年微软的股票收益拟合到一个GARCH(1,1)模型，并使用学生t分布的残差。然后，我们为2021年的每一天创建了3步前的预测。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following steps to create 3-step ahead volatility forecasts using
    a GARCH model:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以使用GARCH模型创建3步前的波动率预测：
- en: 'Import the libraries:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入库：
- en: '[PRE14]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Download data from Yahoo Finance and calculate simple returns:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Yahoo Finance下载数据并计算简单收益：
- en: '[PRE15]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Specify the GARCH model:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定GARCH模型：
- en: '[PRE16]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Define the split date and fit the model:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义分割日期并拟合模型：
- en: '[PRE17]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create and inspect the analytical forecasts:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并检查分析预测：
- en: '[PRE18]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Running the snippet generates the following plot:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码片段生成以下图表：
- en: '![](../Images/B18112_09_04.png)'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_04.png)'
- en: 'Figure 9.4: Analytical forecasts for horizons 1, 2, and 3'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.4：1、2和3步的分析预测
- en: Using the snippet below, we can inspect the generated forecasts.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用下面的代码片段，我们可以检查生成的预测结果。
- en: '[PRE19]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](../Images/B18112_09_05.png)'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_05.png)'
- en: 'Figure 9.5: Table presenting the analytical forecasts for horizons 1, 2, and
    3'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.5：展示1、2、3期分析预测的表格
- en: Each column contains the *h*-step ahead forecasts generated on the date indicated
    by the index. When the forecasts are created, the date from the `Date` column
    corresponds to the last data point used to generate the forecasts. For example,
    the columns with the date 2021-01-08 contain the forecasts for January 9, 10,
    and 11\. Those forecasts were created using data up to and including January 8.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每一列包含在索引所指示的日期生成的*h*步预测。当预测生成时，`Date`列中的日期对应于用于生成预测的最后一个数据点。例如，日期为2021-01-08的列包含了1月9日、10日和11日的预测。这些预测是使用直到1月8日（包括这一天）的数据生成的。
- en: 'Create and inspect the simulation forecasts:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并检查模拟预测：
- en: '[PRE20]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Running the snippet generates the following plot:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码片段后生成以下图表：
- en: '![](../Images/B18112_09_06.png)'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_06.png)'
- en: 'Figure 9.6: Simulation-based forecasts for horizons 1, 2, and 3'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.6：基于模拟的1、2、3期预测
- en: 'Create and inspect the bootstrap forecasts:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并检查自助法预测：
- en: '[PRE21]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Running the snippet generates the following plot:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码片段后生成以下图表：
- en: '![](../Images/B18112_09_07.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_07.png)'
- en: 'Figure 9.7: Bootstrap-based forecasts for horizons 1, 2, and 3'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7：基于自助法的1、2、3期预测
- en: Inspecting the three plots leads to the conclusion that the shape of the volatility
    forecasts from the three different methods is very similar.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 检查这三个图表后得出的结论是，三种不同方法得到的波动率预测形态非常相似。
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the first two steps, we imported the required libraries and downloaded Microsoft’s
    stock prices from the years 2015 to 2021\. We calculated the simple returns and
    multiplied the values by 100 to avoid potential convergence issues during optimization.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个步骤中，我们导入了所需的库，并下载了2015年至2021年间微软的股票价格。我们计算了简单收益率，并将值乘以100，以避免在优化过程中出现潜在的收敛问题。
- en: In *Step 3*, we specified our GARCH model, that is, a zero-mean GARCH(1, 1)
    with residuals following Student’s t distribution.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们指定了我们的GARCH模型，即零均值的GARCH(1, 1)，且残差服从学生t分布。
- en: In *Step 4*, we defined a date (a `datetime` object) used for splitting the
    training and test sets. Then, we fitted the model using the `fit` method. This
    time, we specified the `last_obs` argument to indicate when the training set ends.
    We passed in the value of `datetime(2021, 1, 1)`, which means that the last observation
    actually used for training would be the last date of December 2020.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们定义了一个日期（`datetime`对象），用于拆分训练集和测试集。然后，我们使用`fit`方法拟合模型。这一次，我们指定了`last_obs`参数，表示训练集的结束时间。我们传入了`datetime(2021,
    1, 1)`，这意味着实际用于训练的最后一个观测值是2020年12月的最后一天。
- en: In *Step 5*, we created the analytical forecasts using the `forecast` method
    of a fitted GARCH model. We specified the forecast horizon and the start date
    (which is the same as the `last_obs`, which we provided when fitting the model).
    Then, we plotted the forecasts for each horizon.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们使用拟合好的GARCH模型的`forecast`方法创建了分析预测。我们指定了预测的期数和起始日期（即与我们在拟合模型时提供的`last_obs`相同）。然后，我们为每个期数绘制了预测图。
- en: 'In general, using the `forecast` method returns an `ARCHModelForecast` object
    with 4 main attributes that we might find useful:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用`forecast`方法会返回一个`ARCHModelForecast`对象，其中包含四个我们可能需要的主要属性：
- en: '`mean`—the forecast of the conditional mean'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mean`—条件均值的预测'
- en: '`variance`—the forecast of the conditional variance of the process'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variance`—过程的条件方差预测'
- en: '`residual_variance`—the forecast of the residual variance. These values will
    differ from the ones stored in `variance` (for horizons larger than 1) whenever
    the model has mean dynamics, for example, an AR process.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`residual_variance`—残差方差的预测。当模型具有均值动态时，例如AR过程，`residual_variance`的值将与`variance`中的值不同（对于期数大于1的情况）。'
- en: '`simulations`—an object containing the individual simulations (only for the
    simulation and bootstrap approaches) used for generating the forecasts.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`simulations`—一个对象，包含了生成预测所用的各个单独的模拟结果（仅适用于模拟和自助法方法）。'
- en: In *Steps 6* and *7*, we generated the analogical 3-step ahead forecasts using
    the simulation and bootstrap methods. We only added the optional `method` argument
    to the `forecast` method to indicate which forecasting approach we would like
    to use. By default, those methods use 1,000 simulations to create the forecasts,
    but we can change this number to our liking.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*和*步骤7*中，我们使用模拟和自助法生成了类比的3步 ahead 预测。我们只需向`forecast`方法中添加可选的`method`参数，指示我们希望使用哪种预测方法。默认情况下，这些方法使用1,000次模拟来生成预测，但我们可以根据需要更改此数字。
- en: There’s more...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: We can quite easily visually compare the differences in the forecasts obtained
    using various forecasting approaches. In this case, we would like to compare the
    analytical and bootstrap approaches over 2020\. We chose 2020 as this was the
    last year used in the training sample.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地直观比较使用不同预测方法得到的预测差异。在这种情况下，我们希望比较2020年内分析法和自助法的预测。我们选择2020年作为训练样本中使用的最后一年。
- en: 'Execute the following steps to compare 10-step ahead volatility forecasts over
    the year 2020:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以比较2020年的10步 ahead 波动率预测：
- en: 'Import the libraries:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的库：
- en: '[PRE22]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Estimate the 10-step ahead volatility forecasts for 2020 using the analytical
    and bootstrap approaches:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用分析法和自助法估算2020年的10步 ahead 波动率预测：
- en: '[PRE23]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: While creating the forecasts, we changed the horizon and the start date. We
    recovered the residual variance from the fitted models, filtered for the forecasts
    made in 2020, and then took the square root to convert the variance into volatility.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在创建预测时，我们改变了预测的时间范围和开始日期。我们从拟合模型中恢复了残差方差，过滤出2020年内的预测，然后取平方根以将方差转换为波动率。
- en: 'Get the conditional volatility for 2020:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取2020年的条件波动率：
- en: '[PRE24]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create the hedgehog plot:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建刺猬图：
- en: '[PRE25]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Running the snippet generates the following plot:'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行该代码片段生成了以下图表：
- en: '![](../Images/B18112_09_08.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_08.png)'
- en: 'Figure 9.8: Comparison of analytical and bootstrap-based approaches to volatility
    forecasting'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：分析方法与基于自助法的波动率预测比较
- en: A hedgehog plot is a useful kind of visualization for showing the differences
    between the two forecasting approaches over a longer period of time. In this case,
    we plotted the 10-step ahead forecasts every 10 days.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 刺猬图是一种有用的可视化方法，用于展示两种预测方法在较长时间段内的差异。在本例中，我们每10天绘制一次10步 ahead 预测。
- en: What is interesting to note is the peak in volatility that occurred in March
    2020\. We can see that close to the peak, the GARCH model is predicting a decrease
    in volatility over the next few days. To get a better understanding of how that
    forecast was created, we can refer to the underlying data. By inspecting the DataFrames
    containing the observed volatility and the forecasts, we can state that the peak
    happened on March 17, while the plotted forecast was created using data up until
    March 16\.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，2020年3月发生了波动率的峰值。我们可以看到，在接近峰值时，GARCH模型预测未来几天波动率将下降。为了更好地理解这个预测是如何生成的，我们可以参考基础数据。通过检查包含观察到的波动率和预测的DataFrame，我们可以得出结论：峰值发生在3月17日，而绘制的预测是使用直到3月16日的数据生成的。
- en: When inspecting a single volatility model at a time, it might be easier to use
    the `hedgehog_plot` method of the fitted `arch_model` to create a similar plot.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在逐个检查单一波动率模型时，使用拟合后的`arch_model`的`hedgehog_plot`方法来创建类似的图表可能会更容易。
- en: Multivariate volatility forecasting with the CCC-GARCH model
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CCC-GARCH模型进行多变量波动率预测
- en: In this chapter, we have already considered multiple univariate conditional
    volatility models. That is why, in this recipe, we move to the multivariate setting.
    As a starting point, we consider Bollerslev’s **Constant Conditional Correlation
    GARCH** (**CCC-GARCH**) model. The idea behind it is quite simple. The model consists
    of *N* univariate GARCH models, related to each other via a constant conditional
    correlation matrix **R**.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经考虑了多个单变量条件波动率模型。这就是为什么在这个方法中，我们转向了多变量设置。作为起点，我们考虑了Bollerslev的**常数条件相关GARCH**（**CCC-GARCH**）模型。其背后的思想相当简单。该模型由*N*个单变量GARCH模型组成，通过一个常数条件相关矩阵**R**相互关联。
- en: 'Like before, we start with the model’s specification:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前一样，我们从模型的规格开始：
- en: '![](../Images/B18112_09_022.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_022.png)'
- en: '![](../Images/B18112_09_023.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_023.png)'
- en: '![](../Images/B18112_09_024.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_024.png)'
- en: In the first equation, we represent the return series. The key difference between
    this representation and the one presented in previous recipes is the fact that
    this time, we are considering multivariate returns. That is why **r**[t] is actually
    a vector of returns **r**[t] = (*r*[1t], …, *r*[nt]). The mean and error terms
    are represented analogically. To highlight this, we use bold font when considering
    vectors or matrices.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个方程中，我们表示回报序列。与先前教程中展示的表示方式的主要区别在于，这次我们考虑的是多变量回报。这就是为什么**r**[t]实际上是一个回报向量**r**[t]
    = (*r*[1t], …, *r*[nt])。均值和误差项的表示方式类似。为了突出这一点，当考虑向量或矩阵时，我们使用粗体字。
- en: The second equation shows that the error terms come from a Multivariate Normal
    distribution with zero means and a conditional covariance matrix ![](../Images/B18112_09_025.png)
    (of size N x N).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方程显示，误差项来自一个均值为零的多变量正态分布，且具有条件协方差矩阵！[](../Images/B18112_09_025.png)（大小为N
    x N）。
- en: 'The elements of the conditional covariance matrix are defined as:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 条件协方差矩阵的元素定义为：
- en: 'Diagonal: ![](../Images/B18112_09_026.png)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对角线：![](../Images/B18112_09_026.png)
- en: 'Off-diagonal: ![](../Images/B18112_09_027.png)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非对角线：![](../Images/B18112_09_027.png)
- en: The third equation presents the decomposition of the conditional covariance
    matrix. **D**[t] represents a matrix containing the conditional standard deviations
    on the diagonal, and **R** is a correlation matrix.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个方程展示了条件协方差矩阵的分解。**D**[t]表示包含对角线上的条件标准差的矩阵，**R**是相关性矩阵。
- en: 'The key ideas of the model are as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型的关键思想如下：
- en: The model avoids the problem of guaranteeing positive definiteness of ![](../Images/B18112_09_028.png)
    by splitting it into variances and correlations.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该模型通过将其分解为方差和相关性，避免了保证正定性问题！[](../Images/B18112_09_028.png)。
- en: The conditional correlations between error terms are constant over time.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 误差项之间的条件相关性随时间保持不变。
- en: Individual conditional variances follow a univariate GARCH(1,1) model.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单独的条件方差遵循单变量GARCH(1,1)模型。
- en: In this recipe, we estimate the CCC-GARCH model on a series of stock returns
    for three US tech companies. For more details about the estimation of the CCC-GARCH
    model, please refer to the *How it works...* section.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们估计了三家美国科技公司股票回报序列的CCC-GARCH模型。有关CCC-GARCH模型估计的更多细节，请参阅*它是如何工作的...*部分。
- en: How to do it...
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following steps to estimate the CCC-GARCH model in Python:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤，在Python中估计CCC-GARCH模型：
- en: 'Import the libraries:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入库：
- en: '[PRE26]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Specify the risky assets and the time horizon:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定风险资产和时间范围：
- en: '[PRE27]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Download data from Yahoo Finance:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Yahoo Finance下载数据：
- en: '[PRE28]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Calculate the daily returns:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每日回报：
- en: '[PRE29]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Running the snippet generates the following plot:'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码片段生成如下图：
- en: '![](../Images/B18112_09_09.png)'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_09.png)'
- en: 'Figure 9.9: Simple returns of Apple, Google, and Microsoft'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.9：苹果、谷歌和微软的简单回报
- en: 'Define lists for storing objects:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义用于存储对象的列表：
- en: '[PRE30]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Estimate the univariate GARCH models:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 估计单变量GARCH模型：
- en: '[PRE31]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Store the results in DataFrames:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果存储在DataFrames中：
- en: '[PRE32]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following table contains the estimated coefficients for each return series:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下表包含每个回报序列的估计系数：
- en: '![](../Images/B18112_09_10.png)'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_10.png)'
- en: 'Figure 9.10: Coefficients of the estimated univariate GARCH models'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.10：估计的单变量GARCH模型系数
- en: 'Calculate the constant conditional correlation matrix (R):'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算常数条件相关性矩阵（R）：
- en: '[PRE33]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Calculate the one-step ahead forecast of the conditional covariance matrix:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算条件协方差矩阵的单步预测：
- en: '[PRE34]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The calculated one-step ahead forecast looks as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 计算的单步预测如下所示：
- en: '[PRE35]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can compare this matrix to the one obtained using a more complex DCC-GARCH
    model, which we cover in the next recipe.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此矩阵与使用更复杂的DCC-GARCH模型得到的矩阵进行比较，后者将在下一个教程中介绍。
- en: How it works...
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *Steps 2* and *Step 3*, we downloaded the daily stock prices of Google, Microsoft,
    and Apple. Then, we calculated simple returns and multiplied them by 100 to avoid
    encountering convergence errors.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*和*步骤3*中，我们下载了谷歌、微软和苹果的每日股价。然后，我们计算了简单回报，并将其乘以100，以避免遇到收敛错误。
- en: 'In *Step 5*, we defined empty lists for storing elements required at later
    stages: GARCH coefficients, conditional volatilities, standardized residuals,
    and the models themselves (used for forecasting).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们定义了空列表，用于存储后续阶段所需的元素：GARCH系数、条件波动性、标准化残差以及模型本身（用于预测）。
- en: In *Step 6*, we iterated over the columns of the DataFrame containing the stock
    returns and fitted a univariate GARCH model to each of the series. We stored the
    results in the predefined lists. Then, we wrangled the data in order to have objects
    such as residuals in DataFrames, to make working with them easier.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们遍历了包含股票回报率的 DataFrame 列，并为每个序列拟合了单变量 GARCH 模型。我们将结果存储在预定义的列表中。然后，我们对数据进行了处理，以便将残差等对象存储在
    DataFrame 中，从而方便后续操作。
- en: 'In *Step 8*,we calculated the constant conditional correlation matrix (**R**)
    as the unconditional correlation matrix of **z**[t]:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤8*中，我们计算了常数条件相关性矩阵 (**R**) 作为 **z**[t] 的无条件相关性矩阵：
- en: '![](../Images/B18112_09_029.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_029.png)'
- en: Here, **z**[t] stands for time *t* standardized residuals from the univariate
    GARCH models.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，**z**[t] 表示来自单变量 GARCH 模型的时间 *t* 标准化残差。
- en: 'In the last step, we obtained one-step ahead forecasts of the conditional covariance
    matrix **H**[t+1]. To do so, we did the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们获得了单步预测的条件协方差矩阵 **H**[t+1]。为此，我们进行了以下操作：
- en: We created a matrix **D**[t+1]of zeros, using `np.zeros`.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `np.zeros` 创建了一个全零矩阵 **D**[t+1]。
- en: We stored the one-step ahead forecasts of conditional variances from univariate
    GARCH models in a list called `diag`.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将单步预测的条件方差（来自单变量 GARCH 模型）存储在一个名为 `diag` 的列表中。
- en: Using `np.fill_diagonal`, we placed the elements of the list called `diag` on
    the diagonal of the matrix **D**[t+1]
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `np.fill_diagonal`，我们将名为 `diag` 的列表中的元素放置到矩阵 **D**[t+1] 的对角线上。
- en: Following equation 3 from the introduction, we obtained the one-step ahead forecast
    using matrix multiplication (`np.matmul`).
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据引言中的方程 3，我们使用矩阵乘法（`np.matmul`）获得了单步预测。
- en: See also
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'Additional resources are available here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 额外资源请见此处：
- en: 'Bollerslev, T.1990\. “Modeling the Coherence in Short-Run Nominal Exchange
    Rates: A Multivariate Generalized ARCH Approach,” *Review of Economics and Statistics*,
    72(3): 498–505: https://doi.org/10.2307/2109358'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bollerslev, T.1990\. “建模短期名义汇率的相干性：一种多元广义 ARCH 方法”，*经济学与统计学评论*，72(3)：498–505：https://doi.org/10.2307/2109358
- en: Forecasting the conditional covariance matrix using DCC-GARCH
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DCC-GARCH 预测条件协方差矩阵
- en: 'In this recipe, we cover an extension of the CCC-GARCH model: Engle’s **Dynamic
    Conditional Correlation GARCH** (**DCC-GARCH**) model. The main difference between
    the two is that in the latter, the conditional correlation matrix is not constant
    over time—we work with **R**[t] instead of **R**.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们介绍了 CCC-GARCH 模型的扩展：Engle 的 **动态条件相关性 GARCH**（**DCC-GARCH**）模型。两者的主要区别在于，后者的条件相关性矩阵随着时间变化——我们使用
    **R**[t] 而不是 **R**。
- en: 'There are some nuances in terms of estimation, but the outline is similar to
    the CCC-GARCH model:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在估计过程中存在一些细节差异，但大体框架与 CCC-GARCH 模型相似：
- en: Estimate the univariate GARCH models for conditional volatility
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估计单变量 GARCH 模型的条件波动率
- en: Estimate the DCC model for conditional correlations
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估计 DCC 模型的条件相关性
- en: In the second step of estimating the DCC model, we use a new matrix **Q**[t],
    representing a proxy correlation process.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在估计 DCC 模型的第二步中，我们使用了一个新的矩阵 **Q**[t]，代表代理相关过程。
- en: '![](../Images/B18112_09_033.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_033.png)'
- en: '![](../Images/B18112_09_034.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_034.png)'
- en: '![](../Images/B18112_09_035.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_035.png)'
- en: The first equation describes the relationship between the conditional correlation
    matrix **R**[t] and the proxy process **Q**[t]. The second equation represents
    the dynamics of the proxy process. The last equation shows the definition of ![](../Images/B18112_09_036.png),
    which is defined as the unconditional correlation matrix of standardized residuals
    from the univariate GARCH models.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方程描述了条件相关性矩阵 **R**[t] 与代理过程 **Q**[t] 之间的关系。第二个方程表示代理过程的动态变化。最后一个方程显示了 ![](../Images/B18112_09_036.png)
    的定义，它被定义为来自单变量 GARCH 模型的标准化残差的无条件相关性矩阵。
- en: 'This representation of the DCC model uses an approach called **correlation
    targeting**. It means that we are effectively reducing the number of parameters
    we need to estimate to two: ![](../Images/B18112_09_043.png) and ![](../Images/B18112_09_044.png).
    This is similar to volatility targeting in the case of univariate GARCH models,
    further described in the *There’s more...* section.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 DCC 模型的表示使用了一种叫做 **相关性目标**的方法。它意味着我们实际上将需要估计的参数数量减少到两个：![](../Images/B18112_09_043.png)
    和 ![](../Images/B18112_09_044.png)。这类似于在单变量 GARCH 模型中的波动率目标，后续会在 *更多内容...* 部分进行详细描述。
- en: At the time of writing, there is no Python library that we can use to estimate
    DCC-GARCH models. One solution would be to write such a library from scratch.
    Another, more time-efficient solution would be to use a well-established R package
    for that task. That is why in this recipe, we also introduce how to efficiently
    make Python and R work together in one Jupyter notebook (this can also be done
    in a normal `.py` script). The `rpy2` library is an interface between both languages.
    It enables us to not only run both R and Python in the same notebook but also
    to transfer objects between the two environments.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，没有可以用来估计DCC-GARCH模型的Python库。一种解决方案是从头开始编写这样的库。另一种更节省时间的解决方案是使用成熟的R包来完成这一任务。这就是为什么在本配方中，我们还介绍了如何在一个Jupyter笔记本中高效地让Python和R一起工作（这也可以在普通的`.py`脚本中完成）。`rpy2`库是两种语言之间的接口。它不仅允许我们在同一个笔记本中运行R和Python，还可以在两个环境之间传递对象。
- en: In this recipe, we use the same data as in the previous one, in order to highlight
    the differences in the approach and results.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们使用了与前一个配方相同的数据，以便突出方法和结果的差异。
- en: Getting ready
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For details on how to easily install R, please refer to the following resources:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何轻松安装R的详细信息，请参考以下资源：
- en: '[https://cran.r-project.org/](https://cran.r-project.org/)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://cran.r-project.org/](https://cran.r-project.org/)'
- en: '[https://docs.anaconda.com/anaconda/user-guide/tasks/using-r-language/](https://docs.anaconda.com/anaconda/user-guide/tasks/using-r-language/)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.anaconda.com/anaconda/user-guide/tasks/using-r-language/](https://docs.anaconda.com/anaconda/user-guide/tasks/using-r-language/)'
- en: If you use `conda` as your package manager, the process of setting everything
    up can be greatly simplified. If you just install `rpy2` using the `conda install
    rpy2` command, the package manager will automatically install the latest version
    of R and some other required dependencies.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`conda`作为包管理器，设置过程可以大大简化。如果您仅通过`conda install rpy2`命令安装`rpy2`，包管理器会自动安装最新版本的R及其他一些必要的依赖项。
- en: Before executing the following code, please make sure to run the code from the
    previous recipe to have the data available.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行以下代码之前，请确保运行了前面配方中的代码，以确保数据可用。
- en: How to do it...
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following steps to estimate a DCC-GARCH model in Python (using
    R):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在Python中估计DCC-GARCH模型（使用R）：
- en: 'Set up the connection between Python and R using `rpy2`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`rpy2`建立Python和R之间的连接：
- en: '[PRE36]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Install the `rmgarch` R package and load it:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`rmgarch` R包并加载它：
- en: '[PRE37]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We only need to install the `rmgarch` package once. After doing so, you can
    safely comment out the line starting with `install.packages`.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们只需要安装一次`rmgarch`包。安装后，您可以安全地注释掉以`install.packages`开头的那行代码。
- en: 'Import the dataset into R:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据集导入R：
- en: '[PRE38]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Using the preceding command, we print the first five rows of the R `data.frame`:'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用前面的命令，我们打印R `data.frame`的前五行：
- en: '[PRE39]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Define the model specification:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义模型规范：
- en: '[PRE40]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Estimate the model:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 估计模型：
- en: '[PRE41]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following table contains the model’s specification summary, estimated coefficients,
    as well as a selection of goodness-of-fit criteria:'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下表格包含了模型的规范总结、估计的系数以及一些拟合优度标准的选择：
- en: '[PRE42]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Calculate the five-step ahead forecasts:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算五步 ahead 的预测值：
- en: '[PRE43]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Access the forecasts:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取预测结果：
- en: '[PRE44]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following image shows the five-step ahead forecasts of the conditional
    covariance matrix:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了条件协方差矩阵的五步 ahead 预测值：
- en: '[PRE45]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We can now compare this forecast (the first step) to the one obtained using
    a simpler CCC-GARCH model. The values of the one-step ahead conditional covariance
    forecasts are very similar for CCC- and DCC-GARCH models.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将这个预测（第一步）与使用更简单的CCC-GARCH模型获得的预测进行比较。对于CCC-GARCH和DCC-GARCH模型，单步 ahead
    的条件协方差预测值非常相似。
- en: How it works...
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we used the same data as in the previous recipe, in order to
    compare the results of the CCC- and DCC-GARCH models. For more information on
    downloading the data, please refer to *Steps 1* to *4* in the previousrecipe.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们使用了与前一个配方相同的数据，以便比较CCC-GARCH和DCC-GARCH模型的结果。有关如何下载数据的更多信息，请参考前一个配方中的*步骤1*至*4*。
- en: To work with Python and R at the same time, we used the `rpy2` library. In this
    recipe, we presented how to use the library in combination with Jupyter Notebook.
    For more details on how to use the library in a `.py` script, please refer to
    the official documentation. Also, we do not delve into the details of R code in
    general, as this is outside the scope of this book.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了同时使用 Python 和 R，我们使用了 `rpy2` 库。在本食谱中，我们展示了如何将该库与 Jupyter Notebook 结合使用。有关如何在
    `.py` 脚本中使用该库的更多详情，请参阅官方文档。此外，我们不会深入讨论 R 代码的细节，因为这超出了本书的范围。
- en: 'In *Step 1*, aside from loading any libraries, we also had to use the following
    magic command: `%load_ext rpy2.ipython`. It enabled us to run R code by adding
    `%%R` to the beginning of a cell in the Notebook. For that reason, please assume
    that any code block in this chapter is a separate Notebook cell (see the Jupyter
    Notebook in the accompanying GitHub repository for more information).'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 1 步*中，除了加载任何库，我们还必须使用以下魔法命令：`%load_ext rpy2.ipython`。它使我们能够通过在 Notebook
    单元格前添加 `%%R` 来运行 R 代码。因此，请假设本章中的任何代码块都是单独的 Notebook 单元格（更多信息，请参见随附 GitHub 仓库中的
    Jupyter Notebook）。
- en: In *Step 2*, we had to install the required R dependencies. To do so, we used
    the `install.packages` function, and we specified the repository we wanted to
    use.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 2 步*中，我们必须安装所需的 R 依赖项。为此，我们使用了 `install.packages` 函数，并指定了我们想要使用的仓库。
- en: In *Step 3*, we moved the `pandas` DataFrame into the R environment. To do so,
    we passed the extra code `-i returns`, together with the `%%R` magic command.
    We could have imported the data in any of the ensuing steps.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 3 步*中，我们将 `pandas` DataFrame 移动到 R 环境中。为此，我们在使用 `%%R` 魔法命令时传递了额外的代码 `-i
    returns`。我们本可以在随后的任何步骤中导入数据。
- en: 'When you want to move a Python object to R, do some manipulation/modeling,
    and move the final results back to Python, you can use the following syntax: `%%R
    -i input_object -o output_object`.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想将 Python 对象移到 R 中，进行一些操作/建模，然后将最终结果移回 Python 时，你可以使用以下语法：`%%R -i input_object
    -o output_object`。
- en: 'In *Step 4*, we defined the DCC-GARCH model’s specification. First, we defined
    the univariate GARCH specification (for conditional volatility estimation) using
    `ugarchspec`. This function comes from a package called `rugarch`, which is the
    framework for univariate GARCH modeling. By not specifying the ARMA parameters,
    we chose a constant mean model. For the volatility, we used a GARCH(1,1) model
    with normally distributed innovations. Secondly, we also specified the DCC model.
    To do so, we:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 4 步*中，我们定义了 DCC-GARCH 模型的规格。首先，我们使用 `ugarchspec` 定义了单变量 GARCH 规格（用于条件波动率估计）。该函数来自一个名为
    `rugarch` 的包，这是单变量 GARCH 建模的框架。通过不指定 ARMA 参数，我们选择了一个常数均值模型。对于波动率，我们使用了 GARCH(1,1)
    模型，且创新项服从正态分布。其次，我们还指定了 DCC 模型。为此，我们：
- en: Replicated the univariate specification for each returns series – in this case,
    three
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个收益系列复制了单变量规格——在此案例中，共有三个。
- en: Specified the order of the DCC model—in this case, DCC(1,1)
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定了 DCC 模型的阶数——在此案例中为 DCC(1,1)。
- en: Specified the multivariate distribution—in this case, Multivariate Normal
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定了多元分布——在此案例中为多元正态分布。
- en: We could see the summary of the specification by calling the `dcc_spec` object.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 `dcc_spec` 对象来查看规格的摘要。
- en: 'In *Step 5*, we estimated the model by calling the `dccfit` function with the
    specification and data as arguments. Afterward, we obtained five-step ahead forecasts
    by using the `dccforecast` function, which returned nested objects such as:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 5 步*中，我们通过调用 `dccfit` 函数并将规格和数据作为参数来估计模型。之后，我们使用 `dccforecast` 函数获得了五步预测，这个函数返回了嵌套对象，如下所示：
- en: '`H`: the conditional covariance matrix'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`H`：条件协方差矩阵'
- en: '`R`: the conditional correlation matrix'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R`：条件相关矩阵'
- en: '`Q`: the proxy process for the correlation matrix'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q`：相关矩阵的代理过程'
- en: '`mu`: the conditional mean'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mu`：条件均值'
- en: Each one of them contained five-step ahead forecasts, stored in lists.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 它们每个都包含了五步预测，存储在列表中。
- en: There’s more...
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: In this section, we would also like to go over a few more details on estimating
    GARCH models.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们还希望讨论一些估计 GARCH 模型的更多细节。
- en: Estimation details
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 估计详情
- en: In the first step of estimating the DCC-GARCH model, we can additionally use
    an approach called **variance targeting**. The idea is to reduce the number of
    parameters we need to estimate in the GARCH model.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在估计 DCC-GARCH 模型的第一步中，我们可以额外使用一种称为**方差目标**的方法。其思想是减少我们在 GARCH 模型中需要估计的参数数量。
- en: 'To do so, we can slightly modify the GARCH equation. The original equation
    runs as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可以稍微修改 GARCH 方程。原始方程如下所示：
- en: '![](../Images/B18112_09_037.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_037.png)'
- en: 'Unconditional volatility is defined as:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 无条件波动率定义为：
- en: '![](../Images/B18112_09_038.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_038.png)'
- en: 'We can now plug it into the GARCH equation and produce the following:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将其代入 GARCH 方程，得到以下结果：
- en: '![](../Images/B18112_09_039.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_039.png)'
- en: 'In the last step, we replace the unconditional volatility with the sample variance
    of the returns:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们用收益率的样本方差替换了无条件波动率：
- en: '![](../Images/B18112_09_040.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_09_040.png)'
- en: 'By doing so, we have one less parameter to estimate for each GARCH equation.
    Also, the unconditional variance implied by the model is guaranteed to be equal
    to the unconditional sample variance. To use variance targeting in practice, we
    add an extra argument to the `ugarchspec` function call: `ugarchspec(..., variance.targeting
    = TRUE)`.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们为每个 GARCH 方程减少了一个参数需要估计。此外，模型所隐含的无条件方差保证等于无条件样本方差。为了在实际中使用方差目标化，我们在
    `ugarchspec` 函数调用中添加了一个额外的参数：`ugarchspec(..., variance.targeting = TRUE)`。
- en: Univariate and multivariate GARCH models
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单变量和多变量 GARCH 模型
- en: It is also worth mentioning that `rugarch` and `rmgarch` work nicely together,
    as they were both developed by the same author and created as a single go-to framework
    for estimating GARCH models in R. We have already gained some experience with
    this when we used the `ugarchspec` function in the first step of estimating the
    DCC-GARCH model. There is much more to discover in terms of that package.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 同时值得一提的是，`rugarch` 和 `rmgarch` 可以很好地配合使用，因为它们都是由同一位作者开发的，并作为一个统一的框架创建，用于在 R
    中估计 GARCH 模型。在估计 DCC-GARCH 模型的第一步中，我们已经在使用 `ugarchspec` 函数时积累了一些经验。关于这个包，还有更多可以探索的内容。
- en: Parallelizing the estimation of multivariate GARCH models
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并行化多变量 GARCH 模型的估计
- en: Lastly, the estimation process of the DCC-GARCH model can be easily parallelized,
    with the help of the `parallel` R package.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，DCC-GARCH 模型的估计过程可以轻松地并行化，借助 `parallel` R 包。
- en: 'To potentially speed up computations with parallelization, we reused the majority
    of the code from this recipe and added a few extra lines. First, we had to set
    up a cluster by using `makePSOCKcluster` from the `parallel` package and indicated
    that we would like to use three cores. Then, we defined the parallelizable specification
    using `multifit`. Lastly, we fitted the DCC-GARCH model. The difference here,
    compared to the previously used code, is that we additionally passed the `fit`
    and `cluster` arguments to the function call. When we are done with the estimation,
    we stop the cluster. You can find the entire snippet below:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过并行化可能加速计算，我们重用了该配方中的大部分代码，并添加了几行额外的代码。首先，我们必须使用 `parallel` 包中的 `makePSOCKcluster`
    设置一个集群，并指示我们希望使用三个核心。然后，我们使用 `multifit` 定义并行化的规格。最后，我们拟合了 DCC-GARCH 模型。与之前使用的代码相比，这里的区别在于我们额外传递了
    `fit` 和 `cluster` 参数到函数调用中。当我们完成估计时，我们停止集群。下面是完整的代码片段：
- en: '[PRE46]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Using the preceding code, we can significantly speed up the estimation of the
    DCC-GARCH model. The improvement in performance is mostly visible when dealing
    with large volumes of data. Also, the approach of using the `parallel` package
    together with `multifit` can be used to speed up the calculations of various GARCH
    and ARIMA models from the `rugarch` and `rmgarch` packages.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述代码，我们可以显著加速 DCC-GARCH 模型的估计。当处理大量数据时，性能提升尤为明显。此外，结合 `parallel` 包和 `multifit`
    的方法，也可以用于加速 `rugarch` 和 `rmgarch` 包中各种 GARCH 和 ARIMA 模型的计算。
- en: See also
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Additional resources:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 其他资源：
- en: 'Engle, R.F., 2002\. “Dynamic Conditional Correlation: A Simple Class of Multivariate
    Generalized Autoregressive Conditional Heteroskedasticity Models,” Journal of
    Business and Economic *Statistics*, 20(3): 339–350: [https://doi.org/10.1198/073500102288618487](https://doi.org/10.1198/073500102288618487)'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Engle, R.F., 2002\. “动态条件相关性：一类简单的多变量广义自回归条件异方差模型，”《商业与经济*统计学*》, 20(3): 339–350:
    [https://doi.org/10.1198/073500102288618487](https://doi.org/10.1198/073500102288618487)'
- en: 'Ghalanos, A. (2019). The `rmgarch` models: Background and properties. (Version
    1.3–0): [https://cran.r-project.org/web/packages/rmgarch/vignettes/The_rmgarch_models.pdf](https://cran.r-project.org/web/packages/rmgarch/vignettes/The_rmgarch_models.pdf)'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ghalanos, A. (2019). `rmgarch` 模型：背景和属性。 (版本 1.3–0): [https://cran.r-project.org/web/packages/rmgarch/vignettes/The_rmgarch_models.pdf](https://cran.r-project.org/web/packages/rmgarch/vignettes/The_rmgarch_models.pdf)'
- en: '`rpy2`''s documentation: [https://rpy2.github.io/](https://rpy2.github.io/)'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rpy2`的文档：[https://rpy2.github.io/](https://rpy2.github.io/)'
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Volatility modeling and forecasting have attracted significant attention in
    recent years, largely due to their importance in financial markets. In this chapter,
    we have covered the practical application of GARCH models (both univariate and
    multivariate) to volatility forecasting. By knowing how to model volatility using
    GARCH class models, we can use more accurate volatility forecasts to replace the
    naïve estimates in many practical use cases, for example, risk management, volatility
    trading, and derivatives valuation.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 波动性建模和预测近年来受到了广泛关注，主要因为它们在金融市场中的重要性。本章介绍了GARCH模型（包括单变量和多变量模型）在波动性预测中的实际应用。通过了解如何使用GARCH类模型进行波动性建模，我们可以用更准确的波动性预测来替代许多实际应用中的简单估计，例如风险管理、波动性交易和衍生品估值。
- en: We have focused on GARCH models due to their ability to capture volatility clustering.
    However, there are other approaches to volatility modeling. For example, regime-switching
    models assume that there are certain repeating patterns (regimes) in data. Therefore,
    we should be able to predict future states by using parameter estimates based
    on past observations.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重点介绍了GARCH模型，因为它能够捕捉波动性聚集现象。然而，波动性建模还有其他方法。例如，状态切换模型假设数据中存在某些重复的模式（状态）。因此，我们应该能够通过使用基于过去观察的参数估计来预测未来的状态。
