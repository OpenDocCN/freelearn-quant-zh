- en: Algorithmic Trading - Backtesting
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 算法交易 - 回测
- en: After building algorithmic trading strategies, as we did in the previous chapter,
    the first step is to backtest them over a given duration of time for a given strategy
    configuration.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建算法交易策略之后，正如我们在上一章中所做的那样，第一步是对给定的策略配置在给定的时间段内进行回测。
- en: Backtesting is a method of evaluating the performance of a trading strategy
    by virtually executing it over past data and analyzing its risk and return metrics.
    Real money is not used here. Typical backtesting metrics include **Profit and
    Loss** (**P&L**), maximum drawdown, count of total trades, winning trades, losing
    trades, long trades and short trades, average profit per winning and losing trade,
    and more. Until these metrics meet the necessary requirements, the entire process
    should be repeated with incremental changes being made to strategy parameters
    and/or strategy implementation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 回测是通过在过去的数据上虚拟执行交易策略并分析其风险和回报指标来评估交易策略性能的方法。这里不使用真实资金。典型的回测指标包括**利润和损失**（**P＆L**），最大回撤，总交易数，盈利交易数，亏损交易数，多头交易和空头交易，每笔盈利和亏损交易的平均利润等。直到这些指标满足必要要求为止，整个过程应该重复进行，逐步对策略参数和/或策略实施进行更改。
- en: If a strategy performs well on past data, it is likely to perform well on live
    data also. Similarly, if a strategy is performing poorly on past data, it is likely
    to perform poorly on live data. This is the underlying premise of backtesting.
    You can keep changing the strategy configuration or implementation until the backtesting
    yields results as intended.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个策略在过去的数据上表现良好，那么它在实时数据上也很可能表现良好。同样，如果一个策略在过去的数据上表现不佳，那么它在实时数据上也很可能表现不佳。这是回测的基本前提。您可以不断更改策略配置或实现，直到回测产生预期的结果为止。
- en: Backtesting also helps validate the strategy behavior before we use the strategy
    for real money. This means it helps to ensure that the strategy behaves as expected
    for various marketing scenarios from the past.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 回测还有助于在我们将策略用于真实资金之前验证策略的行为。这意味着它有助于确保策略在过去的各种营销场景中表现如预期。
- en: 'For backtesting, a strategy configuration is required. It consists of multiple
    parameters, some of which are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于回测，需要策略配置。它由多个参数组成，其中一些如下：
- en: '**Start and end timestamps**: The time duration for which backtesting should
    be run.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始和结束时间戳**：回测应运行的时间段。'
- en: '**Financial instrument(s)**: One or more financial instruments for which backtesting
    should be performed.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金融工具**：应进行回测的一个或多个金融工具。'
- en: '**Candle interval**: One of many possible candle intervals; for example, 1
    minute, 15 minutes, 1 hour, or 1 day.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蜡烛间隔**：许多可能的蜡烛间隔之一；例如，1分钟，15分钟，1小时或1天。'
- en: '**Strategy-specific parameters**: Values for custom parameters defined in the
    strategy.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定策略参数**：策略中定义的自定义参数的值。'
- en: '**Strategy mode**: One of intraday or delivery. Intraday strategies punch intraday
    orders, which are squared off at the end of the day. Delivery strategies punch
    delivery orders. These don''t square off at the end of the day and get carried
    forward to the next trading day.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略模式**：日内交易或交割之一。日内交易策略在当天结束时打入日内订单，这些订单在当天结束时结清。交割策略打入交割订单。这些订单不会在当天结束时结清，而是转到下一个交易日。'
- en: A backtesting engine is required to perform backtesting on a given strategy.
    In this chapter, you will use the backtesting engine provided by AlgoBulls ([https://algobulls.com](https://algobulls.com)),
    an algorithmic trading platform that makes its services available via its developer
    options. It provides a Python package called `pyalgotrading` ([https://github.com/algobulls/pyalgotrading](https://github.com/algobulls/pyalgotrading))
    to make these services available.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个回测引擎来执行给定策略的回测。在本章中，您将使用由 AlgoBulls 提供的回测引擎 ([https://algobulls.com](https://algobulls.com))，这是一个通过其开发者选项提供其服务的算法交易平台。它提供了一个名为`pyalgotrading`的Python包
    ([https://github.com/algobulls/pyalgotrading](https://github.com/algobulls/pyalgotrading))
    来提供这些服务。
- en: 'You coded two algorithmic trading strategies in [Chapter 8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml),
    *Algorithmic Trading Strategies – Coding Step by Step*. Recall that the strategy
    descriptions are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您在[第8章](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml)中编码了两种算法交易策略，*算法交易策略 - 逐步编码*。回想一下，策略描述如下：
- en: '**EMA-Regular-Order strategy**: This strategy is based on the technical indicator
    EMA and regular orders. (The first six recipes of [Chapter 8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml),
    *Algorithmic Trading Strategies – Coding Step by Step*.)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EMA-Regular-Order 策略**：该策略基于技术指标 EMA 和常规订单。（[第 8 章](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml)
    的前六个配方，*算法交易策略 – 逐步编码*。）'
- en: '**MACD-Bracket-Order strategy**: This strategy is based on the technical indicator
    MACD and bracket orders. (The remaining six recipes of [Chapter 8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml),
    *Algorithmic Trading Strategies – Coding Step by Step*.)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MACD-Bracket-Order 策略**：该策略基于技术指标 MACD 和括号订单。（[第 8 章](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml)
    的剩余六个配方，*算法交易策略 – 逐步编码*。）'
- en: These strategies are also available as part of a Python package called `pyalgostrategypool`.
    You can install it using pip using the `$ pip install pyalgostrategypool` command.
    You can also check them out on GitHub ([https://github.com/algobulls/pyalgostrategypool](https://github.com/algobulls/pyalgostrategypool)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些策略也作为名为 `pyalgostrategypool` 的 Python 包的一部分可用。您可以使用 pip 安装它，使用命令 `$ pip install
    pyalgostrategypool`。您还可以在 GitHub 上查看它们（[https://github.com/algobulls/pyalgostrategypool](https://github.com/algobulls/pyalgostrategypool)）。
- en: In the previous chapter, you uploaded these two strategies to your AlgoBulls
    account. In this chapter, you will fetch these strategies from your AlgoBulls
    account and perform backtesting on them. After backtesting, you will gather the
    strategy execution logs and various reports, namely, the P&L report, the statistics
    report, and the order history. These logs and reports help validate the strategy's
    performance and prepare it for the next level, which is paper trading, before
    we finally go and do real trading. By using `pyalgotrading`, you ensure that you
    focus on developing and validating the strategy via backtesting, without worrying
    about the ecosystem needed for the strategy execution.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您已将这两个策略上传到您的 AlgoBulls 账户。在本章中，您将从您的 AlgoBulls 账户获取这些策略，并对其进行回测。回测后，您将收集策略执行日志和各种报告，即
    P&L 报告、统计报告和订单历史。这些日志和报告有助于验证策略的表现，并为下一阶段——模拟交易做准备，然后我们最终进行实际交易。通过使用 `pyalgotrading`，您确保专注于通过回测开发和验证策略，而无需担心策略执行所需的生态系统。
- en: This chapter includes step-by-step recipes for the aforementioned strategies,
    from setting up connections with the AlgoBulls platform, fetching the strategy,
    and running backtesting jobs, to fetching the execution logs and various types
    of reports.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括了前述策略的逐步配方，从与 AlgoBulls 平台建立连接、获取策略、运行回测任务，到获取执行日志和各种类型的报告。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: EMA-Regular-Order strategy – fetching the strategy
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMA-Regular-Order 策略 – 获取策略
- en: EMA-Regular-Order strategy – backtesting the strategy
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMA-Regular-Order 策略 – 回测策略
- en: EMA-Regular-Order strategy – fetching backtesting logs in real time
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMA-Regular-Order 策略 – 实时获取回测日志
- en: EMA-Regular-Order strategy – fetching a backtesting report – P&L table
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMA-Regular-Order 策略 – 获取回测报告 – P&L 表
- en: EMA-Regular-Order strategy – fetching a backtesting report – statistics table
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMA-Regular-Order 策略 – 获取回测报告 – 统计表
- en: EMA-Regular-Order strategy – fetching a backtesting report – order history
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMA-Regular-Order 策略 – 获取回测报告 – 订单历史
- en: MACD-Bracket-Order strategy – fetching the strategy
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order 策略 – 获取策略
- en: MACD-Bracket-Order strategy – backtesting the strategy
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order 策略 – 回测策略
- en: MACD-Bracket-Order strategy – fetching backtesting logs in real time
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order 策略 – 实时获取回测日志
- en: MACD-Bracket-Order strategy – fetching a backtesting report – P&L table
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order 策略 – 获取回测报告 – P&L 表
- en: MACD-Bracket-Order strategy – fetching a backtesting report – statistics table
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order 策略 – 获取回测报告 – 统计表
- en: MACD-Bracket-Order strategy – fetching a backtesting report – order history
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order 策略 – 获取回测报告 – 订单历史
- en: Let's get started!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following to successfully execute the recipes in this chapter:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要以下内容才能成功执行本章的配方：
- en: Python 3.7+
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.7+
- en: 'Python packages:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 包：
- en: '`pyalgotrading` (`$ pip install pyalgotrading`)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pyalgotrading`（`$ pip install pyalgotrading`）'
- en: The latest Jupyter notebook for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Python-Algorithmic-Trading-Cookbook/tree/master/Chapter09](https://github.com/PacktPublishing/Python-Algorithmic-Trading-Cookbook/tree/master/Chapter09).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最新的Jupyter笔记本可以在GitHub上找到：[https://github.com/PacktPublishing/Python-Algorithmic-Trading-Cookbook/tree/master/Chapter09](https://github.com/PacktPublishing/Python-Algorithmic-Trading-Cookbook/tree/master/Chapter09)。
- en: EMA-Regular-Order strategy – fetching the strategy
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EMA-Regular-Order策略 - 获取策略
- en: In this recipe, you will fetch the `StrategyEMARegularOrder` strategy class
    from your account on the AlgoBulls platform, which you uploaded while going through
    the *EMA-Regular-Order strategy – uploading the strategy* recipe in [Chapter 8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml), *Algorithmic
    Trading Strategies – Coding Step by Step*, on the AlgoBulls trading platform.
    This recipe starts with setting up a connection to the AlgoBulls platform, querying
    all available strategies in your account, and fetching the details of the required
    strategy class, `StrategyEMARegularOrder`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将从AlgoBulls平台上的您的账户中获取`StrategyEMARegularOrder`策略类，该策略类是您在[第8章](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml)，*算法交易策略
    - 逐步编码*中通过 *EMA-Regular-Order策略 - 上传策略* 配方上传到AlgoBulls交易平台的。本配方从设置到AlgoBulls平台的连接开始，查询您账户中所有可用的策略，并获取所需策略类`StrategyEMARegularOrder`的详细信息。
- en: Make sure you have gone through the first six recipes of the previous chapter
    to get a complete picture of the strategy class we will be using; that is, `StrategyEMARegularOrder`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经完成了前一章的前六个配方，以完全了解我们将要使用的策略类；即`StrategyEMARegularOrder`。
- en: How to do it…
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We execute the following steps for this recipe:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行了本配方的以下步骤：
- en: 'Import the necessary modules:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的模块：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new AlgoBulls connection object:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的AlgoBulls连接对象：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Fetch the authorization URL:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取授权URL：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We got the following output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下输出：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Log into the preceding link with your AlgoBulls credentials, fetch your token,
    and set it here (refer to *Appendix II* for more details):'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的AlgoBulls凭据登录前面的链接，获取您的令牌，并在此处设置它（有关更多详细信息，请参阅*附录II*）：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Fetch and display all the strategies you have created and uploaded so far:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取并显示到目前为止已创建和上传的所有策略：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We got the following output. Your output may differ (make sure you have followed
    the recipes from [Chapter 8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml), *Algorithmic
    Trading Strategies **– Coding Step by Step*, to get a similar output):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下输出。您的输出可能不同（确保您已经按照[第8章](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml)，*算法交易策略**-
    逐步编码*中的配方来获得类似的输出）：
- en: '![](img/4fe744d8-77bd-445d-b79d-288a8259ec5c.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fe744d8-77bd-445d-b79d-288a8259ec5c.png)'
- en: 'Fetch and display the strategy code of the first strategy:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取并显示第一个策略的策略代码：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We got the following output (your output may differ):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下输出（您的输出可能会有所不同）：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Before backtesting your strategy, you can inspect your strategy to ensure you
    have the right strategy:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对策略进行回测之前，您可以检查策略以确保您拥有正确的策略：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We got the following output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下输出：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The complete output is not shown here. Please visit the following link to read
    the complete output: [https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_ema_regular_order.py](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_ema_regular_order.py).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此处未显示完整的输出。请访问以下链接以阅读完整的输出：[https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_ema_regular_order.py](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_ema_regular_order.py)。
- en: How it works…
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In *step 1*, you import the necessary modules. In *step 2*, an instance of the
    `AlgoBullsConnection` class is created, named `algobulls_connection`. In *step
    3*, you get the authorization URL using the `get_authorization_url()` method of
    the `algobulls_connection` object. This prints the authorization URL. You should
    visit this URL from your web browser to sign into the AlgoBulls platform and fetch
    your developer access token. (You can find more details, along with screenshots,
    in *Appendix II* in regard to fetching developer access tokens from the AlgoBulls
    platform.) You copy the access token and set it in *step 4* using the `set_access_token()`
    method of `algobulls_connection`. If the token is accepted, a successful connection
    is set up with the AlgoBulls platform.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1步*中，你导入必要的模块。在*第2步*中，创建了`AlgoBullsConnection`类的一个实例，命名为`algobulls_connection`。在*第3步*中，使用`algobulls_connection`对象的`get_authorization_url()`方法获取授权URL。这将打印出授权URL。你应该从浏览器中访问此URL以登录AlgoBulls平台并获取您的开发者访问令牌。（您可以在*附录II*中找到更多细节，以及关于从AlgoBulls平台获取开发者访问令牌的屏幕截图。）你复制访问令牌，并在*第4步*中使用`algobulls_connection`的`set_access_token()`方法设置它。如果令牌被接受，就会建立与AlgoBulls平台的成功连接。
- en: In *step 5*, you fetch all the strategies you have created and uploaded to the
    AlgoBulls platform so far. You use the `get_all_strategies()` method for this
    step and assign it to a new variable, `all_strategies`. This variable is a `pandas.DataFrame`
    object that has `strategyCode` and `strategyName` columns. This table holds information
    on the strategy codes and the strategy names you uploaded previously. If you followed
    the E*MA-Regular-Order strategy – uploading the strategy on AlgoBulls trading
    platform* recipe from [Chapter 8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml),
    *Algorithmic Trading Strategies – Coding Step by Step*, you will find a strategy
    called **EMA-Regular-Order strategy**. In *step 6*, you assign the strategy code
    of the strategy, **EMA-Regular-Order strategy**, to a new variable called `strategy_code1`.
    The strategy code is shown in the output of this step. This strategy code is unique
    for every strategy on the AlgoBulls platform.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第5步*中，你获取到目前已经创建并上传到AlgoBulls平台的所有策略。你使用`get_all_strategies()`方法来执行此步骤，并将其赋值给一个新变量`all_strategies`。这个变量是一个`pandas.DataFrame`对象，具有`strategyCode`和`strategyName`列。这个表格包含了你之前上传的策略代码和策略名称的信息。如果你按照[第8章](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml)中的*EMA-Regular-Order策略-上传策略到AlgoBulls交易平台*的步骤，你会找到一个名为**EMA-Regular-Order策略**的策略。在*第6步*中，你将策略**EMA-Regular-Order策略**的策略代码赋值给一个新变量`strategy_code1`。这个策略代码在此步骤的输出中显示。这个策略代码对于AlgoBulls平台上的每个策略都是唯一的。
- en: Finally, in *step 7*, you ensure that the strategy being referred to by `strategy_code1`
    is indeed the one you uploaded earlier (in the *EMA-Regular-Order strategy – uploading
    the strategy on AlgoBulls trading platform* recipe of [Chapter 8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml), *Algorithmic
    Trading Strategies – Coding Step by Step*). You use the `get_strategy_details()`
    method of the `algobulls_connection` object to inspect the strategy. This method
    takes the strategy code as an argument. You pass `strategy_code1` here. This method
    returns the entire class code as a string. You assign it to a new variable, `strategy_details1`,
    and display it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*第7步*中，确保被`strategy_code1`引用的策略确实是你之前上传的那个（在[第8章](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml)的*EMA-Regular-Order策略-上传策略到AlgoBulls交易平台*配方中）。你使用`algobulls_connection`对象的`get_strategy_details()`方法来检查策略。这个方法将策略代码作为参数。你在这里传递`strategy_code1`。这个方法将整个类代码作为一个字符串返回。你将其赋值给一个新变量`strategy_details1`，并显示它。
- en: If you would like to change the class code being referred to by `strategy_code1`,
    as shown in *step 7*, please refer to the *There's more…* section of the *EMA-Regular-Order
    strategy – uploading the strategy on AlgoBulls trading platform* recipe, in [Chapter
    8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml), *Algorithmic Trading Strategies –
    Coding Step by Step*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更改`strategy_code1`引用的类代码，如*第7步*所示，请参考[第8章](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml)的*EMA-Regular-Order策略-上传策略到AlgoBulls交易平台*配方中的*还有更多...*部分。
- en: EMA-Regular-Order strategy – backtesting the strategy
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EMA-Regular-Order策略-回测策略
- en: In this recipe, you will perform backtesting on the **EMA-Regular-Order strategy**.
    You must have fetched this strategy from your account in the AlgoBulls platform
    in the preceding recipe. You will leverage the backtesting functionality facilitated
    by `pyalgotrading` for this recipe, which, in turn, submits a backtesting job
    on the AlgoBulls platform.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，您将对**EMA-Regular-Order策略**进行回测。您必须在上一配方中从AlgoBulls平台的帐户中获取此策略。您将为此配方利用`pyalgotrading`提供的回测功能，该功能反过来会在AlgoBulls平台上提交一个回测作业。
- en: 'Once submitted, backtesting will be run by the AlgoBulls backtesting engine.
    You can query the status anytime to find the state of the backtesting job. The
    job goes through the following states, in the given order:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 提交后，回测将由AlgoBulls回测引擎运行。您可以随时查询状态以查找回测作业的状态。作业按给定顺序经历以下状态：
- en: '`STARTING` (intermediate state)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STARTING`（中间状态）'
- en: '`STARTED` (stable state)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STARTED`（稳定状态）'
- en: '`STOPPING` (intermediate state)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STOPPING`（中间状态）'
- en: '`STOPPED` (stable state)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STOPPED`（稳定状态）'
- en: On submitting a job, it starts with an intermediate state, `STARTING`. In this
    state, the AlgoBulls backtesting engine fetches the strategy and get the execution
    environment ready, which may take a couple of minutes. Once done, the job moves
    to the `STARTED` state. Strategy backtesting happens in this stage. Here, it stays
    as long as it takes for backtesting to complete. Once done, the job moves to an
    intermediate state, `STOPPING`. In this state, the AlgoBulls backtesting engine
    cleans up the resources that have been allocated to this job, which usually takes
    less than a minute. Finally, the job moves to the `STOPPED` state.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 提交作业后，它将从中间状态开始，即`STARTING`。在此状态下，AlgoBulls回测引擎获取策略并准备执行环境，这可能需要几分钟。完成后，作业移至`STARTED`状态。策略回测发生在此阶段。在此期间，作业保持在这个状态直到回测完成。完成后，作业移至中间状态，即`STOPPING`。在此状态下，AlgoBulls回测引擎清理已分配给此作业的资源，这通常需要不到一分钟。最后，作业移至`STOPPED`状态。
- en: If you have already submitted a strategy backtesting job, you cannot submit
    another job for the same strategy until the first job completes. This means you
    have to wait for the first job to move to the `STOPPED` state. If the first job
    is long-running and you would like to stop it immediately, you can submit a stop
    job request via `pyalgotrading`. You need to ensure the job is in the `STARTED` state
    before submitting the request.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经提交了一个策略回测作业，则不能为相同的策略提交另一个作业，直到第一个作业完成。这意味着您必须等待第一个作业转移到`STOPPED`状态。如果第一个作业运行时间很长，并且您想立即停止它，您可以通过`pyalgotrading`提交停止作业请求。在提交请求之前，您需要确保作业处于`STARTED`状态。
- en: 'The following state machine diagram demonstrates the various states and transitions
    of a backtesting job during its lifetime on the AlgoBulls platform:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下状态机图示了回测作业在AlgoBulls平台上的生命周期中的各种状态和转换：
- en: '![](img/d95a8413-5cde-4d44-89d7-81da5c752fe0.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d95a8413-5cde-4d44-89d7-81da5c752fe0.png)'
- en: After submitting a backtesting job, you can fetch logs and reports for the strategy
    execution, in real time. The logs and reports help validate the strategy's performance
    and debug any potential issues.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 提交回测作业后，您可以实时获取策略执行的日志和报告。日志和报告有助于验证策略的性能并调试任何潜在问题。
- en: Make sure you have gone through the first six recipes of the previous chapter to
    get a complete picture of the strategy class we will be using; that is, `StrategyEMARegularORder`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经阅读了上一章的前六个配方，以全面了解我们将使用的策略类；即`StrategyEMARegularOrder`。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure the `algobulls_connection` and `strategy_code1` objects are available
    in your Python namespace. Refer to the previous recipe to set up the `algobulls_connection`
    and `strategy_code1` objects.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`algobulls_connection`和`strategy_code1`对象在您的Python命名空间中可用。请参阅上一配方以设置`algobulls_connection`和`strategy_code1`对象。
- en: How to do it…
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We execute the following steps for this recipe:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为此配方执行以下步骤：
- en: 'Import the necessary modules:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的模块：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Search for an instrument by using its trading symbol as a keyword. Assign the
    returned object to `instruments`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用交易符号作为关键字搜索工具。将返回的对象分配给`instruments`：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We get the following output (your output may differ):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出（您的输出可能会有所不同）：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Get `value` for the instrument of choice from `instruments`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`instruments`获取所选工具的`value`：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We get the following output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Submit a backtesting job for `strategy_code1`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`strategy_code1`提交一个回测任务：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We get the following output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Check the status of the submitted job backtesting job:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查已提交的回测作业的状态：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We get the following output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After some time, check the status of the submitted job once more:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一段时间后，再次检查已提交的作业状态：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We get the following output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works…
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理如下…
- en: In *step 1*, you import the `datetime` class from the `datetime` module and
    all the constants from the `pyalgotrading.constants` module. In *step 2*, you
    fetch the instrument that would like to backtest the strategy for, **EMA-Regular-Order
    strategy**, using the `search_instrument()` method of the `algobulls_connection`
    object. The `search_instrument()` method accepts a search string as an argument,
    which should be the trading symbol, in part or complete, of the instrument you
    are interested in. You pass `'SBIN'` here. This function returns a list with details
    of instruments that match the search string. There could be multiple instruments
    that could have the search string in their trading symbols. In *step 3*, you fetch
    the value of the first matched instrument and assign it to a new variable, `instrument`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，你从 `datetime` 模块中导入 `datetime` 类和 `pyalgotrading.constants` 模块中的所有常量。在
    *步骤 2* 中，你使用 `algobulls_connection` 对象的 `search_instrument()` 方法获取要为之进行策略回测的工具，**EMA-Regular-Order
    策略**。`search_instrument()` 方法接受一个搜索字符串作为参数，该参数应该是你感兴趣的工具的交易代码的一部分或完整的交易代码。你在这里传递`'SBIN'`。该函数返回一个包含与搜索字符串匹配的工具详情的列表。可能有多个工具的交易代码中都包含搜索字符串。在
    *步骤 3* 中，你获取第一个匹配工具的值，并将其分配给一个新变量 `instrument`。
- en: 'In *step 4*, you submit a backtesting job using the `backtest()` method of
    the `algobulls_connection()` object. It takes the following arguments:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 4* 中，你使用 `algobulls_connection()` 对象的 `backtest()` 方法提交了一个回测作业。它接受以下参数：
- en: '`strategy_code`: Strategy code of the strategy for which backtesting has to
    be performed. This should be a string. You pass `strategy_code1` here.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strategy_code`: 要进行回测的策略的策略代码。这应该是一个字符串。你在这里传递 `strategy_code1`。'
- en: '`start_timestamp`: Timestamp of the past from which backtesting should be started.
    This should be a `datetime.datetime` object. Here, you pass an object holding
    the value 1st July 2020 9:15 hours – `dt(year=2020, month=7, day=1, hour=9, minute=15)`.
    Refer to the *Creating datetime objects* recipe in [Chapter 1](efb7347f-05e4-4856-9ede-88bdcf393efa.xhtml), *Handling
    and Manipulating Date, Time, and Time Series Data*, for details on creating a
    `datetime` object.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start_timestamp`: 从中开始回测的过去时间戳。这应该是一个 `datetime.datetime` 对象。在这里，你传递一个持有 2020
    年 7 月 1 日 9:15 点的时间对象 - `dt(year=2020, month=7, day=1, hour=9, minute=15)`。有关创建
    `datetime` 对象的详细信息，请参阅[第 1 章](efb7347f-05e4-4856-9ede-88bdcf393efa.xhtml)中的 *创建
    datetime 对象* 配方，处理和操作日期、时间和时间序列数据。.'
- en: '`end_timestamp`: The timestamp of the past when backtesting should be performed.
    This object should hold a timestamp value ahead of the timestamp value held by
    `start_timestamp`. This should be a `datetime.datetime` instance. Here, you pass
    an object holding the value 7th July 2020 15:30 hours – `dt(year=2020, month=7,
    day=7, hour=15, minute=30)`.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end_timestamp`: 回测应该执行的过去时间戳。这个对象应该持有一个比 `start_timestamp` 持有的时间戳值要晚的时间戳值。这应该是一个
    `datetime.datetime` 实例。在这里，你传递一个持有 2020 年 7 月 7 日 15:30 点的时间对象 - `dt(year=2020,
    month=7, day=7, hour=15, minute=30)`。'
- en: '`instrument`: Financial instrument for which backtesting should be run. Historical
    data would be fetched for this instrument. This should be a string. You pass `instrument`
    here.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instrument`: 应该为其运行回测的金融工具。将为此工具获取历史数据。这应该是一个字符串。你在这里传递 `instrument`。'
- en: '`lots`: Number of lots for which backtesting should be performed. This should
    be an integer. The quantity is calculated by the strategy as *number of lots*
    ×* lot size of the financial instrument*. (See the *EMA-Regular-Order strategy
    – coding the strategy_enter_position method* recipe in the previous chapter).
    You pass `1` here.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lots`: 应进行回测的手数。这应该是一个整数。数量由策略计算得出，即 *手数* × *金融工具的手数*。 （请参阅上一章中的 *EMA-Regular-Order
    策略 - 编码 strategy_enter_position 方法*）。你在这里传递`1`。'
- en: '`strategy_parameters`: Parameter names and values expected by the strategy.
    This should be a dictionary, with `parameter-name` and `parameter-value` as key-value
    pairs. You pass the following parameters here:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strategy_parameters`: 策略所需的参数名称和值。这应该是一个字典，其中`parameter-name`和`parameter-value`是键值对。你需要传递以下参数：'
- en: '`timeperiod1: 5`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeperiod1: 5`'
- en: '`timeperiod2: 12 `'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeperiod2: 12 `'
- en: (Recall that the parameters for the EMA-Regular-Order strategy were defined
    in its `__init__()` method, as shown in the first recipe of the previous chapter).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: (回想一下，EMA-Regular-Order 策略的参数是在其 `__init__()` 方法中定义的，如前一章的第一个示例所示)。
- en: '`candle_interval`: The candle interval for the historical data fetched for
    backtesting. This should be an enum of the `CandleInterval` type. You pass `CandleInterval.MINUTES_15`
    here. (The `CandleInterval` enum provides various enums for candle intervals,
    some of which are `MINUTE_1`, `MINUTES_3` , `MINUTES_5`, `MINUTES_10`, `MINUTES_15`,
    `MINUTES_30`, `HOUR`, and `DAY`.)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`candle_interval`：用于回测获取的历史数据的蜡烛间隔。这应该是 `CandleInterval` 类型的枚举。您在这里传递 `CandleInterval.MINUTES_15`。(`CandleInterval`
    枚举提供了各种蜡烛间隔的枚举，其中一些是 `MINUTE_1`、`MINUTES_3`、`MINUTES_5`、`MINUTES_10`、`MINUTES_15`、`MINUTES_30`、`HOUR`
    和 `DAY`)。'
- en: If the job submission is successful, you will see `Success` message printed
    by the `backtest()` function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果作业提交成功，您将会在 `backtest()` 函数中看到打印的 `Success` 消息。
- en: Once a job is submitted, it takes a while to start. After starting, it may take
    some time to finish, depending on the complexity of the strategy and the duration
    of backtesting specified using the `start_timestamp` and `end_timestamp` arguments.
    A few days of backtesting may finish in seconds, while a few months of backtesting
    may take minutes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦作业提交，启动需要一段时间。启动后，根据策略的复杂性和使用 `start_timestamp` 和 `end_timestamp` 参数指定的回测持续时间，完成可能需要一些时间。几天的回测可能在几秒钟内完成，而几个月的回测可能需要几分钟。
- en: In *step 5*, you fetch the job status using the `get_backtesting_job_status()`
    method of the `algobulls_connection` object. You pass `strategy_code1` as the
    argument here. This method returns a dictionary with a single key-value pair –
    the *data* and the *job* status. If you query the status immediately after placing
    the job, you get `'STARTING'` as the status. In *step 6*, you query the status
    again after some time, and if the job has started, you get  `'STARTED'` as the
    status.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 5* 中，您使用 `algobulls_connection` 对象的 `get_backtesting_job_status()` 方法获取作业状态。您在这里将
    `strategy_code1` 作为参数传递。此方法返回一个字典，其中包含一个键值对 - *data* 和 *job* 状态。如果在放置作业后立即查询状态，您将得到
    `'STARTING'` 作为状态。在 *步骤 6* 中，您在一段时间后再次查询状态，如果作业已启动，则状态将为 `'STARTED'`。
- en: A successful submission implies that the minimum inputs needed to backtest a
    strategy have been passed in the required format. However, this does not ensure
    that the strategy will run without errors. The strategy's execution may still
    run into errors during backtesting. To debug execution issues, you would need
    to fetch the output logs, which is explained in the *MACD-Bracket-Order strategy
    – fetching backtesting logs in real time* recipe. Possible reasons for errors
    could be either bugs in the strategy class Python code or an incomplete `strategy_parameters`
    dictionary being passed to the `backtest()` function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 成功提交意味着已以所需格式传递了回测策略所需的最小输入。但是，这并不保证策略将无错误地运行。在回测期间，策略的执行可能仍然会遇到错误。要调试执行问题，您需要获取输出日志，这在
    *MACD-Bracket-Order 策略 - 实时获取回测日志* 配方中有解释。错误的可能原因可能是策略类 Python 代码中的错误或将不完整的 `strategy_parameters`
    字典传递给 `backtest()` 函数。
- en: There's more…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If a job is running for a long time and you would like to stop it before its
    completion, you can use the `stop_backtesting_job()` method of the `algobulls_connection`
    object. This method accepts strategy code as an argument. You pass `strategy_code1`
    here. This method submits a stop request to the AlgoBulls backtesting engine.
    If the request is accepted, you will see a `Success` message here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果作业运行时间很长，您希望在其完成之前停止它，您可以使用 `algobulls_connection` 对象的 `stop_backtesting_job()`
    方法。此方法接受策略代码作为参数。您在这里传递 `strategy_code1`。此方法向 AlgoBulls 回测引擎提交停止请求。如果请求被接受，您将在此处看到
    `Success` 消息：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you query the status after submitting the stop request, you''ll get the
    status as `''STOPPING``:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在提交停止请求后查询状态，您将会得到状态为 `'STOPPING'`：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you query the status again after some time, and if the job has stopped,
    you''ll get the status as `''STOPPED''`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在一段时间后再次查询状态，并且作业已停止，则状态将为 `'STOPPED'`：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: EMA-Regular-Order strategy – fetching backtesting logs in real time
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EMA-Regular-Order 策略 - 实时获取回测日志
- en: After submitting a backtesting job on the AlgoBulls platform, the AlgoBulls
    backtesting engine starts executing the strategy. During the execution, every
    event that occurs and every decision taken by the AlgoBulls backtesting engine
    are recorded with exact timestamps in the form of textual logs. Examples of recorded
    activities include the given strategy config, every new candle generated at regular
    intervals, trades punched by your strategy, the entry and exit of positions created
    by these trades, waits for new candles, and so on. These logs are quintessential
    in validating the strategy behavior and debugging behavior or performance issues
    that are frequently encountered while developing a strategy.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在AlgoBulls平台上提交回测作业后，AlgoBulls回测引擎开始执行策略。在执行过程中，AlgoBulls回测引擎发生的每个事件以及所采取的每个决策都以精确的时间戳记录为文本日志。记录的活动示例包括给定策略配置，定期生成的每个新蜡烛，您的策略打出的交易，由这些交易创建的头寸的进入和退出，等待新蜡烛等等。这些日志对于验证策略行为以及调试在开发策略时经常遇到的行为或性能问题至关重要。
- en: In this recipe, you will fetch the backtesting logs for your strategy. The logs
    start coming up as soon as your submitted backtesting job reaches the `'STARTED'`
    state (refer to the previous recipe for more information on the states of a backtesting
    job). The AlgoBulls platform allows you to fetch logs in real time, even while
    the backtesting job is still going on. You can get insights into the strategy's
    execution without having to wait for the backtesting job to complete, which is
    helpful when jobs are long-running. The `pyalgotrading` package provides a simple
    method that can be used to fetch the execution logs for a given strategy.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你将获取你的策略的回测日志。一旦您提交的回测作业达到`'STARTED'`状态（有关回测作业状态的更多信息，请参考上一节），日志就会开始出现。AlgoBulls平台允许您实时获取日志，即使回测作业仍在进行中。您可以在不必等待回测作业完成的情况下获取对策略执行的见解，这在作业运行时间很长时非常有用。`pyalgotrading`包提供了一个简单的方法，可用于获取给定策略的执行日志。
- en: Make sure you have gone through the first six recipes of the previous chapter to
    get a complete picture of the strategy class we will be using; that is, `StrategyEMARegularOrder`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经阅读了上一章的前六个配方，以完全了解我们将使用的策略类的情况；即，`StrategyEMARegularOrder`。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Make sure the `algobulls_connection` and `strategy_code1` objects are available
    in your Python namespace. Refer to the first recipe of this chapter to set up
    the `algobulls_connection` and `strategy_code1` objects.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的Python命名空间中可用`algobulls_connection`和`strategy_code1`对象。请参考本章的第一个配方设置`algobulls_connection`和`strategy_code1`对象。
- en: How to do it…
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We execute the following steps for this recipe:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对这个配方执行以下步骤：
- en: 'Fetch the backtesting execution logs for `strategy_code1`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`strategy_code1`的回测执行日志：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We get the following output (your output may differ):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出（您的输出可能有所不同）：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Fetch the backtesting execution logs for `strategy_code1` again after some
    time:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再过一段时间，再次获取`strategy_code1`的回测执行日志：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We get the following output (your output may differ):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出（您的输出可能有所不同）：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The complete output is not shown here. Please visit the following link to read
    the complete output: [https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_ema_regular_order/logs.txt](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_ema_regular_order/logs.txt).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有显示完整的输出。请访问以下链接以阅读完整的输出：[https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_ema_regular_order/logs.txt](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_ema_regular_order/logs.txt)。
- en: How it works…
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In *step 1*, you use the `get_backtesting_logs()` method of the `algobulls_connection`
    object to fetch the strategy backtesting logs in real time. This method accepts
    the strategy code as an argument. You pass `strategy_code1` here. The return data
    is a string. If you try this step immediately after submitting the job, you get
    a string, which says the logs are not ready yet (`[2020-07-30 17:27:25] Logs not
    available yet. Please retry in sometime.`). This happens if the backtesting job
    is in the `'STARTING'` state.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，您使用`algobulls_connection`对象的`get_backtesting_logs()`方法实时获取策略回测日志。此方法接受策略代码作为参数。您在这里传递了`strategy_code1`。返回数据是一个字符串。如果您在提交作业后立即尝试此步骤，则会得到一个字符串，该字符串显示日志尚未准备好（`[2020-07-30
    17:27:25] Logs not available yet. Please retry in sometime.`）。如果回测作业处于`'STARTING'`状态，则会发生这种情况。
- en: In *step 2*, you fetch the logs again after some time. If the job is out of
    the `'STARTING'` state, you start getting your strategy execution logs. You get
    the entire backtesting logs every time you call the `get_backtesting_logs()` function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 2* 中，您再次在一段时间后获取日志。如果作业处于 `'STARTING'` 状态之外，您就开始获取您的策略执行日志。每次调用 `get_backtesting_logs()` 函数时，您都会获得完整的回测日志。
- en: There's more...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Once the backtesting job moves to the `'STOPPED'` state, no new logs are generated.
    You can fetch the complete logs any time before you submit the next backtesting
    job for the same strategy. If a new backtesting job is submitted (for the same
    strategy), these logs will no longer be accessible via the `get_backtesting_logs()`
    method. You can save the fetched logs to a file if you'd like to refer to it at
    a later date.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦回测作业转移到 `'STOPPED'` 状态，就不会生成新的日志。在您提交下一个相同策略的回测作业之前，您可以随时获取完整的日志。如果提交了新的回测作业（针对相同的策略），这些日志将无法通过
    `get_backtesting_logs()` 方法再次访问。如果您希望以后参考，您可以将获取的日志保存到文件中。
- en: EMA-Regular-Order strategy – fetching a backtesting report – profit and loss
    table
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EMA-Regular-Order 策略 – 获取一个回测报告 – 收益和损失表
- en: After submitting a backtesting job on the AlgoBulls platform, the AlgoBulls
    backtesting engine starts executing the strategy. During its execution, along
    with the logs, the AlgoBulls backtesting engine also generates a P&L table in
    real time. This table holds information on every trade that's been punched by
    the strategy. It also contains details on the mappings between entry and exit
    orders, the trade P&L, and the cumulative P&L, sorted chronologically, with the
    latest order first. This table gives us an insight into the overall strategy's
    performance with the help of individual and cumulative P&L numbers. The entry-exit
    order mapping also helps validate the strategy behavior.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AlgoBulls 平台提交了一个回测作业后，AlgoBulls 回测引擎开始执行策略。在执行过程中，除了日志之外，AlgoBulls 回测引擎还实时生成了一个
    P&L 表格。这个表格包含了策略 Punch 进来的每一笔交易的信息。它还包含了入场和出场订单之间的映射细节、交易 P&L 以及累计 P&L，按时间顺序排序，最新的订单排在最前面。这张表格让我们通过个别和累计
    P&L 数字来洞察整体策略的表现。入场-出场订单映射也有助于验证策略行为。
- en: In this recipe, you will fetch the P&L table report for your strategy. This
    report is available as soon as the first trade is punched in by your strategy
    after you submit a backtesting job. The AlgoBulls platform allows you to fetch
    the P&L table in real time, even while the backtesting job is still going on.
    You can get insights into the strategy performance without having to wait for
    the backtesting job to complete, which is helpful when jobs are long-running.
    The `pyalgotrading` package provides a simple method that's used to fetch the
    P&L table for a given strategy.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将获取您的策略的 P&L 表格报告。在您提交了回测作业后，只要您的策略 Punch 进了第一笔交易，这份报告就会立即可用。AlgoBulls
    平台允许您实时获取 P&L 表格，即使回测作业仍在进行中。您可以在等待回测作业完成时获取策略表现的洞察，这在作业运行时间较长时非常有用。`pyalgotrading`
    包提供了一个简单的方法，用于获取给定策略的 P&L 表格。
- en: Make sure you have gone through the first six recipes of the previous chapter to
    get a complete picture of the strategy class we will be using; that is, `StrategyEMARegularOrder`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经阅读了前一章的前六个教程，以完全了解我们将要使用的策略类；即 `StrategyEMARegularOrder`。
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure the `algobulls_connection` and `strategy_code1` objects are available
    in your Python namespace. Refer to the first recipe of this chapter to set up
    the `algobulls_connection` and `strategy_code1` objects.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 `algobulls_connection` 和 `strategy_code1` 对象在您的 Python 命名空间中可用。请参考本章第一篇教程设置
    `algobulls_connection` 和 `strategy_code1` 对象。
- en: How to do it…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Fetch the backtesting P&L report for `strategy_code1`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 `strategy_code1` 的回测 P&L 报告：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We got the following output. Your output may differ (note that the following
    output has been split into multiple tables for representation purposes. You will
    see a single wide table in your Jupyter Notebook):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下输出。您的输出可能会有所不同（请注意，以下输出已被分成多个表格以表示目的。您将在您的 Jupyter Notebook 中看到一个宽表）：
- en: '![](img/d7ac60ab-88ea-4692-b0b8-1cc75e334a0e.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d7ac60ab-88ea-4692-b0b8-1cc75e334a0e.png)'
- en: How it works…
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, you use the `get_backtesting_report_pnl_table()` method of
    the `algobulls_connection` object to fetch the backtesting P&L table in real time.
    This method accepts strategy code as an argument. You pass `strategy_code1` here.
    The return data is a `pandas.DataFrame` object with multiple columns, described
    as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，您使用`algobulls_connection`对象的`get_backtesting_report_pnl_table()`方法实时获取回测损益表。此方法接受策略代码作为参数。您在此处传递`strategy_code1`。返回的数据是一个`pandas.DataFrame`对象，具有以下多列，描述如下：
- en: '`instrument`: Financial instrument for which the trade was entered.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instrument`: 进入交易的金融工具。'
- en: '`entry_timestamp`: The timestamp at which the entry order was placed. (Note
    that it may remain in the `''OPEN''` state for a while before it goes to the `''COMPLETE''`
    state. The time for this state transition can be found using the order history
    table, as explained in the sixth recipe of this chapter.)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry_timestamp`: 进入订单放置的时间戳。（请注意，它可能会在进入`''COMPLETE''`状态之前保持`''OPEN''`状态一段时间。您可以使用订单历史表找到此状态转换的时间，如本章第六个示例所述。）'
- en: '`entry_transaction_type`: Entry order transaction type (either `BUY` or `SELL`).'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry_transaction_type`: 进入订单交易类型（`BUY`或`SELL`）。'
- en: '`entry_quantity`: Entry order quantity.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry_quantity`: 进入订单数量。'
- en: '`entry_price`: The price at which the entry order gets executed and goes to
    the `''COMPLETE''` state.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry_price`: 进入订单执行的价格，并进入`''COMPLETE''`状态。'
- en: '`exit_timestamp`: The timestamp at which the exit order was placed. (Note that
    it may remain in the `''OPEN''` state for a while before it goes to the `''COMPLETE''`
    state.)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exit_timestamp`: 退出订单放置的时间戳。（请注意，它可能会在进入`''COMPLETE''`状态之前保持`''OPEN''`状态一段时间。）'
- en: '`exit_transaction_type`: Exit order transaction type (either `BUY` or `SELL`).'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exit_transaction_type`: 退出订单交易类型（`BUY`或`SELL`）。'
- en: '`exit_quantity`: Exit order quantity.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exit_quantity`: 退出订单数量。'
- en: '`exit_price`: The price at which the exit order gets executed and goes to the `''COMPLETE''`
    state.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exit_price`: 退出订单执行的价格，并进入`''COMPLETE''`状态。'
- en: '`pnl_absolute`: Difference between the exit order execution price and the entry
    order execution price. Mathematically, this is (*exit_price* - *entry_price*)**exit_quantity*
    for a long trade and (*entry_price* - *exit_price*)**exit_quantity* for a short
    trade. A positive value would imply that the trade is a profit-making trade. A
    negative value would imply that the trade is a loss-making trade.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pnl_absolute`: 退出订单执行价格与进入订单执行价格之间的差值。数学上，这是对于多头交易为(*exit_price* - *entry_price*)**exit_quantity*，对于空头交易为(*entry_price*
    - *exit_price*)**exit_quantity*。正值意味着交易盈利，负值意味着交易亏损。'
- en: '`pnl_percentage`: The percentage of profit or loss with respect to the entry
    price. Mathematically, this is *pnl_absolute* / *entry_price* / *exit_quantity*
    × *100*.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pnl_percentage`: 利润或亏损的百分比，相对于进入价格。数学上，这是*pnl_absolute* / *entry_price* /
    *exit_quantity* × *100*。'
- en: '`pnl_cumulative_absolute`: Cumulative profit or loss. Mathematically, this
    is the sum of all the `pnl_absolute` values of the previous trades. This number
    gives us direct insight into the strategy performance against the simulation time.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pnl_cumulative_absolute`: 累积利润或亏损。数学上，这是以前交易的所有`pnl_absolute`值的总和。此数字直接反映了策略绩效与模拟时间的关系。'
- en: '`pnl_cumulative_percentage`: The percentage of cumulative profit or loss with
    respect to the entry price. Mathematically, this is *pnl_cumulative* / *entry_price* /
    *exit quantity* × *100*.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pnl_cumulative_percentage`: 相对于进入价格的累积利润或亏损的百分比。数学上，这是*pnl_cumulative* / *entry_price* /
    *exit quantity* × *100*。'
- en: There's more...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多信息...
- en: Once the backtesting job moves to the `'STOPPED'` state, the P&L table report
    will not update anymore. You can fetch the complete P&L report any time before
    you submit the next backtesting job for the same strategy. If a new backtesting
    job is submitted (for the same strategy), this report will no longer be accessible
    via the `get_backtesting_report_pnl_table()` method. You can save the fetched
    report as a `.csv` file if you'd like to refer to it at a later date.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦回测作业转移到`'STOPPED'`状态，损益表报告将不再更新。您可以在提交下一个相同策略的回测作业之前随时获取完整的损益报告。如果提交了新的回测作业（针对相同策略），则无法再通过`get_backtesting_report_pnl_table()`方法访问此报告。如果您希望以后参考，可以将获取的报告保存为`.csv`文件。
- en: EMA-Regular-Order strategy — fetching a backtesting report – statistics table
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EMA-Regular-Order策略 — 获取回测报告 - 统计表
- en: After submitting a backtesting job on the AlgoBulls platform, the AlgoBulls
    backtesting engine starts executing the strategy. During its execution, along
    with the logs and P&L table, the AlgoBulls backtesting engine also generates a
    summary from the P&L table in real time. This summary is a table of statistics
    containing various statistical numbers such as `Net P&L` (absolute and percentage),
    `Max Drawdown` (absolute and percentage), count of total trades, winning trades,
    losing trades, long trades and short trades, maximum gain and minimum gain (or
    maximum loss), and average profit per winning and losing trade. This table gives
    an instant overview of the overall strategy's performance.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在AlgoBulls平台上提交回测任务后，AlgoBulls回测引擎开始执行策略。在执行过程中，除了日志和盈亏表外，AlgoBulls回测引擎还实时生成来自盈亏表的摘要。这个摘要是一个包含各种统计数字的统计表，例如`净盈亏`（绝对值和百分比）、`最大回撤`（绝对值和百分比）、总交易次数、盈利交易次数、亏损交易次数、多头交易和空头交易次数、最大收益和最小收益（或最大亏损），以及每笔盈利交易和亏损交易的平均利润。这个表提供了对整体策略表现的即时概览。
- en: In this recipe, you will fetch the statistics table report for your strategy.
    This report is available as soon as the first trade is punched in by your strategy
    after you submit a backtesting job. The AlgoBulls platform allows you to fetch
    the statistics table in real time, even while the backtesting job is still going
    on. You can get insights into the strategy performance without having to wait
    for the backtesting job to complete, which is helpful when jobs are long-running.
    The `pyalgotrading` package provides a simple method that's used to fetch the
    statistics table for a given strategy.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将获取您的策略的统计表报告。这份报告在您提交回测工作后，您的策略首次打入第一笔交易后即可获得。AlgoBulls平台允许您实时获取统计表，即使回测工作仍在进行中。您可以在等待回测工作完成时就获得对策略表现的洞察，这对于长时间运行的工作非常有帮助。`pyalgotrading`包提供了一个简单的方法，用于获取给定策略的统计表。
- en: Make sure you have gone through the first six recipes of the previous chapter
    to get a complete picture of the strategy class we will be using; that is, `StrategyEMARegularOrder`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经阅读了上一章的前六个配方，以完全了解我们将使用的策略类；即`StrategyEMARegularOrder`。
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure the `algobulls_connection` and `strategy_code1` objects are available
    in your Python namespace. Refer to the first recipe of this chapter to set up
    the `algobulls_connection` and `strategy_code1` objects.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`algobulls_connection`和`strategy_code1`对象在你的Python命名空间中可用。参考本章第一个配方设置`algobulls_connection`和`strategy_code1`对象。
- en: How to do it…
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Fetch the backtesting statistics report for `strategy_code1`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`strategy_code1`的回测统计报告：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We got the following output (your output may differ):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下输出（您的输出可能不同）：
- en: '![](img/1aeeb6bb-6b75-4caa-91cb-bad95e57b3b7.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1aeeb6bb-6b75-4caa-91cb-bad95e57b3b7.png)'
- en: How it works…
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何运作…
- en: 'In this recipe, you use the `get_backtesting_report_statistics()` method of
    the `algobulls_connection` object to fetch the backtesting statistics table in
    real time. This method accepts the strategy code as an argument. You pass `strategy_code1`
    here. The return data is a `pandas.DataFrame` object with two columns – `highlight_type`
    and `highlight_value` – and multiple rows. The rows are described as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你使用`algobulls_connection`对象的`get_backtesting_report_statistics()`方法实时获取回测统计表。该方法接受策略代码作为参数。你在这里传递了`strategy_code1`。返回的数据是一个`pandas.DataFrame`对象，有两列
    - `highlight_type` 和 `highlight_value` - 以及多行。行的描述如下：
- en: '`Net PnL`: The cumulative backtesting P&L. This is also the `pnl_cumulative_absolute`
    value of the first entry in the P&L table.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`净盈亏`：累积回测盈亏。这也是盈亏表中第一个条目的`pnl_cumulative_absolute`值。'
- en: '`Net PnL %`: The cumulative backtesting P&L percentage. This is also the `pnl_cumulative_percentage`
    value of the first entry in the P&L table.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`净盈亏 %`：累积回测盈亏百分比。这也是盈亏表中第一个条目的`pnl_cumulative_percentage`值。'
- en: '`Max Drawdown`: The lowest value in the `pnl_cumulative` column of the P&L
    table. This indicates the maximum loss your strategy has encountered during the
    execution.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`最大回撤`：盈亏表的`pnl_cumulative`列中的最低值。这表明您的策略在执行过程中遇到的最大损失。'
- en: '`Max Drawdown %`: Mathematically, this is *(Max Drawdown)* / *(corresponding
    entry_price) / exit_quantity *× *100*.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`最大回撤 %`：从数学上讲，这是*(最大回撤)* / *(相应的入场价格) / 出场数量 *× *100*。'
- en: '`Number of Trades`: Total trades (entry and exit counted as one) during the
    session.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`交易次数`：会话期间的总交易次数（入场和出场计为一次）。'
- en: '`Number of Wins`: Count of trades where the trade P&L was non-negative.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`获利次数`：交易盈亏非负的交易次数。'
- en: '`Number of Losses`: Count of trades where the trade P&L was negative.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`亏损次数`：交易盈亏为负的交易次数。'
- en: '`Number of Long Trades`: Count of trades where the entry transaction type was
    `''BUY''`.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`多头交易次数`：输入交易类型为 `''BUY''` 的交易次数。'
- en: '`Number of Short Trades`: Count of trades where the entry transaction type
    was `''SELL''`.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`空头交易次数`：输入交易类型为 `''SELL''` 的交易次数。'
- en: '`Max Gain`: P&L of the trade with the maximum P&L value among all trades.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`最大收益`：所有交易中收益最大的交易的盈亏。'
- en: '`Min Gain`: P&L of the trade with the minimum P&L value among all trades.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`最小收益`：所有交易中收益最小的交易的盈亏。'
- en: '`Avg. Profit per winning trade`: Mathematically, this is *(Total P&L of winning
    trades)* / *(Count of winning trades)*.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`每次盈利交易的平均利润`：在数学上，这是 *(盈利交易的总盈亏)* / *(盈利交易的次数)*。'
- en: '`Avg. Profit per losing trade`: Mathematically, this is *(Total P&L of losing
    trades)* / *(Count of losing trades)*.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`每次亏损交易的平均利润`：在数学上，这是 *(亏损交易的总盈亏)* / *(亏损交易的次数)*。'
- en: There's more...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If the statistics table is fetched while the backtesting job is still running,
    the aforementioned numbers would be intermediate numbers, based on the trades
    completed up until that time. The numbers may change as more trades are punched
    in, until the backtesting job completes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在回测任务仍在运行时获取统计表，则上述数字将是中间数字，基于截至该时刻完成的交易。随着更多交易被输入，这些数字可能会更改，直到回测任务完成。
- en: Once the backtesting job moves to the `'STOPPED'` state, the statistics table
    will not change anymore. You can fetch the complete statistics table any time
    before you submit the next backtesting job for the same strategy. If a new backtesting
    job is submitted (for the same strategy), this table will no longer be accessible
    via the `get_backtesting_report_statistics()` method. You can save the fetched
    report table to a `.csv` file if you'd like to refer to it at a later date.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦回测任务转移到 `'STOPPED'` 状态，统计表将不再更改。您可以在提交下一个相同策略的回测任务之前的任何时间获取完整的统计表。如果提交了新的回测任务（相同的策略），则通过
    `get_backtesting_report_statistics()` 方法将无法再访问此表。如果您希望以后参考，可以将获取的报告表保存到 `.csv`
    文件中。
- en: EMA-Regular-Order strategy – fetching a backtesting report – order history
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EMA-Regular-Order 策略 - 获取回测报告 - 订单历史
- en: After submitting a backtesting job on the AlgoBulls platform, the AlgoBulls
    backtesting engine starts executing the strategy. During its execution, along
    with the logs, the P&L table and the statistics table of the AlgoBulls backtesting
    engine generate an order history log in real time. This log contains state transitions
    of every order, along with the timestamps and additional information (if any)
    for each order state. The order history log is crucial for understanding how long
    it has taken for a trade to go from an `'OPEN'` state to `'COMPLETE'` or `'CANCELLED'`.
    For example, the `MARKET` orders would immediately go from `'OPEN'` to `'COMPLETE'` but
    the `LIMIT` orders may take a while, based on the market conditions, to go from
    `'OPEN'` to `'COMPLETE'` – they may even get to `'CANCELLED'`. All this information
    is available in the order history log. (Refer to the state machine diagrams in
    [Chapter 6](077b54a1-c9c4-424c-912a-11f28db3797f.xhtml), *Placing Regular Orders
    on the Exchange*, for more information on order state transitions.)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AlgoBulls 平台提交回测任务后，AlgoBulls 回测引擎开始执行策略。在执行过程中，除了日志外，AlgoBulls 回测引擎的盈亏表和统计表会实时生成订单历史记录。此日志包含每个订单的状态转换，以及每个订单状态的时间戳和附加信息（如果有）。订单历史记录对于理解交易从
    `'OPEN'` 状态到 `'COMPLETE'` 或 `'CANCELLED'` 状态所需的时间至关重要。例如，`MARKET` 订单将立即从 `'OPEN'`
    转换为 `'COMPLETE'`，但是 `LIMIT` 订单可能需要一段时间，根据市场条件从 `'OPEN'` 转换到 `'COMPLETE'` - 甚至可能转为
    `'CANCELLED'`。所有这些信息都包含在订单历史记录中。（有关订单状态转换的更多信息，请参见[第 6 章](077b54a1-c9c4-424c-912a-11f28db3797f.xhtml)的状态机图，*在交易所上放置常规订单*。）
- en: In this recipe, you will fetch the order history log for your strategy. This
    log is available as soon as the first trade is punched in by your strategy, after
    you submit a backtesting job. The AlgoBulls platform allows you to fetch the order
    history log in real time, even while the backtesting job is still going on. This
    helps us get details for orders in their end states, without having to wait for
    the backtesting job to complete. The `pyalgotrading` package provides a simple
    method we can use to fetch the order history log for a given strategy.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，你将获取你的策略的订单历史记录。只要你的策略首次进行交易，并提交了一个回测任务，这个日志就可以获取。AlgoBulls平台允许你实时获取订单历史记录，即使回测任务仍在进行中也是如此。这帮助我们获取订单的最终状态的细节，而无需等待回测任务完成。`pyalgotrading`包提供了一个简单的方法，我们可以用它来获取给定策略的订单历史记录。
- en: Make sure you have gone through the first six recipes of the previous chapter
    to get a complete picture of the strategy class we will be using; that is, `StrategyEMARegularOrder`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经阅读了上一章的前六个配方，以完整了解我们将使用的策略类；即`StrategyEMARegularOrder`。
- en: Getting ready
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure the `algobulls_connection` and `strategy_code1` objects are available
    in your Python namespace. Refer to the first recipe of this chapter to set up
    the `algobulls_connection` and `strategy_code1` objects.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 `algobulls_connection` 和 `strategy_code1` 对象在你的 Python 命名空间中可用。参考本章第一个配方设置
    `algobulls_connection` 和 `strategy_code1` 对象。
- en: How to do it…
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Fetch the backtesting order history report for `strategy_code1`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`strategy_code1`的回测订单历史报告：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We got the following output (your output may differ):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下输出（你的输出可能不同）：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The complete output is not shown here. Please visit this link to read the complete
    output: [https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_ema_regular_order/oms_order_history.log](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_ema_regular_order/oms_order_history.log).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里未显示完整的输出。请访问此链接阅读完整的输出：[https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_ema_regular_order/oms_order_history.log](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_ema_regular_order/oms_order_history.log)。
- en: How it works…
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, you use the `get_backtesting_report_order_history()` method
    of the `algobulls_connection` object to fetch order history logs in real time.
    This method accepts strategy code as an argument. You pass `strategy_code1` here.
    The return data is a string, described as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，你使用`algobulls_connection`对象的`get_backtesting_report_order_history()`方法实时获取订单历史记录。此方法接受策略代码作为参数。你在这里传递了`strategy_code1`。返回的数据是一个字符串，描述如下：
- en: 'For every order, the log contains the following information:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个订单，日志包含以下信息：
- en: 'A descriptive table of the order, with the following mentioned columns:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含以下列的描述性订单表：
- en: '`INST`: Financial instrument of the order'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INST`: 订单的金融工具'
- en: '`TIME`: Time at which the order was placed'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIME`: 下单时间'
- en: '`ID`: The unique ID of the order'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ID`: 订单的唯一ID'
- en: '`TT`: The order transaction type (`BUY` or `SELL`)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TT`: 订单交易类型（`BUY`或`SELL`）'
- en: 'An example of this table is shown here:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此表的示例如下：
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This information will help you find this exact order in the strategy execution
    log.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息将帮助你在策略执行日志中找到这个确切的订单。
- en: 'An order state transition table, with the following columns:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个订单状态转换表，包括以下列：
- en: '`TIME`: Timestamp at which the order enters the state represented by the `''STATE''`
    column.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIME`: 订单进入由`''STATE''`列表示的状态的时间戳。'
- en: '`STATE`: The order enters this `''STATE''` at the timestamp mentioned in the
    `''TIME''` column.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATE`: 订单在`''TIME''`列中提到的时间戳进入此`''STATE''`。'
- en: '`MSG`: An additional message from the **Order Management System** (**OMS**)
    for any unexpected state transitions. For example, orders that go to the `REJECTED`
    state have a message from the OMS stating the reason for their rejection. This
    column is usually empty.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MSG`: 来自**订单管理系统**（**OMS**）的额外信息，用于任何意外状态转换。例如，进入`REJECTED`状态的订单有来自OMS的拒绝原因的消息。该列通常为空。'
- en: 'An example of this table is shown here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 此表的示例如下：
- en: '[PRE33]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: From this table, you can see that, upon placing the order at 9:45 a.m., it transitions
    to the `'COMPLETE'` state immediately. This is expected as the order is a regular
    market order.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 从这张表中，你可以看到，在上午9:45下单后，订单立即转移到`'COMPLETE'`状态。这是预期的，因为订单是常规市价订单。
- en: There's more...
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Once the backtesting job moves to the `'STOPPED'` state, no new order history
    logs are generated. You can fetch the complete order history logs any time before
    you submit the next backtesting job for the same strategy. If a new backtesting
    job is submitted (for the same strategy), these logs will no longer be accessible
    via the `get_backtesting_report_order_history()` method. You can save the fetched
    logs to a file if you'd like to refer to them at a later date.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦回测作业转移到`'STOPPED'`状态，就不会生成新的订单历史记录日志。您可以在提交下一个相同策略的回测作业之前的任何时间获取完整的订单历史记录日志。如果提交了新的回测作业（用于相同的策略），这些日志将不再通过`get_backtesting_report_order_history()`方法访问。如果您希望以后参考这些日志，可以将获取的日志保存到文件中。
- en: MACD-Bracket-Order strategy – fetching the strategy
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order 策略 – 获取策略
- en: In this recipe, you will fetch the `StrategyMACDBracketOrder` strategy class
    from your account on the AlgoBulls platform, which you uploaded while going through
    the last recipe in the previous chapter. This recipe starts with setting up a
    connection to the AlgoBulls platform, querying all available strategies in your
    account, and fetching details of the required strategy class, `StrategyMACDBracketOrder`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将从您在 AlgoBulls 平台上的帐户中获取`StrategyMACDBracketOrder`策略类，这是您在上一章的最后一个配方中上传的。这个配方从建立到
    AlgoBulls 平台的连接开始，查询您帐户中的所有可用策略，并获取所需策略类`StrategyMACDBracketOrder`的详细信息。
- en: Make sure you have gone through the last six recipes of the previous chapter
    to get a complete picture of the strategy class we will be using; that is, `StrategyMACDBracketOrder`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经阅读了上一章的最后六个配方，以完全了解我们将要使用的策略类，即`StrategyMACDBracketOrder`。
- en: How to do it…
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'We execute the following steps for this recipe:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为此配方执行以下步骤：
- en: 'Import the necessary modules:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的模块：
- en: '[PRE34]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a new AlgoBulls connection object:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 AlgoBulls 连接对象：
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Fetch the authorization URL:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取授权 URL：
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We get the following output:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE37]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Log into the preceding link with your AlgoBulls credentials, fetch your token,
    and set it here (refer to *Appendix II* for more details):'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的 AlgoBulls 凭据登录前面的链接，获取您的令牌，并在此设置它（有关更多详细信息，请参阅*附录 II*）：
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Fetch and display all the strategies you have created and uploaded so far:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取并显示您迄今为止创建和上传的所有策略：
- en: '[PRE39]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We get the following output. Your output may differ (make sure you have followed
    the recipes in the previous chapter to get a similar output):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出。您的输出可能会有所不同（确保您已经按照上一章的配方来获得类似的输出）：
- en: '![](img/c4744cb5-ad14-4fc5-98d1-ead69ecca5b1.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4744cb5-ad14-4fc5-98d1-ead69ecca5b1.png)'
- en: 'Fetch and display the strategy code of the second strategy, **MACD-Bracket-Order
    strategy**:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取并显示第二个策略 **MACD-Bracket-Order 策略** 的策略代码：
- en: '[PRE40]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We get the following output (your output may differ):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出（您的输出可能不同）：
- en: '[PRE41]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Before backtesting your strategy, you can inspect your strategy to ensure you
    have the right strategy:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对您的策略进行回测之前，您可以检查您的策略以确保您拥有正确的策略：
- en: '[PRE42]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We get the following output:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE43]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The complete output is not shown here. Please visit the following link to read
    the complete output: [https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_macd_bracket_order.py](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_macd_bracket_order.py).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有显示完整的输出。请访问以下链接以阅读完整的输出：[https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_macd_bracket_order.py](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_macd_bracket_order.py)。
- en: How it works…
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理如下…
- en: You import the necessary modules in *step 1*. In *step 2*, you create an instance
    of the `AlgoBullsConnection` class, named `algobulls_connection`. In *step 3*,
    you get the authorization URL using the `get_authorization_url()` method of the
    `algobulls_connection` object. This prints the authorization URL. You should visit
    this URL from your web browser to sign into the AlgoBulls platform and fetch your
    developer access token. (You can find more details, along with screenshots, in
    *Appendix II* on fetching developer access token from the AlgoBulls platform.)
    You copy the access token and set it in *step 4* using the `set_access_token()`
    method of `algobulls_connection`. If the token is accepted, a successful connection
    is set up with the AlgoBulls platform.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1* 中，您导入必要的模块。在*步骤 2* 中，您创建了 `AlgoBullsConnection` 类的一个实例，命名为 `algobulls_connection`。在*步骤
    3* 中，您使用 `algobulls_connection` 对象的 `get_authorization_url()` 方法获取授权 URL。这会打印授权
    URL。您应该从您的网络浏览器访问此 URL 来登录 AlgoBulls 平台并获取您的开发者访问令牌。（您可以在*附录 II*中找到更多详细信息，以及从
    AlgoBulls 平台获取开发者访问令牌的屏幕截图。）您复制访问令牌并在*步骤 4* 中使用 `algobulls_connection` 的 `set_access_token()`
    方法设置它。如果令牌被接受，则会建立与 AlgoBulls 平台的成功连接。
- en: In *step 5*, you fetch all the strategies you have created and uploaded on the
    AlgoBulls platform so far. You use the `get_all_strategies()` method for this
    step and assign it to a new variable, `all_strategies`. This variable is a `pandas.DataFrame`
    object with `strategyCode` and `strategyName` columns. This table holds information
    about the strategy codes and the strategy names you have uploaded previously.
    If you followed the *MACD-Bracket-Order strategy – uploading the strategy on AlgoBulls
    Trading Platform* recipe from [Chapter 8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml),
    *Algorithmic Trading Strategies – Coding Step by Step*, you will find a strategy
    called **MACD-Regular-Order strategy**. In *step 6*, you assign the strategy code
    of the strategy, **MACD-Regular-Order strategy**, to a new variable called `strategy_code2`.
    The strategy code is shown in the output of this step. This strategy code is unique
    to every strategy on the AlgoBulls platform.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 5* 中，您获取到目前在 AlgoBulls 平台上创建并上传的所有策略。您使用 `get_all_strategies()` 方法进行此步骤，并将其赋值给一个新变量
    `all_strategies`。此变量是一个 `pandas.DataFrame` 对象，具有 `strategyCode` 和 `strategyName`
    列。此表包含您之前上传的策略代码和策略名称的信息。如果您遵循了[第 8 章](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml)中的
    *MACD-Bracket-Order 策略 - 在 AlgoBulls 交易平台上上传策略* 配方，*算法交易策略 - 逐步编码*，您将会找到一个名为 **MACD-Regular-Order
    策略** 的策略。在*步骤 6* 中，您将策略 **MACD-Regular-Order 策略** 的策略代码分配给一个名为 `strategy_code2`
    的新变量。策略代码显示在此步骤的输出中。此策略代码对于 AlgoBulls 平台上的每个策略都是唯一的。
- en: Finally, in *step 7*, you ensure that the strategy being referred to by `strategy_code2`
    is indeed the one you uploaded earlier (in the last recipe of the previous chapter).
    You use the `get_strategy_details()` method of the `algobulls_connection` object
    to inspect the strategy. This method takes strategy code as an argument. You pass
    `strategy_code2` here. This method returns the entire class code as a string.
    You assign it to a new variable, `strategy_details2`, and display it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*步骤 7* 中，您确保 `strategy_code2` 所引用的策略确实是您之前上传的那一个（在上一章的最后一个配方中）。您使用 `algobulls_connection`
    对象的 `get_strategy_details()` 方法来检查策略。这个方法以策略代码作为参数。您在这里传递 `strategy_code2`。此方法返回整个类代码作为字符串。您将其赋值给一个新变量
    `strategy_details2`，并显示它。
- en: If you would like to change the class code being referred to by `strategy_code2`,
    as shown in *step 7*, please refer to the *There's more…* section of the last
    recipe in [Chapter 8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml), *Algorithmic
    Trading Strategies – Coding Step by Step*.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要更改由 `strategy_code2` 引用的类代码，如 *步骤 7* 中所示，请参考[第 8 章](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml)的上一个配方的
    *更多信息…* 部分，*算法交易策略 - 逐步编码*。
- en: MACD-Bracket-Order strategy – backtesting the strategy
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order 策略 - 回测策略
- en: In this recipe, you will perform backtesting on the **MACD-Bracket-Order strategy**.
    You must have fetched this strategy from your account on the AlgoBulls platform
    in the previous recipe of this chapter. You will leverage the backtesting functionality
    facilitated by `pyalgotrading` for this recipe, which, in turn, submits a backtesting
    job on the AlgoBulls platform.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将对 **MACD-Bracket-Order 策略** 进行回测。您必须在本章的上一个配方中从 AlgoBulls 平台的您的账户中获取此策略。您将利用
    `pyalgotrading` 为这个配方提供的回测功能，这将在 AlgoBulls 平台上提交一个回测任务。
- en: 'Once submitted, backtesting will be run by the AlgoBulls backtesting engine.
    You can query the status at any time to find out the state of the backtesting
    job. The job goes through the following states, in the given order:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提交，回测将由AlgoBulls回测引擎运行。您可以随时查询状态以了解回测作业的状态。作业按以下顺序经历以下状态：
- en: '`STARTING` (Intermediate state)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STARTING`（中间状态）'
- en: '`STARTED` (Stable state)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STARTED`（稳定状态）'
- en: '`STOPPING` (Intermediate state)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STOPPING`（中间状态）'
- en: '`STOPPED` (Stable state)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STOPPED`（稳定状态）'
- en: On submitting a job, it starts with an intermediate state, `'STARTING'`. In
    this state, the AlgoBulls backtesting engine fetches the strategy and get the
    execution environment ready, which may take a couple of minutes. Once done, the
    job moves to the `'STARTED'` state. Strategy backtesting happens at this stage.
    Here, it stays as long as it takes for backtesting to complete. Once done, the
    job moves to an intermediate state, `'STOPPING'`. In this state, the AlgoBulls
    backtesting engine cleans up the resources that have been allocated to this job,
    which usually takes less than a minute. Finally, the job moves to the `'STOPPED'`
    state.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交作业时，它会从中间状态`'STARTING'`开始。在此状态下，AlgoBulls回测引擎获取策略并准备执行环境，这可能需要几分钟。完成后，作业转移到`'STARTED'`状态。策略回测发生在此阶段。在此阶段，作业将停留，直到回测完成。完成后，作业将转移到中间状态`'STOPPING'`。在此状态下，AlgoBulls回测引擎清理分配给此作业的资源，通常需要不到一分钟。最后，作业转移到`'STOPPED'`状态。
- en: If you have already submitted a backtesting job for a strategy, you cannot submit
    another job for the same strategy until the first job completes. This means you
    have to wait for the first job to move to the `'STOPPED'` state. If the first
    job is long-running and you would like to stop it immediately, you can submit
    a stop job request via `pyalgotrading`. You need to ensure the job is in the `'STARTED'`
    state before submitting the request.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经为某个策略提交了回测作业，那么在第一个作业完成之前，您不能为同一策略提交另一个作业。这意味着您必须等待第一个作业进入`'STOPPED'`状态。如果第一个作业运行时间很长，并且您希望立即停止它，您可以通过`pyalgotrading`提交停止作业请求。您需要确保作业在提交请求前处于`'STARTED'`状态。
- en: After submitting a backtesting job, you can fetch logs and reports for the strategy
    execution in real time. The logs and reports help validate the strategy's performance
    and debug any potential issues.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交回测作业后，您可以实时获取策略执行的日志和报告。日志和报告有助于验证策略的性能并调试任何潜在问题。
- en: You can refer to the second recipe of this chapter to see the state machine
    diagram of a backtesting job. It demonstrates the various states and transitions
    of a backtesting job during its lifetime on the AlgoBulls platform.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考本章的第二个配方，查看AlgoBulls平台上回测作业的状态机图。它展示了回测作业在其生命周期中的各种状态和转换。
- en: Make sure you have gone through the last six recipes of the previous chapter
    to get a complete picture of the strategy class we will be using; that is, `StrategyMACDBracketOrder`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经阅读了上一章的最后六个配方，以全面了解我们将使用的策略类，即`StrategyMACDBracketOrder`。
- en: Getting ready
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Make sure the `algobulls_connection` and `strategy_code2` objects are available
    in your Python namespace. Refer to the preceding recipe of this chapter to set
    up the `algobulls_connection` and `strategy_code2` object.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`algobulls_connection`和`strategy_code2`对象在您的Python命名空间中可用。请参考本章的上一配方来设置`algobulls_connection`和`strategy_code2`对象。
- en: How to do it…
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We execute the following steps for this recipe:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行以下步骤来完成此操作：
- en: 'Import the necessary modules:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的模块：
- en: '[PRE44]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Search for an instrument using its trading symbol as a keyword. Assign the
    returned object to `instruments`:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用其交易符号作为关键字搜索工具。将返回的对象分配给`instruments`：
- en: '[PRE45]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We get the following output (your output may differ):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得以下输出（您的输出可能不同）：
- en: '[PRE46]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Get `value` for the instrument of choice from `instruments`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`instruments`获取所选工具的`value`：
- en: '[PRE47]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We get the following output:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得以下输出：
- en: '[PRE48]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Submit a backtesting job for `strategy_code2`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`strategy_code2`提交回测作业：
- en: '[PRE49]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We get the following output:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得以下输出：
- en: '[PRE50]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Check the status of the submitted backtesting job:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查提交的回测作业的状态：
- en: '[PRE51]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Check the status of the submitted backtesting job again after some time:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过一段时间后再次检查提交的回测作业的状态：
- en: '[PRE52]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works…
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 1*, you import the `datetime` class from the `datetime` module and
    all the required constants from the `pyalgotrading.constants` module. In *step
    2*, you fetch the instrument that you would like to backtest the strategy for,
    the **MACD-Bracket-Order strategy**, using the `search_instrument()` method of
    the `algobulls_connection` object. The `search_instrument()` method accepts a
    search string as an argument, which should be the trading symbol, in part or complete,
    of the instrument you are interested in. You pass `'TATASTEEL'` here. This function
    returns a list with details of the instruments that match the search string. There
    could be multiple instruments that have the search string in their trading symbols.
    In *step 3*, you fetch the value of the first matched instrument and assign it
    to a new variable, `instrument`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，您从`datetime`模块中导入`datetime`类，以及从`pyalgotrading.constants`模块中导入所有所需的常量。在*步骤2*中，您使用`algobulls_connection`对象的`search_instrument()`方法获取您想要为其回测策略的工具，**MACD-Bracket-Order策略**。`search_instrument()`方法接受一个搜索字符串作为参数，该字符串应该是您感兴趣的工具的交易代码的部分或完整内容。这里您传递了`'TATASTEEL'`。该函数返回一个包含与搜索字符串匹配的工具详细信息的列表。可能会有多个工具的交易代码中含有搜索字符串。在*步骤3*中，您获取第一个匹配工具的值，并将其赋值给一个新变量，`instrument`。
- en: 'In *step 4*, you submit a backtesting job using the `backtest()` method of
    the `algobulls_connection()` object. It takes the following arguments:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，您使用`algobulls_connection()`对象的`backtest()`方法提交一个回测任务。它接受以下参数：
- en: '`strategy_code`: Strategy code of the strategy for which backtesting has to
    be performed. This should be a string. You pass `strategy_code2` here.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strategy_code`: 要进行回测的策略的策略代码。这应该是一个字符串。在这里，您传递了`strategy_code2`。'
- en: '`start_timestamp`: Timestamp of the past from which backtesting should be started.
    This should be a `datetime.datetime` object. Here, you pass an object holding
    the value 1st July 2020 9:15 hours – `dt(year=2020, month=7, day=1, hour=9, minute=15)`. Refer
    to the first recipe of [Chapter 1](efb7347f-05e4-4856-9ede-88bdcf393efa.xhtml), 
    *Handling and Manipulating Date, Time, and Time Series Data*, for details on creating
    a `datetime` object.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start_timestamp`: 进行回测的起始时间戳。这应该是一个`datetime.datetime`对象。这里，您传递了一个包含2020年7月1日9:15小时的值的对象
    - `dt(year=2020, month=7, day=1, hour=9, minute=15)`。有关创建`datetime`对象的详细信息，请参阅[第1章](efb7347f-05e4-4856-9ede-88bdcf393efa.xhtml)的第一个示例，即*处理和操作日期、时间和时间序列数据*。'
- en: '`end_timestamp`: Timestamp of the past for when backtesting should be performed.
    This object should hold a timestamp value ahead of the `timestamp` value held
    by `start_timestamp`. This should be a `datetime.datetime` instance. Here, you
    pass an object holding the value 7th July 2020 15:30 hours - `dt(year=2020, month=7,
    day=7, hour=15, minute=30)`.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end_timestamp`: 进行回测的结束时间戳。此对象应持有比`start_timestamp`持有的时间戳值要晚的时间戳。这应该是一个`datetime.datetime`实例。在这里，您传递了一个包含2020年7月7日15:30小时的值的对象
    - `dt(year=2020, month=7, day=7, hour=15, minute=30)`。'
- en: '`instrument`: A financial instrument for which backtesting should be run. Historical
    data will be fetched for this instrument. This should be a string. You pass `instrument`
    here.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instrument`: 应该运行回测的金融工具。将为此工具获取历史数据。这应该是一个字符串。在这里，您传递了`instrument`。'
- en: '`lots`: Number of lots for which backtesting should be performed. This should
    be an integer. The quantity is calculated by the strategy as *number of lots *×
    *lot size of the financial instrument*. (See the *MACD-Bracket-Order strategy
    – coding the strategy_select_instruments_for_entry method* recipe in [Chapter
    8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml), *Algorithmic Trading Strategies
    - Coding Step by Step*.) You pass `1` here.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lots`: 进行回测的手数。这应该是一个整数。该数量由策略计算为*手数*×*金融工具的手数*。 (请参阅[第8章](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml)的*MACD-Bracket-Order策略
    - 编写策略_select_instruments_for_entry方法*，*算法交易策略 - 逐步编码*。) 在这里，您传递了`1`。'
- en: '`strategy_parameters`: Parameter names and values expected by the strategy.
    This should be a dictionary, with `parameter-name` and `parameter-value` as key-value
    pairs. You pass the following parameters here:'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strategy_parameters`: 策略所需的参数名称和值。这应该是一个字典，其中`parameter-name`和`parameter-value`是键值对。您在这里传递以下参数：'
- en: '`fastma_period: 26`'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fastma_period: 26`'
- en: '`slowma_period: 6 `'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slowma_period: 6`'
- en: '`signal_period: 9`'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signal_period: 9`'
- en: '`target_trigger: 0.01`'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_trigger: 0.01`'
- en: '`stoploss_trigger: 0.01`'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stoploss_trigger: 0.01`'
- en: '`trailing_stoploss_trigger: 1`'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trailing_stoploss_trigger: 1`'
- en: (Recall that the parameters for the MACD-Bracket-Order strategy were defined
    in its `__init__()` method in the first recipe of the previous chapter).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: （回想一下，MACD-Bracket-Order策略的参数在前一章的`__init__()`方法中定义）。
- en: '`candle_interval`: The candle interval for the historical data fetched for
    backtesting. This should be an enum of the `CandleInterval` type. You pass `CandleInterval.MINUTES_15`
    here. (The `CandleInterval` enum provides various enums for candle intervals,
    some of which are `MINUTE_1`, `MINUTES_3` , `MINUTES_5`, `MINUTES_10`, `MINUTES_15`,
    `MINUTES_30`, `HOUR`, and `DAY`.)'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`candle_interval`: 用于回测的历史数据获取的蜡烛图间隔。这应该是`CandleInterval`类型的枚举。在这里，你传递`CandleInterval.MINUTES_15`。（`CandleInterval`枚举提供各种蜡烛图间隔的枚举，其中一些是`MINUTE_1`、`MINUTES_3`、`MINUTES_5`、`MINUTES_10`、`MINUTES_15`、`MINUTES_30`、`HOUR`和`DAY`）。'
- en: If the job submission is successful, you will see `Success` messages being printed
    by the `backtest()` function.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果作业提交成功，你会看到`backtest()`函数打印出`Success`消息。
- en: Once a job has been submitted, it takes a while to start. After starting, it
    may take some time to finish, depending on the complexity of the strategy and
    duration of backtesting specified using the `start_timestamp` and `end_timestamp`
    arguments. A few days of backtesting may finish in seconds, while a few months
    of backtesting may take minutes.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦作业提交，启动需要一段时间。启动后，根据指定的策略复杂度和回测持续时间（使用`start_timestamp`和`end_timestamp`参数），完成可能需要一些时间。几天的回测可能在几秒内完成，而几个月的回测可能需要几分钟。
- en: In *step 5*, you fetch the job status using the `get_backtesting_job_status()`
    method of the `algobulls_connection` object. You pass `strategy_code2` as the
    argument here. This method returns a dictionary with a single key-value pair –
    the data and the job status. If you query the status immediately after placing
    the job, you get `'STARTING'` as the status. In *step 6*, you query the status
    again after some time, and if the job starts, you get a status of `'STARTED'`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，你使用`algobulls_connection`对象的`get_backtesting_job_status()`方法获取作业状态。在这里，你将`strategy_code2`作为参数传递。该方法返回一个键值对字典
    - 数据和作业状态。如果在放置作业后立即查询状态，你会得到`'STARTING'`作为状态。在*步骤6*中，你再次查询状态，如果作业已经启动，你会得到`'STARTED'`的状态。
- en: A successful submission implies that the minimum inputs needed to backtest a
    strategy have been passed in the required format. However, this does not ensure
    that the strategy will run without errors. The strategy's execution may still
    run into errors during backtesting. To debug execution issues, you will need to
    fetch the output logs, which will be explained in the next recipe. Possible reasons
    for errors could be bugs in the strategy class' Python code or an incomplete `strategy_parameters`
    dictionary being passed to the `backtest()` function.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 成功提交意味着以所需格式传递了回测策略的最小输入。然而，这并不保证策略会在回测期间无错误地运行。策略的执行仍然可能在回测过程中遇到错误。要调试执行问题，你需要获取输出日志，这将在下一个示例中解释。错误的可能原因包括策略类的Python代码中的错误或传递给`backtest()`函数的`strategy_parameters`字典不完整。
- en: There's more…
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If a job is running for a long time and you would like to stop it before its
    completion, you can use the `stop_backtesting_job()` method of the `algobulls_connection`
    object. This method accepts strategy code as an argument. You pass `strategy_code2`
    here. This method submits a stop request to the AlgoBulls backtesting engine.
    If the request is accepted, you will see a `Success` message here:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果作业运行时间很长，你希望在完成之前停止它，你可以使用`algobulls_connection`对象的`stop_backtesting_job()`方法。此方法接受策略代码作为参数。在这里，你传递`strategy_code2`。该方法向AlgoBulls回测引擎提交停止请求。如果请求被接受，你会看到一个`Success`消息：
- en: '[PRE53]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you query the status after submitting the stop request, you will get a status
    of `''STOPPING``:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在提交停止请求后查询状态，你会得到一个`'STOPPING'`的状态：
- en: '[PRE54]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you query the status again after some time, and if the job has stopped,
    you will get a status of `''STOPPED''`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一段时间后再次查询状态，如果作业已经停止，你会得到`'STOPPED'`的状态：
- en: '[PRE55]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: MACD-Bracket-Order strategy – fetching backtesting logs in real time
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order策略 - 实时获取回测日志
- en: After submitting a backtesting job on the AlgoBulls platform, the AlgoBulls
    backtesting engine starts executing the strategy. During its execution, every
    event that occurs and the decisions that have been made by the AlgoBulls backtesting
    engine are recorded with exact timestamps in the form of textual logs. Examples
    of recorded activities include the given strategy config, every new candle generated
    at regular intervals, trades punched in by your strategy, the entry and exit of
    positions created by these trades, waits for new candles, and so on. These logs
    are quintessential for validating the strategy's behavior and debugging behavioral
    or performance issues that are frequently encountered while developing a strategy.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在AlgoBulls平台提交回测作业后，AlgoBulls回测引擎开始执行策略。在执行过程中，AlgoBulls回测引擎记录了发生的每个事件以及所做出的决策，以确切的时间戳形式记录在文本日志中。记录的活动示例包括给定策略配置、定期生成的每个新蜡烛、您的策略输入的交易、由这些交易创建的头寸的进入和退出、等待新蜡烛等等。这些日志对于验证策略行为以及调试在开发策略时经常遇到的行为或性能问题至关重要。
- en: In this recipe, you will fetch backtesting logs for your strategy. The logs
    start coming up as soon as your submitted backtesting job reaches the `'STARTED'`
    state. The AlgoBulls platform allows you to fetch logs in real time, even while
    the backtesting job is still going on. You can get insights into the strategy
    execution without having to wait for the backtesting job to complete, which is
    helpful when jobs are long-running. The `pyalgotrading` package provides a simple
    method for fetching the execution logs for a given strategy.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将获取您的策略的回测日志。日志会在您提交的回测作业达到`'STARTED'`状态时开始出现。AlgoBulls平台允许您实时获取日志，即使回测作业仍在进行中。您可以在不等待回测作业完成的情况下深入了解策略执行情况，这在作业运行时间较长时非常有用。`pyalgotrading`包提供了一个简单的方法来获取给定策略的执行日志。
- en: Make sure you have gone through the last six recipes of the previous chapter
    to get a complete picture of the strategy class we will be using; that is, `StrategyMACDBracketOrder`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经浏览了上一章的最后六个配方，以完整了解我们将要使用的策略类别；也就是`StrategyMACDBracketOrder`。
- en: Getting ready
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure the `algobulls_connection` and `strategy_code2` objects are available
    in your Python namespace. Refer to the *MACD-Bracket-Order strategy – fetching
    the strategy* recipe of this chapter to set up the `algobulls_connection` and
    `strategy_code2` objects.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`algobulls_connection`和`strategy_code2`对象在您的Python命名空间中可用。请参考本章的*MACD-Bracket-Order
    strategy – fetching the strategy*配方来设置`algobulls_connection`和`strategy_code2`对象。
- en: How to do it…
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We execute the following steps for this recipe:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对这个配方执行以下步骤：
- en: 'Fetch the backtesting execution logs for `strategy_code2`:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`strategy_code2`的回测执行日志：
- en: '[PRE56]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We get the following output (your output may differ):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下输出（您的输出可能不同）：
- en: '[PRE57]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Fetch the backtesting execution logs for `strategy_code2` again after some
    time:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一段时间后再次获取`strategy_code2`的回测执行日志：
- en: '[PRE58]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We get the following output (your output may differ):'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下输出（您的输出可能不同）：
- en: '[PRE59]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The complete output is not shown here. Please visit the following link to read
    the complete output: [https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_macd_bracket_order/logs.txt](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_macd_bracket_order/logs.txt).'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 此处未显示完整输出。请访问以下链接阅读完整输出：[https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_macd_bracket_order/logs.txt](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_macd_bracket_order/logs.txt)。
- en: How it works…
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 1*, you use the `get_backtesting_logs()` method of the `algobulls_connection`
    object to fetch the strategy backtesting logs in real time. This method accepts
    strategy code as an argument. You pass `strategy_code2` here. The return data
    is a string. If you try this step immediately after submitting the job, you'll
    get a string that states that the logs are not ready yet (`[2020-07-30 17:27:25]
    Logs not available yet. Please retry in sometime.`). This happens if the backtesting
    job is in the `'STARTING'` state.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，您使用`algobulls_connection`对象的`get_backtesting_logs()`方法实时获取策略回测日志。此方法接受策略代码作为参数。在此处传递`strategy_code2`。返回的数据是一个字符串。如果在提交作业后立即尝试此步骤，您将获得一个字符串，指出日志尚未准备好（`[2020-07-30
    17:27:25] 日志尚未准备好，请稍后重试。`）。如果回测作业处于`'STARTING'`状态，则会发生这种情况。
- en: In *step 2*, you fetch the logs again after some time. If the job is out of
    the `'STARTING'` state, you start getting your strategy execution logs. You get
    the entire backtesting log every time you call the `get_backtesting_logs()` function.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 2 步*中，你在一段时间后再次获取日志。如果作业处于`'STARTING'`状态之外，你就开始获取你的策略执行日志。每次调用`get_backtesting_logs()`函数时，你都会得到整个回测日志。
- en: There's more...
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Once the backtesting job moves to the `'STOPPED'` state, no new logs are generated.
    You can fetch the complete logs at any time before you submit the next backtesting
    job for the same strategy. If a new backtesting job is submitted (for the same
    strategy), these logs will no longer be accessible via the `get_backtesting_logs()`
    method. You can save the fetched logs to a file if you'd like to refer to it at
    a later date.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦回测作业转移到`'STOPPED'`状态，就不会生成新的日志。你可以在提交下一个相同策略的回测作业之前的任何时候获取完整的日志。如果提交了一个新的回测作业（针对相同的策略），这些日志将不再通过`get_backtesting_logs()`方法访问。如果你希望以后参考，你可以将获取的日志保存到文件中。
- en: MACD-Bracket-Order strategy – fetching a backtesting report – profit and loss
    table
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order 策略 – 获取回测报告 – 盈亏表
- en: After submitting a backtesting job on the AlgoBulls platform, the AlgoBulls
    backtesting engine starts executing the strategy. During its execution, along
    with the logs, the AlgoBulls backtesting engine also generates a P&L table in
    real time. This table holds information on every trade that's been punched in
    by the strategy. It also contains details on the mappings between entry and exit
    orders, the trade P&L, and the cumulative P&L, sorted chronologically, with the
    latest order first.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AlgoBulls 平台上提交回测作业后，AlgoBulls 回测引擎开始执行策略。在其执行过程中，除了日志外，AlgoBulls 回测引擎还实时生成
    P&L 表。该表包含了策略输入的每一笔交易的信息。它还包含了入口和出口订单之间的映射、交易 P&L 和累积 P&L 的详细信息，按时间顺序排序，最新的订单排在最前面。
- en: This table gives us insights into the strategy's overall performance with the
    help of individual and cumulative P&L numbers. The entry-exit order mapping also
    helps validate the strategy's behavior.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格通过个人和累积 P&L 数字帮助我们了解策略的整体表现。入口-出口订单映射也有助于验证策略的行为。
- en: In this recipe, you will fetch the P&L table report for your strategy. This
    report is available as soon as the first trade is punched in by your strategy
    after you submit a backtesting job. The AlgoBulls platform allows you to fetch
    the P&L table in real time, even while the backtesting job is still going on.
    You can get insights into the strategy's performance without having to wait for
    the backtesting job to complete, which is helpful when jobs are long-running.
    The `pyalgotrading` package provides a simple method you can use to fetch the
    P&L table for a given strategy.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你将获取你的策略的 P&L 表报告。在提交回测作业后，只要你的策略打出第一笔交易，这个报告就可以获得。AlgoBulls 平台允许你实时获取
    P&L 表，即使回测作业仍在进行中。在作业运行时间较长时，这对于获取策略表现的洞察力是有帮助的。`pyalgotrading`包提供了一个简单的方法，你可以用它来获取给定策略的
    P&L 表。
- en: Make sure you have gone through the last six recipes of the previous chapter
    to get a complete picture of the strategy class we will be using; that is, `StrategyMACDBracketOrder`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经浏览了上一章的最后六个食谱，以完整地了解我们将使用的策略类的情况；也就是说，`StrategyMACDBracketOrder`。
- en: Getting ready
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Make sure the `algobulls_connection` and `strategy_code2` objects are available
    in your Python namespace. Refer to the *MACD-Bracket-Order strategy – fetching
    the strategy* recipe of this chapter to set up the `algobulls_connection` and
    `strategy_code2` objects.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的 Python 命名空间中有`algobulls_connection`和`strategy_code2`对象可用。请参考本章的 *MACD-Bracket-Order
    策略 – 获取策略* 食谱设置`algobulls_connection`和`strategy_code2`对象。
- en: How to do it…
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Fetch the backtesting P&L report for `strategy_code2`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`strategy_code2`的回测 P&L 报告：
- en: '[PRE60]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We got the following output. Your output may differ (note that the following
    output has been split into multiple tables for representation purposes. You will
    see a single wide table in your Jupyter Notebook):'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下输出。你的输出可能会有所不同（注意以下输出已经分成多个表格以便表示。你在 Jupyter Notebook 中将看到一个宽表）：
- en: '![](img/cf72229d-6054-416d-899c-1d7c20edbdbc.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf72229d-6054-416d-899c-1d7c20edbdbc.png)'
- en: How it works…
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运作原理...
- en: 'In this recipe, you use the `get_backtesting_report_pnl_table()` method of
    the `algobulls_connection` object to fetch the backtesting P&L table in real time.
    This method accepts strategy code as an argument. You pass `strategy_code2` here.
    The return data is a `pandas.DataFrame` object with multiple columns, described
    as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，您可以使用`algobulls_connection`对象的`get_backtesting_report_pnl_table()`方法实时获取回测P＆L表。
    此方法接受策略代码作为参数。 在此处传递`strategy_code2`。 返回数据是一个带有多列的`pandas.DataFrame`对象，描述如下：
- en: '`instrument`: Financial instrument for which the trade was entered.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instrument`：输入的金融工具。'
- en: '`entry_timestamp`: The timestamp at which the entry order was placed. (Note
    that it may remain in the `''OPEN''` state for a while before it goes to `''COMPLETE''`
    state. The time for this state transition can be found using the order history
    table, as explained in the last recipe of this chapter.)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry_timestamp`：放置进入订单的时间戳。（请注意，它可能在进入`''COMPLETE''`状态之前保持一段时间处于`''OPEN''`状态。可以通过订单历史表找到此状态转换的时间，如本章的最后一个示例所述。）'
- en: '`entry_transaction_type`: Entry order transaction type (either `BUY` or `SELL`).'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry_transaction_type`：进入订单交易类型（`BUY`或`SELL`）。'
- en: '`entry_quantity`: Entry order quantity.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry_quantity`：进入订单数量。'
- en: '`entry_price`: Price at which the entry order gets executed and goes to the `''COMPLETE''`
    state.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`进入价格`：进入订单执行并进入`''COMPLETE''`状态的价格。'
- en: '`exit_timestamp`: The timestamp at which the exit order was placed. (Note that
    it may remain in the `''OPEN''` state for a while before it goes to the `''COMPLETE''`
    state.)'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`退出时间戳`：放置退出订单的时间戳。（请注意，它可能在进入`''COMPLETE''`状态之前保持一段时间处于`''OPEN''`状态。）'
- en: '`exit_transaction_type`: Exit order transaction type (either `BUY` or `SELL`).'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exit_transaction_type`：退出订单交易类型（`BUY`或`SELL`）。'
- en: '`exit_quantity`: Exit order quantity.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exit_quantity`：退出订单数量。'
- en: '`exit_price`: Price at which the exit order gets executed and goes to the `''COMPLETE''`
    state.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`退出价格`：退出订单执行并进入`''COMPLETE''`状态的价格。'
- en: '`pnl_absolute`: Difference between the exit order execution price and the entry
    order execution price. Mathematically, this can be represented as (*exit_price*
    - *entry_price*)**exit_quantity* for a long trade and (*entry_price* - *exit_price*)**exit_quantity*
    for a short trade. A positive value would imply that the trade is a profit-making
    trade. A negative value would imply that the trade is a loss-making trade.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pnl_absolute`：退出订单执行价格与进入订单执行价格之间的差值。 在数学上，这可以表示为（*退出价格* - *进入价格*）**退出数量*（对于多头交易），以及（*进入价格*
    - *退出价格*）**退出数量*（对于空头交易）。 正值意味着交易是盈利交易。 负值意味着交易是亏损交易。'
- en: '`pnl_percentage`: Percentage of profit or loss with respect to the entry price.
    Mathematically, this is *pnl_absolute* / *entry_price / exit_quantity *× *100*.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pnl_percentage`：相对于进入价格的利润或损失的百分比。 在数学上，这是 *pnl_absolute* / *entry_price /
    exit_quantity *× *100*。'
- en: '`pnl_cumulative_absolute`: Cumulative profit or loss. Mathematically, this
    is the sum of all the `pnl_absolute` values of the previous trades. This number
    gives us direct insight into the strategy''s performance against the simulation
    time.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pnl_cumulative_absolute`：累积利润或损失。 在数学上，这是以前交易的所有`pnl_absolute`值的总和。 这个数字直接反映了策略相对于模拟时间的表现。'
- en: '`pnl_cumulative_percentage`: Percentage of cumulative profit or loss with respect
    to the entry price. Mathematically, this is *pnl_cumulative* / *entry_price* /
    *exit_quantity* ×* 100*.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pnl_cumulative_percentage`：相对于进入价格的累积利润或损失的百分比。 在数学上，这是 *pnl_cumulative* /
    *entry_price* / *exit_quantity* ×* 100*。'
- en: There's more...
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Once the backtesting job moves to the `'STOPPED'` state, the P&L table report
    won't update anymore. You can fetch the complete P&L report any time before you
    submit the next backtesting job for the same strategy. If a new backtesting job
    is submitted (for the same strategy), this report will no longer be accessible
    via the `get_backtesting_report_pnl_table()` method. You can save the fetched
    report as a `.csv` file if you'd like to refer to it at a later date.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦回测作业转移到`'STOPPED'`状态，P＆L表报告将不再更新。 您可以在提交下一个相同策略的回测作业之前随时获取完整的P＆L报告。 如果提交了新的回测作业（针对相同的策略），则将无法通过`get_backtesting_report_pnl_table()`方法再访问此报告。
    如果您希望稍后参考，可以将获取的报告保存为`.csv`文件。
- en: MACD-Bracket-Order strategy – fetching a backtesting report – statistics table
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order策略 - 获取回测报告 - 统计表
- en: After submitting a backtesting job on the AlgoBulls platform, the AlgoBulls
    backtesting engine starts executing the strategy. During its execution, along
    with the logs and P&L table, the AlgoBulls backtesting engine also generates a
    summary from the P&L table in real time. This summary is a table of statistics
    containing various statistical numbers such as `Net P&L` (absolute and percentage),
    `Max Drawdown` (absolute and percentage), count of total trades, winning trades,
    losing trades, long trades and short trades, maximum gain and minimum gain (or
    maximum loss), and the average profit per winning and losing trade. This table
    gives us an instant overview of the strategy's overall performance.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AlgoBulls 平台上提交回测任务后，AlgoBulls 回测引擎开始执行策略。在执行过程中，除了日志和 P&L 表之外，AlgoBulls 回测引擎还实时从
    P&L 表生成摘要。这个摘要是一个包含各种统计数字的统计表，比如`净利润`（绝对值和百分比）、`最大回撤`（绝对值和百分比）、总交易次数、盈利交易、亏损交易、多头交易和空头交易的计数、最大盈利和最小盈利（或最大亏损）、以及每笔盈利和亏损交易的平均利润。这张表可以让我们快速了解策略的整体表现。
- en: In this recipe, you will fetch the statistics table report for your strategy.
    This report is available as soon as the first trade is punched in by your strategy
    after you submit a backtesting job. The AlgoBulls platform allows you to fetch
    the statistics table in real time, even while the backtesting job is still going
    on. You can get insights into the strategy performance without having to wait
    for the backtesting job to complete, which is helpful when jobs are long-running.
    The `pyalgotrading` package provides a simple method we can use to fetch the statistics
    table for a given strategy.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将为您的策略获取统计表报告。此报告在您提交回测任务后，您的策略打入第一笔交易后即可获取。AlgoBulls 平台允许您实时获取统计表，即使回测任务仍在进行中。您可以在等待回测任务完成时获得对策略性能的见解，这在任务运行时间较长时非常有用。`pyalgotrading`
    包提供了一个简单的方法，我们可以使用它来获取给定策略的统计表。
- en: Make sure you have gone through the last six recipes of the previous chapter
    to get a complete picture of the strategy class we will be using; that is, `StrategyMACDBracketOrder`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经阅读了上一章的最后六个配方，以完全了解我们将使用的策略类别；即`StrategyMACDBracketOrder`。
- en: Getting ready
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure the `algobulls_connection` and `strategy_code2` objects are available
    in your Python namespace. Refer to the *MACD-Bracket-Order strategy – fetching
    the strategy* recipe of this chapter to set up the `algobulls_connection` and
    `strategy_code2` objects.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的 Python 命名空间中有 `algobulls_connection` 和 `strategy_code2` 对象可用。请参考本章的 *MACD-Bracket-Order
    策略 - 获取策略* 配方来设置 `algobulls_connection` 和 `strategy_code2` 对象。
- en: How to do it…
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Fetch the backtesting statistics report for `strategy_code2`:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 `strategy_code2` 的回测统计报告：
- en: '[PRE61]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We get the following output (your output may differ):'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出（您的输出可能会有所不同）：
- en: '![](img/33bc6676-32d5-4886-abf6-a038f92559d7.png)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33bc6676-32d5-4886-abf6-a038f92559d7.png)'
- en: How it works…
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, you use the `get_backtesting_report_statistics()` method of
    the `algobulls_connection` object to fetch the backtesting statistics table in
    real time. This method accepts strategy code as an argument. You pass `strategy_code2`
    here. The return data is a `pandas.DataFrame` object with two columns – `Highlight`
    and `Value` – and multiple rows. The rows are described as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您可以使用 `algobulls_connection` 对象的 `get_backtesting_report_statistics()`
    方法实时获取回测统计表。此方法接受策略代码作为参数。您在这里传递了 `strategy_code2`。返回的数据是一个 `pandas.DataFrame`
    对象，有两列 - `Highlight` 和 `Value` - 以及多行。行的描述如下：
- en: '`Net PnL`: The cumulative backtesting P&L. This is also the `pnl_cumulative_absolute`
    value of the first entry in the P&L table.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`净利润`：累积回测净利润。这也是 P&L 表中第一个条目的 `pnl_cumulative_absolute` 值。'
- en: '`Net PnL %`: The cumulative backtesting P&L percentage. This is also the `pnl_cumulative_percentage`
    value of the first entry in the P&L table.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`净利润 %`：累积回测利润百分比。这也是 P&L 表中第一个条目的 `pnl_cumulative_percentage` 值。'
- en: '`Max Drawdown`: The lowest value in the `pnl_cumulative` column of the P&L
    table. This indicates the maximum loss your strategy has encountered during the
    execution.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`最大回撤`：P&L 表中 `pnl_cumulative` 列中的最低值。这表示您的策略在执行过程中遇到的最大损失。'
- en: '`Max Drawdown %`: Mathematically, this is *(Max Drawdown)* / *(corresponding
    entry_price) / exit_quantity *× *100*.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`最大回撤 %`：在数学上，这是 *(最大回撤)* / *(相应的 entry_price) / exit_quantity* × *100*。'
- en: '`Number of Trades`: Total trades (entry and exit counted as one) during the
    session.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`交易次数`：会话期间的总交易次数（入场和出场计算为一次）。'
- en: '`Number of Wins`: Count of trades where the trade P&L was non-negative.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`盈利次数`：交易 P&L 为非负数的交易计数。'
- en: '`Number of Losses`: Count of trades where the trade P&L was negative.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`亏损次数`：交易 P&L 为负数的交易计数。'
- en: '`Number of Long Trades`: Count of trades where the entry transaction type was
    `''BUY''`.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`买入交易数`：以 `''BUY''` 为入场交易类型的交易计数。'
- en: '`Number of Short Trades`: Count of trades where the entry transaction type
    was `''SELL''`.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`卖出交易数`：以 `''SELL''` 为入场交易类型的交易计数。'
- en: '`Max Gain`: P&L of the trade with the maximum P&L value among all trades.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`最大利润`：所有交易中 P&L 值最大的交易的 P&L。'
- en: '`Min Gain`: P&L of the trade with the minimum P&L value among all trades.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`最小利润`：所有交易中 P&L 值最小的交易的 P&L。'
- en: '`Avg. Profit per winning trade`: Mathematically, this is *(Total P&L of winning
    trades)* / *(Count of winning trades)*.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`每次盈利交易的平均利润`：从数学上讲，这是 *(盈利交易的总 P&L)* / *(盈利交易的计数)*。'
- en: '`Avg. Profit per losing trade`: Mathematically, this is *(Total P&L of losing
    trades)* / *(Count of losing trades)*.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`每次亏损交易的平均利润`：从数学上讲，这是 *(亏损交易的总 P&L)* / *(亏损交易的计数)*。'
- en: There's more...
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If the statistics table is fetched while the backtesting job is still running,
    the aforementioned numbers will be intermediate numbers, based on the trades that
    had been completed up until that time. The numbers may change as more trades are
    punched in, until the backtesting job completes.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在回测作业仍在运行时获取统计表，则上述数字将是中间数字，基于直到该时刻已完成的交易。随着更多交易的输入，这些数字可能会发生变化，直到回测作业完成。
- en: Once the backtesting job moves to the `'STOPPED'` state, the statistics table
    will not change anymore. You can fetch the complete statistics table any time
    before you submit the next backtesting job for the same strategy. If a new backtesting
    job is submitted (for the same strategy), this table will no longer be accessible
    via the `get_backtesting_report_statistics()` method. You can save the fetched
    report as a `.csv` file if you'd like to refer to it at a later date.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦回测作业转移到 `'STOPPED'` 状态，统计表将不再更改。您可以在提交下一个相同策略的回测作业之前的任何时间获取完整的统计表。如果提交了新的回测作业（针对相同策略），则无法通过
    `get_backtesting_report_statistics()` 方法访问此表。如果您希望稍后参考，可以将获取的报告保存为 `.csv` 文件。
- en: MACD-Bracket-Order strategy – fetching a backtesting report – order history
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order 策略 - 获取回测报告 - 订单历史
- en: After submitting a backtesting job on the AlgoBulls platform, the AlgoBulls
    backtesting engine starts executing the strategy. During its execution, along
    with the logs, the P&L table, and the statistics table, the AlgoBulls backtesting
    engine also generates an order history log in real time. This log contains the
    state transitions of every order, along with the timestamps and additional information
    (if any) for each order state. The order history log is crucial in understanding
    how long it has taken for a trade to go from an `'OPEN'` to `'COMPLETE'` or `'CANCELLED'` state.
    For example, `MARKET` orders would immediately go from `'OPEN'` to `'COMPLETE'` but
    `LIMIT` orders may take a while, based on the market conditions, to go from `'OPEN'`
    to `'COMPLETE'` – they may even get `'CANCELLED'`. All this information is available
    in the order history log. (Refer to the state machine diagrams in [Chapter 6](077b54a1-c9c4-424c-912a-11f28db3797f.xhtml),
    *Placing Regular Orders on the Exchange*, for more information on order state
    transitions.)
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AlgoBulls 平台上提交回测作业后，AlgoBulls 回测引擎开始执行策略。在执行过程中，除了日志、P&L 表和统计表之外，AlgoBulls
    回测引擎还实时生成订单历史记录。此日志包含每个订单的状态转换，以及每个订单状态的时间戳和附加信息（如果有）。订单历史记录对于了解交易从 `'OPEN'` 到
    `'COMPLETE'` 或 `'CANCELLED'` 状态所需的时间非常重要。例如，`MARKET` 订单将立即从 `'OPEN'` 转移到 `'COMPLETE'`，但是
    `LIMIT` 订单可能需要一段时间，根据市场条件，从 `'OPEN'` 转移到 `'COMPLETE'` - 甚至可能会被 `'CANCELLED'`。所有这些信息都在订单历史记录中提供。（有关订单状态转换的更多信息，请参阅[第
    6 章](077b54a1-c9c4-424c-912a-11f28db3797f.xhtml)的状态机图，*在交易所上下单*。）
- en: In this recipe, you will fetch the order history log for your strategy. This
    log is available as soon as the first trade is punched in by your strategy after
    you submit a backtesting job. The AlgoBulls platform allows you to fetch the order
    history log in real time, even while the backtesting job is still going on. This
    helps us get details for orders in the end states, without having to wait for
    the backtesting job to complete. The `pyalgotrading` package provides a simple
    method we can use to fetch the order history log for a given strategy.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将获取您的策略的订单历史记录。只要您提交了回测作业后，您的策略就 punched in 第一笔交易，这个日志就可用了。AlgoBulls平台允许您实时获取订单历史记录，即使回测作业仍在进行中。这样我们就可以获得处于最终状态的订单的详细信息，而不必等待回测作业完成。`pyalgotrading`软件包提供了一种简单的方法，我们可以用它来获取给定策略的订单历史记录。
- en: Make sure you have gone through the last recipes of the previous chapter to
    get a complete picture of the strategy class we will be using; that is, `StrategyMACDBracketOrder`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经阅读了前一章节的最后几个配方，以完全了解我们将使用的策略类`StrategyMACDBracketOrder`。
- en: Getting ready
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Make sure the `algobulls_connection` and `strategy_code2` objects are available
    in your Python namespace. Refer to the *MACD-Bracket-Order strategy – fetching
    the strategy* recipe of this chapter to set up the `algobulls_connection` and
    `strategy_code2` objects.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`algobulls_connection`和`strategy_code2`对象在您的Python命名空间中可用。请参考本章的*MACD-Bracket-Order
    strategy – fetching the strategy*配方设置`algobulls_connection`和`strategy_code2`对象。
- en: How to do it…
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 怎么做…
- en: 'Fetch the backtesting order history report for `strategy_code2`:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`strategy_code2`的回测订单历史报告：
- en: '[PRE62]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We get the following output (your output may differ):'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出（您的输出可能不同）：
- en: '[PRE63]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The complete output is not shown here. Please visit the following link to read
    the complete output: [https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_macd_bracket_order/oms_order_history.log](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_macd_bracket_order/oms_order_history.log).'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有显示完整的输出。请访问以下链接以阅读完整的输出：[https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_macd_bracket_order/oms_order_history.log](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_macd_bracket_order/oms_order_history.log)。
- en: How it works…
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, you use the `get_backtesting_report_order_history()` method
    of the `algobulls_connection` object to fetch order history logs in real time.
    This method accepts strategy code as an argument. You pass `strategy_code2` here.
    The return data is a string, described as follows:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您使用`algobulls_connection`对象的`get_backtesting_report_order_history()`方法来实时获取订单历史记录。此方法接受策略代码作为参数。您在这里传递了`strategy_code2`。返回的数据是一个字符串，描述如下：
- en: 'For every order, the log contains the following information:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个订单，日志包含以下信息：
- en: 'A descriptive table of the order, with the following mentioned columns:'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单的描述性表，包括以下列：
- en: '`INST`: Financial instrument of the order'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INST`：订单的金融工具'
- en: '`TIME`: Time at which the order was placed'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIME`：订单被放置的时间'
- en: '`ID`: The unique ID of the order'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ID`：订单的唯一标识符'
- en: '`TT`: The order transaction type (`BUY` or `SELL`)'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TT`：订单交易类型（`BUY`或`SELL`）'
- en: 'An example of the table is shown as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 表的示例如下所示：
- en: '[PRE64]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This information will help you find this exact order in the strategy execution
    log.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息将帮助您在策略执行日志中找到这个确切的订单。
- en: 'An order state transition table, with the following columns:'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个订单状态转换表，具有以下列：
- en: '`TIME`: Timestamp at which the order enters the state represented by the `''STATE''`
    column.'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIME`：订单进入由`''STATE''`列表示的状态的时间戳。'
- en: '`STATE`: The order enters this `''STATE''` column at the timestamp mentioned
    in the `''TIME''` column.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATE`：订单在`''STATE''`列中的状态进入时间戳所述的时间。'
- en: '`MSG`: Additional message from OMS for any unexpected state transitions; for
    example, orders that go to the `REJECTED` state have a message from the OMS stating
    the reason for their rejection. This column is usually empty.'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MSG`：OMS对于任何意外状态转换的额外消息；例如，进入`REJECTED`状态的订单具有来自OMS的说明其被拒绝原因的消息。此列通常为空。'
- en: 'An example of the table is shown as follows:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 表的示例如下所示：
- en: '[PRE65]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: From this table, you can see that upon placing the order at 10:00 a.m., it transitions
    to the `'OPEN PENDING'` state. It stays there for 2.5 hours before transitioning
    to the `'COMPLETE'` state. This is expected as the order is a bracket limit order.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个表格可以看出，在上午10:00下单后，订单转移到`'OPEN PENDING'`状态。在停留了2.5小时后，订单转移到`'COMPLETE'`状态。这是预期的，因为该订单是一个区间限价订单。
- en: There's more...
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Once the backtesting job moves to the `'STOPPED'` state, no new order history
    logs are generated. You can fetch the complete order history logs any time before
    you submit the next backtesting job for the same strategy. If a new backtesting
    job is submitted (for the same strategy), these logs will no longer be accessible
    via the `get_backtesting_report_order_history()` method. You can save the fetched
    logs to a file if you'd like to refer to them at a later date.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦回测任务转移到`'STOPPED'`状态，将不再生成新的订单历史日志。在提交下一个相同策略的回测任务之前，您可以随时获取完整的订单历史日志。如果提交了新的回测任务（针对相同的策略），则无法再通过`get_backtesting_report_order_history()`方法访问这些日志。如果您希望在以后参考这些日志，可以将获取的日志保存到文件中。
