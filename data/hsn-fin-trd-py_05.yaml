- en: '*Chapter 3*: High-Speed Scientific Computing Using NumPy'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第三章*：使用 NumPy 进行高速科学计算'
- en: This chapter introduces us to NumPy, a high-speed Python library for matrix
    calculations. Most data science/algorithmic trading libraries are built upon NumPy's
    functionality and conventions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 NumPy，一个用于矩阵计算的高速 Python 库。大多数数据科学/算法交易库都是基于 NumPy 的功能和约定构建的。
- en: 'In this chapter, we are going to cover the following key topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下关键主题：
- en: Introduction to NumPy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 简介
- en: Creating NumPy n-dimensional arrays (ndarrays)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 NumPy n 维数组（ndarrays）
- en: Data types used with NumPy arrays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 NumPy 数组一起使用的数据类型
- en: Indexing of ndarrays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ndarray 的索引
- en: Basic ndarray operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本 ndarray 操作
- en: File operations on ndarrays
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 ndarray 进行文件操作
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The Python code used in this chapter is available in the `Chapter03/numpy.ipynb`
    notebook in the book's code repository.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的 Python 代码在书籍代码仓库的 `Chapter03/numpy.ipynb` 笔记本中可用。
- en: Introduction to NumPy
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy 简介
- en: Multidimensional heterogeneous arrays can be represented in Python using lists.
    A list is a 1D array, a list of lists is a 2D array, a list of lists of lists
    is a 3D array, and so on. However, this solution is complex, difficult to use,
    and extremely slow.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，可以使用列表表示多维异构数组。列表是一个一维数组，列表的列表是一个二维数组，列表的列表的列表是一个三维数组，依此类推。然而，这种解决方案很复杂，难以使用，并且非常慢。
- en: One of the primary design goals of the NumPy Python library was to introduce
    high-performant and scalable structured arrays and vectorized computations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy Python 库的主要设计目标之一是引入高性能和可扩展的结构化数组和矢量化计算。
- en: Most data structures and operations in NumPy are implemented in C/C++, which
    guarantees their superior speed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 NumPy 中的数据结构和操作都是用 C/C++ 实现的，这保证了它们具有优越的速度。
- en: Creating NumPy ndarrays
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 NumPy ndarrays
- en: An **ndarray** is an extremely high-performant and space-efficient data structure
    for multidimensional arrays.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**ndarray** 是一个极其高性能和空间有效的多维数组数据结构。'
- en: 'First, we need to import the NumPy library, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入 NumPy 库，如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we will start creating a 1D ndarray.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始创建一个一维 ndarray。
- en: Creating 1D ndarrays
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一维 ndarray
- en: 'The following line of code creates a 1D ndarray:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行创建一个一维 ndarray：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will give the following output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s inspect the type of the array with the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下代码检查数组的类型：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This shows that the array is a NumPy ndarray, as can be seen here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明数组是一个 NumPy ndarray，如下所示：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can easily create ndarrays of two dimensions or more.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地创建两个或更多维的 ndarray。
- en: Creating 2D ndarrays
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建二维 ndarray
- en: 'To create a 2D ndarray, use the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个二维 ndarray，请使用以下代码：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The result has two rows and each row has two values, so it is a 2 x 2 ndarray,
    as illustrated in the following code snippet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 结果有两行，每行有两个值，所以它是一个 2 x 2 的 ndarray，如下代码片段所示：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Creating any-dimension ndarrays
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建任意维度的 ndarray
- en: 'An ndarray can construct arrays with arbitrary dimensions. The following code
    creates an ndarray of 2 x 2 x 2 x 2 dimensions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray 可以构造具有任意维度的数组。以下代码创建了一个 2 x 2 x 2 x 2 维的 ndarray：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The representation of the array is shown here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的表示如下所示：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'NumPy ndarrays have a `shape` attribute that describes the ndarray''s dimensions,
    as shown in the following code snippet:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy ndarrays 具有描述 ndarray 维度的 `shape` 属性，如下代码片段所示：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following snippet shows that `arr1D` is a one-dimensional array with five
    elements:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段显示 `arr1D` 是一个包含五个元素的一维数组：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can inspect the `shape` attribute on `arr2D` with the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码检查 `arr2D` 上的 `shape` 属性：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As expected, the output describes it as being a 2 x 2 ndarray, as we can see
    here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，输出描述它为一个 2 x 2 的 ndarray，如下所示：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In practice, there are certain matrices that are more frequently used, such
    as a matrix of 0s, a matrix of 1s, an identity matrix, a matrix containing a range
    of numbers, or a random matrix. NumPy provides support for generating these frequently
    used ndarrays with one command.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，有一些矩阵经常被使用，比如零矩阵、全一矩阵、单位矩阵、包含一系列数字的矩阵或随机矩阵。NumPy 提供了支持用一个命令生成这些常用 ndarray
    的功能。
- en: Creating an ndarray with np.zeros(...)
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 np.zeros(...) 创建 ndarray
- en: 'The `np.zeros(...)` method creates an ndarray populated with all 0s, as illustrated
    in the following code snippet:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.zeros(...)` 方法创建一个填充有全 0 的 ndarray，如下代码片段所示：'
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is all 0s, with dimensions being 2 x 5, as illustrated in the following
    code snippet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是全 0，维度为 2 x 5，如下代码片段所示：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating an ndarray with np.ones(...)
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 np.ones(...) 创建一个 ndarray
- en: '`np.ones(...)` is similar, but each value is assigned a value of 1 instead
    of 0\. The method is shown in the following code snippet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.ones(...)` 类似，但每个值都被赋予值 1，而不是 0。该方法如下所示：'
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The result is a 2 x 2 ndarray with every value set to 1, as illustrated in
    the following code snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个 2 x 2 的 ndarray，每个值都设置为 1，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Creating an ndarray with np.identity(...)
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 np.identity(...) 创建一个 ndarray
- en: 'Often in matrix operations we need to create an identity matrix, which is available
    in the `np.identity(...)` method, as illustrated in the following code snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在矩阵运算中，我们经常需要创建一个单位矩阵，可以使用 `np.identity(...)` 方法，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This creates a 3 x 3 identity matrix with 1s on the diagonals and 0s everywhere
    else, as illustrated in the following code snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个 3 x 3 的单位矩阵，对角线上为 1，其他位置为 0，如下面的代码片段所示：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating an ndarray with np.arange(...)
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 np.arange(...) 创建一个 ndarray
- en: '`np.arange(...)` is the NumPy equivalent of the Python `range(...)` method.
    This generates values with a start value, end value, and increment, except this
    returns NumPy ndarrays instead, as shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.arange(...)` 是 Python `range(...)` 方法的 NumPy 等价物。这生成具有起始值、结束值和增量的值，但是返回的是
    NumPy ndarrays，如下所示：'
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The ndarray returned is shown here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的 ndarray 如下所示：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By default, values start at 0 and increment by 1.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，值从 0 开始，递增为 1。
- en: Creating an ndarray with np.random.randn(…)
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 np.random.randn(...) 创建一个 ndarray
- en: '`np.random.randn(…)` generates an ndarray of specified dimensions, with each
    element populated with random values drawn from a standard normal distribution
    (`mean=0`, `std=1`), as illustrated here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.random.randn(...)` 生成一个指定维度的 ndarray，每个元素从标准正态分布中随机抽取的随机值（`mean=0`，`std=1`），如下所示：'
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is a 2 x 2 ndarray with random values, as illustrated in the following
    code snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个 2 x 2 的 ndarray，其值为随机值，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Data types used with NumPy ndarrays
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NumPy ndarrays 的数据类型
- en: NumPy ndarrays are homogenous—that is, each element in an ndarray has the same
    data type. This is different from Python lists, which can have elements with different
    data types (heterogenous).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy ndarrays 是同质的——即，ndarray 中的每个元素具有相同的数据类型。这与 Python 列表不同，Python 列表可以包含不同数据类型的元素（异质的）。
- en: The `np.array(...)` method accepts an explicit `dtype=` parameter that lets
    us specify the data type that the ndarray should use. Common data types used are
    `np.int32`, `np.float64`, `np.float128`, and `np.bool`. Note that `np.float128`
    is not supported on Windows.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.array(...)` 方法接受一个显式的 `dtype=` 参数，允许我们指定 ndarray 应该使用的数据类型。常用的数据类型包括 `np.int32`、`np.float64`、`np.float128`
    和 `np.bool`。请注意，`np.float128` 在 Windows 上不受支持。'
- en: The primary reason why you should be conscious about the various numeric types
    for ndarrays is the memory usage—the more precision the data type provides, the
    larger memory requirements it has. For certain operations, a smaller data type
    may be just enough.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意各种数值类型对 ndarrays 的内存使用，主要原因是——数据类型提供的精度越高，其内存需求就越大。对于某些操作，较小的数据类型可能已经足够了。
- en: Creating a numpy.float64 array
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 numpy.float64 数组
- en: 'To create a 128-bit floating-values array, use the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 128 位浮点值数组，请使用以下代码：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is shown here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Creating a numpy.bool array
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 numpy.bool 数组
- en: 'We can create an ndarray by converting specified values to the target type.
    In the following code example, we see that even though integer data values were
    provided, the resulting ndarray has `dtype` as `bool`, since the data type was
    specified to be `np.bool`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将指定的值转换为目标类型来创建一个 ndarray。在下面的代码示例中，尽管提供了整数数据值，但由于指定了数据类型为 `np.bool`，所以生成的
    ndarray 的 `dtype` 为 `bool`：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The values are shown here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 值如下所示：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We observe that the integer values (`-1, 0, 1`) were converted to `bool` values
    (`True, False, True`). `0` gets converted to `False`, and all other values get
    converted to `True`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到整数值 (`-1, 0, 1`) 被转换为布尔值 (`True, False, True`)。`0` 被转换为 `False`，所有其他值被转换为
    `True`。
- en: ndarrays' dtype attribute
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ndarrays 的 dtype 属性
- en: 'ndarrays have a `dtype` attribute to inspect the data type, as shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ndarrays 有一个 `dtype` 属性用于检查数据类型，如下所示：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is a NumPy `dtype` object with a `float64` value, as illustrated
    here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个 NumPy `dtype` 对象，其值为 `float64`，如下所示：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Converting underlying data types of ndarray with numpy.ndarrays.astype(...)
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 numpy.ndarrays.astype(...) 转换 ndarray 的底层数据类型
- en: 'We can easily convert the underlying data type of an ndarray to any other compatible
    data type with the `numpy.ndarrays.astype(...)` method. For example, to convert
    `arr1D` from `np.float64` to `np.int64`, we use the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `numpy.ndarrays.astype(...)` 方法轻松地将 ndarray 的基础数据类型转换为任何其他兼容的数据类型。例如，要将`arr1D`从`np.float64`转换为`np.int64`，我们使用以下代码：
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This reflects the new data type, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这反映了新的数据类型，如下所示：
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When `numpy.ndarray.astype(...)` converts to a narrower data type, it will
    truncate the values, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `numpy.ndarray.astype(...)` 转换为较窄的数据类型时，它将截断值，如下所示：
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This converts `arr1D` to the following integer-valued ndarray:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`arr1D`转换为以下整数值 ndarray：
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The original floating values (1.1, 2.2, …) are converted to their truncated
    integer values (1, 2, …).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的浮点值（1.1, 2.2, …）被转换为它们截断的整数值（1, 2, …）。
- en: Indexing of ndarrays
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ndarray 的索引
- en: Array indexing refers to the way of accessing a particular array element or
    elements. In NumPy, all ndarray indices are zero-based—that is, the first item
    of an array has index `0`. Negative indices are understood as counting from the
    end of the array.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 数组索引是指访问特定数组元素或元素的方式。在 NumPy 中，所有 ndarray 索引都是从零开始的，即数组的第一个项目索引为`0`。负索引被理解为从数组的末尾开始计数。
- en: Direct access to an ndarray's element
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接访问 ndarray 的元素
- en: Direct access to a single ndarray's element is one of the most used forms of
    access.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 直接访问单个 ndarray 元素是最常用的访问形式之一。
- en: 'The following code builds a 3 x 3 random-valued ndarray for our use:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码构建了一个 3 x 3 的随机值 ndarray 供我们使用：
- en: '[PRE33]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `arr` ndarray has the following elements:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr` ndarray 具有以下元素：'
- en: '[PRE34]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can index the first element with integer index `0`, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用整数索引 `0` 索引第一个元素，如下所示：
- en: '[PRE35]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This gives us the first row of the `arr` ndarray, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们了`arr` ndarray 的第一行，如下所示：
- en: '[PRE36]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can access the element at the second column of the first row by using the
    following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下代码访问第一行的第二列元素：
- en: '[PRE37]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The result is shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE38]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'ndarrays also support an alternative notation to perform the same operation,
    as illustrated here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray 也支持执行相同操作的替代表示法，如下所示：
- en: '[PRE39]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It accesses the same element as before, as can be seen here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它访问了与之前相同的元素，如下所示：
- en: '[PRE40]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `numpy.ndarray[index_0, index_1, … index_n]` notation is especially more
    concise and useful when accessing ndarrays with very large dimensions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问具有非常大维度的 ndarray 时，`numpy.ndarray[index_0, index_1, … index_n]` 表示法尤其更简洁和有用。
- en: 'Negative indices start from the end of the ndarray, as illustrated here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 负索引从 ndarray 的末尾开始，如下所示：
- en: '[PRE41]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This returns the last row of the ndarray, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回 ndarray 的最后一行，如下所示：
- en: '[PRE42]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ndarray slicing
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ndarray 切片
- en: While single ndarray access is useful, for bulk processing we require access
    to multiple elements of the array at once (for example, if the ndarray contains
    all daily prices of an asset, we might want to process only all Mondays' prices).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单个 ndarray 访问很有用，但是对于批量处理，我们需要一次访问数组的多个元素（例如，如果 ndarray 包含某个资产的所有每日价格，我们可能只想处理所有星期一的价格）。
- en: Slicing allows access to multiple ndarray records in one command. Slicing ndarrays
    also works similarly to slicing of Python lists.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 切片允许一次访问多个 ndarray 记录。ndarray 的切片工作方式与 Python 列表的切片类似。
- en: The basic slice syntax is *i:j:k*, where *i* is the index of the first record
    we want to include, *j* is the stopping index, and *k* is the step.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 基本切片语法是 *i:j:k*，其中 *i* 是我们想要包括的第一个记录的索引，*j* 是停止索引，*k* 是步长。
- en: Accessing all ndarray elements after the first one
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问第一个元素之后的所有 ndarray 元素
- en: 'To access all elements after the first one, we can use the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问第一个元素之后的所有元素，我们可以使用以下代码：
- en: '[PRE43]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This returns all the rows after the first one, as illustrated in the following
    code snippet:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了第一个元素之后的所有行，如下代码片段所示：
- en: '[PRE44]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Fetching all rows, starting from row 2 and columns 1 and 2
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取所有行，从第二行开始，列为第一列和第二列
- en: 'Similarly, to fetch all rows starting from the second one, and columns up to
    but not including the third one, run the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，要获取从第二行开始的所有行，并且列不包括第三列，运行以下代码：
- en: '[PRE45]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This is a 2 x 2 ndarray as expected, as can be seen here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 2 x 2 的 ndarray，正如预期的那样，可以在这里看到：
- en: '[PRE46]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Slicing with negative indices
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用负索引进行切片
- en: 'More complex slicing notation that mixes positive and negative index ranges
    is also possible, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的切片表示法也是可能的，包括正负索引范围的混合，如下所示：
- en: '[PRE47]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This is a less intuitive way of finding the slice of an element at the second
    row and at the second column, as illustrated here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种不太直观的方法，用于查找位于第二行和第二列的元素的切片，如下所示：
- en: '[PRE48]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Slicing with no indices
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有索引的切片
- en: 'Slicing with no indices yields the entire row/column. The following code generates
    a slice containing all elements on the third row:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 没有索引的切片将产生整个行/列。下面的代码生成包含第三行所有元素的切片：
- en: '[PRE49]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output is shown here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE50]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following code generates a slice of the original `arr` ndarray:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码生成原始`arr` ndarray的切片：
- en: '[PRE51]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output is shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE52]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Setting values of a slice to 0
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将切片的值设置为0
- en: Frequently, we will need to set certain values of an ndarray to a given value.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 经常，我们需要将ndarray的某些值设置为给定值。
- en: 'Let''s generate a slice containing the second row of `arr` and assign it to
    a new variable, `arr1`, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成一个包含`arr`的第二行并将其分配给一个新变量`arr1`的切片，如下所示：
- en: '[PRE53]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`arr1` now contains the last row, as shown in the following code snippet:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr1`现在包含了最后一行，如下代码片段所示：'
- en: '[PRE54]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, let''s set every element of `arr1` to the value `0`, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将`arr1`的每个元素设置为值`0`，如下所示：
- en: '[PRE55]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As expected, `arr1` now contains all 0s, as illustrated here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`arr1`现在包含了全部为0的值，如下所示：
- en: '[PRE56]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let''s re-inspect our original `arr` ndarray, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新检查我们的原始`arr` ndarray，如下所示：
- en: '[PRE57]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output is shown here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE58]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We see that our operation on the `arr1` slice also changed the original `arr`
    ndarray. This brings us to the most important point: ndarray slices are views
    into the original ndarrays, not copies.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们对`arr1`切片的操作也改变了原始的`arr` ndarray。这带我们来到最重要的一点：ndarray切片是原始ndarrays的视图，而不是副本。
- en: It is important to remember this when working with ndarrays so that we do not
    inadvertently change something we did not mean to. This design is purely for efficiency
    reasons, since copying large ndarrays incurs large overheads.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用ndarrays时记住这一点很重要，这样我们就不会无意中改变我们不想改变的东西。这个设计纯粹是为了效率原因，因为复制大型ndarrays会产生巨大的开销。
- en: 'To create a copy of an ndarray, we explicitly call the `numpy.ndarray.copy(...)`
    method, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个ndarray的副本，我们需要显式调用`numpy.ndarray.copy(...)`方法，如下所示：
- en: '[PRE59]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, let''s change some values in the `arr_copy` ndarray, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更改`arr_copy` ndarray中的一些值，如下所示：
- en: '[PRE60]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can see the change in `arr_copy` in the following code snippet:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在下面的代码片段中看到`arr_copy`的变化：
- en: '[PRE61]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s inspect the original `arr` ndarray as well, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也来检查一下原始的`arr` ndarray，如下所示：
- en: '[PRE62]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output is shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE63]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We see that the original ndarray is unchanged since `arr_copy` is a copy of
    `arr` and not a reference/view to it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到原始ndarray没有更改，因为`arr_copy`是`arr`的副本而不是引用/视图。
- en: Boolean indexing
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔索引
- en: 'NumPy provides multiple ways of indexing ndarrays. NumPy arrays can be indexed
    by using conditions that evaluate to `True` or `False`. Let''s start by regenerating
    an `arr` ndarray, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了多种索引ndarray的方法。NumPy数组可以通过使用求值为`True`或`False`的条件进行索引。让我们从重新生成一个`arr`
    ndarray开始，如下所示：
- en: '[PRE64]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This is a 3 x 3 ndarray with random values, as can be seen in the following
    code snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个3 x 3的ndarray，具有随机值，如下代码片段所示：
- en: '[PRE65]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let''s revisit the output of running the following code, which is really just
    calling the `np.less(...)` `np.less(arr, 0)`) method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视一下运行以下代码的输出，实际上只是调用了`np.less(...)` `np.less(arr, 0)`方法：
- en: '[PRE66]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This generates another ndarray of `True` and `False` values, where `True` means
    the corresponding element in `arr` was negative and `False` means the corresponding
    element in `arr` was not negative, as illustrated in the following code snippet:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成另一个包含`True`和`False`值的ndarray，其中`True`表示`arr`中的相应元素为负数，而`False`表示`arr`中的相应元素不是负数，如下代码片段所示：
- en: '[PRE67]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can use that array as an index to `arr` to find the actual negative elements,
    as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用该数组作为索引到`arr`来找到实际的负元素，如下所示：
- en: '[PRE68]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As expected, this fetches the following negative values:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，这会获取以下负值：
- en: '[PRE69]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can combine multiple conditions with `&` (and) and `|` (or) operators. Python''s
    `&` and `|` Boolean operators do not work on ndarrays since they are for scalars.
    An example of a `&` operator is shown here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`&`（和）和`|`（或）运算符组合多个条件。Python的`&`和`|`布尔运算符不适用于ndarrays，因为它们适用于标量。这里是`&`运算符的一个示例：
- en: '[PRE70]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This generates an ndarray with the value `True`, where the elements are between
    `-1` and `1` and `False` otherwise, as illustrated in the following code snippet:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个值为`True`的ndarray，其中元素在`-1`和`1`之间，否则为`False`，如下代码片段所示：
- en: '[PRE71]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'As we saw before, we can use that Boolean array to index `arr` and find the
    actual elements, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，我们可以使用布尔数组索引 `arr` 并找到实际的元素，如下所示：
- en: '[PRE72]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The following output is an array of elements that satisfied the condition:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出是满足条件的元素数组：
- en: '[PRE73]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Indexing with arrays
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数组进行索引
- en: 'ndarray indexing also allows us to directly pass lists of indices of interest.
    Let''s first generate an ndarray of random values to use, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray 的索引还允许我们直接传递感兴趣的索引列表。让我们首先生成一个随机值的 ndarray，如下所示：
- en: '[PRE74]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The output is shown here:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE75]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can select the first and third rows, using the following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码选择第一行和第三行：
- en: '[PRE76]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The output is a 2 x 3 ndarray containing the two rows, as illustrated here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个包含两行的 2 x 3 ndarray，如下所示：
- en: '[PRE77]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We can combine row and column indexing using arrays, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以结合使用数组进行行和列索引，如下所示：
- en: '[PRE78]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The preceding code gives us the second column of the first and third rows,
    as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码给出了第一和第三行的第二列，如下所示：
- en: '[PRE79]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We can also change the order of the indices passed, and this is reflected in
    the output. The following code picks out the third row followed by the first row,
    in that order:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以改变传递的索引的顺序，这在输出中有所体现。下面的代码按照指定的顺序挑选出第三行和第一行：
- en: '[PRE80]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The output reflects the two rows in the order we expected (third row first;
    first row second), as illustrated in the following code snippet:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 输出反映了我们期望的两行的顺序（先第三行；然后第一行），如下代码片段所示：
- en: '[PRE81]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Now that we have learned how to create ndarrays and about the various ways to
    retrieve the values of their elements, let's discuss the most common ndarray operations.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何创建 ndarrays 以及各种检索其元素值的方法，让我们讨论最常见的 ndarray 操作。
- en: Basic ndarray operations
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的 ndarray 操作
- en: 'In the following examples, we will use an `arr2D` ndarray, as illustrated here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将使用一个 `arr2D` ndarray，如下所示：
- en: '[PRE82]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This is a 2 x 2 ndarray with values from `1` to `4`, as shown here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `1` 到 `4` 的值的 2 x 2 ndarray，如下所示：
- en: '[PRE83]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Scalar multiplication with an ndarray
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 ndarray 的标量乘法
- en: 'Scalar multiplication with an ndarray has the effect of multiplying each element
    of the ndarray, as illustrated here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 与 ndarray 的标量乘法会使 ndarray 的每个元素相乘，如下所示：
- en: '[PRE84]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output is shown here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE85]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Linear combinations of ndarrays
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ndarray 的线性组合
- en: 'The following operation is a combination of scalar and ndarray operations,
    as well as operations between ndarrays:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作是标量和 ndarray 操作以及 ndarray 之间的操作的组合：
- en: '[PRE86]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The output is what we would expect, as can be seen here:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是我们预期的，如下所示：
- en: '[PRE87]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Exponentiation of ndarrays
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ndarray 的指数运算
- en: 'We can raise each element of the ndarray to a certain power, as illustrated
    here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 ndarray 的每个元素提升到某个幂，如下所示：
- en: '[PRE88]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The output is shown here:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE89]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Addition of an ndarray with a scalar
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 ndarray 与标量相加
- en: 'Addition of an ndarray with a scalar works similarly, as illustrated here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 将 ndarray 与标量相加的结果类似，如下所示：
- en: '[PRE90]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The output is shown here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE91]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Transposing a matrix
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转置矩阵
- en: 'Finding the transpose of a matrix, which is a common operation, is possible
    in NumPy with the `numpy.ndarray.transpose(...)` method, as illustrated in the
    following code snippet:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 找到矩阵的转置，这是一个常见的操作，在 NumPy 中可以使用 `numpy.ndarray.transpose(...)` 方法实现，如下代码片段所示：
- en: '[PRE92]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This transposes the ndarray and outputs it, as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这转置了 ndarray 并输出它，如下所示：
- en: '[PRE93]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Changing the layout of an ndarray
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变 ndarray 的布局
- en: The `np.ndarray.reshape(...)` method allows us to change the layout (shape)
    of the ndarray without changing its data to a compatible shape.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.ndarray.reshape(...)` 方法允许我们更改 ndarray 的布局（形状），而不改变其数据为兼容的形状。'
- en: 'For instance, to reshape `arr2D` from 2 x 2 to 4 x 1, we use the following
    code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将 `arr2D` 从 2 x 2 重塑为 4 x 1，我们使用以下代码：
- en: '[PRE94]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The new reshaped 4 x 1 ndarray is displayed here:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 新的重塑后的 4 x 1 ndarray 如下所示：
- en: '[PRE95]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The following code example combines `np.random.randn(...)` and `np.ndarray.reshape(...)`
    to create a 3 x 3 ndarray of random values:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例结合了 `np.random.randn(...)` 和 `np.ndarray.reshape(...)` 来创建一个 3 x 3 的随机值
    ndarray：
- en: '[PRE96]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The generated 3 x 3 ndarray is shown here:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 3 x 3 ndarray 如下所示：
- en: '[PRE97]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Finding the minimum value in an ndarray
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找 ndarray 中的最小值
- en: 'To find the minimum value in an ndarray, we use the following command:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找 ndarray 中的最小值，我们使用以下命令：
- en: '[PRE98]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The result is shown here:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE99]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Calculating the absolute value
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算绝对值
- en: 'The `np.abs(...)` method, shown here, calculates the absolute value of an ndarray:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 所示的`np.abs(...)`方法计算 ndarray 的绝对值：
- en: '[PRE100]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The output ndarray is shown here:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 输出ndarray如下所示：
- en: '[PRE101]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Calculating the mean of an ndarray
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算ndarray的均值
- en: 'The `np.mean(...)` method, shown here, calculates the mean of all elements
    in the ndarray:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.mean(...)`方法，如下所示，计算ndarray中所有元素的均值：'
- en: '[PRE102]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The mean of the elements of `arr` is shown here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了`arr`元素的均值：
- en: '[PRE103]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We can find the mean along the columns by specifying the `axis=` parameter,
    as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定`axis=`参数来沿列找到均值，如下所示：
- en: '[PRE104]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This returns the following array, containing the mean for each column:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下数组，其中包含每列的均值：
- en: '[PRE105]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Similarly, we can find the mean along the rows by running the following code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以通过运行以下代码来沿行找到均值：
- en: '[PRE106]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'That returns the following array, containing the mean for each row:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下数组，包含每行的均值：
- en: '[PRE107]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Finding the index of the maximum value in an ndarray
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找ndarray中最大值的索引
- en: 'Often, we''re interested in finding where in an array its largest value is.
    The `np.argmax(...)` method finds the location of the maximum value in the ndarray,
    as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们有兴趣找出数组中最大值的位置。`np.argmax(...)`方法可以找到ndarray中最大值的位置，如下所示：
- en: '[PRE108]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'This returns the following value, to represent the location of the maximum
    value (`2.60439882`):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回以下值，表示最大值的位置（`2.60439882`）：
- en: '[PRE109]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The `np.argmax(...)` method also accepts the `axis=` parameter to perform the
    operation row-wise or column-wise, as illustrated here:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.argmax(...)`方法还接受`axis=`参数，以按行或按列执行操作，如此处所示：'
- en: '[PRE110]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This finds the location of the maximum value on each row, as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这将找到每行中最大值的位置，如下所示：
- en: '[PRE111]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Calculating the cumulative sum of elements of an ndarray
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算ndarray元素的累积和
- en: 'To calculate the running total, NumPy provides the `np.cumsum(...)` method.
    The `np.cumsum(...)` method, illustrated here, finds the cumulative sum of elements
    in the ndarray:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算累积总和，NumPy提供了`np.cumsum(...)`方法。`np.cumsum(...)`方法如下所示，找到ndarray中元素的累积总和：
- en: '[PRE112]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The output provides the cumulative sum after each additional element, as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 输出提供了每个附加元素后的累积和，如下所示：
- en: '[PRE113]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Notice the difference between a cumulative sum and a sum. A cumulative sum is
    an array of a running total, whereas a sum is a single number.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意累积和和求和之间的差异。累积和是一个累加的数组，而求和是一个单个数字。
- en: 'Applying the `axis=` parameter to the `cumsum` method works similarly, as illustrated
    in the following code snippet:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 将`axis=`参数应用于`cumsum`方法的效果类似，如以下代码片段所示：
- en: '[PRE114]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'This goes row-wise and generates the following array output:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按行进行，并生成以下数组输出：
- en: '[PRE115]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Finding NaNs in an ndarray
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找ndarray中的NaN值
- en: Missing or unknown values are often represented in NumPy using a **Not a Number**
    (**NaN**) value. For many numerical methods, these must be removed or replaced
    with an interpolation.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在NumPy中，缺失或未知值通常使用**Not a Number** (**NaN**)值表示。对于许多数值方法，必须将这些值删除或替换为插值。
- en: 'First, let''s set the second row to `np.nan`, as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将第二行设置为`np.nan`，如下所示：
- en: '[PRE116]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The new ndarray has the NaN values, as illustrated in the following code snippet:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 新的ndarray具有NaN值，如以下代码片段所示：
- en: '[PRE117]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The `np.isnan(...)` ufunc finds if values in an ndarray are NaNs, as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.isnan(...)`ufunc找到ndarray中的值是否为NaN，如下所示：'
- en: '[PRE118]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The output is an ndarray with a `True` value where NaNs exist and a `False`
    value where NaNs do not exist, as illustrated in the following code snippet:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个ndarray，其中存在NaN的地方为`True`值，不存在NaN的地方为`False`值，如下所示的代码片段所示：
- en: '[PRE119]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Finding the truth values of x1>x2 of two ndarrays
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找两个ndarray的x1>x2的真值
- en: Boolean ndarrays are an efficient way of obtaining indices for values of interest.
    Using Boolean ndarrays is far more performant than looping over the matrix elements
    one by one.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔ndarray是获取感兴趣的值的索引的有效方式。使用布尔ndarray比逐个遍历矩阵元素要高效得多。
- en: 'Let''s build another `arr1` ndarray with random values, as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式构建另一个具有随机值的`arr1` ndarray：
- en: '[PRE120]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The result is a 3 x 3 ndarray, as illustrated in the following code snippet:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个3 x 3的ndarray，如下所示的代码片段中所示：
- en: '[PRE121]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Similarly, let''s build another `arr2` ndarray, as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，让我们构建另一个`arr2` ndarray，如下所示：
- en: '[PRE122]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The output is shown here:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE123]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The `np.greater(...)` function is a binary ufunc that generates a `True` value
    when the left-hand-side value in the ndarray is greater than the right-hand-side
    value in the ndarray. This function can be seen here:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.greater(...)`函数是一个二进制ufunc，当ndarray中的左值大于ndarray中的右值时生成`True`值。该函数如下所示：'
- en: '[PRE124]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The output is an ndarray of `True` and `False` values as described previously,
    as we can see here:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是如前所述的`True`和`False`值的 ndarray，如我们在这里所见：
- en: '[PRE125]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The `>` infix operator, shown in the following snippet, is a shorthand of `numpy.greater(...)`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`>`中缀操作符，如下段代码片段所示，是`numpy.greater(...)`的简写：'
- en: '[PRE126]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The output is the same, as we can see here:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 输出相同，如我们在这里所见：
- en: '[PRE127]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: any and all Boolean operations on ndarrays
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对 ndarray 进行任何和所有的布尔运算
- en: In addition to relational operators, NumPy supports additional methods for testing
    conditions on matrices' values.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关系运算符外，NumPy 还支持其他方法来测试矩阵值上的条件。
- en: 'The following code generates an ndarray containing `True` for elements that
    satisfy the condition, and `False` otherwise:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码生成一个 ndarray，对满足条件的元素返回`True`，否则返回`False`：
- en: '[PRE128]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The output is shown here:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE129]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The following `numpy.ndarray.any(...)` method returns `True` if any element
    is `True` and otherwise returns `False`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`numpy.ndarray.any(...)`方法在任何元素为`True`时返回`True`，否则返回`False`：
- en: '[PRE130]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Here, we have at least one element that is `True`, so the output is `True`,
    as shown here:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们至少有一个元素为`True`，因此输出为`True`，如下所示：
- en: '[PRE131]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Again, it accepts the common `axis=` parameter and behaves as expected, as
    we can see here:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，它接受常见的`axis=`参数并且表现如预期，如我们在这里所见：
- en: '[PRE132]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'And the operation performed row-wise yields, as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 并且按行执行的操作生成如下所示：
- en: '[PRE133]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The following `numpy.ndarray.all(...)` method returns `True` when all elements
    are `True`, and `False` otherwise:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`numpy.ndarray.all(...)`方法在所有元素都为`True`时返回`True`，否则返回`False`：
- en: '[PRE134]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'This returns the following, since not all elements are `True`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了以下内容，因为并非所有元素都为`True`：
- en: '[PRE135]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'It also accepts the `axis=` parameter, as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 它还接受`axis=`参数，如下所示：
- en: '[PRE136]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Again, each row has at least one `False` value, so the output is `False`, as
    shown here:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，每行至少有一个`False`值，因此输出为`False`，如下所示：
- en: '[PRE137]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Sorting ndarrays
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对 ndarray 进行排序
- en: Finding an element in a sorted ndarray is faster than processing all elements
    of the ndarray.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序的 ndarray 中查找元素比处理 ndarray 的所有元素更快。
- en: 'Let''s generate a 1D random array, as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成一个 1D 随机数组，如下所示：
- en: '[PRE138]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The ndarray contains the following data:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray 包含以下数据：
- en: '[PRE139]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The `np.sort(...)` method is pretty straightforward, as can be seen here:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.sort(...)`方法非常简单，如下所示：'
- en: '[PRE140]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The output is shown here:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE141]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Let''s inspect the original ndarray to see if it was modified by the `numpy.sort(...)`
    operation, as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查原始 ndarray，看看它是否被`numpy.sort(...)`操作修改了，如下所示：
- en: '[PRE142]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The following output shows that the original array is unchanged:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示原始数组未改变：
- en: '[PRE143]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The following `np.argsort(...)` method creates an array of indices that represent
    the location of each element in a sorted array:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`np.argsort(...)`方法创建一个表示每个元素在排序数组中位置的索引数组：
- en: '[PRE144]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The output of this operation generates the following array:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作的输出生成以下数组：
- en: '[PRE145]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'NumPy ndarrays have the `numpy.ndarray.sort(...)` method as well, which sorts
    arrays in place. This method is illustrated in the following code snippet:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy ndarray 还具有`numpy.ndarray.sort(...)`方法，该方法可以就地对数组进行排序。该方法在下面的代码片段中说明：
- en: '[PRE146]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'After the call to `sort()`, we call `numpy.argsort(...)` to make sure the array
    was sorted, and this yields the following array that confirms that behavior:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`sort()`后，我们调用`numpy.argsort(...)`来确保数组已排序，这将生成以下数组，确认了该行为：
- en: '[PRE147]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Searching within ndarrays
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 ndarray 中搜索
- en: Finding indices of elements where a certain condition is met is a fundamental
    operation on an ndarray.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ndarray 上满足某个条件的元素的索引是一种基本操作。
- en: 'First, we start with an ndarray with consecutive values, as illustrated here:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从一个具有连续值的 ndarray 开始，如下所示：
- en: '[PRE148]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'This creates the following ndarray:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建以下 ndarray：
- en: '[PRE149]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'We create a second ndarray based on the first one, except this time the values
    in the second one are multiplied by `1000`, as illustrated in the following code
    snippet:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据第一个 ndarray 创建了第二个 ndarray，不过这次第二个 ndarray 中的值乘以了`1000`，如下面的代码片段所示：
- en: '[PRE150]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Then, we know `arr2` contains the following data:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们知道`arr2`包含以下数据：
- en: '[PRE151]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'We define another ndarray that contains 10 `True` and `False` values randomly,
    as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义另一个 ndarray，其中包含 10 个随机的`True`和`False`值，如下所示：
- en: '[PRE152]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The values in the `cond` ndarray are shown here:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`cond`ndarray 中的值显示如下：'
- en: '[PRE153]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The `np.where(...)` method allows us to select values from one ndarray or another,
    depending on the condition being `True` or `False`. The following code will generate
    an ndarray with a value picked from `arr1` when the corresponding element in the
    `cond` array is `True`; otherwise, the value is picked from `arr2`:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.where(...)` 方法允许我们根据条件是 `True` 还是 `False` 从一个 ndarray 或另一个中选择值。以下代码将生成一个
    ndarray，当 `cond` 数组中对应的元素为 `True` 时，从 `arr1` 中选择值；否则，从 `arr2` 中选择值：'
- en: '[PRE154]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'The returned array is shown here:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的数组如下所示：
- en: '[PRE155]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: File operations on ndarrays
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ndarray 的文件操作
- en: Most NumPy arrays are read in from files and, after processing, written out
    back to files.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 NumPy 数组都是从文件中读取的，在处理后，再写回文件。
- en: File operations with text files
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本文件的文件操作
- en: The key advantages of text files are that they are human-readable and compatible
    with any custom software.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 文本文件的主要优点是它们可读性强，并且与任何自定义软件兼容。
- en: 'Let''s start with the following random array:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下随机数组开始：
- en: '[PRE156]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'This array contains the following data:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 此数组包含以下数据
- en: '[PRE157]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The `numpy.savetxt(...)` method saves the ndarray to disk in text format.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.savetxt(...)` 方法以文本格式将 ndarray 保存到磁盘。'
- en: 'The following example uses a `fmt=''%0.2lf''` format string and specifies a
    comma delimiter:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用了 `fmt='%0.2lf'` 格式字符串并指定了逗号分隔符：
- en: '[PRE158]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Let''s inspect the `arr.csv` file written out to disk in the current directory,
    as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查当前目录中写入磁盘的 `arr.csv` 文件，如下所示：
- en: '[PRE159]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The **comma-separated values** (**CSV**) file contains the following data:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**逗号分隔值** (**CSV**) 文件包含以下数据：'
- en: '[PRE160]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The `numpy.loadtxt(...)` method loads an ndarray from text file to memory.
    Here, we explicitly specify the `delimiter='',''` parameter, as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.loadtxt(...)` 方法从文本文件加载 ndarray 到内存中。在这里，我们显式指定了 `delimiter='',''` 参数，如下所示：'
- en: '[PRE161]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'And the ndarray read in from the text file contains the following data:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 从文本文件中读入的 ndarray 包含以下数据：
- en: '[PRE162]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: File operations with binary files
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二进制文件的文件操作
- en: Binary files are far more efficient for computer processing—they save and load
    more quickly and are smaller than text files. However, their format may not be
    supported by other software.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件对于计算机处理来说效率更高——它们保存和加载更快，比文本文件更小。但是，它们的格式可能不受其他软件支持。
- en: 'The `numpy.save(...)` method stores ndarrays in a binary format, as illustrated
    in the following code snippet:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.save(...)` 方法将 ndarray 存储为二进制格式，如下代码片段所示：'
- en: '[PRE163]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The output of the `arr.npy` file is shown here:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr.npy` 文件的输出如下：'
- en: '![](img/B15029_03_01.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15029_03_01.jpg)'
- en: The `numpy.save(...)` method automatically assigns the `.npy` extension to binary
    files it creates.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.save(...)` 方法会自动为其创建的二进制文件分配 `.npy` 扩展名。'
- en: 'The `numpy.load(...)` method, shown in the following code snippet, is used
    for reading binary files:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.load(...)` 方法，如下代码片段所示，用于读取二进制文件：'
- en: '[PRE164]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'The newly read-in ndarray is shown here:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 新读入的 ndarray 如下所示：
- en: '[PRE165]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Another advantage of having binary file formats is that data can be stored with
    extreme precision, especially when dealing with floating values, which is not
    always possible with text files since there is some loss of precision in certain
    cases.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件格式的另一个优点是，数据可以以极高的精度存储，特别是在处理浮点值时，这在某些情况下在文本文件中并不总是可能的，因为在某些情况下会有一些精度损失。
- en: 'Let''s check if the old `arr` ndarray and the newly read-in `arr_new` array
    match exactly, by running the following code:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行以下代码检查旧的 `arr` ndarray 和新读入的 `arr_new` 数组是否完全匹配：
- en: '[PRE166]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'This will generate the following array, containing `True` if the elements are
    equal and `False` otherwise:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下数组，如果元素相等则包含 `True`，否则包含 `False`：
- en: '[PRE167]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: So, we see that each element matches exactly.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们看到每个元素都完全匹配。
- en: Summary
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we have learned how to create matrices of any dimension in
    Python, how to access the matrices' elements, how to calculate basic linear algebra
    operations on matrices, and how to save and load matrices.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在 Python 中创建任意维度的矩阵，如何访问矩阵的元素，如何对矩阵进行基本的线性代数运算，以及如何保存和加载矩阵。
- en: Working with NumPy matrices is a principal operation for any data analysis since
    vector operations are machine-optimized and thus are much faster than operations
    on Python lists—usually between 5 and 100 times faster. Backtesting any algorithmic
    strategy typically consists of processing enormous matrices, and then the speed
    difference can translate to hours or days of saved time.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NumPy 矩阵是任何数据分析的主要操作，因为向量运算经过机器优化，因此比 Python 列表上的操作要快得多——通常快5到100倍。回测任何算法策略通常包括处理庞大的矩阵，而速度差异可以转化为节省的小时或天数时间。
- en: 'In the next chapter, we introduce the second most important library for data
    analysis: Pandas, built upon NumPy. NumPy provides support for data manipulations
    based upon DataFrames (a DataFrame is the Python version of an Excel worksheet—that
    is, a two-dimensional data structure where each column has its own type).'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍第二重要的用于数据分析的库：Pandas，它是建立在 NumPy 基础上的。NumPy 提供了对基于数据框架的数据操作的支持（数据框架是
    Excel 工作表的 Python 版本——即，一个二维数据结构，其中每列都有自己的类型）。
