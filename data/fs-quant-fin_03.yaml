- en: Chapter 3. Financial Mathematics and Numerical Analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 财务数学与数值分析
- en: In this chapter, the reader will be introduced to the basic numerical analysis
    and algorithm implementation in F#. We will look at how integer and floating-point
    numbers are implemented, and we will also look at their respective limitations.
    The basic statistics are covered, and the existing functions in F# are studied
    and compared with custom implementations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，读者将了解基本的数值分析和F#中的算法实现。我们将讨论整数和浮点数是如何实现的，并且还将研究它们各自的局限性。基础统计内容也将涉及，同时会学习F#中现有的函数，并与自定义实现进行比较。
- en: This chapter will build up the foundation of numerical analysis that can be
    used when we look at option pricing and volatility later on. We'll also use some
    of the functionality covered in the previous chapter to implement the mathematical
    functions for aggregate statistics and to illustrate their usefulness in real
    life.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将建立数值分析的基础，后续在研究期权定价和波动性时可以用到这些基础。我们还将使用上一章中覆盖的部分功能，来实现用于汇总统计的数学函数，并展示它们在现实生活中的实用性。
- en: 'In this chapter, you will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: Implementing algorithms in F#
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在F#中实现算法
- en: Numerical concerns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值问题
- en: Implementing basic financial equations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现基本的财务公式
- en: Curve fitting and regression
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 曲线拟合与回归
- en: Matrices and vectors in F#
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F#中的矩阵与向量
- en: Understanding the number representation
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数字表示
- en: In this section, we will show you how numbers are represented as integers or
    floating-point numbers in computers. Numbers form the foundation of computers
    and programming. Everything in a computer is represented by the binary numbers,
    ones and zeroes. Today, we have 64-bit computers that enable us to have a 64-bit
    representation of integers and floating-point numbers naively in the CPU. Let's
    take a deeper look at how integers and floating-point numbers are represented
    in the following two sections.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将展示数字是如何在计算机中表示为整数或浮点数的。数字是计算机和编程的基础。计算机中的一切都是通过二进制数字——即零和一——来表示的。如今，我们拥有64位计算机，使得我们能够在CPU中天真地使用64位表示整数和浮点数。接下来，我们将深入探讨整数和浮点数在以下两部分中的表示方式。
- en: Integers
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数
- en: When we talk about integers, denoted as Z, we are talking specifically about
    machine-precision integers that are represented exactly in the computer with a
    sequence of bits. Also, an integer is a number that can be written without a fractional
    or decimal component and is denoted as Z by convention. For example, 0 is represented
    as 000000..., 1 is represented as ...000001, 2 is represented as ...000010, and
    so on. As you can see from this pattern, numbers are represented in the power
    of two. To represent negative numbers, the number range is divided into two halves
    and uses two's complement.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论整数，通常用Z表示时，我们具体指的是以机器精度表示的整数，这些整数在计算机中用一系列位来精确表示。同时，整数是指可以不带小数或分数部分写出的数字，按照惯例用Z表示。例如，0表示为000000...，1表示为...000001，2表示为...000010，依此类推。从这个模式可以看出，数字是以二的幂次方表示的。为了表示负数，数字范围被分为两半，并使用二的补码表示。
- en: When we talk about integer representation without any negative numbers, that
    is, numbers from zero and up, we talk about unsigned integers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论没有负数的整数表示，即从零开始的数字时，我们讨论的是无符号整数。
- en: Two's complement
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二的补码
- en: Two's complement is a way of dividing a range of binary numbers into positive
    and negative decimal numbers. In this way, both positive and negative numbers
    can be represented in the computer. On the other hand, this means that the range
    of numbers is the half for two's complement in relation to the unsigned representation.
    Two's complement is the main representation used for signed integers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 二的补码是一种将二进制数字范围分为正负十进制数的方式。通过这种方式，计算机可以表示正数和负数。另一方面，这意味着对于二的补码来说，数字范围相对于无符号表示的范围是减半的。二的补码是表示带符号整数的主要方式。
- en: '![Two''s complement](img/4623OS_03_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![二的补码](img/4623OS_03_01.jpg)'
- en: The representation of integers in two's complement can be thought of as a ring,
    as illustrated in the preceding figure. The overflow occurs when the maximum allowed
    positive or negative value increases. Overflow simply means that we pass the barrier
    between positive and negative numbers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 二的补码表示的整数可以被看作一个环，如前图所示。当最大允许的正值或负值增加时，会发生溢出。溢出意味着我们越过了正负数之间的界限。
- en: 'The following table shows some integers and the representation of their two''s
    complement:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了一些整数及其二进制补码表示：
- en: '| Decimal | Two''s complement |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 十进制 | 二进制补码 |'
- en: '| --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 127 | 0111 1111 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 127 | 0111 1111 |'
- en: '| 64 | 0100 0000 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 64 | 0100 0000 |'
- en: '| 1 | 0000 0001 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0000 0001 |'
- en: '| 0 | 0000 0000 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0000 0000 |'
- en: '| -1 | 1111 1111 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| -1 | 1111 1111 |'
- en: '| -64 | 1100 0000 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| -64 | 1100 0000 |'
- en: '| -127 | 1000 0001 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| -127 | 1000 0001 |'
- en: '| -128 | 1000 0000 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| -128 | 1000 0000 |'
- en: 'As you can see, the range for the 8-bit signed integers is from -128 to -127\.
    In more general terms:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，8位有符号整数的范围是从-128到-127。更一般地说：
- en: '![Two''s complement](img/4623OS_03_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![二进制补码](img/4623OS_03_02.jpg)'
- en: Floating-point numbers
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点数
- en: Floating-point numbers, denoted as R, represent a quantity where decimals are
    needed to define them. Another way of describing these numbers is to think of
    them as values represented as a quantity along a continuous line. They are needed
    to model things in real life, such as economic, statistical, and physical quantities.
    In the machine, floating-point numbers are represented by the IEEE 754 standard.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数，表示为R，表示需要小数来定义的量。另一种描述这些数值的方式是将它们视为沿着连续线的量值。这些数值在实际生活中非常重要，用来建模诸如经济、统计和物理量等事物。在计算机中，浮点数是通过IEEE
    754标准表示的。
- en: The IEEE 754 floating-point standard
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IEEE 754浮点数标准
- en: The IEEE 754 floating-point standard describes floating-points using a mantissa
    and an exponent; see the following figure.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE 754浮点数标准通过尾数和指数来描述浮点数；请参见下图。
- en: 'For example, a 64-bit floating point number is made up of the following bit
    pattern:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个64位的浮点数由以下位模式组成：
- en: '| Sign bit | Exponent | Mantissa |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 符号位 | 指数 | 尾数 |'
- en: '| --- | --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 bit | 11 bits | 52 bits |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 1位 | 11位 | 52位 |'
- en: '![The IEEE 754 floating-point standard](img/4623OS_03_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![IEEE 754浮点数标准](img/4623OS_03_03.jpg)'
- en: 'An example of floating-point numbers and their binary representations are shown
    in the following table:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了浮点数及其二进制表示的示例：
- en: '| Binary representation | Floating-point number |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 二进制表示 | 浮点数 |'
- en: '| --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0x0000000000000000 | 0.0 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 0x0000000000000000 | 0.0 |'
- en: '| 0x3ff0000000000000 | 1.0 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 0x3ff0000000000000 | 1.0 |'
- en: '| 0xc000000000000000 | -2.0 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 0xc000000000000000 | -2.0 |'
- en: '| 0x4000000000000000 | 2.0 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 0x4000000000000000 | 2.0 |'
- en: '| 0x402E000000000000 | 15.0 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 0x402E000000000000 | 15.0 |'
- en: 'F# Interactive is capable of decoding the representations of floating-point
    numbers in hexadecimal format into floating-points:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: F# Interactive能够将浮点数的十六进制表示解码为浮点数：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Try out the preceding binary representations in F# Interactive.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在F# Interactive中尝试前述的二进制表示。
- en: Learning about numerical types in F#
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习F#中的数值类型
- en: In F#, as in most other modern languages, there is a variety of numerical types.
    The main reason for this is to enable you, as a programmer, to choose the most
    appropriate numerical type at any given situation. Sometimes there is no need
    for a 64-bit integer as 8-bit will be enough for small numbers. Another aspect
    is memory efficiency and consumption, that is, 64-bit integers will consume eight
    times as much as 8-bit integers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，像大多数现代编程语言一样，存在多种数值类型。这样做的主要原因是让你作为程序员能够在任何给定情况下选择最合适的数值类型。有时候，64位整数并不必要，8位整数就足够表示小数字了。另一个方面是内存效率和消耗，即64位整数将消耗8倍于8位整数的内存。
- en: 'The following is a table with the most common numerical types used in the F#
    code. They come in two main varieties; integers and floating-point numbers:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是F#代码中最常用的数值类型表格。这些类型分为两大类：整数和浮点数：
- en: '| Type | Description | Example |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| byte | 8-bit unsigned integers | 10uy, 0xA0uy |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| byte | 8位无符号整数 | 10uy, 0xA0uy |'
- en: '| sbyte | 8-bit signed integers | 10y |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| sbyte | 8位有符号整数 | 10y |'
- en: '| int16 | 16-bit signed integers | 10s |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| int16 | 16位有符号整数 | 10s |'
- en: '| uint16 | 16-bit unsigned integers | 10us |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| uint16 | 16位无符号整数 | 10us |'
- en: '| int, int32 | 32-bit signed integers | 10 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| int, int32 | 32位有符号整数 | 10 |'
- en: '| uint32 | 32-bit unsigned integers | 10u |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| uint32 | 32位无符号整数 | 10u |'
- en: '| int64 | 64-bit signed integers | 10L |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| int64 | 64位有符号整数 | 10L |'
- en: '| uint64 | 64-bit unsigned integers | 10UL |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| uint64 | 64位无符号整数 | 10UL |'
- en: '| nativeint | Hardware-sized signed integers | 10n |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| nativeint | 硬件大小的有符号整数 | 10n |'
- en: '| unativeint | Hardware-sized signed integers | 10un |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| unativeint | 硬件大小的有符号整数 | 10un |'
- en: '| single, float32 | 32-bit IEEE 754 floating-point | 10.0f |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| single, float32 | 32位IEEE 754浮点数 | 10.0f |'
- en: '| double, float | 64-bit IEEE 754 floating-point | 10.0 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| double, float | 64 位 IEEE 754 浮点数 | 10.0 |'
- en: '| decimal | High-precision decimal | 10.0M |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| decimal | 高精度十进制 | 10.0M |'
- en: '| bigint | Arbitrary precision integers | 10I |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| bigint | 任意精度整数 | 10I |'
- en: '| complex | Complex numbers using 64-bit floats | Complex(10.0, 10.0) |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| complex | 使用 64 位浮点数的复数 | Complex(10.0, 10.0) |'
- en: 'The following are some examples of how to use suffixes for integers:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用整数后缀的一些示例：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Arithmetic operators
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术运算符
- en: Arithmetic operators should be familiar to you; however, we'll cover them in
    this section for consistency. The operators work as expected, and the succeeding
    table illustrates this using an example for each one. The remainder operator that
    returns the remainder from an integer division is worth noticing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符应该是你熟悉的；不过，为了保持一致性，我们将在本节中覆盖它们。这些运算符按预期工作，接下来的表格通过每个运算符的示例来说明这一点。值得注意的是，返回整数除法余数的余数运算符。
- en: 'Let''s look at an example to see this in more detail. First, we try to divide
    10 by 2, and the remainder is 0 as expected:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例更详细地查看这个问题。首先，我们尝试将 10 除以 2，余数正如预期的那样为 0：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we try to divide 10 by 3, we get 1 as the remainder, because 3 x 3 = 9,
    and 10 – 9 = 1:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试将 10 除以 3，我们得到的余数是 1，因为 3 x 3 = 9，而 10 – 9 = 1：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following table shows arithmetic operators with examples and a description:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了算术运算符、示例和描述：
- en: '| Operator | Example | Description |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 示例 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| + | x + y | Addition |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| + | x + y | 加法 |'
- en: '| - | x - y | Subtraction |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| - | x - y | 减法 |'
- en: '| * | x * y | Multiplication |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| * | x * y | 乘法 |'
- en: '| / | x / y | Division |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| / | x / y | 除法 |'
- en: '| % | x % y | Remainder |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| % | x % y | 余数 |'
- en: '| - | -x | Unary minus |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| - | -x | 一元负号 |'
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Arithmetic operators do not check for overflow. If you want to check for overflow,
    you can use the `Checked` module. You can find more about the `Checked` module
    at [http://msdn.microsoft.com/en-us/library/vstudio/ee340296.aspfx](http://msdn.microsoft.com/en-us/library/vstudio/ee340296.aspfx).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符不会检查溢出。如果你想检查溢出，可以使用 `Checked` 模块。你可以在 [http://msdn.microsoft.com/en-us/library/vstudio/ee340296.aspfx](http://msdn.microsoft.com/en-us/library/vstudio/ee340296.aspfx)
    中找到更多关于 `Checked` 模块的信息。
- en: Learning about arithmetic comparisons
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习算术比较
- en: 'Arithmetic comparisons are used to compare two numbers for relationships. It''s
    good to know all the operators that are shown in the following table:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 算术比较用于比较两个数字之间的关系。了解以下表格中显示的所有运算符是很有用的：
- en: '| Operator | Example | Description |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 示例 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| < | x < y | Less than |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| < | x < y | 小于 |'
- en: '| <= | x <= y | Less than or equal to |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| <= | x <= y | 小于或等于 |'
- en: '| > | x > y | Greater than |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| > | x > y | 大于 |'
- en: '| >= | x >= y | Greater than or equal to |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| >= | x >= y | 大于或等于 |'
- en: '| (=) | x = y | Equality |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| (=) | x = y | 相等 |'
- en: '| <> | x <> y | Inequality |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| <> | x <> y | 不等于 |'
- en: '| min | min x y | Minimum |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| min | min x y | 最小值 |'
- en: '| max | max x y | Maximum |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| max | max x y | 最大值 |'
- en: 'Some examples of arithmetic comparisons are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一些算术比较的示例如下：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It is also worth noticing that you can''t compare numbers of different types
    in F#. To do this, you have to convert one of them as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另外值得注意的是，在 F# 中你不能比较不同类型的数字。为了做到这一点，你必须将其中一个数字转换，方法如下：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Math operators
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学运算符
- en: 'The following table of mathematical operators covers the most basic mathematical
    functions that are expected to be found in a programming language or its standard
    libraries:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下数学运算符表涵盖了编程语言或其标准库中预期包含的最基本的数学函数：
- en: '| Operator | Example | Description |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 示例 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| abs | abs x | Overloaded absolute value |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| abs | abs x | 重载绝对值 |'
- en: '| acos | acos x | Overloaded inverse cosine |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| acos | acos x | 重载反余弦 |'
- en: '| asin | asin x | Overloaded inverse sine |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| asin | asin x | 重载反正弦 |'
- en: '| atan | atan x | Overloaded inverse tangent |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| atan | atan x | 重载反正切 |'
- en: '| ceil | ceil x | Overloaded floating-point ceil |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| ceil | ceil x | 重载浮点数向上取整 |'
- en: '| cos | cos x | Overloaded cosine |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| cos | cos x | 重载余弦 |'
- en: '| exp | exp x | Overloaded exponent |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| exp | exp x | 重载指数 |'
- en: '| floor | floor x | Overloaded floating-point floor |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| floor | floor x | 重载浮点数向下取整 |'
- en: '| log | log x | Overloaded natural logarithm |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| log | log x | 重载自然对数 |'
- en: '| log10 | log10 x | Overloaded base-10 logarithm |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| log10 | log10 x | 重载以 10 为底的对数 |'
- en: '| (**) | x ** y | Overloaded exponential |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| (**) | x ** y | 重载指数 |'
- en: '| pown | pown x y | Overloaded integer exponential |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| pown | pown x y | 重载整数指数 |'
- en: '| round | round x | Overloaded rounding |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| round | round x | 重载四舍五入 |'
- en: '| sin | sin x | Overloaded sine function |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| sin | sin x | 重载正弦函数 |'
- en: '| sqrt | sqrt x | Overloaded square root function |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| sqrt | sqrt x | 重载平方根函数 |'
- en: '| tan | tan x | Overloaded tangent function |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| tan | tan x | 重载正切函数 |'
- en: Conversion functions
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换函数
- en: 'There are no implicit conversions in F# as conversions have to be done manually
    using conversion routines. Conversion must be made explicitly between types using
    the operators that are described in the following table:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中没有隐式转换，因为转换必须通过转换例程手动完成。类型之间的转换必须显式地使用下表中描述的运算符进行：
- en: '| Operator | Example | Description |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 示例 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| byte | byte x | Overloaded conversion to a byte |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| byte | byte x | 重载转换为字节 |'
- en: '| sbyte | sbyte x | Overloaded conversion to a signed byte |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| sbyte | sbyte x | 重载转换为有符号字节 |'
- en: '| int16 | int16 | Overloaded conversion to a 16-bit integer |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| int16 | int16 | 重载转换为 16 位整数 |'
- en: '| uint16 | uint16 | Overloaded conversion to an unsigned 16-bit integer |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| uint16 | uint16 | 重载转换为无符号 16 位整数 |'
- en: '| int32, int | Int32 x, int x | Overloaded conversion to a 32-bit integer |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| int32, int | Int32 x, int x | 重载转换为 32 位整数 |'
- en: '| uint32 | uint32 x | Overloaded conversion to an unsigned 32-bit integer |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| uint32 | uint32 x | 重载转换为无符号 32 位整数 |'
- en: '| int64 | int64 x | Overloaded conversion to a 64-bit integer |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| int64 | int64 x | 重载转换为 64 位整数 |'
- en: '| uint64 | uint64 x | Overloaded conversion to an unsigned 64-bit integer |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| uint64 | uint64 x | 重载转换为无符号 64 位整数 |'
- en: '| nativeint | nativeint x | Overloaded conversion to a native integer |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| nativeint | nativeint x | 重载转换为本机整数 |'
- en: '| unativeint | unativeint x | Overloaded conversion to an unsigned native integer
    |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| unativeint | unativeint x | 重载转换为无符号本机整数 |'
- en: '| float, double | float x, double x | Overloaded conversion to a 64-bit IEEE
    floating-point number |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| float, double | float x, double x | 重载转换为 64 位 IEEE 浮动点数 |'
- en: '| float32, single | float32 x, single x | Overloaded conversion to a 32-bit
    IEEE floating-point number |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| float32, single | float32 x, single x | 重载转换为 32 位 IEEE 浮动点数 |'
- en: '| decimal | decimal x | Overloaded conversion to a System.decimal number |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| decimal | decimal x | 重载转换为 System.decimal 数字 |'
- en: '| char | char x | Overloaded conversion to a System.Char value |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| char | char x | 重载转换为 System.Char 值 |'
- en: '| enum | enum x | Overloaded conversion to a typed enum value |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| enum | enum x | 重载转换为类型化的枚举值 |'
- en: This means that there will never be any automatic type conversion behind the
    scenes that may lead to loss of precision. For example, numbers are not converted
    from floating-points to integers just to fit the code that you have written. The
    compiler will tell you that there is an error in the code before converting it
    (it will never be converted by the compiler). The positive side about this is
    that you always know the representation of your numbers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着后台永远不会有任何自动类型转换，这可能导致精度丢失。例如，数字不会从浮动点数转换为整数，仅仅为了适应你编写的代码。编译器会在转换前告诉你代码存在错误（它永远不会由编译器转换）。这方面的积极作用是，你总是清楚地知道数字的表示方式。
- en: Introducing statistics
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入统计学
- en: In this section, we'll look at statistics using both built-in functions and
    simple custom ones. Statistics are used a lot throughout quantitative finance.
    Larger time series are often analyzed, and F# has great support for sequences
    of numbers; some of its power will be illustrated in the examples mentioned in
    this section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过内置函数和简单的自定义函数来了解统计学。统计学在定量金融中被广泛应用。通常会分析更大的时间序列，F# 对数字序列有很好的支持；一些功能将在本节提到的示例中进行演示。
- en: Aggregate statistics
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合统计
- en: Aggregated statistics is all about statistics on aggregated data such as sequences
    of numbers collected from measurements. It's useful to know the average value
    in such a collection; this tells us where the values are centered. The `min` and
    `max` values are also useful to determine the extremes in the collection.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合统计是关于聚合数据的统计，例如从测量中收集的数字序列。了解这种集合的平均值是有用的；它告诉我们这些值的集中位置。`min` 和 `max` 值也很有用，可以帮助确定集合中的极值。
- en: In F#, the `Seq` module has this functionality built-in. Let's take a look at
    how to use it in each case using an example.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，`Seq` 模块内置了此功能。让我们通过示例查看如何在每种情况下使用它。
- en: Calculating the sum of a sequence
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算序列的和
- en: 'Consider a sequence of 100 random numbers:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含 100 个随机数的序列：
- en: '[PRE6]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can calculate the sum of the preceding sequence, `data`, using the pipe
    operator and then the module function `Seq.sum`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用管道运算符和模块函数`Seq.sum`来计算前述序列`data`的总和：
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that the result, `sum`, will vary from time to time due to the fact that
    we use a random number generator:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们使用的是随机数生成器，结果`sum`会时常变化：
- en: '[PRE8]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You might think that the `sum` function is not the most useful one; but there
    are times you need it, and knowing about its existence in the module library will
    save you time.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为`sum`函数并不是最有用的，但有时它确实有用，了解它在模块库中的存在会节省你很多时间。
- en: Calculating the average of a sequence
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算序列的平均值
- en: 'For this example, let''s modify the random seed function a bit to generate
    500 numbers between 0 and 10:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们稍微修改一下随机种子函数，以生成0到10之间的500个数字：
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The expected value of this sequence is 5 because of the distribution of the
    random function:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于随机函数的分布，这个序列的期望值是5：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The value may vary a bit due to the fact that we generate numbers randomly:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是随机生成数字，因此数值可能会有所变化：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As expected, the average value is almost 5\. If we generate more numbers, we
    will soon come closer and closer to the theoretical expected value of 5:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，平均值几乎是5。如果我们生成更多的数字，数值会越来越接近理论上的期望值5：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Calculating the minimum of a sequence
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算序列的最小值
- en: 'Instead of iterating the sequence and keeping track of the minimum value using
    some kind of a loop construct with a temporary variable, we lend ourselves towards
    the functional approach in F#. To calculate the minimum of a sequence, we use
    the module function `Seq.min`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不通过迭代序列并使用某种循环结构与临时变量来跟踪最小值，而是倾向于使用F#中的函数式方法。为了计算序列的最小值，我们使用模块函数`Seq.min`：
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This looks a lot like the preceding code seen, except that we generate 10 random
    numbers and inspect the values in the list. If we manually look for the smallest
    value and then compare it to the one calculated by F#, we see that they match.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这与前面的代码非常相似，不同的是我们生成了10个随机数并检查列表中的值。如果我们手动寻找最小值，并将其与F#计算得出的值进行比较，会发现它们是匹配的。
- en: Calculating the maximum of a sequence
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算序列的最大值
- en: 'In the following example, we''ll use `Seq.max` to calculate the maximum number
    of a list:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用`Seq.max`来计算列表的最大值：
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Calculating the variance and standard deviation of a sequence
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算序列的方差和标准差
- en: So far, we have already used the existing functions for our statistical analysis.
    Now, let's implement variance and standard deviation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用现有的函数进行了统计分析。现在，让我们实现方差和标准差。
- en: Calculating variance
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计算方差
- en: 'Let''s use the following function and calculate the variance for a dice:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下函数并计算骰子的方差：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A dice has six discrete outcomes, one to six, where every outcome has equal
    probability. The expected value is 3.5, (1 + 2 + 3 + 4 + 5 + 6)/6\. The variance
    of a dice is calculated using the following function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一个骰子有六个离散的结果，从1到6，每个结果的概率相等。期望值是3.5，计算公式为(1 + 2 + 3 + 4 + 5 + 6)/6。骰子的方差通过以下函数计算：
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Calculating standard deviation
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计算标准差
- en: 'We start by implementing the standard deviation function using the previously
    defined `variance` function. According to statistics, standard deviation is the
    square root of the variance:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从使用之前定义的`variance`函数来实现标准差函数开始。根据统计学，标准差是方差的平方根：
- en: '[PRE17]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding function works just fine, but to illustrate the power of sequences,
    we will implement the standard deviation using the `fold` function. The `fold`
    function will apply a given function to every element and accumulate the result.
    The `0.0` value in the end just means that we don''t have an initial value. You
    may remember this from the section about `fold` in the previous chapter. If we
    were to fold using multiplication, `1.0` is used instead as the initial value.
    In the end, we just pass the sum to the square root function, `sqrt`, and we are
    done:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前述函数工作得很好，但为了展示序列的强大功能，我们将使用`fold`函数来实现标准差。`fold`函数将对每个元素应用给定的函数并累积结果。最后的`0.0`值意味着我们没有初始值。你可能记得在上一章的`fold`部分中提到过这一点。如果我们使用乘法进行折叠，则初始值应为`1.0`。最后，我们只需将总和传递给平方根函数`sqrt`，就完成了：
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s verify using some sample data:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一些样本数据来验证：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can go back and analyze the random data that was generated and used
    earlier when we looked at the build in the sequence functions:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以回过头来分析之前生成并使用的随机数据，这些数据出现在我们查看序列函数构建时：
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can check the fact that the square of the standard deviation is equal to
    the variance:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证标准差的平方等于方差这一事实：
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Looking at an example application
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看一个示例应用
- en: 'The example application that we''ll look at in this section is a combination
    of the parts that we looked at in this chapter and will simply produce an output
    with statistics about the given sequence of data:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中我们将看到的示例应用是本章中各个部分的结合，简单地生成一个关于给定数据序列的统计信息输出：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Evaluating the code results in an output of the statistical properties of the
    random sequence generated is shown as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 评估代码后，输出显示如下生成的随机序列的统计属性：
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This means that the sequence has an approximate mean value of 5.15 and an approximate
    standard deviation of 2.94\. Using these facts, we can rebuild the distribution
    assuming that the numbers are distributed according to any of the known distributions,
    such as normal distribution.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着该序列的平均值大约为 5.15，标准差大约为 2.94。基于这些事实，我们可以假设该序列按照某种已知分布（例如正态分布）重新构建其分布。
- en: Using the Math.NET library
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Math.NET 库
- en: Instead of implementing your own functions for numerical support, there is an
    excellent library called **Math.NET**. It's an open-source library covering fundamental
    mathematics such as linear algebra and statistics.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想自己实现数值计算相关的函数，可以使用一个非常优秀的库——**Math.NET**。这是一个开源库，涵盖了线性代数、统计学等基础数学内容。
- en: 'The Math.NET library consists of the following libraries:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Math.NET 库由以下几个库组成：
- en: '**Math.NET numerics**: Numerical computing'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Math.NET 数值库**：数值计算'
- en: '**Math.NET neodym**: Signal processing'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Math.NET 钕库**：信号处理'
- en: '**Math.NET linq algebra**: Computer algebra'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Math.NET LINQ 代数**：计算机代数'
- en: '**Math.NET yttrium**: Experimental network computer algebra'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Math.NET 钇库**：实验性网络计算代数'
- en: In this section, we'll look at Math.NET numerics, and see how it can help us
    in our F# programming. First, we need to make sure that Math.NET is installed
    on our system.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习 Math.NET 数值库，并了解它如何帮助我们在 F# 编程中使用。首先，我们需要确保 Math.NET 已经安装在我们的系统中。
- en: Installing the Math.NET library
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Math.NET 库
- en: The Math.NET library can be installed using the built-in **Package Manager**.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过内置的**包管理器**安装 Math.NET 库。
- en: '![Installing the Math.NET library](img/4623OS_03_04.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![安装 Math.NET 库](img/4623OS_03_04.jpg)'
- en: Open the **Package Manager Console** by going to **View** | **Other Windows**
    | **Package Manager Console**.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过进入**视图** | **其他窗口** | **包管理器控制台**来打开**包管理器控制台**。
- en: 'Type in the following command:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE24]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Wait for the installation to complete.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待安装完成。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can read more about the Math.NET project on the project''s website: [http://www.mathdotnet.com/](http://www.mathdotnet.com/).'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在项目网站上阅读更多关于 Math.NET 项目的内容：[http://www.mathdotnet.com/](http://www.mathdotnet.com/)。
- en: Introduction to random number generation
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机数生成简介
- en: Let's start by looking at the various ways of generating random numbers. Random
    numbers are frequently used in statistics and simulations. They are used extensively
    in the Monte Carlo simulations. Before we start looking at Math.NET and how to
    generate random numbers, we need a little bit of the background theory.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看生成随机数的不同方法。随机数在统计学和模拟中使用频繁，尤其是在蒙特卡洛模拟中。我们在开始研究 Math.NET 和如何生成随机数之前，需要了解一些基础理论。
- en: Pseudo-random numbers
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 伪随机数
- en: In computers and programming, random numbers often refer to pseudo-random numbers.
    Pseudo-random numbers appear to be random, but they are not. In other words, they
    are deterministic if some properties of the algorithm and the seed that is used
    are known. The seed is the input to the algorithm to generate the number. Often,
    one chooses the seed to be the current time of the system or another unique number.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机和编程中，随机数通常指的是伪随机数。伪随机数看起来是随机的，但实际上并非如此。换句话说，只要已知算法的某些特性和所使用的种子值，它们就是确定性的。种子是生成随机数的算法输入。通常，种子的选择会是系统的当前时间或其他唯一值。
- en: The random number generator in the `System.Random` class that is provided with
    the .NET platform is based on a subtractive random number generator algorithm
    by *Donald E. Knuth*. This algorithm will generate the same series of numbers
    if the same seed is used.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 平台提供的 `System.Random` 类中的随机数生成器基于 *Donald E. Knuth* 提出的减法随机数生成算法。该算法如果使用相同的种子，将生成相同的数字序列。
- en: Mersenne Twister
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 梅森旋转
- en: 'The Mersenne Twister pseudo random number generator is capable of producing
    less deterministic numbers in an efficient way. These properties make this algorithm
    one of the most popular ones used today. The following is an example of how to
    use this algorithm in Math.NET:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 梅森旋转伪随机数生成器能够以高效的方式生成不那么确定的数字。这些特性使得该算法成为今天最流行的算法之一。以下是如何在 Math.NET 中使用该算法的示例：
- en: '[PRE25]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In F# Interactive, we can generate some numbers using Mersenne Twister:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# Interactive 中，我们可以使用梅森旋转生成一些数字：
- en: '[PRE26]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Probability distributions
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概率分布
- en: Probability distributions are commonly used in statistics and finance. They
    are used to analyze and categorize a set of samples to investigate their statistical
    properties.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 概率分布通常用于统计学和金融学。它们用于分析和分类一组样本，以研究其统计属性。
- en: Normal distribution
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正态分布
- en: Normal distribution is one of the most commonly used probability distributions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 正态分布是最常用的概率分布之一。
- en: 'In Math.NET, normal distribution can be used in the following way:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Math.NET 中，正态分布可以如下使用：
- en: '[PRE27]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By using the preceding example, we create a normal distribution with zero mean
    and a standard deviation of one. We can also retrieve the mean, variance, and
    standard deviation from a distribution:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用前面的示例，我们创建了一个均值为零，标准差为一的正态分布。我们还可以从分布中检索均值、方差和标准差：
- en: '[PRE28]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this case, the mean and standard deviation is the same as we specified in
    the constructor of the `Normal` class. It''s also possible to generate random
    numbers from a distribution. We can use the preceding distribution to generate
    some random numbers, from the properties that are defined:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，均值和标准差与我们在 `Normal` 类的构造函数中指定的相同。也可以从分布中生成随机数字。我们可以使用前面的分布生成一些随机数字，这些数字基于已定义的属性：
- en: '[PRE29]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the Math.NET library, there are also other distributions such as:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Math.NET 库中，还有其他一些分布，如：
- en: Poisson
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泊松分布
- en: Log normal
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数正态
- en: Erlang
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 埃尔朗分布
- en: Binomial
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二项分布
- en: Statistics
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统计
- en: In Math.NET, there is also great support for descriptive statistics that can
    be used to determine the properties of a collection of samples. The samples can
    be numbers from a measurement or generated by the same library.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Math.NET 中，还提供了对描述性统计的强大支持，可以用来确定样本集合的属性。这些样本可以是来自测量的数字，也可以是同一库生成的数字。
- en: In this section, we'll look at an example where we'll analyze a collection of
    samples with known properties, and see how the `DescriptiveStatistics` class can
    help us out.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将查看一个示例，分析一个具有已知属性的样本集合，并了解 `DescriptiveStatistics` 类如何为我们提供帮助。
- en: 'We start by generating some data to be analyzed:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过生成一些数据来进行分析：
- en: '[PRE30]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Notice the conversion from `Seq` to `List`; this is done because otherwise,
    `samples` will be a lazy collection. This means that the collection will be a
    set of different numbers every time it''s used in the program, which is not what
    we want in this case. Next we instantiate the `DescriptiveStatistics` class:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意从`Seq`到`List`的转换；这是因为如果不进行转换，`samples` 将是一个惰性集合。这意味着该集合每次在程序中使用时都会生成不同的数字，而这正是我们在这种情况下不希望发生的。接下来，我们实例化
    `DescriptiveStatistics` 类：
- en: '[PRE31]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It will take the samples that were previously created and create an object
    that describes the statistical properties of the numbers in the `samples` list.
    Now, we can get some valuable information about the data:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 它将处理之前创建的样本，并创建一个描述 `samples` 列表中数字统计属性的对象。现在，我们可以获取有关数据的有价值信息：
- en: '[PRE32]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we look closer at the mean, variance, and standard deviation respectively,
    we see that they correspond well with the expected values for the collection:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更仔细地查看均值、方差和标准差，我们会发现它们与该集合的预期值相符：
- en: '[PRE33]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Linear regression
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性回归
- en: Linear regression is heavily used in statistics where sample data is analyzed.
    Linear regression tells the relationship between two variables. It is currently
    not part of Math.NET but can be implemented using it. Regression in Math.NET is
    an asked-for feature; and hopefully, it will be supported natively by the library
    in the future.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归在统计学中广泛应用，用于分析样本数据。线性回归揭示了两个变量之间的关系。它目前不是Math.NET的一部分，但可以通过它实现。Math.NET中回归是一个被请求的功能；希望在未来，库将本地支持这一功能。
- en: Using the least squares method
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用最小二乘法
- en: Let's look at one of the most commonly used methods in linear regression, the
    least squares method. It's a standard approach to find the approximate solution
    using the least squares method. The least squares method will optimize the overall
    solution with respect to the squares of the error, which means that it will find
    the solution that best fits the data.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看线性回归中最常用的一种方法，最小二乘法。这是一种标准的方法，用于通过最小二乘法找到近似解。最小二乘法将优化总体解，以最小化误差的平方，这意味着它将找到最能拟合数据的解。
- en: 'The following is an implementation of the least squares method in F# using
    Math.NET for the linear algebra part:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Math.NET进行线性代数部分的F#实现最小二乘法：
- en: '[PRE34]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The independent data `y` and the dependent data `x` are used as inputs to the
    solver. You can use any linear relationship here, between `x` and `y`. The regression
    coefficients will tell us the properties of the regression line, `y` = `ax` +
    `b`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 自变量数据`y`和因变量数据`x`作为输入提供给求解器。你可以在这里使用`x`和`y`之间的任何线性关系。回归系数将告诉我们回归线的特性，`y` = `ax`
    + `b`。
- en: Using polynomial regression
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用多项式回归
- en: In this section, we're going to look at a method for fitting a polynomial to
    data points. This method is useful when the relationship in the data is better
    described by a polynomial, such as a second or third degree one. We'll use this
    method in [Chapter 6](ch06.html "Chapter 6. Exploring Volatility"), *Exploring
    Volatility*, where we'll fit a second degree polynomial to a option data to construct
    a graph over the volatility smile. We'll lay out the foundations needed for that
    use case in this section.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一种将多项式拟合到数据点的方法。当数据中的关系更适合用多项式来描述时，这种方法非常有用，例如二次或三次多项式。我们将在[第六章](ch06.html
    "第六章：波动率探索")，*波动率探索*中使用此方法，我们将拟合一个二次多项式到期权数据上，以构建一个波动率微笑图表。在本节中，我们将为这个用例奠定基础。
- en: We'll continue to use Math.NET for our linear algebra calculations, to solve
    for the coefficients for a polynomial of a second degree.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用Math.NET进行线性代数计算，以求解二次多项式的系数。
- en: 'We''ll start out by generating some sample data for a polynomial:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从生成一些多项式的样本数据开始：
- en: '![Using polynomial regression](img/4623OS_03_05.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![使用多项式回归](img/4623OS_03_05.jpg)'
- en: 'Then, we generate x-values from `-10.0` to `10.0` with increments of `0.2`,
    and y-values using these x-values and the preceding equation with added noise.
    To accomplish this, the normal distribution with zero mean and 1.0 in standard
    deviation is used:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从`-10.0`到`10.0`生成x值，步长为`0.2`，并使用这些x值和前面的方程加噪声来生成y值。为了实现这一点，我们使用了均值为零、标准差为1.0的正态分布：
- en: '[PRE35]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we use the linear algebra functions from Math.NET to implement the least
    square estimation for the coefficients. In mathematical terms, this can be expressed
    as:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用Math.NET中的线性代数函数实现系数的最小二乘估算。在数学术语中，这可以表示为：
- en: '![Using polynomial regression](img/4623OS_03_06.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![使用多项式回归](img/4623OS_03_06.jpg)'
- en: 'This means we will use the matrix A, which stores the x-values and the y-vector
    to estimate the coefficient vector c. Let''s look at the following code to see
    how this is implemented:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们将使用矩阵A，它存储x值和y向量，用来估算系数向量c。让我们看一下下面的代码，看看这是如何实现的：
- en: '[PRE36]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The values in the coefficient vector are in reverse order, which means they
    correspond to a polynomial that fits the data, but the coefficient is reversed:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 系数向量中的值是倒序的，这意味着它们对应于一个拟合数据的多项式，但系数是倒转的：
- en: '[PRE37]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The values are pretty close to the polynomial we used as the input in the preceding
    code. The following is a graph of the sample data points together with the fitted
    curve. The graph is made using FSharpChart, which we'll look into in the next
    chapter.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值与我们在前面代码中用作输入的多项式非常接近。下面是样本数据点与拟合曲线的图表。该图表使用FSharpChart制作，我们将在下一章中介绍它。
- en: '![Using polynomial regression](img/4623OS_03_07.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![使用多项式回归](img/4623OS_03_07.jpg)'
- en: Polynomial regression using Math.net
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Math.net进行多项式回归
- en: 'The curious reader can use the following snippet to produce the preceding graph:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 好奇的读者可以使用以下代码段来生成前面的图形：
- en: '[PRE38]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Learning about root-finding algorithms
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习根寻找算法
- en: In this section, we'll learn about the different methods used in numerical analysis
    to find the roots of functions. Root-finding algorithms are very useful, and we
    will learn more about their applications when we talk about volatility and implied
    volatility.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习在数值分析中用于寻找函数根的不同方法。根寻找算法非常有用，当我们讨论波动率和隐含波动率时，我们将进一步了解它们的应用。
- en: The bisection method
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二分法
- en: In this section, we will look at a method for finding the roots of a function
    using the bisection method. This method will be used later in this book to numerically
    find the implied volatility for an option that is given a certain market price.
    The bisection method uses iteration and repeatedly bisects an interval for the
    next iteration.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一种使用二分法找到函数根的方法。此方法将在本书后续章节中用于通过数值方法找到给定某一市场价格的期权的隐含波动率。二分法使用迭代，并反复将一个区间二分为下一个迭代的范围。
- en: 'The following function implements bisection in F#:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数在F#中实现了二分法：
- en: '[PRE39]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Looking at an example
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 看一个例子
- en: 'Now, we will look at an example of solving the roots of a quadratic equation.
    The equation, x^2 - x- 6, is plotted in the following figure:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看一个求解二次方程根的例子。方程x^2 - x - 6在下面的图中进行了绘制：
- en: '![Looking at an example](img/4623OS_03_08.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![看一个例子](img/4623OS_03_08.jpg)'
- en: The roots of the preceding quadratic equation can easily be seen in the figure.
    Otherwise, there are analytical methods of solving it; for example, the method
    of completing the square. The roots of the equation are -2 and 3.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的二次方程的根可以在图中轻松看到。否则，也有解析方法可以求解；例如，配方法。方程的根是-2和3。
- en: 'Next, we create an anonymous function in F# to describe the one that we are
    interested in solving the roots for:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在F#中创建一个匿名函数来描述我们感兴趣的用于求解根的函数：
- en: '[PRE40]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can test the preceding function using the roots that we found in the preceding
    figure:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面图中找到的根来测试上面的函数：
- en: '[PRE41]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The results are as expected. Now, we can continue and use the lambda function
    as an argument to the `bisect` function:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如预期所示。现在，我们可以继续并使用lambda函数作为`bisect`函数的参数：
- en: '[PRE42]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first two arguments, `0` and `25`, are used to keep track of the iterations.
    We pass in `0` because we want to start from iteration 0 and then iterate 25 times.
    The next argument is the function itself that we defined in the preceding code
    as `f`. The next two arguments are limits, that is, the range within which we
    can look for the root. And the last one is just a value for the accuracy used
    for comparison inside the iteration.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数，`0`和`25`，用于跟踪迭代过程。我们传入`0`是因为我们希望从第0次迭代开始，然后迭代25次。下一个参数是我们在前面代码中定义的函数`f`。接下来的两个参数是限制条件，也就是我们可以在其中寻找根的范围。最后一个参数是用于迭代内部比较的精度值。
- en: 'We can now inspect the two variables and see if we find the roots:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以检查这两个变量，看看是否找到了根：
- en: '[PRE43]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: They are almost equal to the analytical solution of -2 and 3 respectively. This
    is something that is typical for numerical analysis. The solutions will almost
    never be exact. In every step, some inaccuracy is added due to the floating-point
    numbers, rounding, and so on.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 它们几乎与解析解-2和3完全相同。这是数值分析中典型的情况。解几乎永远不会完全准确。每一步都会因为浮点数、四舍五入等原因引入一些不准确。
- en: Finding roots using the Newton–Raphson method
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用牛顿-拉夫森法寻找根
- en: 'The Newton-Raphson method, or simply Newton''s method, usually converges faster
    than the bisection method. The Newton-Raphson method also needs the derivative
    of the function, which can be a problem in some cases. This is especially true
    when there is no analytical solution available. The following implementation is
    a modification of the bisection method using the derivative of the function to
    determine if a solution has been found. Let''s look at the implementation of Newton''s
    method in F#:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿-拉夫森法，或简称牛顿法，通常比二分法收敛得更快。牛顿-拉夫森法还需要函数的导数，这在某些情况下可能是一个问题。特别是当没有解析解时，这个问题尤为突出。以下实现是二分法的修改版，使用函数的导数来判断是否找到了解。我们来看看牛顿法在F#中的实现：
- en: '[PRE44]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: One of the drawbacks of using the preceding method is that we use a fixed point
    convergence criteria, `abs(newtonX - x0) < tol`, which means that we can be far
    from the actual solution when this criteria is met.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的方法的一个缺点是，我们使用了一个固定点收敛标准，`abs(newtonX - x0) < tol`，这意味着当满足此标准时，我们可能离实际解还很远。
- en: Looking at an example
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 看一个例子
- en: 'We can now try to find the square root of two, which is expected to be 1.41421\.
    First, we need the function itself, `fun x -> (x**2.0 – 2.0)`. We also need the
    derivative of the same function, `x -> (2.0*x)`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试求解二的平方根，预期结果是1.41421。首先，我们需要函数本身，`fun x -> (x**2.0 – 2.0)`。我们还需要该函数的导数，`x
    -> (2.0*x)`：
- en: '[PRE45]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we use the Newton-Raphson method to find the root of the function, x^2
    - 2\. Using F# Interactive, we can investigate this as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用牛顿-拉弗森方法来求解方程x^2 - 2的根。使用F#交互式环境，我们可以按如下方式进行研究：
- en: '[PRE46]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is the answer we would expect, and the method works for finding roots!
    Notice that if we change the starting value, `x0`, from `1.0` to `-1.0`, we''ll
    get the negative root:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们预期的答案，且该方法能有效求解根！注意，如果我们将起始值`x0`从`1.0`改为`-1.0`，我们将得到负根：
- en: '[PRE47]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is also a valid solution to the equation, so be aware of this when you
    use this method for solving the roots. It can be helpful to plot the function,
    as we did in the section about the bisection method, to get a grip on where to
    start from.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是方程的一个有效解，因此在使用此方法求解根时要注意这一点。绘制函数图像可能会有所帮助，正如我们在二分法部分所做的那样，以便更好地了解从哪里开始。
- en: Finding roots using the secant method
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用割线法求根
- en: 'The secant method, which doesn''t need the derivative of the function, is an
    approximation of the Newton-Raphson method. It uses the finite difference approximation
    in iterations. The following is a recursive implementation in F#:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 割线法不需要函数的导数，是牛顿-拉弗森方法的一种近似方法。它在迭代中使用有限差分近似。以下是F#中的递归实现：
- en: '[PRE48]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Looking at an example
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 看一个例子
- en: 'Let''s look at an example where we use the secant method to find one root of
    a function. We''ll try to find the positive root of `612`, which is a number just
    under the square of 25 (25 x 25 = 625):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，我们使用割线法来求解一个函数的一个根。我们将尝试求解`612`的正根，它是25的平方（25 x 25 = 625）略小的数字：
- en: '[PRE49]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked deeper into F# and numerical analysis and how well
    the two fit together because of the functional syntax of the language. We covered
    algorithm implementation, basic numerical concerns, and the Math.NET library.
    After reading this chapter, you will be more familiar with both F# and numerical
    analysis and be able to implement algorithms yourself. At the end of the chapter,
    an example using the bisection method was covered. This method will prove to be
    very useful later on when we talk about Black-Scholes and implied volatility.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们深入探讨了F#与数值分析的结合，以及这两者如何因为语言的函数式语法而紧密配合。我们介绍了算法实现、基本的数值问题以及Math.NET库。阅读完这一章后，你将更加熟悉F#和数值分析，并能够自己实现算法。在本章的结尾，我们介绍了一个使用二分法的例子。这个方法在我们稍后讨论Black-Scholes模型和隐含波动率时将非常有用。
- en: In the next chapter, we will build on what we learned so far and extend our
    current knowledge with data visualization, basic GUI programming, and plotting
    financial data.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将基于到目前为止学到的内容，扩展我们当前的知识，涉及数据可视化、基础GUI编程以及财务数据的绘制。
