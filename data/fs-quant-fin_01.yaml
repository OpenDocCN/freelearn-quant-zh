- en: Chapter 1. Introducing F# Using Visual Studio
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章：使用 Visual Studio 介绍 F#
- en: In this chapter, you will learn about the history of F# and its roots in other
    programming languages. We will also be introducing Visual Studio and the fundamental
    language constructs of F#. You will be comfortable using the interactive mode
    for prototyping the code step-by-step. You will get a better understanding of
    how to build programs in F# by putting pieces together. Also, the basics of the
    language are covered by using and evaluating the code in the **Read Eval Print
    Loop** (**REPL**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解 F# 的历史及其在其他编程语言中的根源。我们还将介绍 Visual Studio 及 F# 的基本语言构造。你将通过交互模式逐步原型化代码，变得更加熟悉如何在
    F# 中将各个模块拼接起来构建程序。此外，本章将通过使用和评估代码的 **读取-求值-打印循环**（**REPL**）来涵盖语言的基础。
- en: 'In this chapter you will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: How to use F# with Visual Studio 2012
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Visual Studio 2012 中使用 F#
- en: How to use F# Interactive to write the code in a new exploratory way
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 F# Interactive 以全新的探索方式编写代码
- en: The basics of F# and how to write your first non-toy application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 的基础知识及如何编写你的第一个非玩具应用
- en: How functional programming will make you more productive
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程如何让你更高效
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Before we dive in to the language itself, we should discuss why we need it in
    the first place. F# is a powerful language, which may sound like a cliché, but
    it combines multiple paradigms into real-life productivity and supports the .NET
    components and libraries natively as well as the **Common Language Infrastructure**
    (**CLI**). Functional programming has long been associated with academics and
    experts. F# is one of the few languages offering a complete environment that is
    mature enough to comfortably be integrated into an organization.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨语言本身之前，我们应该先讨论一下为什么我们需要它。F# 是一门强大的语言，这听起来可能像是陈词滥调，但它将多种编程范式结合在一起，实际提升生产力，并且原生支持
    .NET 组件和库，以及 **公共语言基础设施**（**CLI**）。函数式编程长期以来与学术界和专家紧密相关。F# 是为数不多的提供完整环境的语言之一，其成熟度足以让其顺利集成到组织中。
- en: Also, F# has extensive support for parallel programming, where advanced features
    such as asynchronous and multi-threaded concepts are implemented as language constructs.
    It hides a lot of implementation details from the programmer. In F#, the functional
    programming paradigm is the main philosophy used to solve problems. The other
    paradigms, object-oriented and imperative programming, are prioritized to be used
    as subsidiaries and complements for this main paradigm. Reasons for them to coexist,
    involves compatibility and pragmatic, real-world productivity concerns.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，F# 对并行编程有广泛的支持，其中包括异步和多线程等高级特性，这些特性作为语言构造实现，极大地简化了程序员的实现细节。在 F# 中，函数式编程范式是解决问题的主要哲学。其他范式，如面向对象编程和命令式编程，被优先作为补充和辅助来支持这一主要范式。它们的共存是基于兼容性和实际生产力的考虑。
- en: Getting started with Visual Studio
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门 Visual Studio
- en: We will start by introducing Visual Studio as the main tool of choice for this
    book. Although it's possible to use the standalone F# compiler and your favorite
    editor, you will most likely be more productive using Visual Studio 2012, as we
    will do throughout this book.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从介绍 Visual Studio 作为本书的主要工具开始。虽然可以使用独立的 F# 编译器和你喜欢的编辑器，但使用 Visual Studio
    2012，你会更高效，我们将在本书中始终如一地使用它。
- en: F# has been a part of Visual Studio since 2010\. We will use the latest version
    of Visual Studio and F# throughout this book. This will enable us to use the latest
    functionality and enhancements available in Visual Studio 2012 and F# 3.0.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: F# 自 2010 年以来就已成为 Visual Studio 的一部分。在本书中，我们将使用 Visual Studio 和 F# 的最新版本。这将使我们能够使用
    Visual Studio 2012 和 F# 3.0 中最新的功能和改进。
- en: F# is open source, which means you can use it on any supported platform; it's
    not bound to Microsoft or Visual Studio. There is good support in other IDEs,
    such as MonoDevelop, which will run on Linux and Mac OS X.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: F# 是开源的，这意味着你可以在任何支持的平台上使用它；它不依赖于 Microsoft 或 Visual Studio。在其他 IDE 中，如 MonoDevelop，也有良好的支持，它能在
    Linux 和 Mac OS X 上运行。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about F# and the F# Software Foundation, visit [http://fsharp.org](http://fsharp.org).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 F# 和 F# 软件基金会的更多信息，请访问 [http://fsharp.org](http://fsharp.org)。
- en: Creating a new F# project
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的 F# 项目
- en: Create a new project in Visual Studio for F#, which is to be used in this guide
    to explore the basics, as shown in the following sections.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中创建一个新的 F# 项目，本指南将使用该项目来探索基础知识，具体内容见下文各节。
- en: Creating a new project in Visual Studio
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中创建一个新项目
- en: 'Using the following steps, we can create a new project in Visual Studio:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们可以在 Visual Studio 中创建一个新项目：
- en: To create your first F# project, open Visual Studio 12 and navigate to **File**
    | **New** | **Project,** then, from the menu select **New Project**.![Creating
    a new project in Visual Studio](img/4623OS_01_1.jpg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建你的第一个 F# 项目，打开 Visual Studio 12，并导航到**文件** | **新建** | **项目**，然后在菜单中选择**新建项目**。![在
    Visual Studio 中创建新项目](img/4623OS_01_1.jpg)
- en: Now you will see the **New Project** window appear. Select **F#** in the left
    panel and then select **F# Application**. You can name it anything you like. Finally,
    click on **OK**.![Creating a new project in Visual Studio](img/4623OS_01_2.jpg)
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你将看到**新建项目**窗口出现。选择左侧面板中的**F#**，然后选择**F# 应用程序**。你可以给它命名任何你喜欢的名称。最后，点击**确定**。![在
    Visual Studio 中创建新项目](img/4623OS_01_2.jpg)
- en: Now you have created your first F# application, which will just print the arguments
    passed to it.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经创建了你的第一个 F# 应用程序，它将仅仅打印传递给它的参数。
- en: Understanding the program template
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解程序模板
- en: Let's have a brief look at the program template generated by Visual Studio.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要看一下 Visual Studio 生成的程序模板。
- en: '![Understanding the program template](img/4623OS_01_3.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![理解程序模板](img/4623OS_01_3.jpg)'
- en: If you run this program, which will just print out the arguments passed to it,
    you will see a terminal window appear.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，它将仅仅打印出传递给它的参数，你将看到一个终端窗口出现。
- en: '![Understanding the program template](img/4623OS_01_4.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![理解程序模板](img/4623OS_01_4.jpg)'
- en: The `[<EntryPoint>]` function in the preceding screenshot is the main function,
    which tells Visual Studio to use that particular function as the entry point for
    the program executable. We will not dig any deeper into this program template
    for now, but we will come back to this in the last three chapters when we'll build
    the trading system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图中的`[<EntryPoint>]`函数是主函数，它告诉 Visual Studio 使用该函数作为程序可执行文件的入口点。我们暂时不深入讨论这个程序模板，但在接下来的三章中，我们将在构建交易系统时回到这个话题。
- en: Adding an F# script file
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一个 F# 脚本文件
- en: 'We will use an F# script file after having looked at the standard program template
    instead of exploring the basics of the language in a more interactive fashion.
    You can think of F# script files as notebooks, where you have executable code
    that you can explore in pieces in an incremental style:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 F# 脚本文件来代替更交互式地探索语言的基础知识，而是在查看标准程序模板之后进行操作。你可以将 F# 脚本文件视为笔记本，在其中你可以逐步探索可执行的代码：
- en: Add the F# script file by right-clicking on the **Solution Explorer** to the
    right of the code editor.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击代码编辑器右侧的**解决方案资源管理器**，添加 F# 脚本文件。
- en: Then navigate to **Add** | **New Item…,** as shown in the following screenshot:![Adding
    an F# script file](img/4623OS_01_5.jpg)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，导航到**添加** | **新建项…**，如以下截图所示：![添加一个 F# 脚本文件](img/4623OS_01_5.jpg)
- en: You can name the script file anything you like, such as `GettingStarted.fsx`.![Adding
    an F# script file](img/4623OS_01_6.jpg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以为脚本文件命名任何你喜欢的名称，比如`GettingStarted.fsx`。![添加一个 F# 脚本文件](img/4623OS_01_6.jpg)
- en: Now that we have set up the basic project structure in Visual Studio, let's
    continue and explore F# Interactive.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 Visual Studio 中设置好了基本的项目结构，接下来让我们继续探索 F# Interactive。
- en: Understanding F# Interactive
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 F# Interactive
- en: F# Interactive is a way of executing parts of a program interactively. Doing
    this enables you as a programmer to explore parts of the code and how it behaves.
    You will have a more dynamic feel for writing code. It's also more fun. F# Interactive
    is a REPL for F#. This means, it will read the code, evaluate it, and then print
    out the result. It will then do this over and over again. It's much like a command
    line, where the code is executed and the result is displayed to the user.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: F# Interactive 是一种交互式执行程序部分的方式。通过这种方式，程序员可以探索代码的不同部分及其行为。这样，你会对编写代码有更动态的感受，也更有趣。F#
    Interactive 是 F# 的 REPL，这意味着它会读取代码、评估它，然后输出结果。接着，它会反复执行这一过程。这就像命令行一样，代码被执行，结果展示给用户。
- en: 'To execute a code in F# Interactive, have a look at the following steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 F# Interactive 中执行代码，请查看以下步骤：
- en: Select the source code you are interested in and press *Alt* + *Enter*.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你感兴趣的源代码，然后按*Alt* + *Enter*。
- en: 'You can write a simple line of code that will just print a string to the REPL''s
    output window:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以写一行简单的代码，它将仅仅打印一个字符串到 REPL 的输出窗口：
- en: '[PRE0]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's also possible to right-click on the selected code and choose **Execute
    In Interactive**.![Understanding F# Interactive](img/4623OS_01_7.jpg)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以右键点击选中的代码，选择**在交互式中执行**。![理解 F# 交互式](img/4623OS_01_7.jpg)
- en: When executing the code using the Interactive mode, the result is shown in the
    **F# Interactive Evaluation** window below the code editor. It is also possible,
    and sometimes preferable to enter snippets into the **Interactive** window like
    the following example illustrates.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在使用交互模式执行代码时，结果会显示在代码编辑器下方的**F# 交互式评估**窗口中。也可以输入代码片段到**交互式**窗口中，这样做有时更为合适，正如以下示例所展示的。
- en: 'Enter the following line in the **F# Interactive** window and press *Enter*:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**F# 交互式**窗口中输入以下代码并按*Enter*键：
- en: '[PRE1]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will be evaluated to the following in the REPL:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在 REPL 中被评估为以下内容：
- en: '[PRE2]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using double semicolons (;;) after the line will terminate the input and enable
    you to just hit the *Enter* key, they are required if you type directly into the
    terminal window.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在代码行后使用双分号(;;)将终止输入，并允许你直接按*Enter*键，它们在你直接在终端窗口中输入时是必须的。
- en: If you want to cancel the evaluation, it's possible to right-click on and then
    select **Cancel Interactive Evaluation**, or simply press *Ctrl* + *Break*.![Understanding
    F# Interactive](img/4623OS_01_8.jpg)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想取消评估，可以右键点击并选择**取消交互式评估**，或者直接按*Ctrl* + *Break*。![理解 F# 交互式](img/4623OS_01_8.jpg)
- en: Language overview
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言概览
- en: We will now start our journey into functional programming using F#, and explore
    its capabilities in quantitative finance applications.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开始使用 F# 进行函数式编程的旅程，并探索其在定量金融应用中的能力。
- en: Let's start by looking at how values are declared, that is, how to bind values
    to names, mutability, and immutability.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看一下如何声明值，也就是如何将值绑定到名称，及其可变性和不可变性。
- en: To initialize and create a value, use the `let` keyword. `let` will bind the
    value on the right-hand side to the variable name on the left-hand side of the
    equals sign. This is a bind operator, a lot like math.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化并创建一个值，请使用`let`关键字。`let`将右侧的值绑定到等号左侧的变量名。这是一个绑定操作符，很像数学中的操作。
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `let` binding is also used in the same way for binding functions to a name,
    as we will see in the following sections.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`绑定也可以用来将函数绑定到名称上，正如我们将在接下来的章节中看到的那样。'
- en: Explaining mutability and immutability
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释可变性和不可变性
- en: Once a variable is defined to have a particular value, it keeps that value indefinitely.
    There are exceptions to this, and shadowing can be used to override a previous
    assignment made within the same scope. Thus, variables in mathematics are immutable.
    Similarly, variables in F# are immutable with some exceptions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦变量被定义为具有特定值，它将一直保持该值。对此有一些例外情况，且可以使用遮蔽来覆盖同一作用域内先前的赋值。因此，数学中的变量是不可变的。同样，F#中的变量也是不可变的，但有一些例外。
- en: Immutable variables are default in F#. They are useful because they are thread-safe
    and easier to reason about. This is one of the reasons you may have heard a lot
    about immutability recently. The concept is to solve the biggest issues and design
    flaws of concurrent programming, including shared mutable state. If the values
    do not change, there is no need to protect them either, which is one of the reasons
    for promoting immutability in concurrent programming.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变变量是 F# 中的默认值。它们很有用，因为它们是线程安全的，更容易推理。这也是你最近可能听到很多关于不可变性的原因之一。这个概念旨在解决并发编程中的最大问题和设计缺陷，包括共享的可变状态。如果值不会改变，那么就不需要保护它们，这也是推动并发编程中不可变性的原因之一。
- en: 'If you try to alter the value of an immutable variable, you will encounter
    a message similar to the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试修改不可变变量的值，你将遇到类似以下的消息：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Sometimes, however, it's desirable to have variables that are mutable. Often
    the need arises in real-life applications when some global state is shared like
    a counter. Also, object-oriented programming and interoperability with other .NET
    languages makes the use of mutability unavoidable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时需要拥有可变变量。在实际应用中，当某些全局状态被共享（例如计数器）时，经常会有这种需求。此外，面向对象编程和与其他 .NET 语言的互操作性使得使用可变性变得不可避免。
- en: 'To create a mutable variable, you simply put the keyword `mutable` in front
    of the name as shown in the following line of code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可变变量，你只需在名称前面加上关键字`mutable`，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To change the variable, after it is created, use the arrow operator (`←`) as
    shown in the following line of code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要在创建变量后更改其值，请使用箭头操作符（`←`），如下代码所示：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is a little bit different from other languages. But once you have wrapped
    your head around the concept, it makes more sense. In fact, it will most likely
    be one of the main ways to reason about variables in the future as well.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他语言稍有不同。但一旦你理解了这个概念，就能更好地理解它。事实上，它很可能会成为未来推理变量的主要方式之一。
- en: Primitive types
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始类型
- en: It may look like F# is a dynamic typed language like JavaScript, Ruby, or Python.
    In fact, F# is statically typed like C#, C++, and Java. It uses type inference
    to figure out the correct types. Type inference is a technique which is used to
    automatically deduce the type used by analyzing the code. This approach works
    remarkably well in nearly all situations. However, there are circumstances in
    which you as a programmer need to make clarifications to the compiler. This is
    done using type annotations, a concept we will look into in the following sections.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: F# 看起来可能像是 JavaScript、Ruby 或 Python 等动态类型语言。实际上，F# 是像 C#、C++ 和 Java 一样的静态类型语言。它通过类型推断来确定正确的类型。类型推断是一种通过分析代码自动推导出类型的技术。这种方法在几乎所有情况下都能很好地工作。然而，有时程序员需要对编译器进行明确的说明。这可以通过类型注解实现，我们将在接下来的章节中进一步探讨这一概念。
- en: Let's explore some of the built-in types in F# using the REPL.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 REPL 探索一些 F# 内建类型。
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This means that F# figured out the type of `anInt` to be of type `int`. It simply
    inferred the type on the left-hand side to be of the same type as the right-hand
    side of the assignment. Logically, the type must be the same on both sides of
    the assignment operator, right?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 F# 推断 `anInt` 的类型为 `int`。它仅仅通过推断左边的类型与右边赋值的类型一致。逻辑上，赋值操作符两边的类型必须相同，不是吗？
- en: 'We can extend our analysis into floating point numbers as shown in the following
    lines of code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将分析扩展到浮点数，如下代码所示：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Because of the decimal sign, the type is determined to be of type `float`.
    The same holds true for `double` as shown in the following lines of code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有小数点符号，类型被确定为 `float` 类型。同样的规则适用于 `double`，如下代码所示：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For other types, it works in the same way as expected as shown in the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他类型，其工作方式与预期一致，如下所示：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All the primitive built-in types, except for `unit`, have a corresponding type
    in .NET.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `unit` 类型，所有原始的内建类型都有对应的 .NET 类型。
- en: 'The following table shows the most common primitive types in F#:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了 F# 中最常见的原始类型：
- en: '| Type | .NET type | Description |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | .NET 类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| bool | Boolean | true or false |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| bool | Boolean | true 或 false |'
- en: '| byte | Byte | 0 to 255 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| byte | Byte | 0 到 255 |'
- en: '| int | Int32 | -128 to 127 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| int | Int32 | -128 到 127 |'
- en: '| int64 | Int64 | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| int64 | Int64 | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |'
- en: '| char | Char | 0 to 18,446,744,073,709,551,615 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| char | Char | 0 到 18,446,744,073,709,551,615 |'
- en: '| string | String | Unicode text |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| string | String | Unicode 文本 |'
- en: '| decimal | Decimal | Floating data type |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| decimal | Decimal | 浮动数据类型 |'
- en: '| unit | - | Absence of an actual value |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| unit | - | 缺少实际值 |'
- en: '| void | Void | No type or value |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| void | Void | 无类型或值 |'
- en: '| float | Single | 64-bit floating point value |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| float | Single | 64 位浮点值 |'
- en: '| double | Double | Same as above |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| double | Double | 与上述相同 |'
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information and all type you can visit [http://msdn.microsoft.com/en-us/library/dd233210.aspx.](http://msdn.microsoft.com/en-us/library/dd233210.aspx.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息及所有类型，可以访问 [http://msdn.microsoft.com/en-us/library/dd233210.aspx.](http://msdn.microsoft.com/en-us/library/dd233210.aspx.)
- en: There are also other types that are built into the language which will be covered
    in more detail in the next chapter, such as lists, arrays, sequences, records,
    and discriminated unions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 语言中还有其他类型，这些类型将在下一章中详细讲解，例如列表、数组、序列、记录和区分联合。
- en: Explaining type inference
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释类型推断
- en: Type inference means that the compiler will automatically deduce the type of
    an expression used in the code, based on the information provided from the programmer
    about the context of the expression. Type inference analyses the code, as you
    have seen in the preceding section, to determine types that are often obvious
    to the programmer. This spares the programmer from having to explicitly define
    the types of every single variable. It's not always needed to have the types defined
    to be able to understand the code, as seen in the preceding section for simple
    assignments of integers and floats. Type inference will make the code easier to
    write, and as a consequence, easier to read, leaving a lot of ceremony where it
    belongs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推导意味着编译器会根据程序员提供的表达式上下文信息，自动推断代码中表达式的类型。类型推导分析代码，如你在前面的章节中所看到的，确定程序员通常可以轻松识别的类型。这使得程序员无需显式定义每个变量的类型。在前面的章节中，我们看到的简单整数和浮点数赋值不需要定义类型就能理解代码。类型推导将使代码更易于编写，从而更易于阅读，省去了不必要的冗余。
- en: Explaining functions
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释函数
- en: 'It''s now time to look at functions, the most basic and powerful building block
    in F#, and any other functional programming language for that matter. Functional
    programming languages use functions as first class constructs, in contrast to
    object-oriented programming, where objects and data are first class constructs.
    This means that in functional programming, functions will produce data based on
    the input and not based on state. In object-oriented programming, the state is
    encapsulated into objects and passed around. Functions are declared in the same
    way as variables were declared previously in the preceding snippets, with `let`
    bindings. Have a look at the following code snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候了解函数了，它是F#以及任何其他函数式编程语言中最基本且强大的构建块。函数式编程语言将函数视为一等构造，与面向对象编程不同，在面向对象编程中，对象和数据是第一类构造。这意味着在函数式编程中，函数根据输入生成数据，而不是依赖状态。在面向对象编程中，状态被封装到对象中并传递。在之前的代码片段中，函数的声明方式与变量声明方式相同，都是使用`let`绑定。请看以下代码片段：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you try to evaluate the first `sum` function using *Alt* + *Enter*, F# Interactive
    will respond with a function like the following line of code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用*Alt* + *Enter*来评估第一个`sum`函数，F#交互式会返回如下类似的函数代码：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This means that `sum` is a function that takes two values of type `int` and
    returns a value of type `int`. The compiler simply knows that it's just the last
    type that is the return type.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`sum`是一个接受两个`int`类型值并返回一个`int`类型值的函数。编译器只需要知道最后一个类型就是返回类型。
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s look at the following case where parameters of wrong types are passed
    to the function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个传递错误类型参数给函数的例子：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As seen in the modified version of the `sum` function, the types are explicitly
    declared as float. This is a way of telling the compiler beforehand that float
    is the value to be used in the function. The first version of sum used type inference
    to calculate the types for `x` and `y` respectively and found it to be of type
    `int`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如修改版的`sum`函数所示，类型被显式声明为float。这是一种提前告诉编译器，函数中将使用float类型的值的方式。sum函数的第一个版本使用类型推导来计算`x`和`y`的类型，并发现它们是`int`类型。
- en: Learning about anonymous functions
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解匿名函数
- en: 'Since it is common to create small helper functions in F# programming, F# also
    provides a special syntax for creating anonymous functions. These functions are
    sometimes called lambdas, or lambda functions. To define an anonymous function,
    the keyword `fun` is used. Have a look at the following code snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在F#编程中创建小型辅助函数很常见，F#还提供了一个用于创建匿名函数的特殊语法。这些函数有时被称为lambda，或lambda函数。定义匿名函数时，使用关键字`fun`。请看以下代码片段：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Explaining higher-order functions
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释高阶函数
- en: 'Now the square function can be used by itself or as an argument to other functions
    or higher-order functions. Have a look at the following square function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，平方函数可以单独使用，也可以作为其他函数或高阶函数的参数。请看以下平方函数：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the square function is passed as an argument to the function `squareByFour`.
    The function `squareByFour` is a higher-order function; it takes another function
    as an argument. Higher-order functions can take a function as an argument or return
    a function, or do both. This is an often used technique in functional programming
    to be able to construct new functions from existing functions and reuse them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，平方函数作为参数传递给函数`squareByFour`。`squareByFour`是一个高阶函数，它接收另一个函数作为参数。高阶函数可以接受一个函数作为参数或返回一个函数，或者两者兼有。这是函数式编程中常用的技术，能够从现有函数构建新函数并重用它们。
- en: Currying
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柯里化
- en: Though, currying is sometimes considered to be an advanced feature of programming
    languages, it makes the most sense on connection to functions and higher-order
    functions. The idea is not complicated at all, and once you have seen a couple
    of examples, the concept should be clear.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管柯里化有时被认为是编程语言的高级特性，但它与函数和高阶函数的关联使得它最具意义。这个概念一点也不复杂，一旦你看过几个例子，概念应该就很清楚了。
- en: 'Let''s look at the following `sum` function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下下面的`sum`函数：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s assume we want to reuse the function, but we may often call it for some
    fixed value of `x`. That means we have a fixed `x`, let''s say `2`, and we vary
    the `y` parameter. Have a look at the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要重用这个函数，但我们可能经常对某个固定的`x`值进行调用。这意味着我们有一个固定的`x`，假设是`2`，然后我们改变`y`参数。请看以下示例：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Instead of having to write out the `x` parameter every time, we can make use
    of the concept of currying. That means we create a new function with the first
    parameter fixed in this case. Take a look at the following function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 不必每次都写出`x`参数，我们可以利用柯里化的概念。这意味着我们可以创建一个新的函数，在这种情况下第一个参数被固定。看一下下面的函数：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have now saved ourselves from rewriting some arguments, but this is not the
    main reason. It's the ability to control the parameters and reuse functionality.
    More about currying will be covered in later chapters, but the basics were covered
    here in connection to higher-order functions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们避免了重写一些参数，但这并不是主要原因。主要原因是能够控制参数并重用功能。更多关于柯里化的内容将在后续章节中介绍，但这里已经涵盖了与高阶函数相关的基础知识。
- en: Investigating lists
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调查列表
- en: Lists in F# are very useful, they are some of the most frequently used building
    blocks. They are the basic building blocks in functional languages and often replace
    the need of other types or classes. This is because the support for manipulating
    and creating lists and also being able to nest lists can be enough to replace
    custom types. You can think of lists as a sequence of values of the same type.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，列表非常有用，它们是最常用的构建块之一。它们是函数式语言中的基本构建块，通常可以替代其他类型或类。这是因为支持操作和创建列表的功能，以及能够嵌套列表，足以替代自定义类型。你可以将列表看作是同一类型值的序列。
- en: 'Lists in F# are the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: F#中的列表如下：
- en: A powerful way to store data
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储数据的一种强大方式
- en: Immutable linked lists of values of any type
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变的值列表，支持任何类型
- en: Often used as building blocks
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常作为构建块使用
- en: One of the best ways to store data
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储数据的最佳方式之一
- en: '![Investigating lists](img/4623OS_01_9.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![调查列表](img/4623OS_01_9.jpg)'
- en: This illustrates a list in F#, with a head and a tail, where each element is
    linked to the next.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了F#中的一个列表，具有头部和尾部，其中每个元素与下一个元素相连。
- en: 'Let''s consider the following simple list of price information which are represented
    as floating points:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个简单的价格信息列表，这些信息以浮动点表示：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Suppose you want a list with values between 0 and 100, instead of writing them
    yourself, F# can do it for you. Take a look at the following lines of code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要一个值在0到100之间的列表，F#可以帮你实现，而不需要你手动编写。请看以下代码：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is fine if we just want a simple range with fixed size increments. Sometimes
    however, you may want to have a smaller increment, let''s say 0.1, which is between
    1.0 and 10.0\. The following code shows how it is done:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要一个固定增量的简单范围，这样做是可以的。然而，有时你可能需要更小的增量，比如0.1，范围是从1.0到10.0。以下代码展示了如何实现：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Lists can be of any type, and type inference works here as well. Have a look
    at the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以是任何类型的，类型推断在这里也能正常工作。请看下面的代码：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, if you mix the types in a list, the compiler will get confused about
    the actual type used:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你在列表中混合不同类型，编译器会对实际使用的类型产生困惑：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你在[http://www.packtpub.com](http://www.packtpub.com)购买的所有Packt书籍的账户中下载示例代码文件。如果你是在其他地方购买的这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，将文件直接通过电子邮件发送给你。
- en: Concatenating lists
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表连接
- en: 'Concatenating lists is useful when you want to add lists together. This is
    done using the `@` operator. Have a look at the following code where the `@` operator
    is used:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表连接在你想将多个列表合并时非常有用。可以使用`@`操作符来实现这一点。请看以下代码，其中使用了`@`操作符：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s have a look at some of the most commonly used functions in the List
    Module: `Length`, `Head`, `Tail`, `map`, and `filter` respectively.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下列表模块中最常用的一些函数：`Length`、`Head`、`Tail`、`map`和`filter`。
- en: 'The function `Length` will simply return the length of the list:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`Length`将简单地返回列表的长度：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you want the first element of a list, use `Head`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要列表的第一个元素，使用`Head`：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The rest of the list, meaning all other elements except the `Head`, is defined
    as the `Tail`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的其余部分，意味着除`Head`之外的所有其他元素，被定义为`Tail`：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can also do some more interesting things with lists, such as calculating
    the square of all the elements one by one. Note that it''s an entirely new list
    returned from the `map` function, since lists are immutable. This is done using
    higher-order functions, where `List.map` takes a lambda function defined to return
    the value of `x*x` as seen in the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以对列表做一些更有趣的事情，比如逐个计算所有元素的平方。请注意，它返回的是一个全新的列表，这是因为列表是不可变的。这是通过高阶函数完成的，其中`List.map`接受一个返回`x*x`值的lambda函数，如以下代码所示：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Another interesting function is the `filter` function of lists, which will
    return a new list matching the filter criteria:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的函数是列表的`filter`函数，它将返回一个符合过滤条件的新列表：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Tuples
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: Tuples are a group of unnamed but ordered values. The values can be of different
    types, if needed. You can think of them as more flexible versions of the Tuple
    class in C#.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是一组无名但有序的值。根据需要，值可以是不同类型的。你可以把它们看作是C#中的元组类的更灵活版本。
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s analyze the type information from the tuples in the REPL. The first
    tuple has the type information:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在REPL中分析元组的类型信息。第一个元组具有以下类型信息：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `*` symbol is used to separate the type elements for a tuple. It''s simply
    a tuple of two floats. The next one is a bit more complex:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`符号用于分隔元组的类型元素。它只是一个包含两个浮点数的元组。下一个稍微复杂一点：'
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'But the type inference figured it out without any doubts. The last one consists
    of expressions:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但是类型推断没有任何疑问地弄清楚了。最后一个包含表达式：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, the expressions are evaluated before the type data is analyzed.
    It may be useful to extract the values from a tuple, this can be done using simple
    patterns:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，表达式在类型数据分析之前被求值。提取元组中的值可能是有用的，这可以通过简单的模式来完成：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you are not interested in the first value, use the wildcard character (the
    underscore) to simply ignore it. The wildcard is used throughout F#, for example,
    in pattern matching, which will be introduced in the next chapter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对第一个值不感兴趣，可以使用通配符字符（下划线）来简单地忽略它。通配符在F#中广泛使用，例如在模式匹配中，在下一章将介绍这一点。
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The pipe operator
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道操作符
- en: The pipe operator is used a lot and it's defined as a function which takes the
    values on the left-hand side of the operator and applies them to the function
    on the right-hand side. There is another version of the pipe operator with various
    numbers of arguments, and more about them will be covered later.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 管道操作符使用得很频繁，它被定义为一个函数，该函数将操作符左边的值传递给右边的函数并应用它们。还有一个带有不同参数数量的管道操作符版本，关于它们的更多内容将在后面讲解。
- en: 'The pipe-forward operator (|>) is the most common pipe operator:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 管道前向操作符(`|>`)是最常见的管道操作符：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This snippet first creates a list from 0 to 100, as illustrated in the section
    about lists previously. Then, the list is piped to the filter function with a
    conditional lambda function. Every even value in the list gets passed on to the
    next function. The map function will execute the lambda function to square every
    number. Finally, all numbers are summed, with the result of:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先创建一个从 0 到 100 的列表，如前面关于列表的部分所示。然后，列表被传递给 filter 函数，使用条件 lambda 函数。列表中的每个偶数值都会传递给下一个函数。map
    函数会执行 lambda 函数，对每个数字进行平方。最后，所有的数字都会被求和，结果是：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Documenting your code
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写代码文档
- en: Documenting your code is a good practice to get used to. Do you remember details
    about code you worked on some weeks ago? Then imagine yourself looking at the
    code you worked on several years ago. This is where documentation comes in. Just
    some hints about the logic will be sufficient for you and your colleges to grasp
    the main concepts behind the logic.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码文档是一个值得养成的好习惯。你还记得几周前你写的代码的细节吗？再想象一下，几年前你写的代码会是什么样的。这就是文档发挥作用的地方。仅仅对逻辑的一些提示就足够让你和你的同事理解背后的主要概念。
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Your first application
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的第一个应用
- en: The first application for doing something useful will be this Hello World of
    finance, which will illustrate some powerful yet simple concepts and strengths
    of F# and functional languages in general.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个有用的应用将是这个金融领域的 Hello World，它将展示 F# 和函数式语言的一些强大而简单的概念和优点。
- en: Let's start our journey into quantitative finance by looking at a simple yet
    illustrative example using Yahoo finance data. First, we will just put the data
    into the code to get used to the basic concepts.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单但富有启发性的例子来开始我们的定量金融之旅，使用 Yahoo 财务数据。首先，我们将数据输入到代码中，以便熟悉基本概念。
- en: 'First, we put some data in. In F# you can declare a list of strings on multiple
    lines like the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们输入一些数据。在 F# 中，你可以像下面的代码那样在多行上声明一个字符串列表：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We introduce a function for splitting strings on commas; this will create an
    array of strings. Don't forget to evaluate the parts of the program in F# Interactive
    using *Alt* + *Enter*. Doing this as a practice will make the number of errors
    less, and you will also be getting more comfortable and understand the types involved.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个用于按逗号分割字符串的函数；这将创建一个字符串数组。不要忘记在 F# Interactive 中使用 *Alt* + *Enter* 评估程序的各个部分。通过这样练习，可以减少错误数量，并且你会变得更加熟悉，理解涉及的类型。
- en: 'The type of the `stockData` value is not explicitly declared, but if you evaluate
    it, you should see it is of type `string list`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`stockData` 值的类型没有显式声明，但如果你评估它，你应该看到它是 `string list` 类型：'
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Evaluating the expression `lowestVolume` will parse the strings in `stockData`
    and extract the row with the lowest trading volume, column six. Hopefully, the
    result will be the row with date 2013-05-29, as in the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 评估表达式 `lowestVolume` 会解析 `stockData` 中的字符串，并提取出交易量最小的那一行，第六列。希望结果是包含日期 2013-05-29
    的那一行，如下所示：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The whole program
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整个程序
- en: 'The following is the code listing for the program we developed in the previous
    section, the Hello World program of finance. Try it out for yourself and make
    changes to it if you like:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在上一部分开发的程序代码清单，即金融领域的 Hello World 程序。你可以自己尝试并根据需要做出更改：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Understanding the program
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解程序
- en: The pipe operator makes the logic of the program very straightforward. The program
    takes the list `stockData`, splits for commas, then selects specific columns and
    applies a mathematical operator. Then, it selects the maximum value of these calculations
    and finally returns the first column of the row fulfilling the `minBy` criteria.
    You can think of it as building blocks, where each piece is a standalone function
    on its own. Combining many functions into powerful programs is the philosophy
    behind functional programming.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 管道操作符使程序的逻辑非常直观。程序首先获取 `stockData` 列表，按逗号分割，然后选择特定的列并应用数学运算符。接着，它选择这些计算中的最大值，最后返回符合
    `minBy` 条件的行的第一列。你可以把它看作是构建模块，其中每一部分都是一个独立的函数。将多个函数组合成强大的程序，是函数式编程背后的理念。
- en: Extending the example program
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展示例程序
- en: Let's extend the preceding program to read data from a file instead. Since having
    it explicitly declared in the code is not that useful in the long run, as data
    tends to change. During this extension, we will also introduce exceptions and
    how they are used in .NET.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展前面的程序，改为从文件中读取数据。由于在代码中显式声明数据在长远来看并不那么有用，因为数据会变化。在扩展的过程中，我们还将介绍异常及其在.NET中的使用。
- en: We start by writing a simple function to read all the contents from a file,
    where its path is passed as an argument. The argument is of type string, as you
    can see in the function header using the type annotation. Annotations are used
    either when the compiler can't figure out the type on its own, or when you as
    a programmer want to clarify the type used or enforce a certain type.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编写一个简单的函数来读取文件的所有内容，其中文件路径作为参数传递。参数的类型是字符串，如你在函数头部看到的类型注释。注释的使用通常是编译器无法自行推断类型时，或者作为程序员你想要明确指定或强制使用某种类型时。
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The function will catch `FileNotFoundException` if the file is not found. There
    is also a new operator (`:?`) before the exception type. This is a type test operator,
    which returns true if the value matches the specified type, otherwise, returns
    false.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件未找到，函数将捕获`FileNotFoundException`。在异常类型前还有一个新的运算符（`:?`）。这是一个类型测试运算符，如果值与指定的类型匹配，则返回true，否则返回false。
- en: Let's change the preceding code to use the content loaded from the file instead
    of the pre-coded stock prices.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改前面的代码，使用从文件中加载的内容，而不是预先编码的股票价格。
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There are some minor changes needed to the code to make it able to handle the
    input from the **Comma-Separated Values** (**CSV**) file. As with the input to
    the pipes, we use the result from the call to the `openFile` function. Then, we
    split for commas as before. It was necessary to have a way to skip the first line;
    this is easy to do in F#, and you just insert a `Seq.skip n`, where n is the number
    of elements in the sequence to skip.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 代码需要进行一些小的修改，以便能够处理来自**逗号分隔值**（**CSV**）文件的输入。与管道的输入一样，我们使用`openFile`函数的调用结果。然后，我们像之前一样按逗号进行拆分。需要有一种方法来跳过第一行；在F#中这很容易实现，你只需插入`Seq.skip
    n`，其中n是要跳过的序列元素的数量。
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, we simply use `printfn` formatted with `%A`, which will just take anything
    and format for output (very convenient).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地使用`printfn`并格式化为`%A`，这样就可以接受任何内容并格式化输出（非常方便）。
- en: 'Let''s look at one more example of this useful string formatter:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个有用的字符串格式化器的例子：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The entire program
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整个程序
- en: Let's look at the code for the entire program, which we looked at in the previous
    section.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看整个程序的代码，这是我们在前一部分中看到的。
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The power of prototyping
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型设计的力量
- en: Using the interactive mode in Visual Studio and being able to write the program
    in smaller building blocks using prototyping is a great way of writing software.
    You have already used this exploratory way of writing programs with the first
    application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Visual Studio的交互模式，并能够通过原型设计以更小的构建块编写程序，是编写软件的一个好方法。你已经通过第一个应用程序使用了这种探索性的编程方式。
- en: The workflow is to build up programs incrementally instead of running all code
    at once. The REPL is a perfect place to try out snippets and experiment with different
    aspects of F#.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程是逐步构建程序，而不是一次性运行所有代码。REPL是一个完美的地方，可以尝试代码片段并实验F#的不同方面。
- en: Functional languages in quantitative finance
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能性语言在量化金融中的应用
- en: In the preceding example code, we saw that parsing data from a file and extracting
    various information is straightforward, and results in code that is both easy
    to read and understand. That's one of the highlights of F#, not less important
    in quantitative finance where code can be complex and hard to follow and comprehend
    in many languages.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，我们看到从文件中解析数据并提取各种信息是直接且简单的，产生的代码既易于阅读又易于理解。这是F#的亮点之一，尤其在量化金融中，这一点尤为重要，因为在许多语言中，代码可能复杂且难以跟踪和理解。
- en: 'Let''s illustrate the preceding statements with another example. The data in
    the CSV file in the previous sample application was sorted with the most recent
    date first. If we want the data to be ordered in a more natural way, lowest date
    first and so on, we can simply reverse the entire list in the following way:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过另一个例子来说明前述的说法。前一个示例应用中的CSV文件数据是按最新日期排序的。如果我们希望数据以更自然的方式排序，最早的日期排在前面，我们可以简单地通过以下方式反转整个列表：
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Understanding the imperative code and interoperability
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解命令式代码和互操作性
- en: 'Suppose we are interested in parsing the date column in the example with the
    stock prices. The entire row looks something like the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们对解析示例中股票价格的日期列感兴趣。整行数据大致如下所示：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We are interested in the first column, with index 0:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对第一列感兴趣，索引为 0：
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can make use of the .NET classes for date and time in the `System.DateTime`
    namespace:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用 .NET 中 `System.DateTime` 命名空间下的日期和时间类：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now we have a `System.DateTime` object, which is compatible with C# and the
    other .NET languages, to work with!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个`System.DateTime`对象，它与 C# 以及其他 .NET 语言兼容，可以用来处理时间！
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we had a look into the basics of programming in F# using Visual
    Studio. We covered a wide variety of the language and scratched the surface of
    functional programming, where immutability plays a key role. Throughout the chapter
    we started out illustrating some of F#'s language features and how to make use
    of the .NET framework. At the end of the chapter, we put together a simple application
    which shows the power and elegant syntax of F#. Functions are the main building
    block in any functional programming language. Building new functions from existing
    ones is a way of abstracting away the complexity and allows for reuse.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，我们初步了解了如何使用 Visual Studio 编写 F# 编程。我们涵盖了语言的各种基础知识，并浅尝了函数式编程（functional
    programming），其中不可变性（immutability）扮演了关键角色。在整章中，我们通过展示一些 F# 语言特性并说明如何利用 .NET 框架（framework），让大家对
    F# 编程有了初步的认识。在本章结束时，我们实现了一个简单的应用，展示了 F# 的强大功能和优雅语法。函数是任何函数式编程语言中的核心构件。从现有函数构建新函数是一种抽象复杂性的方式，并且能实现复用。
- en: In the next chapter, we'll dive into more details about the F# language. You'll
    learn more about data structures, such as Lists, Sequences, and Arrays. You'll
    also learn how to structure your program using modules and namespaces, things
    that will become useful in larger programs. The next chapter will also introduce
    you to threads, thread pools, asynchronous programming using .NET, and language-specific
    constructs for the F# language.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将深入了解更多关于 F# 语言的细节。你将学习更多的数据结构，如列表（Lists）、序列（Sequences）和数组（Arrays）。你还将学习如何使用模块（modules）和命名空间（namespaces）来组织你的程序，这些内容在更大的程序中会变得非常有用。下一章还将介绍线程（threads）、线程池（thread
    pools）、使用 .NET 进行异步编程（asynchronous programming）以及 F# 语言特有的语言构造（language-specific
    constructs）。
