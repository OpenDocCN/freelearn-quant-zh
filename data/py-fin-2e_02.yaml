- en: Chapter 2. Introduction to Python Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 Python模块简介
- en: 'In this chapter, we will discuss the most important issues related to Python
    modules, which are packages written by experts or any individual to serve a special
    purpose. In this book, we will use about a dozen modules in total. Thus, knowledge
    related to modules is critical in our understanding of Python and its application
    to finance. In particular, in this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论与Python模块相关的最重要问题，这些模块是由专家或任何个人编写的，用于特定目的。在本书中，我们将使用大约十几个模块。因此，模块相关的知识对于我们理解Python及其在金融中的应用至关重要。特别地，在本章中，我们将涵盖以下主题：
- en: Introduction to Python modules
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python模块简介
- en: Introduction to NumPy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy简介
- en: Introduction to SciPy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SciPy简介
- en: Introduction to `matplotlib`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matplotlib`简介'
- en: Introduction to `statsmodels`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statsmodels`简介'
- en: Introduction to pandas
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pandas简介
- en: Python modules related to finance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与金融相关的Python模块
- en: Introduction to the pandas_reader module
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pandas_reader模块简介
- en: Two financial calculators written in Python
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Python编写的两个金融计算器
- en: How to install a Python module
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装Python模块
- en: Module dependency
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块依赖关系
- en: What is a Python module?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Python模块？
- en: A module is a package or group of programs that is written by an expert, user,
    or even a beginner who is usually very good in a specific area, to serve a specific
    purpose.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是由专家、用户甚至是初学者编写的一组程序或软件包，通常这些人精通某个特定领域，且为了特定的目的而编写这些程序。
- en: 'For example, a Python module called quant is for quantitative financial analysis.
    quant combines two modules of SciPy and `DomainModel`. The module contains a domain
    model that has exchanges, symbols, markets, and historical prices, among other
    things. Modules are very important in Python. In this book, we will discuss about
    a dozen modules implicitly or explicitly. In particular, we will explain five
    modules in detail: NumPy, SciPy, `matplotlib`, `statsmodels`, and Pandas.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个名为quant的Python模块用于定量金融分析。quant结合了SciPy和`DomainModel`两个模块。该模块包含一个领域模型，其中有交易所、符号、市场和历史价格等内容。模块在Python中非常重要。在本书中，我们将或多或少地讨论十几个模块。特别地，我们将详细讲解五个模块：NumPy、SciPy、`matplotlib`、`statsmodels`和Pandas。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As of November 16, 2016, there are 92,872 Python modules (packages) with different
    areas available according to the Python Package Index.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2016年11月16日，Python包索引中有92,872个不同领域的Python模块（包）。
- en: For the financial and insurance industries, there are 384 modules currently
    available.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于金融和保险行业，目前有384个模块可供使用。
- en: 'Assume that we want to estimate the square root of `3` by using the `sqrt()`
    function. However, after issuing the following lines of code, we will encounter
    an error message:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想使用`sqrt()`函数估算`3`的平方根。然而，在执行以下代码后，我们将遇到错误消息：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The reason is that the `sqrt()` function is not a built-in function. A built-in
    function could be viewed as an existing function when Python is launched. To use
    the `sqrt()` function, we need to import the math module first, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于`sqrt()`函数不是内置函数。内置函数可以视为在Python启动时就已存在的函数。要使用`sqrt()`函数，我们需要先导入math模块，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To use the `sqrt()` function, we have to type `math.sqrt()` if we use the `import
    math` command to import or upload the math module. In the preceding code, the
    `round()` function is used to control the number of decimal places. In addition,
    after issuing the command of `dir()`, we will see the existence of the math module,
    which is the last one in the output shown here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`sqrt()`函数，如果我们使用`import math`命令导入math模块，则必须输入`math.sqrt()`。在前面的代码中，`round()`函数用于控制小数位数。此外，在执行`dir()`命令后，我们将看到math模块的存在，它是此处输出中的最后一个：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In addition, when a module is preinstalled, we could use `import x_module`
    to upload it. For instance, the math module is preinstalled. Later in the chapter,
    we will see how to find all built-in modules. In the preceding output, after issuing
    the command `dir()`, we also observe `__builtins__`. There are two underscores,
    before and after `builtin`. This `__builtins__` module is different from other
    built-in modules, such as the `math` module. It is for all built-in functions
    and other objects. Again, the command of `dir(__builtins__)` could be issued to
    list all built-in functions, as shown in the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当一个模块是预安装时，我们可以使用`import x_module`来上传它。例如，math模块是预安装的。在本章后面，我们将看到如何查找所有内置模块。在前面的输出中，发出`dir()`命令后，我们还观察到`__builtins__`。在`builtin`前后都有两个下划线。这个`__builtins__`模块不同于其他内置模块，例如`math`模块。它包含所有内置函数和其他对象。再次发出`dir(__builtins__)`命令可以列出所有内置函数，如以下代码所示：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'From the preceding output, we find a function called `pow()`. The command of
    `help(pow)` could be used to find more information about this specific function;
    see the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们发现一个名为`pow()`的函数。可以使用`help(pow)`命令来查找有关这个特定函数的更多信息；见下文：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For convenience, it is a good idea to adopt a short name for an imported module.
    To save some typing effort when programming, we could use the command `import
    x_module as short_name` as shown in the following lines of code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，建议为导入的模块采用简短名称。为了在编程时减少一些输入工作量，我们可以使用`import x_module as short_name`命令，如以下代码所示：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When calling a specific function contained in an imported module, we use the
    module''s short name, as shown in the following lines of code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用导入模块中包含的特定函数时，我们使用模块的简短名称，如以下代码所示：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Although users are free to choose any short names for an imported module, it
    is a great idea to respect some conventions, such as using `np` for NumPy and
    `sp` for SciPy. One added advantage of using such commonly used short names is
    to make our programs more readable to others. To show all functions in an imported
    module, the `dir(module)` command could be used, as shown in the following lines
    of code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然用户可以自由选择任何简短的名称来导入模块，但遵循一些约定是个不错的主意，例如使用`np`表示NumPy，使用`sp`表示SciPy。使用这些常用的简短名称的一个额外好处是能使我们的程序对他人更具可读性。要显示导入模块中的所有函数，可以使用`dir(module)`命令，如以下代码所示：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Recall that in [Chapter 1](ch01.html "Chapter 1. Python Basics"), *Python Basics*,
    `import math` and `from math import *` are compared. Generally speaking, to make
    your programs simpler, you could use `from math import *`. This is especially
    true for a beginner who has just started to learn Python programming. Let''s take
    a look at the following lines of code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下在[第1章](ch01.html "第1章 Python基础")，*Python基础*中，比较了`import math`和`from math
    import *`。一般来说，为了简化程序，可以使用`from math import *`。这对于刚开始学习Python编程的初学者尤其适用。让我们看一下以下代码：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, all functions contained in the module will be available directly. On the
    other hand, if we use `import math`, we have to add the module name as a prefix,
    such as `math.sqrt()` instead of `sqrt()`. After getting more familiar with Python,
    it is a good idea to use the import module format instead of using `from module
    import *`. There are two reasons behind such a preference:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，模块中包含的所有函数将可以直接使用。另一方面，如果我们使用`import math`，我们必须将模块名作为前缀，例如`math.sqrt()`而不是`sqrt()`。熟悉Python后，建议使用导入模块的格式，而不是使用`from
    module import *`。这种偏好背后有两个原因：
- en: First, users know exactly from which module the function comes from.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，用户可以准确知道函数来自哪个模块。
- en: 'Second, we might have written our own function with the same name as the function
    contained in another module. A module name ahead of a function will distinguish
    it from our own function, as shown in the following lines of code:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们可能已经编写了一个与另一个模块中函数同名的函数。模块名加在函数前面可以将其与我们自己的函数区分开，如以下代码所示：
- en: '[PRE9]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `del()` function is used to remove an imported/uploaded module which is
    deemed unnecessary, as shown in the following lines of code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`del()`函数用于移除一个被认为不再需要的导入/上传模块，如以下代码所示：'
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On the other hand, if we use `from math import *`, we cannot remove all functions,
    just issue `del math`. We have to remove those individual functions separately.
    The following two commands demonstrate such an effect:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们使用`from math import *`，我们不能通过`del math`来移除所有函数。必须单独移除这些函数。以下两个命令演示了这种效果：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For convenience, we could import only a few needed functions. To price a European
    call option, several functions are needed, such as `log()`, `exp()`, `sqrt()`
    and `cdf()`. `cdf()` is the function for cumulative standard normal distribution.
    To make those four functions available, we specify their names, as shown in the
    following lines of code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，我们可以只导入几个需要的函数。为了定价一个欧洲看涨期权，需要几个函数，比如`log()`、`exp()`、`sqrt()`和`cdf()`。`cdf()`是累积标准正态分布函数。为了使这四个函数可用，我们指定它们的名称，如下代码所示：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The complete codes for pricing Black-Scholes-Merton call options are given
    here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出了定价Black-Scholes-Merton看涨期权的完整代码：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'One example of calling the `bsCall` function is given here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出了调用`bsCall`函数的一个示例：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To find all available modules, a help window should be activated first. After
    that, issue modules. The result is shown here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找所有可用模块，首先应激活帮助窗口。之后，输入`modules`命令。结果如下所示：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If this is your first time using Python, you should definitely check out the
    tutorial on the internet at [http://docs.python.org/3.5/tutorial/](http://docs.python.org/3.5/tutorial/).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次使用Python，应该一定访问互联网上的教程：[http://docs.python.org/3.5/tutorial/](http://docs.python.org/3.5/tutorial/)。
- en: Enter the name of any module, keyword, or topic to get help on writing Python
    programs and using Python modules. To quit this help utility and return to the
    interpreter, just type `quit`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 输入任何模块、关键字或主题的名称，即可获得关于编写Python程序和使用Python模块的帮助。要退出该帮助工具并返回解释器，只需输入`quit`。
- en: 'To get a list of available modules, keywords, symbols, or topics, type `modules`,
    `keywords`, `symbols`, or `topics`. Each module also comes with a one-line summary
    of what it does; to list the modules whose name or summary contain a given string
    such as `spam`, type `modules spam`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取可用模块、关键字、符号或主题的列表，输入`modules`、`keywords`、`symbols`或`topics`。每个模块还附有一行总结其功能；要列出名称或总结包含给定字符串（如`spam`）的模块，输入`modules
    spam`：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we issue modules under the Python `help>` prompt as shown in the following
    screenshot (to save space, only the first part of it is shown):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在Python的`help>`提示符下输入`modules`，如下截图所示（为节省空间，这里仅展示了前部分）：
- en: '![What is a Python module?](img/B06175_02_01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![什么是Python模块？](img/B06175_02_01.jpg)'
- en: 'To find a specific module, we just type `modules` followed by the module''s
    name. Assume that we are interested in the module called `cmd`. Then, we issue
    `modules cmd` in the help window; see the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找特定模块，我们只需输入`modules`后跟模块名称。假设我们对名为`cmd`的模块感兴趣，那么我们在帮助窗口中输入`modules cmd`；请参见以下截图：
- en: '![What is a Python module?](img/B06175_02_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![什么是Python模块？](img/B06175_02_02.jpg)'
- en: 'To get more information on modules, navigate to **All Programs** | `Python
    3.5` | `Python 3.5 Module Docs`, as shown in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得更多有关模块的信息，请导航至**所有程序** | `Python 3.5` | `Python 3.5 Module Docs`，如下截图所示：
- en: '![What is a Python module?](img/B06175_02_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![什么是Python模块？](img/B06175_02_03.jpg)'
- en: After clicking `Python 3.5 Module Docs (32-bit)`, we will get more information.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`Python 3.5 Module Docs (32-bit)`后，我们将获得更多信息。
- en: Introduction to NumPy
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy简介
- en: 'In the following examples, the `np.size()` function from NumPy shows the number
    of data items of an array, and the `np.std()` function is used to calculate standard
    deviation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，NumPy中的`np.size()`函数显示了数组的数据项数量，`np.std()`函数用于计算标准差：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Compared with a Python array, a NumPy array is a contiguous piece of memory
    that is passed directly to LAPACK, which is a software library for numerical linear
    algebra under the hood, so that matrix manipulation is very fast in Python. An
    array in NumPy is like a matrix in MATLAB. Unlike lists in Python, an array should
    contain the same data type, as shown in the following line of code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python数组相比，NumPy数组是一个连续的内存块，直接传递给LAPACK，这是一个用于数值线性代数的底层软件库，因此在Python中矩阵操作非常快速。NumPy中的数组就像MATLAB中的矩阵。与Python中的列表不同，数组应该包含相同的数据类型，如下代码所示：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The real data type is `float64`, and the default for numerical values is also
    `float64`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实际数据类型是`float64`，数值的默认类型也是`float64`。
- en: 'In the preceding example, we could view that the `np.array()` function converts
    a list with the same data type, an integer in this case, to an array. To change
    the data type, it should be specified with the second input value, `dtype`, as
    shown in the following lines of code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到`np.array()`函数将一个相同数据类型的列表（此例中为整数）转换为数组。要更改数据类型，应使用第二个输入值`dtype`进行指定，如下代码所示：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the previous example, `dtype` is the keyword specifying the data type. For
    a list, different data types could coexist without causing any problems. However,
    when converting a list containing different data types into an array, an error
    message will appear, as shown in the following lines of code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，`dtype`是指定数据类型的关键字。对于列表，不同的数据类型可以共存而不会引发问题。然而，当将包含不同数据类型的列表转换为数组时，会出现错误信息，如以下代码所示：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To show all functions contained in Numpy, `dir(np)` is used after the Numpy
    module is imported.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示Numpy中包含的所有函数，在导入Numpy模块后使用`dir(np)`。
- en: 'The following shows the first few lines:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示的是前几行代码：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Actually, a better way is to generate an array containing all functions as
    follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，更好的方法是生成一个包含所有函数的数组，如下所示：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To show the functions from `200` to `250`, `x[200:250]` is typed; see the following
    code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示`200`到`250`的函数，可以输入`x[200:250]`；请参见以下代码：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It is easy to find out more information about a specific function. After issuing
    `dir(np)`, the `std()` function appears, among others. To seek more information
    about this function, `help(np.std)` is used. The following shows only a few lines
    of code for brevity:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 查找特定函数的更多信息非常简单。执行`dir(np)`后，`std()`函数等将会出现。要获取该函数的更多信息，可以使用`help(np.std)`。为了简洁起见，以下仅显示部分代码：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The function returns the standard deviation, a measure of the spread of a distribution,
    of the array elements. The standard deviation is computed for the flattened array
    by default, otherwise over the specified axis:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回标准差，它是衡量分布离散程度的指标，表示数组元素的标准差。默认情况下，标准差是针对展平后的数组计算的，或者根据指定的轴进行计算：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Introduction to SciPy
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SciPy简介
- en: The following are a few examples based on the functions enclosed in the SciPy
    module. The `sp.npv()` function estimates the present values for a given set of
    cash flows with the first cash flow happening at time zero. The first input value
    is the discount rate, and the second input is an array of all cash flows.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是几个基于SciPy模块中函数的示例。`sp.npv()`函数估算给定现金流的现值，第一个现金流发生在时间零。第一个输入值是贴现率，第二个输入值是所有现金流的数组。
- en: 'The following is one example. Note that the `sp.npv()` function is different
    from the Excel `npv()` function. We will explain why this is so in [Chapter 3](ch03.html
    "Chapter 3. Time Value of Money"), *Time Value of Money*:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例。请注意，`sp.npv()`函数与Excel中的`npv()`函数不同。我们将在[第3章](ch03.html "第3章. 货币的时间价值")中详细解释原因，*货币的时间价值*：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `sp.pmt()` function is used to answer the following question.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`sp.pmt()`函数用于解答以下问题。'
- en: 'What is the monthly cash flow to pay off a mortgage of $250,000 over 30 years
    with an annual percentage rate (APR) of 4.5 percent, compounded monthly? The following
    code shows the answer:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每月现金流是多少，用于偿还一笔$250,000的抵押贷款，贷款期为30年，年利率（APR）为4.5%，按月复利？以下代码显示了答案：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Based on the preceding result, the monthly payment will be $1,266.71\. It might
    be quite strange that we have a negative value. Actually, this `sp.pmt()` function
    mimics the equivalent function in Excel, as we will see in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面的结果，每月支付金额为$1,266.71。出现负值可能让人感到奇怪。实际上，`sp.pmt()`函数模拟了Excel中的等效函数，正如我们在以下截图中看到的那样：
- en: '![Introduction to SciPy](img/B06175_02_04.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![SciPy简介](img/B06175_02_04.jpg)'
- en: 'The input values are: the effective period rate, the number of the period,
    and the present value. By the way, the number in a pair of parentheses means a
    negative one.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 输入值包括：有效期利率、期数和现值。顺便提一下，括号中的数字表示负数。
- en: At the moment, just ignore the negative sign. In [Chapter 3](ch03.html "Chapter 3. Time
    Value of Money"), *Time Value of Money*, this so-called Excel convention will
    be discussed in more detail.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，暂时忽略负号。在[第3章](ch03.html "第3章. 货币的时间价值")，*货币的时间价值*中，将更详细讨论这一所谓的Excel约定。
- en: 'Similarly, the `sp.pv()` function replicates the Excel `PV()` function. For
    the `sp.pv()` function, its input format is `sp.pv(rate, nper, pmt, fv=0.0, when=''end'')`,
    where `rate` is the discount rate, `nper` is the number of periods, `pmt` is the
    period payment, and `fv` is the future value with a default value of zero. The
    last input variable specifies whether the cash flows are at the end of each time
    period or at the beginning of each period. By default, it is at the end of each
    period. The following commands show how to call this function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`sp.pv()` 函数复制了 Excel 的 `PV()` 函数。对于 `sp.pv()` 函数，其输入格式为 `sp.pv(rate, nper,
    pmt, fv=0.0, when='end')`，其中 `rate` 是折现率，`nper` 是期数，`pmt` 是期支付额，`fv` 是未来值，默认为零。最后一个输入变量指定现金流是在每个时间段的末尾还是开始时进行。默认为每期末尾。以下命令演示了如何调用此函数：
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `sp.fv()` function has a setting similar to that of `sp.pv()`. In finance,
    we estimate both arithmetic and geometric means, which are defined in the following
    formulas.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`sp.fv()` 函数的设置类似于 `sp.pv()`。在金融领域，我们估算算术平均值和几何平均值，定义在以下公式中。'
- en: 'For *n* numbers of *x*, that is, *x1*, *x2*, *x3*, and *xn*, we have the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *n* 个 *x* 数字，即 *x1*、*x2*、*x3* 和 *xn*，我们有以下公式：
- en: '![Introduction to SciPy](img/B06175_02_05.jpg)![Introduction to SciPy](img/B06175_02_06.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![SciPy介绍](img/B06175_02_05.jpg)![SciPy介绍](img/B06175_02_06.jpg)'
- en: 'Here, ![Introduction to SciPy](img/B06175_02_26.jpg) and ![Introduction to
    SciPy](img/B06175_02_27.jpg). Assume that we have three numbers of *a*, *b*, and
    *c*. Then their arithmetic mean is *(a+b+c)/3*, while their geometric mean is
    *(a*b*c)^(1/3)*. For three values of `2`, `3`, and `4`, we have the following
    two means:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![SciPy介绍](img/B06175_02_26.jpg) 和 ![SciPy介绍](img/B06175_02_27.jpg)。假设我们有三个数字
    *a*、*b* 和 *c*，那么它们的算术平均值是 *(a+b+c)/3*，而它们的几何平均值是 *(a*b*c)^(1/3)*。对于 `2`、`3` 和
    `4` 三个值，我们得到以下两种均值：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If *n* returns are given, the formula to estimate their arithmetic mean remains
    the same. However, the geometric mean formula for returns is different, as shown
    here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定 *n* 个回报，估算其算术平均值的公式保持不变。然而，回报的几何平均值公式不同，如下所示：
- en: '![Introduction to SciPy](img/B06175_02_07.jpg)![Introduction to SciPy](img/B06175_02_08.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![SciPy介绍](img/B06175_02_07.jpg)![SciPy介绍](img/B06175_02_08.jpg)'
- en: 'To estimate a geometric mean, the `sp.prod()` function would be applied. The
    function gives us the products of all data items; see the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要估算几何平均值，可以使用 `sp.prod()` 函数。该函数为我们提供所有数据项的乘积；请参见以下代码：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Actually, a simple Python function could be written with just two lines to
    calculate a geometric mean for a set of given returns; see the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，可以通过仅写两行简单的 Python 函数来计算一组给定回报的几何平均值；请参见以下代码：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It is easy to call the preceding function; see the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 调用前面的函数非常简单；请参见以下代码：
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Two other useful functions are `sp.unique()` and `sp.median()`, as shown in
    the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个有用的函数是 `sp.unique()` 和 `sp.median()`，如以下代码所示：
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Python''s `sp.pv()`, `sp.fv()`, and `sp.pmt()` functions behave like Excel''s
    `pv()`, `fv()`, and `pmt()` functions, respectively. They have the same sign convention:
    the sign of the present value is the opposite of the future value.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `sp.pv()`、`sp.fv()` 和 `sp.pmt()` 函数分别与 Excel 的 `pv()`、`fv()` 和 `pmt()`
    函数行为相似。它们具有相同的符号约定：现值的符号与未来值相反。
- en: 'In the following example, to estimate a present value if we enter a positive
    future value, we will end up with a negative present value:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，假设我们输入一个正的未来值来估算现值，最终会得到一个负的现值：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are several ways to find out all the functions contained in the SciPy
    module.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以查找 SciPy 模块中包含的所有函数。
- en: 'Firstly, we can read related manuals. Secondly, we can issue the following
    lines of code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以阅读相关手册。其次，我们可以发出以下代码行：
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To save space, only a few lines of the output are shown in the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，以下代码仅显示部分输出：
- en: '[PRE36]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Similarly, we could save all the functions to a vector (array); see the following
    code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以将所有函数保存到一个向量（数组）中；请参见以下代码：
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Introduction to matplotlib
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: matplotlib 介绍
- en: Graphs and other visual representations have become more important in explaining
    many complex financial concepts, trading strategies, and formulas.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图表和其他可视化表示在解释许多复杂的金融概念、交易策略和公式中变得更加重要。
- en: In this section, we discuss the `matplotlib` module, which is used to create
    various types of graphs. In addition, the module will be used intensively in [Chapter
    10](ch10.html "Chapter 10. Options and Futures"), *Options and Futures*, when
    we discuss the famous Black-Scholes-Merton option model and various trading strategies.
    The `matplotlib` module is designed to produce publication-quality figures and
    graphs. The `matplotlib` module depends on NumPy and SciPy, which were discussed
    in the previous sections. To save generated graphs, there are several output formats
    available, such as PDF, Postscript, SVG, and PNG.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们讨论了 `matplotlib` 模块，它用于创建各种类型的图形。此外，模块将在 [第10章](ch10.html "第10章：期权与期货")，*期权与期货*
    中得到广泛应用，当时我们将讨论著名的 Black-Scholes-Merton 期权模型以及各种交易策略。`matplotlib` 模块旨在生成出版质量的图形和图表。`matplotlib`
    模块依赖于 NumPy 和 SciPy，这些在前面的章节中已经讨论过。为了保存生成的图形，有多种输出格式可供选择，如 PDF、Postscript、SVG
    和 PNG。
- en: How to install matplotlib
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何安装 matplotlib
- en: 'If Python was installed by using the Anaconda super package, then `matplotlib`
    is preinstalled already. After launching Spyder, type the following line to test.
    If there is no error, it means that we have imported/uploaded the module successfully.
    This is the beauty of using a super package such as Anaconda:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Python 是通过 Anaconda 超级包安装的，那么 `matplotlib` 已经预先安装好了。启动 Spyder 后，输入以下命令进行测试。如果没有错误，说明我们已经成功导入/上传了该模块。这就是使用像
    Anaconda 这样超级包的好处：
- en: '[PRE38]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To install the `matplotlib` module or other modules independently, see the *Module
    dependency – how to install a module* section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 若要单独安装 `matplotlib` 模块或其他模块，请参见 *模块依赖 - 如何安装模块* 部分。
- en: Several graphical presentations using matplotlib
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 matplotlib 的几种图形展示
- en: The best way to understand the usage of the `matplotlib` module is through examples.
    The following example could be the simplest one since it has just three lines
    of Python code. The objective is to link several points. By default, the `matplotlib`
    module assumes that the *x* axis starts at zero and moves by one on every element
    of the array.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 `matplotlib` 模块的最佳方式是通过示例。以下示例可能是最简单的，因为它仅包含三行 Python 代码。目标是连接几个点。默认情况下，`matplotlib`
    模块假设 *x* 轴从零开始，并且数组的每个元素增加 1。
- en: 'The following screenshot of command lines illustrates this situation:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令行截图说明了这一情况：
- en: '![Several graphical presentations using matplotlib](img/B06175_02_09.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![使用 matplotlib 的几种图形展示](img/B06175_02_09.jpg)'
- en: After typing the last command of `show()` and hitting the *Enter* key, the above-right
    graph will appear. At the top of the graph, a set of icons (functions) are available.
    By clicking them, we could adjust our image or save our image. After closing the
    preceding figure, we could return to the Python prompt. On the other hand, if
    we issue `show()` a second time, nothing will happen. To show the preceding graph
    again, we have to issue both `plot([1,2,3,9])` and `show()`. Two labels could
    be added for both the *x* axis and *y* axis as follows.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入最后一个命令 `show()` 并按下 *Enter* 键后，上图右侧的图形将出现。在图形顶部，有一组图标（功能）可供选择。点击它们，我们可以调整图像或保存图像。关闭上述图形后，我们可以返回到
    Python 提示符。另一方面，如果我们第二次输入 `show()`，则什么也不会发生。要重新显示上面的图形，我们必须同时输入 `plot([1,2,3,9])`
    和 `show()`。可以为 *x* 轴和 *y* 轴添加两个标签，如下所示。
- en: 'The corresponding graph is shown in the following screenshot on the right:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的图形显示在右侧的以下截图中：
- en: '![Several graphical presentations using matplotlib](img/B06175_02_10.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![使用 matplotlib 的几种图形展示](img/B06175_02_10.jpg)'
- en: 'The next example presents two cosine functions:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子展示了两个余弦函数：
- en: '![Several graphical presentations using matplotlib](img/B06175_02_11.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![使用 matplotlib 的几种图形展示](img/B06175_02_11.jpg)'
- en: 'In the preceding code, the `linspace()` function has four input values: `start`,
    `stop`, `num`, and `endpoint`. In the preceding example, we will start from *-3.1415916*
    and stop at *3.1415926*, with *256* values between. In addition, the endpoints
    will be included. By the way, the default value of `num` is *50*. The following
    example shows the scatter pattern. First, the `np.random.normal()` function is
    used to generate two sets of random numbers. Since `n` is `1024`, we have 1,024
    observations for both `X` and `Y` variables. The key function is `scatter(X,Y)`,
    as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`linspace()` 函数有四个输入值：`start`、`stop`、`num` 和 `endpoint`。在前面的示例中，我们将从
    *-3.1415916* 开始，到 *3.1415926* 结束，中间有 *256* 个值。此外，端点将被包括在内。顺便提一下，`num` 的默认值是 *50*。以下示例显示了散点图。首先，使用
    `np.random.normal()` 函数生成两组随机数。由于 `n` 为 `1024`，所以 `X` 和 `Y` 变量都有 1,024 个观测值。关键函数是
    `scatter(X,Y)`，如下所示：
- en: '![Several graphical presentations using matplotlib](img/B06175_02_12.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![使用 matplotlib 的多种图形展示](img/B06175_02_12.jpg)'
- en: 'Here is a more complex graph showing the stock movement. Let''s look at the
    code first:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更复杂的图，展示了股票的波动。我们先看看代码：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The corresponding graph is shown here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的图表如下所示：
- en: '![Several graphical presentations using matplotlib](img/B06175_02_13.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![使用 matplotlib 的多种图形展示](img/B06175_02_13.jpg)'
- en: Introduction to statsmodels
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 statsmodels
- en: '`statsmodels` is a powerful Python package for many types of statistical analysis.
    Again, if Python was installed via Anaconda, then the module was installed at
    the same time. In statistics, **ordinary least square** (**OLS**) regression is
    a method for estimating the unknown parameters in a linear regression model. It
    minimizes the sum of squared vertical distances between the observed values and
    the values predicted by the linear approximation. The OLS method is used extensively
    in finance. Assume that we have the following equation, where *y* is an *n* by
    *1* vector (array), and *x* is an *n* by *(m+1)* matrix, a return matrix (*n*
    by *m*), plus a vector that contains *1* only. *n* is the number of observations,
    and *m* is the number of independent variables:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`statsmodels` 是一个强大的 Python 包，适用于多种类型的统计分析。同样，如果通过 Anaconda 安装了 Python，那么该模块也会随之安装。在统计学中，**普通最小二乘法**
    (**OLS**) 回归是一种估计线性回归模型中未知参数的方法。它通过最小化观测值与线性近似预测值之间的垂直距离的平方和来进行优化。OLS 方法在金融领域被广泛使用。假设我们有如下方程，其中
    *y* 是一个 *n* 行 *1* 列的向量（数组），*x* 是一个 *n* 行 *(m+1)* 列的矩阵，表示回报矩阵（*n* 行 *m* 列），加上一个仅包含
    *1* 的向量。*n* 是观测值的数量，*m* 是独立变量的数量：'
- en: '![Introduction to statsmodels](img/B06175_02_14.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![statsmodels 介绍](img/B06175_02_14.jpg)'
- en: 'In the following program, after generating the `x` and `y` vectors, we run
    an OLS regression (a linear regression). The `x` and `y` are artificial data.
    The last line prints the parameters only (the intercept is `1.28571420` and the
    slope is `0.35714286`):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下程序中，生成 `x` 和 `y` 向量后，我们运行一个 OLS 回归（线性回归）。`x` 和 `y` 是人工数据。最后一行只打印参数（截距为 `1.28571420`，斜率为
    `0.35714286`）：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To find out more information about this module, the `dir()` function could
    be used:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解有关此模块的更多信息，可以使用 `dir()` 函数：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For various submodules, `dir()` could be used as well; see the example shown
    here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于各种子模块，也可以使用 `dir()`；请参见这里的示例：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'From the preceding output, it can be seen that 16 functions start with the
    word `read`; see the following table:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出可以看出，有 16 个函数以 `read` 开头；请参见下表：
- en: '| Name | Description |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `read_clipboard` | Input data from a clipboard |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `read_clipboard` | 从剪贴板输入数据 |'
- en: '| `read_csv` | Input data from a csv (comma separated value) |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `read_csv` | 从 CSV（逗号分隔值）输入数据 |'
- en: '| `read_excel` | Input data from an Excel file |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `read_excel` | 从 Excel 文件输入数据 |'
- en: '| `read_fwf` | Input data with a fixed width |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `read_fwf` | 输入定宽数据 |'
- en: '| `read_gbq` | Load data from Google BigQuery |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `read_gbq` | 从 Google BigQuery 加载数据 |'
- en: '| `read_hdf` | Read HDF5 format data |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `read_hdf` | 读取 HDF5 格式的数据 |'
- en: '| `read_html` | Input data from a web page |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `read_html` | 从网页输入数据 |'
- en: '| `read_json` | Read JSON (JavaScript Object Notation) data |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `read_json` | 读取 JSON（JavaScript 对象表示法）数据 |'
- en: '| `read_msgpack` | MessagePack is a fast, compact binary serialization format,
    suitable for similar data to JSON |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `read_msgpack` | MessagePack 是一种快速、紧凑的二进制序列化格式，适用于类似 JSON 的数据 |'
- en: '| `read_pickle` | Input a Python dataset called pickle |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `read_pickle` | 输入一个 Python 数据集，称为 pickle |'
- en: '| `read_sas` | Input data from a SAS dataset |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `read_sas` | 从 SAS 数据集输入数据 |'
- en: '| `read_sql` | Input data from SQL database |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `read_sql` | 从 SQL 数据库输入数据 |'
- en: '| `read_sql_query` | Input data from a query |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `read_sql_query` | 从查询中输入数据 |'
- en: '| `read_sql_table` | Read SQL database table into a DataFrame |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `read_sql_table` | 将SQL数据库表读入DataFrame |'
- en: '| `read_stata` | Input data from a Stata dataset |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `read_stata` | 从Stata数据集输入数据 |'
- en: '| `read_table` | Input data from a text file |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `read_table` | 从文本文件输入数据 |'
- en: Table 2.1 A list of functions used to input data
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表2.1 输入数据所用的函数列表
- en: Introduction to pandas
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pandas简介
- en: 'The `pandas` module is a powerful tool used to process various types of data,
    including economics, financial, and accounting data. If Python was installed on
    your machine via Anaconda, then the `pandas` module was installed already. If
    you issue the following command without any error, it indicates that the `pandas`
    module was installed:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas`模块是一个强大的工具，用于处理各种类型的数据，包括经济、金融和会计数据。如果你通过Anaconda在你的机器上安装了Python，那么`pandas`模块已经安装好了。如果你执行以下命令且没有错误提示，则说明`pandas`模块已经安装：'
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the following example, we generate two time series starting from January
    1, 2013\. The names of those two time series (columns) are `A` and `B`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们生成了两个从2013年1月1日开始的时间序列。这两列时间序列的名称分别是`A`和`B`：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'First, we import both NumPy and `pandas` modules. The `pd.date_range()` function
    is used to generate an index array. The `x` variable is a pandas DataFrame with
    dates as its index. Later in this chapter, we will discuss the `pd.DataFrame()`
    function. The `columns()` function defines the names of those columns. Because
    the `seed()` function is used in the program, anyone can generate the same random
    values. The `describe()` function offers the properties of those two columns,
    such as mean and standard deviation. Again, we call such a function, as shown
    in the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入了NumPy和`pandas`模块。`pd.date_range()`函数用于生成索引数组。`x`变量是一个以日期为索引的pandas DataFrame。稍后我们将在本章中讨论`pd.DataFrame()`函数。`columns()`函数定义了列的名称。由于程序中使用了`seed()`函数，任何人都可以生成相同的随机值。`describe()`函数提供了这两列的属性，例如均值和标准差。再次调用这样的函数，如下所示：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To show all functions contained in the `pandas` module, the command of `dir(pd)`
    is used after importing the module; see the following code and the corresponding
    output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示`pandas`模块中包含的所有函数，在导入该模块后，使用`dir(pd)`命令；请参见以下代码及相应的输出：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If going through the preceding list carefully, we will see the same functions
    starting with `read_`, shown in Table 2.1, as those contained in the `statsmodels`
    module. This type of duplication makes our program job a little bit easier. Assume
    that we plan to replace missing values (`NaN`) with the mean of the time series.
    The two functions used are `mean()` and `fillna()`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看前面的列表，我们会看到与`statsmodels`模块中包含的相同函数，它们以`read_`开头，如表2.1所示。这种重复使我们的程序工作变得稍微简单一点。假设我们计划用时间序列的均值替换缺失值（`NaN`）。这时使用的两个函数是`mean()`和`fillna()`：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'From the output on the right-hand side, the fourth observation of `NaN` is
    replaced with a mean of 1.75\. In the following code, we generate a DataFrame
    by using the `dataFrame()` function contained in the `pandas` module:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从右侧的输出中可以看到，第四个观察值`NaN`被替换为均值1.75。在以下代码中，我们通过使用`pandas`模块中包含的`dataFrame()`函数生成了一个DataFrame：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Since, in the program, the `numpy.random.seed()` function is used, different
    users will get the same random numbers:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序中使用了`numpy.random.seed()`函数，不同的用户将得到相同的随机数：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'At the moment, readers might be confused why we would get the same random values
    while trying to get a set of random numbers. This topic will be discussed and
    explained in more detail in [Chapter 12](ch12.html "Chapter 12. Monte Carlo Simulation"),
    *Monte Carlo Simulation*. In the following code, how to use different ways to
    interpolate is presented:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，读者可能会感到困惑，为什么在尝试获取一组随机数时，我们会得到相同的随机值。这个问题将在[第12章](ch12.html "第12章. 蒙特卡洛模拟")，*蒙特卡洛模拟*中进行更详细的讨论和解释。在以下代码中，展示了如何使用不同的方法进行插值：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The corresponding graph is shown in the following screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的图表如下截图所示：
- en: '![Introduction to pandas](img/B06175_02_15.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![pandas简介](img/B06175_02_15.jpg)'
- en: Usually, different languages have their own types of datasets.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，不同的编程语言有各自的类型数据集。
- en: For example, SAS has its datasets with an extension of `.sas7bdat`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，SAS有自己的数据集，其扩展名为`.sas7bdat`。
- en: 'For R, its extensions could be .`RData`, `.rda`, or `.rds`. This is true for
    Python to have its own datasets. One type of dataset is with an extension of `.pickle`
    or `.pkl`. Let''s generate a pickle dataset; see the following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于R，其扩展名可能是`.RData`、`.rda`或`.rds`。Python也有自己的数据集格式。一种数据集类型的扩展名是`.pickle`或`.pkl`。让我们生成一个pickle数据集；请查看以下代码：
- en: '[PRE51]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The last command saves the variable to a pickle dataset called `test.pkl` under
    the current working directory. To save the pickle dataset to a file under a specific
    address, that is, an absolute address, we have the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条命令将变量保存为一个名为`test.pkl`的pickle数据集，保存在当前工作目录下。要将pickle数据集保存到特定地址的文件中，即绝对路径，我们有以下代码：
- en: '[PRE52]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To read a pickle dataset, the `pd.read_pickle()` function is used:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取pickle数据集，使用`pd.read_pickle()`函数：
- en: '[PRE53]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Merging two different sets is one of the common procedures researchers are
    routinely doing. The objective of the following program is to merge two datasets
    based on their common variable called `key`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 合并两个不同的数据集是研究人员常做的常见操作。以下程序的目的是根据它们的公共变量`key`合并两个数据集：
- en: '[PRE54]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The initial values for `x` and `y`, plus the merged dataset, called `z`, are
    shown in the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`x`和`y`的初始值，以及合并后的数据集`z`：
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For finance, time series occupy a unique position since many datasets are in
    the form of time series, such as stock prices and returns. Thus, knowing how to
    define a `date` variable and study related functions is essential for processing
    economics, financial, and accounting data. Let''s look at a few examples:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于金融领域，时间序列占据了独特的地位，因为许多数据集是以时间序列的形式存在的，例如股价和回报。因此，了解如何定义`date`变量并研究相关函数，对于处理经济、金融和会计数据至关重要。我们来看一些例子：
- en: '[PRE56]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The difference between two dates can be easily estimated; see the following
    code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 两个日期之间的差异可以轻松估算；请查看以下代码：
- en: '[PRE57]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'From the `pandas` module, one submodule called `datetools` is quite useful;
    see the list of functions contained in it:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`pandas`模块的一个子模块`datetools`非常有用；请查看其中包含的函数列表：
- en: '[PRE58]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here is one example to use the `weekday()` function contained in the `pandas`
    module. This function will be essential when tests are conducted to test the so-called
    Weekday-Effect. This test will be explained in detail in [Chapter 4](ch04.html
    "Chapter 4. Sources of Data"), *Sources of Data*. So let''s see the following
    code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`pandas`模块中`weekday()`函数的例子。该函数在进行所谓的周效应测试时非常重要。该测试将在[第4章](ch04.html "Chapter
    4. Sources of Data") *数据来源*中详细解释。让我们来看一下以下代码：
- en: '[PRE59]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Under certain situations, users might want to stack data together or the other
    way around; see the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，用户可能希望将数据堆叠在一起或反过来；请查看以下代码：
- en: '[PRE60]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The comparison of the original dataset and the stacked datasets is given here.
    The left-hand side is the original dataset:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据集与堆叠数据集的比较如下。左侧是原始数据集：
- en: '[PRE61]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The opposite operation of stock is to apply the `unstack()` function; see the
    following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 股票的反操作是应用`unstack()`函数；请查看以下代码：
- en: '[PRE62]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This operation could be applied to generate a return matrix if the input dataset
    is sorted by stock ID and date, that is, a dataset viewed as stacked one stock
    after another.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入数据集按股票ID和日期排序，即视为按顺序堆叠每只股票，那么此操作可以用于生成回报矩阵。
- en: Python modules related to finance
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与金融相关的Python模块
- en: Since this book is applying Python to finance, the modules (packages) related
    to finance will be our first priority.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书是将Python应用于金融领域，因此与金融相关的模块（包）将是我们的首要任务。
- en: 'The following table presents about a dozen Python modules or submodules related
    to finance:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了约十个与金融相关的Python模块或子模块：
- en: '| Name | Description |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Numpy.lib.financial` | Many functions for corporate finance and financial
    management. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `Numpy.lib.financial` | 提供许多公司财务和财务管理相关的函数。 |'
- en: '| `pandas_datareader` | Retrieves data from Google, Yahoo! Finance, FRED, Fama-French
    factors. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `pandas_datareader` | 从Google、Yahoo! Finance、FRED、Fama-French因子获取数据。 |'
- en: '| `googlefinance` | Python module to get real-time (no delay) stock data from
    Google Finance API. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `googlefinance` | Python模块，用于通过Google Finance API获取实时（无延迟）股票数据。 |'
- en: '| `yahoo-finance` | Python module to get stock data from Yahoo! Finance. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `yahoo-finance` | Python模块，用于从Yahoo! Finance获取股票数据。 |'
- en: '| `Python_finance` | Download and analyze Yahoo! Finance data and develop trading
    strategies. |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `Python_finance` | 下载并分析Yahoo! Finance数据，并开发交易策略。 |'
- en: '| `tstockquote` | Retrieves stock quote data from Yahoo! Finance. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `tstockquote` | 从Yahoo! Finance获取股票报价数据。 |'
- en: '| `finance` | Financial risk calculations. Optimized for ease of use through
    class construction and operator overload. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `finance` | 财务风险计算。通过类构造和运算符重载优化，便于使用。 |'
- en: '| `quant` | Enterprise architecture for quantitative analysis in finance. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `quant` | 用于财务定量分析的企业架构。 |'
- en: '| `tradingmachine` | A backtester for financial algorithms. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `tradingmachine` | 一个用于金融算法回测的工具。 |'
- en: '| `economics` | Functions and data manipulation for economics data. Check the
    following link for better understanding:[https://github.com/tryggvib/economics](https://github.com/tryggvib/economics).
    |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `economics` | 经济数据的函数和数据处理。有关更好理解，请访问以下链接：[https://github.com/tryggvib/economics](https://github.com/tryggvib/economics)。
    |'
- en: '| `FinDates` | Deals with dates in finance. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `FinDates` | 处理财务中的日期。 |'
- en: Table 2.2 A list of modules or submodules related to finance
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表2.2 与财务相关的模块或子模块列表
- en: 'To find out more information about economics, finance or accounting, go to
    the following web pages:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解更多关于经济学、财务或会计的信息，请访问以下网页：
- en: '| Name | Location |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 位置 |'
- en: '| --- | --- |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Python Module Index (v3.5) | [https://docs.python.org/3/py-modindex.html](https://docs.python.org/3/py-modindex.html)
    |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| Python模块索引（v3.5） | [https://docs.python.org/3/py-modindex.html](https://docs.python.org/3/py-modindex.html)
    |'
- en: '| PyPI – the Python Package Index | [https://pypi.python.org/pypi](https://pypi.python.org/pypi)
    |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| PyPI – Python包索引 | [https://pypi.python.org/pypi](https://pypi.python.org/pypi)
    |'
- en: '| Python Module Index (v2.7) | [https://docs.python.org/2/py-modindex.html](https://docs.python.org/2/py-modindex.html)
    |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| Python模块索引（v2.7） | [https://docs.python.org/2/py-modindex.html](https://docs.python.org/2/py-modindex.html)
    |'
- en: Table 2.3 Websites related to Python modules (packages)
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表2.3 与Python模块（包）相关的网站
- en: Introduction to the pandas_reader module
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pandas_reader模块介绍
- en: Via this module, users can download various economics and financial via Yahoo!
    Finance, Google Finance, **Federal Reserve Economics Data** (**FRED**), and Fama-French
    factors.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过该模块，用户可以从Yahoo! Finance、Google Finance、**联邦储备经济数据**（**FRED**）和Fama-French因子下载各种经济和财务数据。
- en: 'Assume that the `pandas_reader` module is installed. For detail on how to install
    this module, see the *How to install a Python module* section. First, let''s look
    at the simplest example, just two lines to get IBM''s trading data; see the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 假设已安装`pandas_reader`模块。有关如何安装此模块的详细信息，请参阅*如何安装Python模块*部分。首先，让我们看一个最简单的例子，只需两行代码即可获取IBM的交易数据；请见下文：
- en: '[PRE63]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We could use a dot head and dot tail to show part of the results; see the following
    code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用点头和点尾显示部分结果；请见以下代码：
- en: '[PRE64]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This module will be explained again in more detail in [Chapter 4](ch04.html
    "Chapter 4. Sources of Data"), *Sources of Data*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 本模块将在[第四章](ch04.html "第4章 数据来源")，*数据来源*中再次进行更详细的解释。
- en: Two financial calculators
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两个财务计算器
- en: In the next chapter, many basic financial concepts and formulas will be introduced
    and discussed. Usually, when taking corporate finance or financial management,
    students rely on either Excel or a financial calculator to conduct their estimations.
    Since Python is the computational tool, a financial calculator written in Python
    would definitely enhance our understanding of both finance and Python.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，将介绍并讨论许多基本的财务概念和公式。通常，在学习企业财务或财务管理时，学生依赖Excel或财务计算器来进行估算。由于Python是计算工具，因此用Python编写的财务计算器无疑将加深我们对财务和Python的理解。
- en: 'Here is the first financial calculator, written in Python, from `Numpy.lib.financial`;
    see the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个用Python编写的财务计算器，来自`Numpy.lib.financial`；请见以下代码：
- en: '[PRE65]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The functions that will be used and discussed in [Chapter 3](ch03.html "Chapter 3. Time
    Value of Money"), *Time Value of Money*, include `fv()`, `irr()`, `nper()`, `npv()`,
    `pmt()`, `pv()`, and `rate()`. One example of using `pv()` is shown in the following
    code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三章](ch03.html "第3章 时间价值")，*时间价值*中将使用并讨论的函数包括`fv()`、`irr()`、`nper()`、`npv()`、`pmt()`、`pv()`和`rate()`。以下代码展示了使用`pv()`的一个示例：
- en: '[PRE66]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The second financial calculator is supplied by the author. There are many advantages
    of using this second financial calculator. First, all its functions possess the
    same format of the formulas from textbooks.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个财务计算器由作者提供。使用这个第二个财务计算器有许多优点。首先，所有功能都采用与教科书中公式相同的格式。
- en: In other words, there is no Excel sign convention.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这里没有Excel的符号约定。
- en: 'For example, the `pv_f()` function will depend on the following formula:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`pv_f()`函数将依赖于以下公式：
- en: '![Two financial calculators](img/B06175_02_16.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![两个财务计算器](img/B06175_02_16.jpg)'
- en: 'The function called `pvAnnuity()` is based on the following formula:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 名为`pvAnnuity()`的函数基于以下公式：
- en: '![Two financial calculators](img/B06175_02_17.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![两个金融计算器](img/B06175_02_17.jpg)'
- en: Second, the formula of estimating the present value of one future cash flow
    is separated from the formula to estimate the present value of an annuity. This
    would help students, especially beginners, avoid unnecessary confusions.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，估算一个未来现金流的现值的公式与估算年金现值的公式是分开的。这将帮助学生，特别是初学者，避免不必要的困惑。
- en: For a comparison, the `numpy.lib.financial.pv()` function actually combines
    both equations (6) and (7). We will discuss this in more detail in [Chapter 3](ch03.html
    "Chapter 3. Time Value of Money"), *Time Value of Money*. Third, for each function,
    many examples are offered. It means users spend less time trying to figure out
    the meaning of individual functions. Fourth, this second financial calculator
    offers more functions than the `numpy.lib.financial` submodule can offer. Last
    but not least, users eventually learn to how to write their own financial calculator
    in Python. For more detail, see the last section in [Chapter 3](ch03.html "Chapter 3. Time
    Value of Money"), *Time Value of Money*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行对比，`numpy.lib.financial.pv()`函数实际上结合了公式（6）和（7）。我们将在[第3章](ch03.html "第3章.
    货币的时间价值")，*货币的时间价值*中详细讨论这一点。第三，对于每个函数，提供了许多示例。这意味着用户花费更少的时间去理解各个函数的含义。第四，这个第二个金融计算器提供的功能比`numpy.lib.financial`子模块能提供的更多。最后但同样重要的是，用户最终会学会如何用Python编写自己的金融计算器。更多细节，请参见[第3章](ch03.html
    "第3章. 货币的时间价值")，*货币的时间价值*中的最后一节。
- en: 'To use such a financial calculator, users should download a file called `fincal.cpython-35.syc`
    at the author''s website ([http://canisius.edu/~yany/fincal.cpython-35.pyc](http://canisius.edu/~yany/fincal.cpython-35.pyc)).
    Assume that the executable file is saved under `c:/temp/`. To add `c:/temp/` to
    the Python path, click the rightmost Python logo on the menu bar; see the following
    screenshot:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这样的金融计算器，用户应从作者的网站下载名为`fincal.cpython-35.syc`的文件（[http://canisius.edu/~yany/fincal.cpython-35.pyc](http://canisius.edu/~yany/fincal.cpython-35.pyc)）。假设可执行文件已保存在`c:/temp/`目录下。要将`c:/temp/`添加到Python路径中，请点击菜单栏最右侧的Python徽标；请参见下图：
- en: '![Two financial calculators](img/B06175_02_18.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![两个金融计算器](img/B06175_02_18.jpg)'
- en: 'After clicking the logo shown in the preceding screenshot, users will see the
    screen shown on the left in the following screenshot:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 点击前面截图中所示的徽标后，用户将看到以下截图中左侧的屏幕：
- en: '![Two financial calculators](img/B06175_02_19.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![两个金融计算器](img/B06175_02_19.jpg)'
- en: 'After clicking **Add path**, type `c:/temp/`; see the screen shown on the right
    in the preceding screenshot. Now, we could use `import fincal` to use all functions
    contained inside the module. In [Chapter 3](ch03.html "Chapter 3. Time Value of
    Money"), *Time Value of Money*, we show how to produce such a `fincal` module:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**添加路径**后，输入`c:/temp/`；请参见前面截图中右侧的屏幕。现在，我们可以使用`import fincal`来使用模块中的所有函数。在[第3章](ch03.html
    "第3章. 货币的时间价值")，*货币的时间价值*中，我们展示了如何生成这样的`fincal`模块：
- en: '[PRE67]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To find the usage of each function, use the `help()` function; see the following
    example:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找每个函数的用法，请使用`help()`函数；请参见以下示例：
- en: '[PRE68]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: From the preceding information, users know the objective of the function, the
    definitions of three input values, the formula used, plus a few examples.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的信息中，用户可以知道该函数的目标、三个输入值的定义、使用的公式以及一些示例。
- en: How to install a Python module
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何安装Python模块
- en: If Python was installed via Anaconda, there is a good chance that many of the
    modules discussed in this book have been installed together with Python. If Python
    was installed independently, users could use PyPi to install or update.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Python是通过Anaconda安装的，那么很可能本书中讨论的许多模块已经随着Python一起安装。如果Python是独立安装的，用户可以使用PyPi来安装或更新。
- en: 'For example, we are interested in installing NumPy. On Windows, we have the
    following code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们对安装NumPy感兴趣。在Windows上，我们使用以下代码：
- en: '[PRE69]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If `Python.exe` is on the path, we could open a DOS window first, then issue
    the preceding line. If `Python.exe` is not on the path, we open a DOS window,
    then move to the location of the `Python.exe` file; for an example, see the following
    screenshot:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Python.exe`在路径中，我们可以先打开一个DOS窗口，然后输入前述命令。如果`Python.exe`不在路径中，我们需要打开一个DOS窗口，然后移动到`Python.exe`文件的位置；例如，见下图：
- en: '![How to install a Python module](img/B06175_02_20.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![如何安装Python模块](img/B06175_02_20.jpg)'
- en: 'For a Mac, we have the following codes. Sometimes, after running the preceding
    command, you might receive the following message asking for an update of PiP:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Mac，我们有以下代码。有时，在运行前述命令后，你可能会收到以下信息，提示更新 PiP：
- en: '![How to install a Python module](img/B06175_02_21.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![如何安装 Python 模块](img/B06175_02_21.jpg)'
- en: 'The command line to update `pip` is given here:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出了更新 `pip` 的命令行：
- en: '[PRE70]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'See the result shown in the following screenshot:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见以下截图显示的结果：
- en: '![How to install a Python module](img/B06175_02_22.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![如何安装 Python 模块](img/B06175_02_22.jpg)'
- en: 'To install NumPy independently, on Linux or OS X, we issue the following command:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要独立安装 NumPy，在 Linux 或 OS X 上，我们执行以下命令：
- en: '[PRE71]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To install a new Python module for Anaconda, we have the following list. See
    the link at [http://conda.pydata.org/docs/using/pkgs.html](http://conda.pydata.org/docs/using/pkgs.html)
    as well:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 Anaconda 安装一个新的 Python 模块，我们有以下列表。另见链接：[http://conda.pydata.org/docs/using/pkgs.html](http://conda.pydata.org/docs/using/pkgs.html)：
- en: '| Command | Description |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `conda list` | Lists all of your packages in the active environment |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `conda list` | 列出活动环境中的所有软件包 |'
- en: '| `conda list -n snowflakes` | Lists all of your packages installed into a
    non-active environment named `snowflakes` |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `conda list -n snowflakes` | 列出安装到名为 `snowflakes` 的非活动环境中的所有软件包 |'
- en: '| `conda search beautiful-soup` | Installs a package such as `Beautiful Soup`
    into the current environment, using `conda install` as follows |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `conda search beautiful-soup` | 使用 `conda install` 将如`Beautiful Soup`等包安装到当前环境
    |'
- en: '| `conda install --name bunnies quant` | Installs Python module (package) called
    `quant` |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `conda install --name bunnies quant` | 安装名为`quant`的 Python 模块（包） |'
- en: '| `conda info` | Gets more information |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `conda info` | 获取更多信息 |'
- en: Table 2.4 A list of commands using conda to install a new package
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表 2.4 使用 conda 安装新软件包的命令列表
- en: 'The following screenshot shows what you will see after the command of `conda
    info` is issued:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了执行 `conda info` 命令后你将看到的内容：
- en: '![How to install a Python module](img/B06175_02_23.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![如何安装 Python 模块](img/B06175_02_23.jpg)'
- en: 'The following example is related to the installation of the Python module called
    `pandas_datareader`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例与安装名为`pandas_datareader`的 Python 模块有关：
- en: '![How to install a Python module](img/B06175_02_24.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![如何安装 Python 模块](img/B06175_02_24.jpg)'
- en: 'After answering `y`, the following result will appear after the module is completed:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在回答`y`后，模块完成安装后，以下结果将显示：
- en: '![How to install a Python module](img/B06175_02_25.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![如何安装 Python 模块](img/B06175_02_25.jpg)'
- en: 'To get the versions of various modules, we have the following code:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取各种模块的版本，我们有以下代码：
- en: '[PRE72]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Module dependency
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块依赖性
- en: At the very beginning of this book, we argued that one of the advantages of
    using Python is that it is a rich source of hundreds of special packages called
    modules.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最开始，我们提到使用 Python 的一个优势是它提供了数百个被称为模块的特殊软件包。
- en: To avoid duplicated efforts and to save time in developing new modules, later
    modules choose to use functions developed on early modules; that is, they depend
    on early modules.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免重复劳动并节省开发新模块的时间，后续模块选择使用早期模块开发的函数；也就是说，它们依赖于早期模块。
- en: The advantage is obvious because developers can save lots of time and effort
    when building and testing a new module. However, one disadvantage is that installation
    becomes difficult.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个优势显而易见，因为开发者在构建和测试新模块时可以节省大量时间和精力。然而，一个缺点是安装变得更加困难。
- en: 'There are two competing approaches:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种竞争方法：
- en: The first approach is to bundle everything together and make sure that all parts
    play together nicely, thus avoiding the pain of installing *n* packages independently.
    This is wonderful, assuming that it works. A potential issue is that the updating
    of individual modules might not be reflected in the super package.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法是将所有内容打包在一起，确保各部分能够协调运行，从而避免独立安装*n*个软件包的麻烦。假设它能正常工作，这非常棒。但潜在的问题是，单个模块的更新可能不会反映在超级包中。
- en: 'The second approach is to use minimal dependencies. It causes fewer headaches
    for the package maintainer, but for users who have to install several components,
    it can be more of a hassle. Linux has a better way: using the package installer.
    The publishers of the package can declare dependencies and the system tracks them
    down, assuming they are in the Linux repository. SciPy, NumPy, and quant are all
    set up like that, and it works great.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法是使用最小依赖项。这对包的维护者来说会减少麻烦，但对于需要安装多个组件的用户来说，可能会更加麻烦。Linux 有更好的方法：使用包管理器。包的发布者可以声明依赖项，系统会追踪它们，前提是它们在
    Linux 仓库中。SciPy、NumPy 和 quant 都是这样设置的，效果很好。
- en: Exercises
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Do we have to install NumPy independently if our Python was installed via Anaconda?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的 Python 是通过 Anaconda 安装的，是否需要单独安装 NumPy？
- en: What are the advantages of using a super package to install many modules simultaneously?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用超级包同时安装多个模块有哪些优点？
- en: How do you find all the functions contained in NumPy or SciPy?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何查找 NumPy 或 SciPy 中包含的所有函数？
- en: How many ways are there to import a specific function contained in SciPy?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有多少种方法可以导入 SciPy 中包含的特定函数？
- en: What is wrong with the following operation?
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下操作有什么问题？
- en: '[PRE73]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: How can we print all the data items for a given array?
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何打印给定数组的所有数据项？
- en: What is wrong with the following lines of code?
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码行有什么问题？
- en: '[PRE74]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Find out the meaning of `skewtest` included in the stats submodule (SciPy),
    and give an example of using this function.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找 `stats` 子模块（SciPy）中包含的 `skewtest` 函数的含义，并给出一个使用该函数的示例。
- en: What is the difference between an arithmetic mean and a geometric mean?
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算术平均数和几何平均数有什么区别？
- en: 'Debug the following lines of code, which are used to estimate a geometric mean
    for a given set of returns:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试以下代码行，用于估算给定收益集的几何平均数：
- en: '[PRE75]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Write a Python program to estimate both arithmetic and geometric means for a
    given set of returns.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，估算给定收益集的算术平均数和几何平均数。
- en: Find out the meaning of `zscore()` included in the `stats` submodule (SciPy),
    and offer a simple example of using this function.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找 `stats` 子模块（SciPy）中包含的 `zscore()` 函数的含义，并提供一个使用该函数的简单示例。
- en: What is wrong with the following lines of code?
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码行有什么问题？
- en: '[PRE76]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: What is module dependency and how do you deal with it?
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是模块依赖性，如何处理它？
- en: What are the advantages and disadvantages of writing a module that depends on
    other modules?
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写依赖其他模块的模块有哪些优缺点？
- en: How do you use the financial functions contained in NumPy; for example, the
    `pv()` or `fv()` functions?
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用 NumPy 中包含的财务函数；例如，`pv()` 或 `fv()` 函数？
- en: For functions contained in `numpy.lib.financial`, are there similar functions
    contained in SciPy?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `numpy.lib.financial` 中包含的函数，SciPy 中是否有类似的函数？
- en: How do you use the functions contained in the `fincal` module, generated by
    the author?
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用作者生成的 `fincal` 模块中包含的函数？
- en: Where can you find a list of all Python modules?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在哪里可以找到所有 Python 模块的列表？
- en: How do you find more information about Python modules related to finance?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何查找与财务相关的 Python 模块的更多信息？
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have discussed one of the most important properties of
    Python: modules. A module is a package written by an expert or any individual
    to serve a special purpose. The knowledge related to modules is essential in our
    understanding of Python and its application to finance. In particular, we have
    introduced and discussed the most important modules, such as NumPy, SciPy, `matplotlib`,
    `statsmodels`, `pandas`, and `pandas_reader`. In addition, we have briefly mentioned
    module dependency and other issues. Two financial calculators written in Python
    were also presented. In [Chapter 3](ch03.html "Chapter 3. Time Value of Money"),
    *Time Value of Money*, we will discuss many basic concepts associated with finance,
    such as the present value of one future cash flow, present value of perpetuity,
    present value of growing perpetuity, present value of annuity, and formulas related
    to future values. In addition, we will discuss definitions of **Net Present Value**
    (**NPV**), **Internal Rate of Return** (**IRR**), and Payback period. After that,
    several investment decision rules will be explained.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 Python 最重要的特性之一：模块。模块是由专家或任何个人编写的包，用于服务于特定的目的。与模块相关的知识对于我们理解 Python
    及其在金融中的应用至关重要。特别地，我们介绍并讨论了最重要的模块，如 NumPy、SciPy、`matplotlib`、`statsmodels`、`pandas`
    和 `pandas_reader`。此外，我们简要提及了模块依赖关系和其他问题。还介绍了两个用 Python 编写的金融计算器。在[第 3 章](ch03.html
    "第 3 章. 货币的时间价值")中，*货币的时间价值*，我们将讨论许多与金融相关的基本概念，如单个未来现金流的现值、永续年金的现值、成长永续年金的现值、年金现值以及与未来价值相关的公式。此外，我们将讨论**净现值**（**NPV**）、**内部收益率**（**IRR**）和回收期的定义。之后，我们将解释几个投资决策规则。
