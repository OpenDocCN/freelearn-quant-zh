- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: Parameterised Quantum Circuits and Data Encoding
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化量子电路和数据编码
- en: Having built the quantum hardware, how can we use it to the maximum effect given
    its scale, connectivity, and fidelity rate? This question can be best answered
    if we split it into two parts. First, what problems are in principle solvable
    on NISQ computers? Second, how do we encode classical data into quantum states?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了量子硬件之后，如何在其规模、连接性和保真度下最大限度地发挥其效用呢？这个问题可以通过将其分为两个部分来更好地回答。首先，哪些问题原则上可以在NISQ计算机上求解？其次，如何将经典数据编码为量子态？
- en: 'The rest of this book focuses on the first part: problems and models that can
    be formulated in a way that doesn’t require a massive number of qubits and that
    are, at least to some extent, noise tolerant. The first step in this direction
    is the concept of the Parameterised Quantum Circuit (PQC) as a generic quantum
    machine learning model.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的其余部分集中讨论第一部分：那些可以以不需要大量量子比特的方式进行表述，并且至少在某种程度上具有噪声容忍性的模型和问题。朝着这个方向迈出的第一步是参数化量子电路（PQC）的概念，作为一种通用的量子机器学习模型。
- en: The second part – data encoding – is equally important and relies on several
    practical methods described in this chapter. This is an active area of research
    where we can expect most of the progress to come from the quantum software side.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分——数据编码——同样重要，并依赖于本章中描述的几种实用方法。这是一个活跃的研究领域，我们可以预计大多数进展将来自量子软件方面。
- en: 7.1 Parameterised Quantum Circuits
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1 参数化量子电路
- en: 'We have seen how to combine quantum gates to form arbitrarily wide and deep
    quantum circuits. A quantum circuit transforms an initial quantum state ![|ψ⟩](img/file659.jpg)
    into a final quantum state ![|ψ ′⟩](img/file660.jpg) by applying a sequence of
    unitary operators:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何组合量子门以形成任意宽度和深度的量子电路。量子电路通过应用一系列单元算符，将初始量子态 ![|ψ⟩](img/file659.jpg)
    转换为最终量子态 ![|ψ ′⟩](img/file660.jpg)。
- en: '| ![&#124;ψ′⟩ = U (𝜃 )...U (𝜃 )U (𝜃 ) &#124;ψ ⟩. m m 2 2 1 1 ](img/file661.jpg)
    |  |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| ![&#124;ψ′⟩ = U (𝜃 )...U (𝜃 )U (𝜃 ) &#124;ψ ⟩. m m 2 2 1 1 ](img/file661.jpg)
    |  |'
- en: Here, (U[i])[i=1,…,m] and (𝜃[i])[i=1,…,m] denote respectively the individual
    gates and the associated vectors of gate parameters. Some gates may be *fixed*
    (e.g., a two-qubit CNOT gate viewed as a controlled rotation of the target qubit
    state around the *x*-axis by a fixed angle *𝜃* = *π*) while some gates may be
    *adjustable* (e.g., a one-qubit R[X](*𝜃*) gate that rotates the qubit state around
    *x*-axis by an arbitrary angle *𝜃* ∈ [−*π,π*]).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，(U[i])[i=1,…,m] 和 (𝜃[i])[i=1,…,m] 分别表示个别门和与之关联的门参数向量。有些门可能是*固定的*（例如，一个二比特CNOT门，视为围绕*x*轴以固定角度*𝜃*
    = *π*控制旋转目标量子比特的状态），而有些门可能是*可调的*（例如，一个一比特的R[X](*𝜃*)门，绕*x*轴以任意角度*𝜃* ∈ [−*π,π*]旋转量子比特状态）。
- en: Once the final quantum state ![ ′ |ψ ⟩](img/file662.jpg) is constructed, the
    individual qubits can be measured. After measurement the qubit states stay the
    same in the basis in which they were measured, which we always assume to be the
    standard computational basis unless explicitly specified otherwise. Therefore,
    the final output of running the quantum circuit and then measuring the qubits
    (not necessarily all qubits have to be measured) is a classical bitstring.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦最终量子态 ![ ′ |ψ ⟩](img/file662.jpg) 被构造出来，个别量子比特就可以被测量。测量后，量子比特的状态会保持在其测量时所使用的基态中，我们通常假定该基态为标准计算基态，除非特别指定。
    因此，运行量子电路并测量量子比特（不一定所有量子比特都需要测量）的最终输出是一个经典的比特串。
- en: What we just described is a parameterised quantum circuit schematically shown
    in Figure [7.1](#7.1). The PQC can be used in many different ways. First of all,
    let us note that the PQC can be *trained*. Training the PQC has the meaning of
    finding an optimal set of adjustable parameters (the vectors 𝜃[1]*,…,*𝜃[m] above,
    for example) given the overall PQC *ansatz* (architecture). The meaning of "optimal"
    is problem dependent but generally means a configuration of adjustable parameters
    that ensures maximum closeness of the final quantum state ![ ′ |ψ ⟩](img/file663.jpg)
    to some desired target quantum state that corresponds to a particular probability
    distribution we aim to encode.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才描述的是一个参数化量子电路，示意图见图[7.1](#7.1)。PQC可以以多种方式使用。首先，让我们注意到PQC可以被*训练*。训练PQC意味着在给定整体PQC*ansatz*（架构）的情况下，找到一组最佳的可调参数（例如上面提到的向量𝜃[1]*，…，*𝜃[m]）。所谓的“最佳”是问题依赖的，但通常意味着一组可调参数的配置，它确保最终量子态
    ![ ′ |ψ ⟩](img/file663.jpg) 与某个目标量子态尽可能接近，这个目标量子态对应于我们要编码的特定概率分布。
- en: '![Figure 7.1: Schematic representation of a Parameterised Quantum Circuit.
    ](img/file664.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 7.1: 参数化量子电路的示意表示。](img/file664.jpg)'
- en: 'Figure 7.1: Schematic representation of a Parameterised Quantum Circuit.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：参数化量子电路的示意表示。
- en: 'In the following chapters, we will see how PQCs can be used as discriminative
    ML models (Chapter [8](Chapter_8.xhtml#x1-1620008)), as generative ML models (Chapter [9](Chapter_9.xhtml#x1-1850009)),
    and as optimisers (Chapters [10](Chapter_10.xhtml#x1-20200010) and [11](Chapter_11.xhtml#x1-21700011)):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到如何将PQC作为判别式机器学习模型（第[8](Chapter_8.xhtml#x1-1620008)章）、生成式机器学习模型（第[9](Chapter_9.xhtml#x1-1850009)章）以及优化器（第[10](Chapter_10.xhtml#x1-20200010)章和第[11](Chapter_11.xhtml#x1-21700011)章）来使用：
- en: In the case of the Variational Quantum Eigensolver, a PQC is used to construct
    the final quantum state ![ ′ |ψ ⟩](img/file665.jpg) that is close to the eigenstate
    of the problem Hamiltonian that corresponds to the smallest eigenvalue (the ground
    state energy that is linked to the minimum of the cost function).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在变分量子特征求解器的情况下，PQC被用来构建最终的量子态![ ′ |ψ ⟩](img/file665.jpg)，该态接近于问题哈密顿量的本征态，对应于最小本征值（与代价函数最小值相关的基态能量）。
- en: When we build a quantum discriminative model – a Quantum Neural Network trained
    as a classifier – we are interested in measuring only a handful of qubits (or
    even just a single qubit). This should give us the binary representation of the
    "class label" for the given sample. The input (initial quantum state ![|ψ ⟩](img/file666.jpg))
    encodes the sample we want to classify.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们构建一个量子判别模型——一个作为分类器训练的量子神经网络时，我们只关注测量少数几个量子比特（甚至只有一个量子比特）。这应该给我们提供一个二进制表示的“类标签”用于给定的样本。输入（初始量子态![|ψ
    ⟩](img/file666.jpg)）编码了我们想要分类的样本。
- en: When our objective is to build a quantum generative model – the Quantum Circuit
    Born Machine – we measure all qubits. This gives us a bitstring that is a generated
    sample from the probability distribution encoded in the final quantum state ![|ψ
    ′⟩](img/file667.jpg) constructed by the PQC. The initial state is initialised
    as ![|0⟩](img/file668.jpg)^(⊗n).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们的目标是构建一个量子生成模型——量子电路Born机时，我们测量所有的量子比特。这将给我们一个比特串，这是从最终量子态![|ψ ′⟩](img/file667.jpg)中编码的概率分布生成的样本。初始状态初始化为![|0⟩](img/file668.jpg)^(⊗n)。
- en: 'PQCs are invariably trained using hybrid quantum-classical protocols. The hybrid
    approach is shown schematically in Figure [7.2](#7.2) and consists of three components:
    the user, the classical computer, and the quantum computer  [[29](Biblography.xhtml#XBenedetti2019)].'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: PQC通常使用混合量子-经典协议进行训练。混合方法在图[7.2](#7.2)中以示意图的形式展示，由三个部分组成：用户、经典计算机和量子计算机[[29](Biblography.xhtml#XBenedetti2019)]。
- en: '![Figurex1-151003r2: Training PQCs – schematic process. ](img/file669.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Figurex1-151003r2: 训练PQC - 示意流程。](img/file669.jpg)'
- en: 'Figure 7.2: Training PQCs – schematic process.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：训练PQC - 示意流程。
- en: The user provides the model for the problem; the classical computer pre-processes
    the data and produces the initial set of parameters for the PQC; the quantum computer
    runs the PQC by preparing the quantum state as prescribed by the PQC and by performing
    measurements. Measurement outcomes are then post-processed by the classical computer,
    which updates the model parameters as per the chosen training algorithm (backpropagation
    of error with gradient descent, non-differentiable learning method, etc.) The
    overall algorithm is run in a closed loop between the classical and quantum computers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 用户为问题提供模型；经典计算机预处理数据并生成PQC的初始参数集；量子计算机通过按照PQC的要求准备量子态并进行测量来运行PQC。测量结果随后由经典计算机进行后处理，经典计算机会根据选定的训练算法（如误差反向传播与梯度下降、不可微学习方法等）更新模型参数。整体算法在经典计算机与量子计算机之间以闭环形式运行。
- en: PQC is one of the most successful frameworks for applying NISQ computers to
    solving non-trivial real-world problems. It follows the paradigm of a hybrid quantum-classical
    computational protocol and can be used for experimenting with the wide range of
    quantum machine learning models.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: PQC是将NISQ计算机应用于解决非平凡现实世界问题的最成功框架之一。它遵循混合量子-经典计算协议的范式，并可用于实验广泛的量子机器学习模型。
- en: 7.2 Angle Encoding
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2 角度编码
- en: 'Let us go back to the Bloch sphere (Figure [7.2](#x1-1520002)) that visualises
    the canonical representation of the qubit state – a unit vector in the 2-dimensional
    complex vector space:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到布洛赫球（图[7.2](#x1-1520002)），它可视化了量子比特态的标准表示——二维复向量空间中的单位向量：
- en: '| ![ ⌊ ( ) ⌋ cos 𝜃- &#124;ψ⟩ = &#124;&#124; (2 ) &#124;&#124;. ⌈eiϕsin 𝜃- ⌉
    2 ](img/file670.jpg) |  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| ![ ⌊ ( ) ⌋ cos 𝜃- &#124;ψ⟩ = &#124;&#124; (2 ) &#124;&#124;. ⌈eiϕsin 𝜃- ⌉
    2 ](img/file670.jpg) |  |'
- en: The angles *𝜃* ∈ [0*,π*] and *ϕ* ∈ [0*,*2*π*] uniquely determine the position
    of the qubit on the unit sphere. Since we need two continuous variables to specify
    the qubit state, a single qubit can encode two real-valued features.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 角度 *𝜃* ∈ [0*,π*] 和 *ϕ* ∈ [0*,*2*π*] 唯一地确定量子比特在单位球上的位置。由于我们需要两个连续变量来指定量子比特的状态，因此一个量子比特可以编码两个实值特征。
- en: '![Figure 7.3: Quantum state |ψ ⟩ on the Bloch sphere. ](img/file672.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3：量子态 |ψ ⟩ 在布洛赫球上的表示。](img/file672.jpg)'
- en: 'Figure 7.3: Quantum state ![|ψ ⟩](img/file671.jpg) on the Bloch sphere.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：量子态 ![|ψ ⟩](img/file671.jpg) 在布洛赫球上的表示。
- en: 7.2.1 The basic encoding scheme
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1 基本编码方案
- en: 'We can illustrate this with the following schematic example: let us assume
    that we have an 8-feature dataset consisting of *N* samples and that all features
    *X*[1]*,…,X*[8] are real-valued and such that their extremal values, *X*[i]^(min)
    and *X*[i]^(max), *i* = 1*,…,*8, can be computed. Then, for every sample *j* =
    1*,…,N* from the dataset, we can establish a one-to-one mapping between the values
    of the features *X*[i]^j and the corresponding rotation angles *𝜃*[i]^j:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下示意例子来说明这一点：假设我们有一个包含 *N* 个样本的 8 特征数据集，所有特征 *X*[1]*,…,X*[8] 都是实值，并且可以计算出它们的极值
    *X*[i]^(min) 和 *X*[i]^(max)，*i* = 1*,…,*8。然后，对于数据集中每个样本 *j* = 1*,…,N*，我们可以建立一个特征值
    *X*[i]^j 与对应旋转角度 *𝜃*[i]^j 之间的一对一映射关系：
- en: '| ![ j Xj − Xmin 𝜃i = --miax----iminπ, X i − X i ](img/file673.jpg) |  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| ![ j Xj − Xmin 𝜃i = --miax----iminπ, X i − X i ](img/file673.jpg) |  |'
- en: where *X*[i]^(min) := min[j]*X*[i]^j and *X*[i]^(max) := max[j]*X*[i]^j. Rotation
    angles *𝜃*[i]^j generalise angles *𝜃* and *ϕ* in Figure [7.2](#x1-1520002).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *X*[i]^(min) := min[j]*X*[i]^j 和 *X*[i]^(max) := max[j]*X*[i]^j。旋转角度 *𝜃*[i]^j
    推广了图 [7.2](#x1-1520002) 中的角度 *𝜃* 和 *ϕ*。
- en: '![Figure 7.4: Feature encoding – rotations around y axis. States of qubits
    q1,…,q4 are shown on the same Bloch sphere. The initial state of all qubits is
    |0⟩ and the end states after rotations around the y-axis by angles 𝜃1,…,𝜃4 are
    denoted as A, B, C, and D. ](img/file675.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4：特征编码 – 绕 y 轴旋转。量子比特 q1,…,q4 的状态在同一布洛赫球上显示。所有量子比特的初始状态为 |0⟩，绕 y 轴旋转角度
    𝜃1,…,𝜃4 后的最终状态分别表示为 A、B、C 和 D。](img/file675.jpg)'
- en: 'Figure 7.4: Feature encoding – rotations around y axis. States of qubits q[1],…,q[4]
    are shown on the same Bloch sphere. The initial state of all qubits is ![|0⟩](img/file674.jpg)
    and the end states after rotations around the y-axis by angles 𝜃[1],…,𝜃[4] are
    denoted as A, B, C, and D.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：特征编码 – 绕 y 轴旋转。量子比特 q[1],…,q[4] 在同一布洛赫球上的状态。所有量子比特的初始状态为 ![|0⟩](img/file674.jpg)，绕
    y 轴旋转角度 𝜃[1],…,𝜃[4] 后的最终状态分别表示为 A、B、C 和 D。
- en: 'The 8-feature sample can be encoded in a 4-qubit state (unentangled). For example,
    starting with four quantum registers initialised as ![|0⟩](img/file676.jpg) in
    the computational basis, we can first perform rotations around the *y*-axis: rotation
    by *𝜃*[1] for qubit 1, rotation by *𝜃*[2] for qubit 2, and so on. This is shown
    schematically in Figure [7.2.1](#x1-1530001) where qubits move from their initial
    state ![|0⟩](img/file677.jpg) to states *A*, *B*, *C*, and *D*.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 8 特征样本可以编码为一个 4 量子比特状态（非纠缠）。例如，从四个初始化为 ![|0⟩](img/file676.jpg) 的量子寄存器开始，我们可以首先在
    *y* 轴上进行旋转：量子比特 1 按角度 *𝜃*[1] 旋转，量子比特 2 按角度 *𝜃*[2] 旋转，依此类推。这在图 [7.2.1](#x1-1530001)
    中示意展示，量子比特从其初始状态 ![|0⟩](img/file677.jpg) 移动到状态 *A*、*B*、*C* 和 *D*。
- en: 7.2.2 Encoding two features per quantum register
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.2 每个量子寄存器编码两个特征
- en: 'After that, we encode the remaining features by performing rotations around
    the *z*-axis: rotation by *𝜃*[5] for qubit 1, rotation by *𝜃*[6] for qubit 2,
    and so on as shown in Figure [7.5](#7.5).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们通过在 *z* 轴上进行旋转来编码剩余特征：量子比特 1 按角度 *𝜃*[5] 旋转，量子比特 2 按角度 *𝜃*[6] 旋转，依此类推，正如图
    [7.5](#7.5) 中所示。
- en: '![Figure 7.5: Feature encoding – rotations around the z-axis. The initial states
    of qubits q1,…,q4 are A,B,C,D. After rotation around the z-axis by angles 𝜃5,…,𝜃8,
    the final qubit states are E,F,G,H. ](img/file678.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5：特征编码 – 绕 z 轴旋转。量子比特 q1,…,q4 的初始状态分别为 A,B,C,D。在绕 z 轴旋转角度 𝜃5,…,𝜃8 后，最终的量子比特状态为
    E,F,G,H。](img/file678.jpg)'
- en: 'Figure 7.5: Feature encoding – rotations around the z-axis. The initial states
    of qubits q[1],…,q[4] are A,B,C,D. After rotation around the z-axis by angles
    𝜃[5],…,𝜃[8], the final qubit states are E,F,G,H.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：特征编码 – 绕 z 轴旋转。量子比特 q[1],…,q[4] 的初始状态分别为 A,B,C,D。在绕 z 轴旋转角度 𝜃[5],…,𝜃[8]
    后，最终的量子比特状态为 E,F,G,H。
- en: 'The qubit states move from *A* to *E*, from *B* to *F*, from *C* to *G*, and
    from *D* to *H*. The corresponding quantum circuit looks as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 量子比特状态从*A*转移到*E*，从*B*转移到*F*，从*C*转移到*G*，从*D*转移到*H*。对应的量子电路如下所示：
- en: '![Figure 7.6: 4-qubit quantum circuit for 8-feature sample encoding. ](img/file679.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6：8特征样本编码的4量子比特量子电路。](img/file679.jpg)'
- en: 'Figure 7.6: 4-qubit quantum circuit for 8-feature sample encoding.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：8特征样本编码的4量子比特量子电路。
- en: 7.2.3 Mapping a classical data sample into a quantum state
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.3 将经典数据样本映射到量子状态
- en: We can summarise the angle encoding scheme as follows. For the classical data
    sample *X*^j := (*X*[1]^j*,…,X*[K]^j) ∈ℝ^K, *j* = 1*,…,N*, angle encoding works
    by constructing the map
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将角度编码方案总结如下。对于经典数据样本*X*^j := (*X*[1]^j*,…,X*[K]^j) ∈ℝ^K，*j* = 1*,…,N*，角度编码通过构造映射来工作
- en: '![ K ( ( j) ( j) ) j ⊗ 𝜃i 𝜃i X ↦−→ cos 2 |0⟩+ sin 2 |1⟩ , i=1 ](img/file680.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![ K ( ( j) ( j) ) j ⊗ 𝜃i 𝜃i X ↦−→ cos 2 |0⟩+ sin 2 |1⟩ , i=1 ](img/file680.jpg)'
- en: 'where angles (*𝜃*[i]^j)[i=1,…,K;j=1,…,N] are given by the expression ([7.2.1](#x1-1530001)).
    This scheme only requires one rotation gate for each qubit, hence encodes as many
    features as the number of qubits. However, we know that a single quantum register
    can encode two real variables. The following scheme maps the classical sample
    into the quantum state with the help of an extra phase gate:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 其中角度（*𝜃*[i]^j)[i=1,…,K;j=1,…,N]由表达式([7.2.1](#x1-1530001))给出。该方案仅需要为每个量子比特旋转门，因此可以编码与量子比特数量相同数量的特征。然而，我们知道单个量子寄存器可以编码两个实数变量。以下方案在附加相位门的帮助下将经典样本映射到量子状态：
- en: '![ ⊗K ( ( 𝜃j ) (𝜃j ) ) Xj ↦−→ cos -2i−1 |0⟩+ exp (i𝜃2i)sin -2i−1 |1⟩ . i=1
    2 2 ](img/file681.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![ ⊗K ( ( 𝜃j ) (𝜃j ) ) Xj ↦−→ cos -2i−1 |0⟩+ exp (i𝜃2i)sin -2i−1 |1⟩ . i=1
    2 2 ](img/file681.jpg)'
- en: This scheme allows us to encode 2*n* features with *n* qubits.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该方案允许我们使用*n*个量子比特编码2*n*个特征。
- en: '*n* quantum registers have capacity to encode 2*n* continuous features with
    just two layers of one-qubit gates.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*个量子寄存器具有仅通过两层单量子比特门就能编码2*n*个连续特征的能力。'
- en: 7.3 Amplitude Encoding
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3 振幅编码
- en: 'So far we have not utilised the information encoding possibilities provided
    by entanglement although, in principle, most of the information in large quantum
    systems can be stored in correlations. In the case of our 8-feature dataset example
    considered in the previous section, we can reduce the number of necessary qubits
    to just three if we use entanglement. The first six rotation angles *𝜃*[1]*,…,𝜃*[6]
    can still be used for the single-qubit rotations R[Y]*,*R[Z]. The last two, *𝜃*[7]
    and *𝜃*[8], can be used for controlled rotations that entangle qubits 1 and 2
    and qubits 2 and 3 as shown in Figure [7.7](#7.7):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有利用纠缠所提供的信息编码可能性，尽管从理论上讲，大多数大规模量子系统中的信息可以存储在关联中。在前一节中考虑的8特征数据集示例中，如果使用纠缠，我们可以将所需量子比特的数量减少到仅三个。前六个旋转角度*𝜃*[1]*，…，𝜃*[6]仍然可以用于单量子比特旋转R[Y]*，*R[Z]。最后两个角度，*𝜃*[7]和*𝜃*[8]，可以用于受控旋转，纠缠量子比特1和2以及量子比特2和3，如图[7.7](#7.7)所示：
- en: '![Figure 7.7: 3-qubit quantum circuit for 8-feature sample encoding. ](img/file682.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7：8特征样本编码的3量子比特量子电路。](img/file682.jpg)'
- en: 'Figure 7.7: 3-qubit quantum circuit for 8-feature sample encoding.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：8特征样本编码的3量子比特量子电路。
- en: In principle, since the *n*-qubit state can be uniquely described by specifying
    2^n probability amplitudes, we only need *n* qubits to encode 2^n features. However,
    this superdense encoding is not always practical or desirable. The *amplitude*
    *encoding* was used in the seminal work by Harrow, Hassidim, and Lloyd  [[126](Biblography.xhtml#XHHL2009)],
    but obtaining the amplitude encoding is a non-trivial task for problems of realistic
    size and this, usually, is the main bottleneck for many quantum algorithms  [[184](Biblography.xhtml#XLandman2021)].
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，由于*n*量子比特状态可以通过指定2^n个概率振幅来唯一描述，我们只需要*n*个量子比特就可以编码2^n个特征。然而，这种超密编码并不总是实用或可取的。*振幅*
    *编码*曾在Harrow、Hassidim和Lloyd的开创性工作中使用[[126](Biblography.xhtml#XHHL2009)]，但对于现实规模的问题，获得振幅编码是一项非平凡的任务，这通常是许多量子算法的主要瓶颈[[184](Biblography.xhtml#XLandman2021)]。
- en: The amplitude encoding can be formalised in the following way. Consider an *N*-dimensional
    (with *N* = 2^n) data point x := (*x*[1]*,…,x*[N]) ∈ℂ^N. We can associate quantum
    amplitudes to the coordinates as
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 振幅编码可以通过以下方式形式化。考虑一个*N*维度（*N* = 2^n）的数据点x := (*x*[1]*，…，x*[N]) ∈ℂ^N。我们可以将量子振幅与坐标关联，如下所示：
- en: '![ ∑N |ψx⟩ = -1-- xi |i⟩, ∥x∥ i=1 ](img/file683.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑N |ψx⟩ = -1-- xi |i⟩, ∥x∥ i=1 ](img/file683.jpg)'
- en: where ∥x∥ := ∑ [i=1]^N|*x*[i]|² is the normalisation factor. We can therefore
    encode the dataset D := (x¹*,…,*x^M) consisting of *M* points in ℝ^N as
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ∥x∥ := ∑ [i=1]^N|*x*[i]|² 是归一化因子。因此，我们可以将由 *M* 个点组成的数据集 D := (x¹*,…,*x^M)
    编码为
- en: '![ p 1 2∑ -- |D⟩ = C-- xi |i⟩, D i=1 ](img/file684.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![ p 1 2∑ -- |D⟩ = C-- xi |i⟩, D i=1 ](img/file684.jpg)'
- en: for some integer *p*, where
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某个整数 *p*，其中
- en: '![-- -- 1 1 2 2 M M MN x = (xi)i=1,...,2p = (x1,...,xN ,x1,...,x N,...,x1 ,...,x
    N ) ∈ ℝ ](img/file685.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![-- -- 1 1 2 2 M M MN x = (xi)i=1,...,2p = (x1,...,xN ,x1,...,x N,...,x1 ,...,x
    N ) ∈ ℝ ](img/file685.jpg)'
- en: is the concatenation of all the data points and *C*[D] is a normalisation constant.
    Here the constraint is hence that 2^p ≥ *MN*, namely *p* ≥ log [2](*MN*). Note
    that there may again be some sparsity in the case where 2^p *> MN*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 是所有数据点的拼接，且 *C*[D] 是一个归一化常数。因此，约束条件为 2^p ≥ *MN*，即 *p* ≥ log [2](*MN*)。注意，在 2^p
    *> MN* 的情况下，可能会再次出现稀疏性。
- en: The clear advantage is that it can store 2^n features with only *n* qubits,
    but unfortunately has a depth 𝒪(2*n*) and is hence hard to build.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 明显的优点是它可以用仅 *n* 个量子比特存储 2^n 个特征，但不幸的是其深度为 𝒪(2*n*)，因此很难构建。
- en: With the amplitude encoding, *n* quantum registers have capacity to encode 2^n
    continuous features. However, this requires construction of the deep quantum circuits
    with the circuit depth growing as 𝒪(2*n*). This solution may not be practical
    for NISQ computers when dealing with a large number of features.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过幅度编码，*n* 个量子寄存器可以编码 2^n 个连续特征。然而，这需要构建深度量子电路，且电路深度随着 𝒪(2*n*) 增长。因此，当处理大量特征时，对于
    NISQ 计算机而言，这种方案可能并不实际。
- en: 7.4 Binary Inputs into Basis States
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4 二进制输入到基态
- en: Consider a real number *x* ∈ℝ approximated with the binary representation
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个实数 *x* ∈ℝ，用二进制表示法近似
- en: '| ![ ( ) 𝔦∑−1 ∑𝔡 x ≈ ^x = (x 𝔦,x𝔦−1,⋅⋅⋅ ,x−𝔡) := (− 1)x𝔦( xj2j + x −j2−j) j=0
    j=1 ↦− → &#124;x𝔦x𝔦−1⋅⋅⋅x−𝔡⟩ =: &#124;x⟩, ](img/file686.jpg) |  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| ![ ( ) 𝔦∑−1 ∑𝔡 x ≈ ^x = (x 𝔦,x𝔦−1,⋅⋅⋅ ,x−𝔡) := (− 1)x𝔦( xj2j + x −j2−j) j=0
    j=1 ↦− → &#124;x𝔦x𝔦−1⋅⋅⋅x−𝔡⟩ =: &#124;x⟩, ](img/file686.jpg) |  |'
- en: for some non-negative integers 𝔦*,*𝔡, where *x*[𝔦] ∈{0*,*1} accounts for the
    sign of *x* and (*x*[j])[j=0,…,𝔦−1] ∈{0*,*1}^(𝔦) and (*x*[j])[j=−1,…,−𝔡] ∈{0*,*1}^(𝔡)
    represent respectively the integer and decimal parts of *x*. Consider now a vector
    x := (*x*¹*,…,x*^N) ∈ℝ^N. We can concatenate all the binary approximations *x*¹*,…,**x*^N
    into one vector
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些非负整数𝔦*，*𝔡，其中 *x*[𝔦] ∈{0*,*1}表示 *x* 的符号，且 (*x*[j])[j=0,…,𝔦−1] ∈{0*,*1}^(𝔦)
    和 (*x*[j])[j=−1,…,−𝔡] ∈{0*,*1}^(𝔡)分别表示 *x* 的整数部分和小数部分。现在考虑一个向量 x := (*x*¹*,…,x*^N)
    ∈ℝ^N。我们可以将所有二进制近似值 *x*¹*,…,**x*^N 拼接成一个向量。
- en: '![( 1 1 1 N N N ) (1+𝔦+𝔡)N x𝔦,x𝔦− 1,⋅⋅⋅ ,x−𝔡,⋅⋅⋅ ,x𝔦 ,x 𝔦−1,⋅⋅⋅ ,x− 𝔡 ∈ {0,1}
    ](img/file687.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![( 1 1 1 N N N ) (1+𝔦+𝔡)N x𝔦,x𝔦− 1,⋅⋅⋅ ,x−𝔡,⋅⋅⋅ ,x𝔦 ,x 𝔦−1,⋅⋅⋅ ,x− 𝔡 ∈ {0,1}
    ](img/file687.jpg)'
- en: to obtain a quantum state representation with (1 + 𝔦 + 𝔡)*N* qubits of the form
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以 (1 + 𝔦 + 𝔡)*N* 个量子比特的形式获得量子态表示
- en: '![ 1 1 1 N N N ⟩ |x𝔦x𝔦−1⋅⋅⋅x−𝔡 ⋅⋅⋅x 𝔦 ,x𝔦−1⋅⋅⋅x−𝔡 . ](img/file688.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![ 1 1 1 N N N ⟩ |x𝔦x𝔦−1⋅⋅⋅x−𝔡 ⋅⋅⋅x 𝔦 ,x𝔦−1⋅⋅⋅x−𝔡 . ](img/file688.jpg)'
- en: Since the vector thus obtained only contains 0 and 1, starting from the quantum
    state ![|0⟩](img/file689.jpg)^(⊗(1+𝔦+𝔡)N), we only need to apply the NOT gate X
    whenever the corresponding value is equal to one, so that the encoding circuit
    simply reads
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于由此获得的向量仅包含 0 和 1，从量子态 ![|0⟩](img/file689.jpg)^(⊗(1+𝔦+𝔡)N) 开始，我们只需在相应值为 1 时应用非门
    X，因此编码电路仅需读取
- en: '![ ⊗(1+𝔦+𝔡)N ⊗N ⊗ 𝔦 xl ⊗(1+𝔦+𝔡)N |0⟩ ↦− → X k |0⟩ . l=1 k=−𝔡 ](img/file690.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![ ⊗(1+𝔦+𝔡)N ⊗N ⊗ 𝔦 xl ⊗(1+𝔦+𝔡)N |0⟩ ↦− → X k |0⟩ . l=1 k=−𝔡 ](img/file690.jpg)'
- en: While the algorithm is straightforward and only requires the use of the single-qubit
    quantum gate X, it requires a large number of qubits and is in general not efficient
    in practice. Indeed, for a given dimension *N*, there are 2^N possible basis states.
    If a dataset contains only *M* points with *M* being much smaller than *N*, the
    quantum representation will therefore be sparse.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然该算法直接且只需要使用单量子比特门 X，但它需要大量的量子比特，并且通常在实际中效率较低。实际上，对于给定的维度 *N*，存在 2^N 种可能的基态。如果一个数据集只包含
    *M* 个点，且 *M* 远小于 *N*，那么量子表示将会非常稀疏。
- en: '**Example:** Consider a dataset D = (*x*¹*,x*²) with *x*¹*,x*² ∈ [−2*,*2],
    each approximated with four qubits:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：** 考虑一个数据集 D = (*x*¹*,x*²)，其中 *x*¹*,x*² ∈ [−2*,*2]，每个用四个量子比特近似表示：'
- en: '![ 1 1( 1 1 ) x1 ≈ (− 1)x1(20x10 + 2− 1x1−1 + 2−2x1−2) = (− 1)x1 x10 +-x1−1
    +-x1− 2 2 4 ](img/file691.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![ 1 1( 1 1 ) x1 ≈ (− 1)x1(20x10 + 2− 1x1−1 + 2−2x1−2) = (− 1)x1 x10 +-x1−1
    +-x1− 2 2 4 ](img/file691.jpg)'
- en: and
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '![ 2 2 ( 1 1 ) x2 ≈ (− 1)x1(20x20 + 2−1x2− 1 + 2−2x2−2) = (− 1)x1 x20 +-x2−1
    +-x2−2 , 2 4 ](img/file692.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![ 2 2 ( 1 1 ) x2 ≈ (− 1)x1(20x20 + 2−1x2− 1 + 2−2x2−2) = (− 1)x1 x20 +-x2−1
    +-x2−2 , 2 4 ](img/file692.jpg)'
- en: with *x*[k]^i ∈{0*,*1} for each *i* = 1*,*2 and *k* = −2*,*−1*,*0*,*1\. Their
    quantum embeddings therefore read ![|x1x1x1 x1 ⟩ 1 0 − 1 −2](img/file693.jpg)
    and ![|x2x2x2 x2 ⟩ 1 0 −1 − 2](img/file694.jpg), and the quantum circuit to encode
    the dataset therefore takes the form
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个*i* = 1*,*2 和 *k* = −2*,*−1*,*0*,*1，*x*[k]^i ∈{0*,*1}。因此，它们的量子嵌入为！[|x1x1x1
    x1 ⟩ 1 0 − 1 −2](img/file693.jpg) 和 ![|x2x2x2 x2 ⟩ 1 0 −1 − 2](img/file694.jpg)，因此编码数据集的量子电路采用如下形式：
- en: '![ [( 1 1 1 1 ) ( 2 2 2 2 )] |0⟩⊗8 ↦−→ Xx1 ⊗ Xx0 ⊗ Xx−1 ⊗ Xx−2 ⊗ Xx1 ⊗ Xx0
    ⊗ Xx−1 ⊗ Xx−2 |0⟩⊗8\. ](img/file695.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![ [( 1 1 1 1 ) ( 2 2 2 2 )] |0⟩⊗8 ↦−→ Xx1 ⊗ Xx0 ⊗ Xx−1 ⊗ Xx−2 ⊗ Xx1 ⊗ Xx0
    ⊗ Xx−1 ⊗ Xx−2 |0⟩⊗8\. ](img/file695.jpg)'
- en: 7.5 Superposition Encoding
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5 叠加编码
- en: As developed in  [[287](Biblography.xhtml#XTrugenberger2001), [294](Biblography.xhtml#XVentura2000)],
    it is possible to build such a superposition of data in time linear in the number
    of points and features. We consider again a dataset D := (x¹*,…,*x^M), with x^k
    := (*x*[1]^k*,…,x*[n]^k) ∈{0*,*1}^n for each *k* = 1*,…,M*. We use a quantum system
    of the form
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[[287](Biblography.xhtml#XTrugenberger2001), [294](Biblography.xhtml#XVentura2000)]中所述，可以在时间上与数据点和特征数量成线性关系地构建这样的数据叠加。我们再次考虑一个数据集
    D := (x¹*,…,*x^M)，其中 x^k := (*x*[1]^k*,…,x*[n]^k) ∈{0*,*1}^n 对于每个 *k* = 1*,…,M*。我们使用一个量子系统，其形式为：
- en: '![|ψ0⟩ := |0⟩⊗n |00⟩ |0⟩⊗n , ](img/file696.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![|ψ0⟩ := |0⟩⊗n |00⟩ |0⟩⊗n , ](img/file696.jpg)'
- en: where the left-most part with *n* qubits is called the loading register while
    the right-most one (also with *n* qubits) is the storage register. The middle
    one is an ancilla register that will be used to control manipulations between
    the loading and storage registers. The encoding algorithm works recursively. We
    first apply an Hadamard gate to the second ancilla qubit and store the first data
    point x¹ into the storage register. Since
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最左边的部分包含*n*个量子比特，称为加载寄存器，而最右边的部分（同样包含*n*个量子比特）是存储寄存器。中间部分是一个辅助寄存器，用于控制加载寄存器和存储寄存器之间的操作。编码算法是递归工作的。我们首先对第二个辅助量子比特应用
    Hadamard 门，并将第一个数据点 x¹ 存入存储寄存器。由于
- en: '![(⊗ n ) Xx1i |0⟩⊗n = |x1 ⋅⋅⋅x1⟩ = |x1⟩, i=1 1 n ](img/file697.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![(⊗ n ) Xx1i |0⟩⊗n = |x1 ⋅⋅⋅x1⟩ = |x1⟩, i=1 1 n ](img/file697.jpg)'
- en: this can be achieved (after the Hadamard operation) by applying the unitary
    operator
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过应用酉算符（在 Hadamard 操作之后）来实现。
- en: '![ ( n ) I⊗n ⊗ I⊗ H ⊗ ⊗ Xx1i i=1 ](img/file698.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![ ( n ) I⊗n ⊗ I⊗ H ⊗ ⊗ Xx1i i=1 ](img/file698.jpg)'
- en: controlled with the second ancilla qubit, and the resulting quantum state reads
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由第二个辅助量子比特控制，得到的量子态为：
- en: '![ ⊗n ⊗n ⊗n 1⟩ |ψ ⟩ := |0⟩--|0√0⟩-|0⟩---+ |0⟩---|√01⟩ |x-. 1 2 2 ](img/file699.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![ ⊗n ⊗n ⊗n 1⟩ |ψ ⟩ := |0⟩--|0√0⟩-|0⟩---+ |0⟩---|√01⟩ |x-. 1 2 2 ](img/file699.jpg)'
- en: This can easily be turned (see the proof of Lemma [7](#x1-158003r7) below) into
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过（参见下文引理[7](#x1-158003r7)的证明）轻松转化为
- en: '![ ⊗n 1⟩ ⊗n ⊗n |ψ ⟩ = |0⟩--|√00⟩ |x--+ |0⟩---|0√1⟩-|0⟩---. 1 2 2 ](img/file700.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![ ⊗n 1⟩ ⊗n ⊗n |ψ ⟩ = |0⟩--|√00⟩ |x--+ |0⟩---|0√1⟩-|0⟩---. 1 2 2 ](img/file700.jpg)'
- en: After *m* steps, we arrive at a quantum state of the form
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在*m*步之后，我们得到了如下形式的量子态：
- en: '| ![ 1 ∑m ⟩ ∘ M--−-m-- &#124;ψm ⟩ := √--- &#124;0⟩⊗n &#124;00⟩ &#124;xk + -------
    &#124;0⟩⊗n &#124;01 ⟩ &#124;0 ⟩⊗n . M k=1 M ](img/file701.jpg) |  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| ![ 1 ∑m ⟩ ∘ M--−-m-- &#124;ψm ⟩ := √--- &#124;0⟩⊗n &#124;00⟩ &#124;xk + -------
    &#124;0⟩⊗n &#124;01 ⟩ &#124;0 ⟩⊗n . M k=1 M ](img/file701.jpg) |  |'
- en: 'The following lemma guarantees the validity of the algorithm:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下引理保证了算法的有效性：
- en: '**Lemma 7.** *There exists a unitary operator* U *such that*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**引理 7.** *存在一个酉算符* U *使得*'
- en: '![ m+1 ∘ ------------- -1-- ∑ ⊗n k⟩ M-−--(m--+-1) ⊗n ⊗n U |ψm ⟩ = √M--- |0⟩
    |00⟩ |x + M |0⟩ |01⟩ |0⟩ =: |ψm+1 ⟩ k=1 ](img/file702.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![ m+1 ∘ ------------- -1-- ∑ ⊗n k⟩ M-−--(m--+-1) ⊗n ⊗n U |ψm ⟩ = √M--- |0⟩
    |00⟩ |x + M |0⟩ |01⟩ |0⟩ =: |ψm+1 ⟩ k=1 ](img/file702.jpg)'
- en: '*Proof.* The proof is constructive and shows precisely what the operator U
    looks like.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明。* 证明是构造性的，精确地展示了算符U的形态。'
- en: Construct the successive maps
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造连续的映射
- en: '| ![ ∑m ⟩ ∘ -------- &#124;ψ ⟩ = √-1-- &#124;0⟩⊗n &#124;00 ⟩ &#124;xk + M-−--m-&#124;0⟩⊗n
    &#124;01⟩ &#124;0⟩⊗n , m M k=1 M m ⟩ ∘ -------- ↦−→ √-1--∑ &#124;xm+1 ⟩ &#124;00⟩
    &#124;xk + M--−-m-&#124;xm+1 ⟩ &#124;01⟩ &#124;0⟩⊗n, M M km=1 ⟩ ∘ -------- ↦−→
    √-1--∑ &#124;xm+1 ⟩ &#124;00⟩ &#124;xk + M--−-m-&#124;xm+1 ⟩ &#124;01⟩ &#124;xm+1
    ⟩, M M km=1 ∘ -------- --1- ∑ m+1 ⟩ k⟩ M--−-m- m+1 ⟩ m+1 ⟩ ^ ⟩ ↦−→ √M--- &#124;x
    &#124;00⟩ &#124;x + M &#124;x &#124;11⟩ &#124;x =: &#124;ψm . k=1 ](img/file703.jpg)
    |'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![ ∑m ⟩ ∘ -------- &#124;ψ ⟩ = √-1-- &#124;0⟩⊗n &#124;00 ⟩ &#124;xk + M-−--m-&#124;0⟩⊗n
    &#124;01⟩ &#124;0⟩⊗n , m M k=1 M m ⟩ ∘ -------- ↦−→ √-1--∑ &#124;xm+1 ⟩ &#124;00⟩
    &#124;xk + M--−-m-&#124;xm+1 ⟩ &#124;01⟩ &#124;0⟩⊗n, M M km=1 ⟩ ∘ -------- ↦−→
    √-1--∑ &#124;xm+1 ⟩ &#124;00⟩ &#124;xk + M--−-m-&#124;xm+1 ⟩ &#124;01⟩ &#124;xm+1
    ⟩, M M km=1 ∘ -------- --1- ∑ m+1 ⟩ k⟩ M--−-m- m+1 ⟩ m+1 ⟩ ^ ⟩ ↦−→ √M--- &#124;x
    &#124;00⟩ &#124;x + M &#124;x &#124;11⟩ &#124;x =: &#124;ψm . k=1 ](img/file703.jpg)
    |'
- en: The first one is easily achieved by applying the operator ![( ) ⊗ni=1 Xxmi+1](img/file704.jpg)⊗I^(⊗2)
    ⊗I^(⊗n) to ![|ψm⟩](img/file705.jpg). The second step is realised with controlled
    gates using the second qubit of the ancilla register as control. The last one
    is trivial with a CNOT gate on the first ancilla qubit using the second ancilla
    qubit as control.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一步可以通过应用算符 ![( ) ⊗ni=1 Xxmi+1](img/file704.jpg)⊗I^(⊗2) ⊗I^(⊗n) 到 ![|ψm⟩](img/file705.jpg)
    来轻松实现。第二步是通过控制门，利用辅助寄存器的第二个量子比特作为控制来实现。最后一步通过在第一个辅助量子比特上使用CNOT门，以第二个辅助量子比特为控制实现，过程非常简单。
- en: Now define the unitary gate
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在定义这个单位门
- en: '![ ( √----------- ) ^U := √--1-----( M − m − 1 ----1-----) , M − m − 1 √ M
    − m − 1 ](img/file706.jpg)'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![ ( √----------- ) ^U := √--1-----( M − m − 1 ----1-----) , M − m − 1 √ M
    − m − 1 ](img/file706.jpg)'
- en: and note that its controlled (by the first ancilla qubit *a*[1]) version [a[1]]U
    acts as
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并且请注意，控制版本（由第一个辅助量子比特 *a*[1] 控制）[a[1]]U 的作用是
- en: '| [a[1]]U![&#124;00⟩](img/file707.jpg) | = ![&#124;00⟩](img/file708.jpg)*,*
    |'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| [a[1]]U![&#124;00⟩](img/file707.jpg) | = ![&#124;00⟩](img/file708.jpg)*,*
    |'
- en: '| [a[1]]U![&#124;11⟩](img/file709.jpg) | = ![---1----- √M--−-m--](img/file710.jpg)![&#124;1⟩](img/file711.jpg)⊗![(
    √ ----------- ) &#124;0⟩ + M − m − 1 &#124;1⟩](img/file712.jpg) = ![ √ -----------
    &#124;10⟩+---M--−-m-−-1-&#124;11⟩- √M--−-m--](img/file713.jpg)*.* |'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| [a[1]]U![&#124;11⟩](img/file709.jpg) | = ![---1----- √M--−-m--](img/file710.jpg)![&#124;1⟩](img/file711.jpg)⊗![(
    √ ----------- ) &#124;0⟩ + M − m − 1 &#124;1⟩](img/file712.jpg) = ![ √ -----------
    &#124;10⟩+---M--−-m-−-1-&#124;11⟩- √M--−-m--](img/file713.jpg)*.* |'
- en: Applying it to the ancilla register of ![ ⟩ |^ψm](img/file714.jpg) in Step 1
    (and leaving all other qubits unchanged) yields
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将其应用于步骤 1 中的辅助寄存器 ![ ⟩ |^ψm](img/file714.jpg)（并保持其他量子比特不变）将得到
- en: '|  | = I^(⊗n) ⊗ [a[1]]U⊗I^(⊗n)![ ⟩ &#124;^ψm](img/file715.jpg) |'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = I^(⊗n) ⊗ [a[1]]U⊗I^(⊗n)![ ⟩ &#124;^ψm](img/file715.jpg) |'
- en: '|  | = ![√-1-- M](img/file716.jpg)∑ [k=1]^m![&#124;xm+1 ⟩](img/file717.jpg)![
    &#124;00⟩](img/file718.jpg)![ ⟩ &#124;xk](img/file719.jpg) |'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = ![√-1-- M](img/file716.jpg)∑ [k=1]^m![&#124;xm+1 ⟩](img/file717.jpg)![
    &#124;00⟩](img/file718.jpg)![ ⟩ &#124;xk](img/file719.jpg) |'
- en: '|  | + ![∘ M--−-m-- ------- M](img/file720.jpg)![ ⟩ &#124;xm+1](img/file721.jpg)![
    { &#124;10⟩+ √M--−-m-−-1-&#124;11⟩} -------√--------------- M − m](img/file722.jpg)![
    ⟩ &#124;xm+1](img/file723.jpg) |'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | + ![∘ M--−-m-- ------- M](img/file720.jpg)![ ⟩ &#124;xm+1](img/file721.jpg)![
    { &#124;10⟩+ √M--−-m-−-1-&#124;11⟩} -------√--------------- M − m](img/file722.jpg)![
    ⟩ &#124;xm+1](img/file723.jpg) |'
- en: '|  | = ![√-1-- M](img/file724.jpg)∑ [k=1]^m![&#124;xm+1 ⟩](img/file725.jpg)![
    &#124;00⟩](img/file726.jpg)![ ⟩ &#124;xk](img/file727.jpg) |'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = ![√-1-- M](img/file724.jpg)∑ [k=1]^m![&#124;xm+1 ⟩](img/file725.jpg)![
    &#124;00⟩](img/file726.jpg)![ ⟩ &#124;xk](img/file727.jpg) |'
- en: '|  | + ![ 1 √---- M](img/file728.jpg)![ ⟩ &#124;xm+1](img/file729.jpg)![{ √
    ----------- } &#124;10⟩+ M − m − 1 &#124;11⟩](img/file730.jpg)![ ⟩ &#124;xm+1](img/file731.jpg)
    |'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | + ![ 1 √---- M](img/file728.jpg)![ ⟩ &#124;xm+1](img/file729.jpg)![{ √
    ----------- } &#124;10⟩+ M − m − 1 &#124;11⟩](img/file730.jpg)![ ⟩ &#124;xm+1](img/file731.jpg)
    |'
- en: We then flip the first ancilla qubit to 0 in the ![|10⟩](img/file732.jpg) case
    (easily achievable with SWAP and CNOT gates) and, regrouping the same ancilla
    terms together we obtain
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们在 ![|10⟩](img/file732.jpg) 的情况下将第一个辅助量子比特翻转为 0（可以通过 SWAP 和 CNOT 门轻松实现），并将相同的辅助项重新组合在一起，得到
- en: '![ m+∑1 ⟩ ⟩ ∘ ------------- ⟩ ⟩ √1-- |xm+1 |00⟩ |xk + M--−-(m-+-1) |xm+1 |11⟩
    |xm+1 . M k=1 M ](img/file733.jpg)'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![ m+∑1 ⟩ ⟩ ∘ ------------- ⟩ ⟩ √1-- |xm+1 |00⟩ |xk + M--−-(m-+-1) |xm+1 |11⟩
    |xm+1 . M k=1 M ](img/file733.jpg)'
- en: Resetting the registers as in ([7.5](#x1-1580005)) to obtain
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如同在 ([7.5](#x1-1580005)) 中所示，重置寄存器得到
- en: '![ ------------- 1 m∑+1 ⟩ ∘ M − (m + 1) √---- |0⟩⊗n |00⟩ |xk + ------------
    |0 ⟩⊗n |01⟩ |0⟩⊗n M k=1 M ](img/file734.jpg)'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![ ------------- 1 m∑+1 ⟩ ∘ M − (m + 1) √---- |0⟩⊗n |00⟩ |xk + ------------
    |0 ⟩⊗n |01⟩ |0⟩⊗n M k=1 M ](img/file734.jpg)'
- en: finishes the proof of the lemma.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成引理的证明。
- en: □
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: □
- en: 7.6 Hamiltonian Simulation
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6 哈密顿量模拟
- en: Hamiltonian encoding, popular in quantum machine learning, is inspired by the
    Schrödinger equation ([1.2.2](Chapter_1.xhtml#x1-370002)), which reads
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 哈密顿量编码，量子机器学习中的一个热门概念，灵感来自于薛定谔方程 ([1.2.2](Chapter_1.xhtml#x1-370002))，其表达式为
- en: '![ d|ψ-(t)⟩- iℏ dt = ℋ |ψ (t)⟩, ](img/file735.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![ d|ψ-(t)⟩- iℏ dt = ℋ |ψ (t)⟩, ](img/file735.jpg)'
- en: for some Hamiltonian ℋ, where ℏ is the Planck constant, and subject to some
    boundary condition at *t* = 0\. The solution to the equation reads
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些哈密顿量 ℋ，其中 ℏ 是普朗克常数，并且在 *t* = 0 时满足某些边界条件。该方程的解为
- en: '![ ( ) |ψ (t)⟩ = exp − iℋt-- |ψ(0)⟩. ℏ ](img/file736.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![ ( ) |ψ (t)⟩ = exp − iℋt-- |ψ(0)⟩. ℏ ](img/file736.jpg)'
- en: The idea of Hamiltonian encoding is to encode the initial data into the Hamiltonian ℋ.
    Consider a cloud of points X ∈ℳ[n,n](ℂ). If X is Hermitian, we can define the
    Hamiltonian matrix ℋ[X] := X, otherwise the augmented version
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 哈密顿量编码的思想是将初始数据编码到哈密顿量 ℋ 中。考虑一个点云 X ∈ℳ[n,n](ℂ)。如果 X 是厄米矩阵，我们可以定义哈密顿量矩阵 ℋ[X]
    := X，否则使用扩展版本
- en: '![ ( ) 0n,n X ℋX := ( † ) X 0n,n ](img/file737.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![ ( ) 0n,n X ℋX := ( † ) X 0n,n ](img/file737.jpg)'
- en: is Hermitian by construction.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 按照构造是厄米的。
- en: Our aim is, for a given precision level *𝜀*, to find a state ![ ⟩ |^ψ](img/file738.jpg)
    (or an algorithm generating this state) such that
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是，对于给定的精度级别*𝜀*，找到一个态![ ⟩ |^ψ](img/file738.jpg)（或生成此态的算法），使得
- en: '![∥ ⟩ ∥ ∥∥|^ψ − |ψ (t)⟩∥∥ ≤ 𝜀, ](img/file739.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![∥ ⟩ ∥ ∥∥|^ψ − |ψ (t)⟩∥∥ ≤ 𝜀, ](img/file739.jpg)'
- en: for some given norm ∥⋅∥, where ![|ψ (t)⟩](img/file740.jpg) solves the Schrödinger
    equation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某个给定的范数∥⋅∥，其中![|ψ (t)⟩](img/file740.jpg)解了薛定谔方程。
- en: An important bottleneck of this method is the computation of exp![(ℋXt )](img/file741.jpg)
    (where we ignore the ratio −i*∕*ℏ for simplicity). Suppose that the Hamiltonian ℋ[X]
    can be written as a sum
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的一个重要瓶颈是计算exp![(ℋXt)](img/file741.jpg)（为简便起见我们忽略了比率−i*∕*ℏ）。假设哈密顿量ℋ[X]可以写成和的形式
- en: '![ ∑p ℋX = ℋi i=1 ](img/file742.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑p ℋX = ℋi i=1 ](img/file742.jpg)'
- en: of easy-to-compute Hamiltonians (ℋ[i])[i=1,…,p]. If the latter do not commute,
    then the identity
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由易于计算的哈密顿量（ℋ[i]）[i=1,…,p]组成。如果后者不对易，那么身份
- en: '![ ( ∑p ) ∏p exp ℋit = eℋit i=1 i=1 ](img/file743.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![ ( ∑p ) ∏p exp ℋit = eℋit i=1 i=1 ](img/file743.jpg)'
- en: does not hold, but the first-order Suzuki-Trotter  [[220](Biblography.xhtml#XNaomichi-Suzuki), [286](Biblography.xhtml#XTrotter)]
    formula (used by Lloyd in  [[191](Biblography.xhtml#XLloydsUniv)])
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 不成立，但一阶铃木-特罗特[[220](Biblography.xhtml#XNaomichi-Suzuki)，[286](Biblography.xhtml#XTrotter)]公式（Lloyd在[[191](Biblography.xhtml#XLloydsUniv)]中使用）
- en: '![ ( ∑p ) ∏p exp ℋit = eℋit + 𝒪 (t2), i=1 i=1 ](img/file744.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![ ( ∑p ) ∏p exp ℋit = eℋit + 𝒪 (t2), i=1 i=1 ](img/file744.jpg)'
- en: for *t* small enough, allows us to bypass this issue.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于足够小的*t*，我们可以绕过这个问题。
- en: Indeed, even if *t* is not so small, we may pick *δ >* 0 small enough and use
    the factorisation
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，即使*t*并不那么小，我们也可以选择*δ >* 0足够小并使用分解
- en: '![ ⌊ ( ) ⌋ ( ∑p ) ∑ t∕δ [ p∏ ]t∕δ exp ℋit = ⌈exp ( ℋiδ) ⌉ = eℋiδ + 𝒪 (δ2) ,
    i=1 i=1,...,p i=1 ](img/file745.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊ ( ) ⌋ ( ∑p ) ∑ t∕δ [ p∏ ]t∕δ exp ℋit = ⌈exp ( ℋiδ) ⌉ = eℋiδ + 𝒪 (δ2) ,
    i=1 i=1,...,p i=1 ](img/file745.jpg)'
- en: which has a small error (albeit with the caveat that the operation needs to
    be computed many times). In general, any *n*-qubit Hamiltonian ℋ can be decomposed
    in at most 4^n elementary Hamiltonians (of the Pauli form) as
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有较小的误差（尽管需要多次计算该操作）。一般来说，任何*n*-量子比特哈密顿量ℋ都可以分解为最多4^n个基础哈密顿量（帕利形式），如
- en: '![ ∑ ( ⊗n ) ⊗n ℋ = -1- Tr σi ℋ σi , 2n i,...,i∈{I,X,Y,Z} k=1 k k=1 k 1 n ](img/file746.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑ ( ⊗n ) ⊗n ℋ = -1- Tr σi ℋ σi , 2n i,...,i∈{I,X,Y,Z} k=1 k k=1 k 1 n ](img/file746.jpg)'
- en: where *σ*[i[k]] is a Pauli operator. Of course, 4^n appeals to Pauli operators
    may be too large in general, but local features of the Hamiltonian (such as sparse  [[34](Biblography.xhtml#XBerrySparse)]
    or diluted or degree-reducted  [[8](Biblography.xhtml#XAharonovZhou)] Hamiltonians)
    help reduce the complexity.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*σ*[i[k]]是一个帕利算符。当然，4^n对帕利算符的要求通常可能过大，但哈密顿量的局部特性（如稀疏[[34](Biblography.xhtml#XBerrySparse)]、稀释或度数降低的[[8](Biblography.xhtml#XAharonovZhou)]哈密顿量）有助于减少复杂度。
- en: '**Remark:** An alternative approach, especially for QML problems analysed in
    the next chapter, is to encode the data using Quantum Random Access Memory (QRAM),
    essentially with the bucket-brigade algorithm developed in  [[110](Biblography.xhtml#XGiovannettiQRAM)]
    (see also  [[140](Biblography.xhtml#XHongQRAM), [15](Biblography.xhtml#XMoscaQRAM)]),
    and we refer the interested reader to  [[65](Biblography.xhtml#XCilibertoQRAM_Summary)]
    for a good summary of the current state-of-the-art algorithms.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**备注：** 另一种方法，尤其是对于下一章分析的量子机器学习（QML）问题，是使用量子随机存取存储器（QRAM）对数据进行编码，本质上使用了由[[110](Biblography.xhtml#XGiovannettiQRAM)]开发的桶传递算法（参见[[140](Biblography.xhtml#XHongQRAM)，[15](Biblography.xhtml#XMoscaQRAM)]），我们将感兴趣的读者引导至[[65](Biblography.xhtml#XCilibertoQRAM_Summary)]，以了解当前最先进算法的良好总结。'
- en: Encoding classical data into a quantum computer has seen many advances recently
    and several competing techniques are now available depending on the problem under
    investigation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将经典数据编码到量子计算机中，最近取得了许多进展，现在有多种竞争性的技术可供选择，具体使用哪种技术取决于正在研究的问题。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the concept of a parameterised quantum circuit
    as a generic QML model. PQCs can be trained and used as discriminative and generative
    QML models as well as optimisers. They can also be used to encode classical data
    samples into the corresponding quantum states.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了参数化量子电路的概念，作为通用的QML模型。PQC可以训练并用作判别和生成QML模型以及优化器。它们还可以用来将经典数据样本编码为相应的量子态。
- en: We considered several popular data encoding methods. Arguably, the simplest
    and easiest to implement is the angle encoding algorithm – we shall use this approach
    in the next chapter. Other methods also have their strong points, although they
    tend to be either more demanding in terms of the hardware capabilities or better
    suited for some niche applications.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑了几种流行的数据编码方法。可以说，最简单且最易实现的方法是角度编码算法——我们将在下一章中使用这种方法。其他方法也有其优点，尽管它们通常在硬件要求方面更为苛刻，或更适合某些特定应用。
- en: In the next chapter, we apply what we learned so far to the task of building
    the quantum neural network trained as a classifier and compare its performance
    on the binary classification problem with standard classical machine learning
    models.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将应用到目前为止所学的内容，构建一个作为分类器训练的量子神经网络，并将其在二分类问题上的表现与标准经典机器学习模型进行比较。
- en: Join our book’s Discord space
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加入我们书籍的 Discord 空间
- en: 'Join our Discord community to meet like-minded people and learn alongside more
    than 2000 members at: [https://packt.link/quantum](https://packt.link/quantum)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区，与志同道合的人交流，并与超过2000名成员一起学习，网址：[https://packt.link/quantum](https://packt.link/quantum)
- en: '![PIC](img/file1.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file1.png)'
