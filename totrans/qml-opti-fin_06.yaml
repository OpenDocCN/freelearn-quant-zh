- en: '7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parameterised Quantum Circuits and Data Encoding
  prefs: []
  type: TYPE_NORMAL
- en: Having built the quantum hardware, how can we use it to the maximum effect given
    its scale, connectivity, and fidelity rate? This question can be best answered
    if we split it into two parts. First, what problems are in principle solvable
    on NISQ computers? Second, how do we encode classical data into quantum states?
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of this book focuses on the first part: problems and models that can
    be formulated in a way that doesnâ€™t require a massive number of qubits and that
    are, at least to some extent, noise tolerant. The first step in this direction
    is the concept of the Parameterised Quantum Circuit (PQC) as a generic quantum
    machine learning model.'
  prefs: []
  type: TYPE_NORMAL
- en: The second part â€“ data encoding â€“ is equally important and relies on several
    practical methods described in this chapter. This is an active area of research
    where we can expect most of the progress to come from the quantum software side.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 Parameterised Quantum Circuits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have seen how to combine quantum gates to form arbitrarily wide and deep
    quantum circuits. A quantum circuit transforms an initial quantum stateÂ ![|ÏˆâŸ©](img/file659.jpg)
    into a final quantum state ![|Ïˆ â€²âŸ©](img/file660.jpg) by applying a sequence of
    unitary operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![&#124;Ïˆâ€²âŸ© = U (ğœƒ )...U (ğœƒ )U (ğœƒ ) &#124;Ïˆ âŸ©. m m 2 2 1 1 ](img/file661.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: Here, (U[i])[i=1,â€¦,m] and (ğœƒ[i])[i=1,â€¦,m] denote respectively the individual
    gates and the associated vectors of gate parameters. Some gates may be *fixed*
    (e.g., a two-qubit CNOT gate viewed as a controlled rotation of the target qubit
    state around the *x*-axis by a fixed angle *ğœƒ* = *Ï€*) while some gates may be
    *adjustable* (e.g., a one-qubit R[X](*ğœƒ*) gate that rotates the qubit state around
    *x*-axis by an arbitrary angle *ğœƒ* âˆˆ [âˆ’*Ï€,Ï€*]).
  prefs: []
  type: TYPE_NORMAL
- en: Once the final quantum state ![ â€² |Ïˆ âŸ©](img/file662.jpg) is constructed, the
    individual qubits can be measured. After measurement the qubit states stay the
    same in the basis in which they were measured, which we always assume to be the
    standard computational basis unless explicitly specified otherwise. Therefore,
    the final output of running the quantum circuit and then measuring the qubits
    (not necessarily all qubits have to be measured) is a classical bitstring.
  prefs: []
  type: TYPE_NORMAL
- en: What we just described is a parameterised quantum circuit schematically shown
    in FigureÂ [7.1](#7.1). The PQC can be used in many different ways. First of all,
    let us note that the PQC can be *trained*. Training the PQC has the meaning of
    finding an optimal set of adjustable parameters (the vectors ğœƒ[1]*,â€¦,*ğœƒ[m] above,
    for example) given the overall PQC *ansatz* (architecture). The meaning of "optimal"
    is problem dependent but generally means a configuration of adjustable parameters
    that ensures maximum closeness of the final quantum state ![ â€² |Ïˆ âŸ©](img/file663.jpg)
    to some desired target quantum state that corresponds to a particular probability
    distribution we aim to encode.
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 7.1: Schematic representation of a Parameterised Quantum Circuit.
    ](img/file664.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 7.1: Schematic representation of a Parameterised Quantum Circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following chapters, we will see how PQCs can be used as discriminative
    ML models (ChapterÂ [8](Chapter_8.xhtml#x1-1620008)), as generative ML models (ChapterÂ [9](Chapter_9.xhtml#x1-1850009)),
    and as optimisers (ChaptersÂ [10](Chapter_10.xhtml#x1-20200010) andÂ [11](Chapter_11.xhtml#x1-21700011)):'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the Variational Quantum Eigensolver, a PQC is used to construct
    the final quantum state ![ â€² |Ïˆ âŸ©](img/file665.jpg) that is close to the eigenstate
    of the problem Hamiltonian that corresponds to the smallest eigenvalue (the ground
    state energy that is linked to the minimum of the cost function).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we build a quantum discriminative model â€“ a Quantum Neural Network trained
    as a classifier â€“ we are interested in measuring only a handful of qubits (or
    even just a single qubit). This should give us the binary representation of the
    "class label" for the given sample. The input (initial quantum state ![|Ïˆ âŸ©](img/file666.jpg))
    encodes the sample we want to classify.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When our objective is to build a quantum generative model â€“ the Quantum Circuit
    Born Machine â€“ we measure all qubits. This gives us a bitstring that is a generated
    sample from the probability distribution encoded in the final quantum state ![|Ïˆ
    â€²âŸ©](img/file667.jpg) constructed by the PQC. The initial state is initialised
    as ![|0âŸ©](img/file668.jpg)^(âŠ—n).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PQCs are invariably trained using hybrid quantum-classical protocols. The hybrid
    approach is shown schematically in FigureÂ [7.2](#7.2) and consists of three components:
    the user, the classical computer, and the quantum computerÂ Â [[29](Biblography.xhtml#XBenedetti2019)].'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-151003r2: Training PQCs â€“ schematic process. ](img/file669.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 7.2: Training PQCs â€“ schematic process.'
  prefs: []
  type: TYPE_NORMAL
- en: The user provides the model for the problem; the classical computer pre-processes
    the data and produces the initial set of parameters for the PQC; the quantum computer
    runs the PQC by preparing the quantum state as prescribed by the PQC and by performing
    measurements. Measurement outcomes are then post-processed by the classical computer,
    which updates the model parameters as per the chosen training algorithm (backpropagation
    of error with gradient descent, non-differentiable learning method, etc.) The
    overall algorithm is run in a closed loop between the classical and quantum computers.
  prefs: []
  type: TYPE_NORMAL
- en: PQC is one of the most successful frameworks for applying NISQ computers to
    solving non-trivial real-world problems. It follows the paradigm of a hybrid quantum-classical
    computational protocol and can be used for experimenting with the wide range of
    quantum machine learning models.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 Angle Encoding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us go back to the Bloch sphere (FigureÂ [7.2](#x1-1520002)) that visualises
    the canonical representation of the qubit state â€“ a unit vector in the 2-dimensional
    complex vector space:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ âŒŠ ( ) âŒ‹ cos ğœƒ- &#124;ÏˆâŸ© = &#124;&#124; (2 ) &#124;&#124;. âŒˆeiÏ•sin ğœƒ- âŒ‰
    2 ](img/file670.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: The angles *ğœƒ* âˆˆ [0*,Ï€*] and *Ï•* âˆˆ [0*,*2*Ï€*] uniquely determine the position
    of the qubit on the unit sphere. Since we need two continuous variables to specify
    the qubit state, a single qubit can encode two real-valued features.
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 7.3: Quantum state |Ïˆ âŸ© on the Bloch sphere. ](img/file672.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 7.3: Quantum state ![|Ïˆ âŸ©](img/file671.jpg) on the Bloch sphere.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.2.1 The basic encoding scheme
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can illustrate this with the following schematic example: let us assume
    that we have an 8-feature dataset consisting ofÂ *N* samples and that all features
    *X*[1]*,â€¦,X*[8] are real-valued and such that their extremal values, *X*[i]^(min)
    and *X*[i]^(max), *i* = 1*,â€¦,*8, can be computed. Then, for every sample *j* =
    1*,â€¦,N* from the dataset, we can establish a one-to-one mapping between the values
    of the featuresÂ *X*[i]^j and the corresponding rotation anglesÂ *ğœƒ*[i]^j:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ j Xj âˆ’ Xmin ğœƒi = --miax----iminÏ€, X i âˆ’ X i ](img/file673.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: where *X*[i]^(min) := min[j]*X*[i]^j and *X*[i]^(max) := max[j]*X*[i]^j. Rotation
    angles *ğœƒ*[i]^j generalise angles *ğœƒ* and *Ï•* in FigureÂ [7.2](#x1-1520002).
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 7.4: Feature encoding â€“ rotations around y axis. States of qubits
    q1,â€¦,q4 are shown on the same Bloch sphere. The initial state of all qubits is
    |0âŸ© and the end states after rotations around the y-axis by angles ğœƒ1,â€¦,ğœƒ4 are
    denoted asÂ A, B, C, andÂ D. ](img/file675.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 7.4: Feature encoding â€“ rotations around y axis. States of qubits q[1],â€¦,q[4]
    are shown on the same Bloch sphere. The initial state of all qubits is ![|0âŸ©](img/file674.jpg)
    and the end states after rotations around the y-axis by angles ğœƒ[1],â€¦,ğœƒ[4] are
    denoted asÂ A, B, C, andÂ D.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The 8-feature sample can be encoded in a 4-qubit state (unentangled). For example,
    starting with four quantum registers initialised as ![|0âŸ©](img/file676.jpg) in
    the computational basis, we can first perform rotations around the *y*-axis: rotation
    by *ğœƒ*[1] for qubit 1, rotation by *ğœƒ*[2] for qubit 2, and so on. This is shown
    schematically in FigureÂ [7.2.1](#x1-1530001) where qubits move from their initial
    state ![|0âŸ©](img/file677.jpg) to states *A*, *B*, *C*, and *D*.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.2.2 Encoding two features per quantum register
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After that, we encode the remaining features by performing rotations around
    the *z*-axis: rotation by *ğœƒ*[5] for qubit 1, rotation by *ğœƒ*[6] for qubit 2,
    and so on as shown in FigureÂ [7.5](#7.5).'
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 7.5: Feature encoding â€“ rotations around the z-axis. The initial states
    of qubits q1,â€¦,q4 are A,B,C,D. After rotation around the z-axis by angles ğœƒ5,â€¦,ğœƒ8,
    the final qubit states areÂ E,F,G,H. ](img/file678.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 7.5: Feature encoding â€“ rotations around the z-axis. The initial states
    of qubits q[1],â€¦,q[4] are A,B,C,D. After rotation around the z-axis by angles
    ğœƒ[5],â€¦,ğœƒ[8], the final qubit states areÂ E,F,G,H.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The qubit states move fromÂ *A* toÂ *E*, fromÂ *B* toÂ *F*, fromÂ *C* toÂ *G*, and
    fromÂ *D* toÂ *H*. The corresponding quantum circuit looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 7.6: 4-qubit quantum circuit for 8-feature sample encoding. ](img/file679.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 7.6: 4-qubit quantum circuit for 8-feature sample encoding.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.2.3 Mapping a classical data sample into a quantum state
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can summarise the angle encoding scheme as follows. For the classical data
    sample *X*^j := (*X*[1]^j*,â€¦,X*[K]^j) âˆˆâ„^K, *j* = 1*,â€¦,N*, angle encoding works
    by constructing the map
  prefs: []
  type: TYPE_NORMAL
- en: '![ K ( ( j) ( j) ) j âŠ— ğœƒi ğœƒi X â†¦âˆ’â†’ cos 2 |0âŸ©+ sin 2 |1âŸ© , i=1 ](img/file680.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'where angles (*ğœƒ*[i]^j)[i=1,â€¦,K;j=1,â€¦,N] are given by the expressionÂ ([7.2.1](#x1-1530001)).
    This scheme only requires one rotation gate for each qubit, hence encodes as many
    features as the number of qubits. However, we know that a single quantum register
    can encode two real variables. The following scheme maps the classical sample
    into the quantum state with the help of an extra phase gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ âŠ—K ( ( ğœƒj ) (ğœƒj ) ) Xj â†¦âˆ’â†’ cos -2iâˆ’1 |0âŸ©+ exp (iğœƒ2i)sin -2iâˆ’1 |1âŸ© . i=1
    2 2 ](img/file681.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This scheme allows us to encodeÂ 2*n* features withÂ *n* qubits.
  prefs: []
  type: TYPE_NORMAL
- en: '*n* quantum registers have capacity to encode 2*n* continuous features with
    just two layers of one-qubit gates.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.3 Amplitude Encoding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far we have not utilised the information encoding possibilities provided
    by entanglement although, in principle, most of the information in large quantum
    systems can be stored in correlations. In the case of our 8-feature dataset example
    considered in the previous section, we can reduce the number of necessary qubits
    to just three if we use entanglement. The first six rotation angles *ğœƒ*[1]*,â€¦,ğœƒ*[6]
    can still be used for the single-qubit rotations R[Y]*,*R[Z]. The last two, *ğœƒ*[7]
    and *ğœƒ*[8], can be used for controlled rotations that entangle qubits 1 and 2
    and qubits 2 and 3 as shown in FigureÂ [7.7](#7.7):'
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 7.7: 3-qubit quantum circuit for 8-feature sample encoding. ](img/file682.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 7.7: 3-qubit quantum circuit for 8-feature sample encoding.'
  prefs: []
  type: TYPE_NORMAL
- en: In principle, since the *n*-qubit state can be uniquely described by specifying
    2^n probability amplitudes, we only need *n* qubits to encode 2^n features. However,
    this superdense encoding is not always practical or desirable. The *amplitude*
    *encoding* was used in the seminal work by Harrow, Hassidim, and LloydÂ Â [[126](Biblography.xhtml#XHHL2009)],
    but obtaining the amplitude encoding is a non-trivial task for problems of realistic
    size and this, usually, is the main bottleneck for many quantum algorithmsÂ Â [[184](Biblography.xhtml#XLandman2021)].
  prefs: []
  type: TYPE_NORMAL
- en: The amplitude encoding can be formalised in the following way. Consider an *N*-dimensional
    (with *N* = 2^n) data point x := (*x*[1]*,â€¦,x*[N]) âˆˆâ„‚^N. We can associate quantum
    amplitudes to the coordinates as
  prefs: []
  type: TYPE_NORMAL
- en: '![ âˆ‘N |ÏˆxâŸ© = -1-- xi |iâŸ©, âˆ¥xâˆ¥ i=1 ](img/file683.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where âˆ¥xâˆ¥ := âˆ‘ [i=1]^N|*x*[i]|Â² is the normalisation factor. We can therefore
    encode the dataset D := (xÂ¹*,â€¦,*x^M) consisting ofÂ *M* points inÂ â„^N as
  prefs: []
  type: TYPE_NORMAL
- en: '![ p 1 2âˆ‘ -- |DâŸ© = C-- xi |iâŸ©, D i=1 ](img/file684.jpg)'
  prefs: []
  type: TYPE_IMG
- en: for some integerÂ *p*, where
  prefs: []
  type: TYPE_NORMAL
- en: '![-- -- 1 1 2 2 M M MN x = (xi)i=1,...,2p = (x1,...,xN ,x1,...,x N,...,x1 ,...,x
    N ) âˆˆ â„ ](img/file685.jpg)'
  prefs: []
  type: TYPE_IMG
- en: is the concatenation of all the data points andÂ *C*[D] is a normalisation constant.
    Here the constraint is hence that 2^p â‰¥ *MN*, namely *p* â‰¥ log [2](*MN*). Note
    that there may again be some sparsity in the case where 2^p *> MN*.
  prefs: []
  type: TYPE_NORMAL
- en: The clear advantage is that it can storeÂ 2^n features with onlyÂ *n* qubits,
    but unfortunately has a depth ğ’ª(2*n*) and is hence hard to build.
  prefs: []
  type: TYPE_NORMAL
- en: With the amplitude encoding, *n* quantum registers have capacity to encode 2^n
    continuous features. However, this requires construction of the deep quantum circuits
    with the circuit depth growing as ğ’ª(2*n*). This solution may not be practical
    for NISQ computers when dealing with a large number of features.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Binary Inputs into Basis States
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider a real number *x* âˆˆâ„ approximated with the binary representation
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ( ) ğ”¦âˆ‘âˆ’1 âˆ‘ğ”¡ x â‰ˆ ^x = (x ğ”¦,xğ”¦âˆ’1,â‹…â‹…â‹… ,xâˆ’ğ”¡) := (âˆ’ 1)xğ”¦( xj2j + x âˆ’j2âˆ’j) j=0
    j=1 â†¦âˆ’ â†’ &#124;xğ”¦xğ”¦âˆ’1â‹…â‹…â‹…xâˆ’ğ”¡âŸ© =: &#124;xâŸ©, ](img/file686.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: for some non-negative integers ğ”¦*,*ğ”¡, where *x*[ğ”¦] âˆˆ{0*,*1} accounts for the
    sign ofÂ *x* and (*x*[j])[j=0,â€¦,ğ”¦âˆ’1] âˆˆ{0*,*1}^(ğ”¦) and (*x*[j])[j=âˆ’1,â€¦,âˆ’ğ”¡] âˆˆ{0*,*1}^(ğ”¡)
    represent respectively the integer and decimal parts ofÂ *x*. Consider now a vector
    x := (*x*Â¹*,â€¦,x*^N) âˆˆâ„^N. We can concatenate all the binary approximations *x*Â¹*,â€¦,**x*^N
    into one vector
  prefs: []
  type: TYPE_NORMAL
- en: '![( 1 1 1 N N N ) (1+ğ”¦+ğ”¡)N xğ”¦,xğ”¦âˆ’ 1,â‹…â‹…â‹… ,xâˆ’ğ”¡,â‹…â‹…â‹… ,xğ”¦ ,x ğ”¦âˆ’1,â‹…â‹…â‹… ,xâˆ’ ğ”¡ âˆˆ {0,1}
    ](img/file687.jpg)'
  prefs: []
  type: TYPE_IMG
- en: to obtain a quantum state representation with (1 + ğ”¦ + ğ”¡)*N* qubits of the form
  prefs: []
  type: TYPE_NORMAL
- en: '![ 1 1 1 N N N âŸ© |xğ”¦xğ”¦âˆ’1â‹…â‹…â‹…xâˆ’ğ”¡ â‹…â‹…â‹…x ğ”¦ ,xğ”¦âˆ’1â‹…â‹…â‹…xâˆ’ğ”¡ . ](img/file688.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since the vector thus obtained only containsÂ 0 andÂ 1, starting from the quantum
    state ![|0âŸ©](img/file689.jpg)^(âŠ—(1+ğ”¦+ğ”¡)N), we only need to apply the NOT gateÂ X
    whenever the corresponding value is equal to one, so that the encoding circuit
    simply reads
  prefs: []
  type: TYPE_NORMAL
- en: '![ âŠ—(1+ğ”¦+ğ”¡)N âŠ—N âŠ— ğ”¦ xl âŠ—(1+ğ”¦+ğ”¡)N |0âŸ© â†¦âˆ’ â†’ X k |0âŸ© . l=1 k=âˆ’ğ”¡ ](img/file690.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While the algorithm is straightforward and only requires the use of the single-qubit
    quantum gateÂ X, it requires a large number of qubits and is in general not efficient
    in practice. Indeed, for a given dimensionÂ *N*, there are 2^N possible basis states.
    If a dataset contains onlyÂ *M* points withÂ *M* being much smaller thanÂ *N*, the
    quantum representation will therefore be sparse.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example:** Consider a dataset D = (*x*Â¹*,x*Â²) with *x*Â¹*,x*Â² âˆˆ [âˆ’2*,*2],
    each approximated with four qubits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ 1 1( 1 1 ) x1 â‰ˆ (âˆ’ 1)x1(20x10 + 2âˆ’ 1x1âˆ’1 + 2âˆ’2x1âˆ’2) = (âˆ’ 1)x1 x10 +-x1âˆ’1
    +-x1âˆ’ 2 2 4 ](img/file691.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '![ 2 2 ( 1 1 ) x2 â‰ˆ (âˆ’ 1)x1(20x20 + 2âˆ’1x2âˆ’ 1 + 2âˆ’2x2âˆ’2) = (âˆ’ 1)x1 x20 +-x2âˆ’1
    +-x2âˆ’2 , 2 4 ](img/file692.jpg)'
  prefs: []
  type: TYPE_IMG
- en: with *x*[k]^i âˆˆ{0*,*1} for each *i* = 1*,*2 and *k* = âˆ’2*,*âˆ’1*,*0*,*1\. Their
    quantum embeddings therefore read ![|x1x1x1 x1 âŸ© 1 0 âˆ’ 1 âˆ’2](img/file693.jpg)
    and ![|x2x2x2 x2 âŸ© 1 0 âˆ’1 âˆ’ 2](img/file694.jpg), and the quantum circuit to encode
    the dataset therefore takes the form
  prefs: []
  type: TYPE_NORMAL
- en: '![ [( 1 1 1 1 ) ( 2 2 2 2 )] |0âŸ©âŠ—8 â†¦âˆ’â†’ Xx1 âŠ— Xx0 âŠ— Xxâˆ’1 âŠ— Xxâˆ’2 âŠ— Xx1 âŠ— Xx0
    âŠ— Xxâˆ’1 âŠ— Xxâˆ’2 |0âŸ©âŠ—8\. ](img/file695.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 7.5 Superposition Encoding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As developed inÂ Â [[287](Biblography.xhtml#XTrugenberger2001),Â [294](Biblography.xhtml#XVentura2000)],
    it is possible to build such a superposition of data in time linear in the number
    of points and features. We consider again a dataset D := (xÂ¹*,â€¦,*x^M), with x^k
    := (*x*[1]^k*,â€¦,x*[n]^k) âˆˆ{0*,*1}^n for each *k* = 1*,â€¦,M*. We use a quantum system
    of the form
  prefs: []
  type: TYPE_NORMAL
- en: '![|Ïˆ0âŸ© := |0âŸ©âŠ—n |00âŸ© |0âŸ©âŠ—n , ](img/file696.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where the left-most part withÂ *n* qubits is called the loading register while
    the right-most one (also withÂ *n* qubits) is the storage register. The middle
    one is an ancilla register that will be used to control manipulations between
    the loading and storage registers. The encoding algorithm works recursively. We
    first apply an Hadamard gate to the second ancilla qubit and store the first data
    point xÂ¹ into the storage register. Since
  prefs: []
  type: TYPE_NORMAL
- en: '![(âŠ— n ) Xx1i |0âŸ©âŠ—n = |x1 â‹…â‹…â‹…x1âŸ© = |x1âŸ©, i=1 1 n ](img/file697.jpg)'
  prefs: []
  type: TYPE_IMG
- en: this can be achieved (after the Hadamard operation) by applying the unitary
    operator
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( n ) IâŠ—n âŠ— IâŠ— H âŠ— âŠ— Xx1i i=1 ](img/file698.jpg)'
  prefs: []
  type: TYPE_IMG
- en: controlled with the second ancilla qubit, and the resulting quantum state reads
  prefs: []
  type: TYPE_NORMAL
- en: '![ âŠ—n âŠ—n âŠ—n 1âŸ© |Ïˆ âŸ© := |0âŸ©--|0âˆš0âŸ©-|0âŸ©---+ |0âŸ©---|âˆš01âŸ© |x-. 1 2 2 ](img/file699.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This can easily be turned (see the proof of LemmaÂ [7](#x1-158003r7) below) into
  prefs: []
  type: TYPE_NORMAL
- en: '![ âŠ—n 1âŸ© âŠ—n âŠ—n |Ïˆ âŸ© = |0âŸ©--|âˆš00âŸ© |x--+ |0âŸ©---|0âˆš1âŸ©-|0âŸ©---. 1 2 2 ](img/file700.jpg)'
  prefs: []
  type: TYPE_IMG
- en: AfterÂ *m* steps, we arrive at a quantum state of the form
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ 1 âˆ‘m âŸ© âˆ˜ M--âˆ’-m-- &#124;Ïˆm âŸ© := âˆš--- &#124;0âŸ©âŠ—n &#124;00âŸ© &#124;xk + -------
    &#124;0âŸ©âŠ—n &#124;01 âŸ© &#124;0 âŸ©âŠ—n . M k=1 M ](img/file701.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'The following lemma guarantees the validity of the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lemma 7.** *There exists a unitary operator* U *such that*'
  prefs: []
  type: TYPE_NORMAL
- en: '![ m+1 âˆ˜ ------------- -1-- âˆ‘ âŠ—n kâŸ© M-âˆ’--(m--+-1) âŠ—n âŠ—n U |Ïˆm âŸ© = âˆšM--- |0âŸ©
    |00âŸ© |x + M |0âŸ© |01âŸ© |0âŸ© =: |Ïˆm+1 âŸ© k=1 ](img/file702.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Proof.* The proof is constructive and shows precisely what the operatorÂ U
    looks like.'
  prefs: []
  type: TYPE_NORMAL
- en: Construct the successive maps
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![ âˆ‘m âŸ© âˆ˜ -------- &#124;Ïˆ âŸ© = âˆš-1-- &#124;0âŸ©âŠ—n &#124;00 âŸ© &#124;xk + M-âˆ’--m-&#124;0âŸ©âŠ—n
    &#124;01âŸ© &#124;0âŸ©âŠ—n , m M k=1 M m âŸ© âˆ˜ -------- â†¦âˆ’â†’ âˆš-1--âˆ‘ &#124;xm+1 âŸ© &#124;00âŸ©
    &#124;xk + M--âˆ’-m-&#124;xm+1 âŸ© &#124;01âŸ© &#124;0âŸ©âŠ—n, M M km=1 âŸ© âˆ˜ -------- â†¦âˆ’â†’
    âˆš-1--âˆ‘ &#124;xm+1 âŸ© &#124;00âŸ© &#124;xk + M--âˆ’-m-&#124;xm+1 âŸ© &#124;01âŸ© &#124;xm+1
    âŸ©, M M km=1 âˆ˜ -------- --1- âˆ‘ m+1 âŸ© kâŸ© M--âˆ’-m- m+1 âŸ© m+1 âŸ© ^ âŸ© â†¦âˆ’â†’ âˆšM--- &#124;x
    &#124;00âŸ© &#124;x + M &#124;x &#124;11âŸ© &#124;x =: &#124;Ïˆm . k=1 ](img/file703.jpg)
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: The first one is easily achieved by applying the operator ![( ) âŠ—ni=1 Xxmi+1](img/file704.jpg)âŠ—I^(âŠ—2)
    âŠ—I^(âŠ—n) to ![|ÏˆmâŸ©](img/file705.jpg). The second step is realised with controlled
    gates using the second qubit of the ancilla register as control. The last one
    is trivial with a CNOT gate on the first ancilla qubit using the second ancilla
    qubit as control.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now define the unitary gate
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![ ( âˆš----------- ) ^U := âˆš--1-----( M âˆ’ m âˆ’ 1 ----1-----) , M âˆ’ m âˆ’ 1 âˆš M
    âˆ’ m âˆ’ 1 ](img/file706.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: and note that its controlled (by the first ancilla qubitÂ *a*[1]) version [a[1]]U
    acts as
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| [a[1]]U![&#124;00âŸ©](img/file707.jpg) | = ![&#124;00âŸ©](img/file708.jpg)*,*
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [a[1]]U![&#124;11âŸ©](img/file709.jpg) | = ![---1----- âˆšM--âˆ’-m--](img/file710.jpg)![&#124;1âŸ©](img/file711.jpg)âŠ—![(
    âˆš ----------- ) &#124;0âŸ© + M âˆ’ m âˆ’ 1 &#124;1âŸ©](img/file712.jpg) = ![ âˆš -----------
    &#124;10âŸ©+---M--âˆ’-m-âˆ’-1-&#124;11âŸ©- âˆšM--âˆ’-m--](img/file713.jpg)*.* |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Applying it to the ancilla register ofÂ ![ âŸ© |^Ïˆm](img/file714.jpg) in StepÂ 1
    (and leaving all other qubits unchanged) yields
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|  | = I^(âŠ—n) âŠ— [a[1]]UâŠ—I^(âŠ—n)![ âŸ© &#124;^Ïˆm](img/file715.jpg) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = ![âˆš-1-- M](img/file716.jpg)âˆ‘ [k=1]^m![&#124;xm+1 âŸ©](img/file717.jpg)![
    &#124;00âŸ©](img/file718.jpg)![ âŸ© &#124;xk](img/file719.jpg) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | + ![âˆ˜ M--âˆ’-m-- ------- M](img/file720.jpg)![ âŸ© &#124;xm+1](img/file721.jpg)![
    { &#124;10âŸ©+ âˆšM--âˆ’-m-âˆ’-1-&#124;11âŸ©} -------âˆš--------------- M âˆ’ m](img/file722.jpg)![
    âŸ© &#124;xm+1](img/file723.jpg) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = ![âˆš-1-- M](img/file724.jpg)âˆ‘ [k=1]^m![&#124;xm+1 âŸ©](img/file725.jpg)![
    &#124;00âŸ©](img/file726.jpg)![ âŸ© &#124;xk](img/file727.jpg) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | + ![ 1 âˆš---- M](img/file728.jpg)![ âŸ© &#124;xm+1](img/file729.jpg)![{ âˆš
    ----------- } &#124;10âŸ©+ M âˆ’ m âˆ’ 1 &#124;11âŸ©](img/file730.jpg)![ âŸ© &#124;xm+1](img/file731.jpg)
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: We then flip the first ancilla qubit toÂ 0 in the ![|10âŸ©](img/file732.jpg) case
    (easily achievable with SWAP and CNOT gates) and, regrouping the same ancilla
    terms together we obtain
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![ m+âˆ‘1 âŸ© âŸ© âˆ˜ ------------- âŸ© âŸ© âˆš1-- |xm+1 |00âŸ© |xk + M--âˆ’-(m-+-1) |xm+1 |11âŸ©
    |xm+1 . M k=1 M ](img/file733.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Resetting the registers as inÂ ([7.5](#x1-1580005)) to obtain
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![ ------------- 1 mâˆ‘+1 âŸ© âˆ˜ M âˆ’ (m + 1) âˆš---- |0âŸ©âŠ—n |00âŸ© |xk + ------------
    |0 âŸ©âŠ—n |01âŸ© |0âŸ©âŠ—n M k=1 M ](img/file734.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: finishes the proof of the lemma.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: â–¡
  prefs: []
  type: TYPE_NORMAL
- en: 7.6 Hamiltonian Simulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hamiltonian encoding, popular in quantum machine learning, is inspired by the
    SchrÃ¶dinger equationÂ ([1.2.2](Chapter_1.xhtml#x1-370002)), which reads
  prefs: []
  type: TYPE_NORMAL
- en: '![ d|Ïˆ-(t)âŸ©- iâ„ dt = â„‹ |Ïˆ (t)âŸ©, ](img/file735.jpg)'
  prefs: []
  type: TYPE_IMG
- en: for some HamiltonianÂ â„‹, whereÂ â„ is the Planck constant, and subject to some
    boundary condition at *t* = 0\. The solution to the equation reads
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( ) |Ïˆ (t)âŸ© = exp âˆ’ iâ„‹t-- |Ïˆ(0)âŸ©. â„ ](img/file736.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The idea of Hamiltonian encoding is to encode the initial data into the HamiltonianÂ â„‹.
    Consider a cloud of points X âˆˆâ„³[n,n](â„‚). IfÂ X is Hermitian, we can define the
    Hamiltonian matrix â„‹[X] := X, otherwise the augmented version
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( ) 0n,n X â„‹X := ( â€  ) X 0n,n ](img/file737.jpg)'
  prefs: []
  type: TYPE_IMG
- en: is Hermitian by construction.
  prefs: []
  type: TYPE_NORMAL
- en: Our aim is, for a given precision levelÂ *ğœ€*, to find a state ![ âŸ© |^Ïˆ](img/file738.jpg)
    (or an algorithm generating this state) such that
  prefs: []
  type: TYPE_NORMAL
- en: '![âˆ¥ âŸ© âˆ¥ âˆ¥âˆ¥|^Ïˆ âˆ’ |Ïˆ (t)âŸ©âˆ¥âˆ¥ â‰¤ ğœ€, ](img/file739.jpg)'
  prefs: []
  type: TYPE_IMG
- en: for some given normÂ âˆ¥â‹…âˆ¥, whereÂ ![|Ïˆ (t)âŸ©](img/file740.jpg) solves the SchrÃ¶dinger
    equation.
  prefs: []
  type: TYPE_NORMAL
- en: An important bottleneck of this method is the computation of exp![(â„‹Xt )](img/file741.jpg)
    (where we ignore the ratio âˆ’i*âˆ•*â„ for simplicity). Suppose that the HamiltonianÂ â„‹[X]
    can be written as a sum
  prefs: []
  type: TYPE_NORMAL
- en: '![ âˆ‘p â„‹X = â„‹i i=1 ](img/file742.jpg)'
  prefs: []
  type: TYPE_IMG
- en: of easy-to-compute Hamiltonians (â„‹[i])[i=1,â€¦,p]. If the latter do not commute,
    then the identity
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( âˆ‘p ) âˆp exp â„‹it = eâ„‹it i=1 i=1 ](img/file743.jpg)'
  prefs: []
  type: TYPE_IMG
- en: does not hold, but the first-order Suzuki-TrotterÂ Â [[220](Biblography.xhtml#XNaomichi-Suzuki),Â [286](Biblography.xhtml#XTrotter)]
    formula (used by Lloyd inÂ Â [[191](Biblography.xhtml#XLloydsUniv)])
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( âˆ‘p ) âˆp exp â„‹it = eâ„‹it + ğ’ª (t2), i=1 i=1 ](img/file744.jpg)'
  prefs: []
  type: TYPE_IMG
- en: forÂ *t* small enough, allows us to bypass this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, even ifÂ *t* is not so small, we may pick *Î´ >* 0 small enough and use
    the factorisation
  prefs: []
  type: TYPE_NORMAL
- en: '![ âŒŠ ( ) âŒ‹ ( âˆ‘p ) âˆ‘ tâˆ•Î´ [ pâˆ ]tâˆ•Î´ exp â„‹it = âŒˆexp ( â„‹iÎ´) âŒ‰ = eâ„‹iÎ´ + ğ’ª (Î´2) ,
    i=1 i=1,...,p i=1 ](img/file745.jpg)'
  prefs: []
  type: TYPE_IMG
- en: which has a small error (albeit with the caveat that the operation needs to
    be computed many times). In general, any *n*-qubit HamiltonianÂ â„‹ can be decomposed
    in at mostÂ 4^n elementary Hamiltonians (of the Pauli form) as
  prefs: []
  type: TYPE_NORMAL
- en: '![ âˆ‘ ( âŠ—n ) âŠ—n â„‹ = -1- Tr Ïƒi â„‹ Ïƒi , 2n i,...,iâˆˆ{I,X,Y,Z} k=1 k k=1 k 1 n ](img/file746.jpg)'
  prefs: []
  type: TYPE_IMG
- en: whereÂ *Ïƒ*[i[k]] is a Pauli operator. Of course, 4^n appeals to Pauli operators
    may be too large in general, but local features of the Hamiltonian (such as sparseÂ Â [[34](Biblography.xhtml#XBerrySparse)]
    or diluted or degree-reductedÂ Â [[8](Biblography.xhtml#XAharonovZhou)] Hamiltonians)
    help reduce the complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Remark:** An alternative approach, especially for QML problems analysed in
    the next chapter, is to encode the data using Quantum Random Access Memory (QRAM),
    essentially with the bucket-brigade algorithm developed inÂ Â [[110](Biblography.xhtml#XGiovannettiQRAM)]
    (see alsoÂ Â [[140](Biblography.xhtml#XHongQRAM),Â [15](Biblography.xhtml#XMoscaQRAM)]),
    and we refer the interested reader toÂ Â [[65](Biblography.xhtml#XCilibertoQRAM_Summary)]
    for a good summary of the current state-of-the-art algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: Encoding classical data into a quantum computer has seen many advances recently
    and several competing techniques are now available depending on the problem under
    investigation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we introduced the concept of a parameterised quantum circuit
    as a generic QML model. PQCs can be trained and used as discriminative and generative
    QML models as well as optimisers. They can also be used to encode classical data
    samples into the corresponding quantum states.
  prefs: []
  type: TYPE_NORMAL
- en: We considered several popular data encoding methods. Arguably, the simplest
    and easiest to implement is the angle encoding algorithm â€“ we shall use this approach
    in the next chapter. Other methods also have their strong points, although they
    tend to be either more demanding in terms of the hardware capabilities or better
    suited for some niche applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we apply what we learned so far to the task of building
    the quantum neural network trained as a classifier and compare its performance
    on the binary classification problem with standard classical machine learning
    models.
  prefs: []
  type: TYPE_NORMAL
- en: Join our bookâ€™s Discord space
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Join our Discord community to meet like-minded people and learn alongside more
    than 2000 members at: [https://packt.link/quantum](https://packt.link/quantum)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
