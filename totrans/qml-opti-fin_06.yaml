- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: Parameterised Quantum Circuits and Data Encoding
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: å‚æ•°åŒ–é‡å­ç”µè·¯å’Œæ•°æ®ç¼–ç 
- en: Having built the quantum hardware, how can we use it to the maximum effect given
    its scale, connectivity, and fidelity rate? This question can be best answered
    if we split it into two parts. First, what problems are in principle solvable
    on NISQ computers? Second, how do we encode classical data into quantum states?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ„å»ºäº†é‡å­ç¡¬ä»¶ä¹‹åï¼Œå¦‚ä½•åœ¨å…¶è§„æ¨¡ã€è¿æ¥æ€§å’Œä¿çœŸåº¦ä¸‹æœ€å¤§é™åº¦åœ°å‘æŒ¥å…¶æ•ˆç”¨å‘¢ï¼Ÿè¿™ä¸ªé—®é¢˜å¯ä»¥é€šè¿‡å°†å…¶åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†æ¥æ›´å¥½åœ°å›ç­”ã€‚é¦–å…ˆï¼Œå“ªäº›é—®é¢˜åŸåˆ™ä¸Šå¯ä»¥åœ¨NISQè®¡ç®—æœºä¸Šæ±‚è§£ï¼Ÿå…¶æ¬¡ï¼Œå¦‚ä½•å°†ç»å…¸æ•°æ®ç¼–ç ä¸ºé‡å­æ€ï¼Ÿ
- en: 'The rest of this book focuses on the first part: problems and models that can
    be formulated in a way that doesnâ€™t require a massive number of qubits and that
    are, at least to some extent, noise tolerant. The first step in this direction
    is the concept of the Parameterised Quantum Circuit (PQC) as a generic quantum
    machine learning model.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ä¹¦çš„å…¶ä½™éƒ¨åˆ†é›†ä¸­è®¨è®ºç¬¬ä¸€éƒ¨åˆ†ï¼šé‚£äº›å¯ä»¥ä»¥ä¸éœ€è¦å¤§é‡é‡å­æ¯”ç‰¹çš„æ–¹å¼è¿›è¡Œè¡¨è¿°ï¼Œå¹¶ä¸”è‡³å°‘åœ¨æŸç§ç¨‹åº¦ä¸Šå…·æœ‰å™ªå£°å®¹å¿æ€§çš„æ¨¡å‹å’Œé—®é¢˜ã€‚æœç€è¿™ä¸ªæ–¹å‘è¿ˆå‡ºçš„ç¬¬ä¸€æ­¥æ˜¯å‚æ•°åŒ–é‡å­ç”µè·¯ï¼ˆPQCï¼‰çš„æ¦‚å¿µï¼Œä½œä¸ºä¸€ç§é€šç”¨çš„é‡å­æœºå™¨å­¦ä¹ æ¨¡å‹ã€‚
- en: The second part â€“ data encoding â€“ is equally important and relies on several
    practical methods described in this chapter. This is an active area of research
    where we can expect most of the progress to come from the quantum software side.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒéƒ¨åˆ†â€”â€”æ•°æ®ç¼–ç â€”â€”åŒæ ·é‡è¦ï¼Œå¹¶ä¾èµ–äºæœ¬ç« ä¸­æè¿°çš„å‡ ç§å®ç”¨æ–¹æ³•ã€‚è¿™æ˜¯ä¸€ä¸ªæ´»è·ƒçš„ç ”ç©¶é¢†åŸŸï¼Œæˆ‘ä»¬å¯ä»¥é¢„è®¡å¤§å¤šæ•°è¿›å±•å°†æ¥è‡ªé‡å­è½¯ä»¶æ–¹é¢ã€‚
- en: 7.1 Parameterised Quantum Circuits
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1 å‚æ•°åŒ–é‡å­ç”µè·¯
- en: 'We have seen how to combine quantum gates to form arbitrarily wide and deep
    quantum circuits. A quantum circuit transforms an initial quantum stateÂ ![|ÏˆâŸ©](img/file659.jpg)
    into a final quantum state ![|Ïˆ â€²âŸ©](img/file660.jpg) by applying a sequence of
    unitary operators:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»çœ‹åˆ°å¦‚ä½•ç»„åˆé‡å­é—¨ä»¥å½¢æˆä»»æ„å®½åº¦å’Œæ·±åº¦çš„é‡å­ç”µè·¯ã€‚é‡å­ç”µè·¯é€šè¿‡åº”ç”¨ä¸€ç³»åˆ—å•å…ƒç®—ç¬¦ï¼Œå°†åˆå§‹é‡å­æ€ ![|ÏˆâŸ©](img/file659.jpg)
    è½¬æ¢ä¸ºæœ€ç»ˆé‡å­æ€ ![|Ïˆ â€²âŸ©](img/file660.jpg)ã€‚
- en: '| ![&#124;Ïˆâ€²âŸ© = U (ğœƒ )...U (ğœƒ )U (ğœƒ ) &#124;Ïˆ âŸ©. m m 2 2 1 1 ](img/file661.jpg)
    |  |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| ![&#124;Ïˆâ€²âŸ© = U (ğœƒ )...U (ğœƒ )U (ğœƒ ) &#124;Ïˆ âŸ©. m m 2 2 1 1 ](img/file661.jpg)
    |  |'
- en: Here, (U[i])[i=1,â€¦,m] and (ğœƒ[i])[i=1,â€¦,m] denote respectively the individual
    gates and the associated vectors of gate parameters. Some gates may be *fixed*
    (e.g., a two-qubit CNOT gate viewed as a controlled rotation of the target qubit
    state around the *x*-axis by a fixed angle *ğœƒ* = *Ï€*) while some gates may be
    *adjustable* (e.g., a one-qubit R[X](*ğœƒ*) gate that rotates the qubit state around
    *x*-axis by an arbitrary angle *ğœƒ* âˆˆ [âˆ’*Ï€,Ï€*]).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œ(U[i])[i=1,â€¦,m] å’Œ (ğœƒ[i])[i=1,â€¦,m] åˆ†åˆ«è¡¨ç¤ºä¸ªåˆ«é—¨å’Œä¸ä¹‹å…³è”çš„é—¨å‚æ•°å‘é‡ã€‚æœ‰äº›é—¨å¯èƒ½æ˜¯*å›ºå®šçš„*ï¼ˆä¾‹å¦‚ï¼Œä¸€ä¸ªäºŒæ¯”ç‰¹CNOTé—¨ï¼Œè§†ä¸ºå›´ç»•*x*è½´ä»¥å›ºå®šè§’åº¦*ğœƒ*
    = *Ï€*æ§åˆ¶æ—‹è½¬ç›®æ ‡é‡å­æ¯”ç‰¹çš„çŠ¶æ€ï¼‰ï¼Œè€Œæœ‰äº›é—¨å¯èƒ½æ˜¯*å¯è°ƒçš„*ï¼ˆä¾‹å¦‚ï¼Œä¸€ä¸ªä¸€æ¯”ç‰¹çš„R[X](*ğœƒ*)é—¨ï¼Œç»•*x*è½´ä»¥ä»»æ„è§’åº¦*ğœƒ* âˆˆ [âˆ’*Ï€,Ï€*]æ—‹è½¬é‡å­æ¯”ç‰¹çŠ¶æ€ï¼‰ã€‚
- en: Once the final quantum state ![ â€² |Ïˆ âŸ©](img/file662.jpg) is constructed, the
    individual qubits can be measured. After measurement the qubit states stay the
    same in the basis in which they were measured, which we always assume to be the
    standard computational basis unless explicitly specified otherwise. Therefore,
    the final output of running the quantum circuit and then measuring the qubits
    (not necessarily all qubits have to be measured) is a classical bitstring.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æœ€ç»ˆé‡å­æ€ ![ â€² |Ïˆ âŸ©](img/file662.jpg) è¢«æ„é€ å‡ºæ¥ï¼Œä¸ªåˆ«é‡å­æ¯”ç‰¹å°±å¯ä»¥è¢«æµ‹é‡ã€‚æµ‹é‡åï¼Œé‡å­æ¯”ç‰¹çš„çŠ¶æ€ä¼šä¿æŒåœ¨å…¶æµ‹é‡æ—¶æ‰€ä½¿ç”¨çš„åŸºæ€ä¸­ï¼Œæˆ‘ä»¬é€šå¸¸å‡å®šè¯¥åŸºæ€ä¸ºæ ‡å‡†è®¡ç®—åŸºæ€ï¼Œé™¤éç‰¹åˆ«æŒ‡å®šã€‚
    å› æ­¤ï¼Œè¿è¡Œé‡å­ç”µè·¯å¹¶æµ‹é‡é‡å­æ¯”ç‰¹ï¼ˆä¸ä¸€å®šæ‰€æœ‰é‡å­æ¯”ç‰¹éƒ½éœ€è¦æµ‹é‡ï¼‰çš„æœ€ç»ˆè¾“å‡ºæ˜¯ä¸€ä¸ªç»å…¸çš„æ¯”ç‰¹ä¸²ã€‚
- en: What we just described is a parameterised quantum circuit schematically shown
    in FigureÂ [7.1](#7.1). The PQC can be used in many different ways. First of all,
    let us note that the PQC can be *trained*. Training the PQC has the meaning of
    finding an optimal set of adjustable parameters (the vectors ğœƒ[1]*,â€¦,*ğœƒ[m] above,
    for example) given the overall PQC *ansatz* (architecture). The meaning of "optimal"
    is problem dependent but generally means a configuration of adjustable parameters
    that ensures maximum closeness of the final quantum state ![ â€² |Ïˆ âŸ©](img/file663.jpg)
    to some desired target quantum state that corresponds to a particular probability
    distribution we aim to encode.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åˆšæ‰æè¿°çš„æ˜¯ä¸€ä¸ªå‚æ•°åŒ–é‡å­ç”µè·¯ï¼Œç¤ºæ„å›¾è§å›¾[7.1](#7.1)ã€‚PQCå¯ä»¥ä»¥å¤šç§æ–¹å¼ä½¿ç”¨ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬æ³¨æ„åˆ°PQCå¯ä»¥è¢«*è®­ç»ƒ*ã€‚è®­ç»ƒPQCæ„å‘³ç€åœ¨ç»™å®šæ•´ä½“PQC*ansatz*ï¼ˆæ¶æ„ï¼‰çš„æƒ…å†µä¸‹ï¼Œæ‰¾åˆ°ä¸€ç»„æœ€ä½³çš„å¯è°ƒå‚æ•°ï¼ˆä¾‹å¦‚ä¸Šé¢æåˆ°çš„å‘é‡ğœƒ[1]*ï¼Œâ€¦ï¼Œ*ğœƒ[m]ï¼‰ã€‚æ‰€è°“çš„â€œæœ€ä½³â€æ˜¯é—®é¢˜ä¾èµ–çš„ï¼Œä½†é€šå¸¸æ„å‘³ç€ä¸€ç»„å¯è°ƒå‚æ•°çš„é…ç½®ï¼Œå®ƒç¡®ä¿æœ€ç»ˆé‡å­æ€
    ![ â€² |Ïˆ âŸ©](img/file663.jpg) ä¸æŸä¸ªç›®æ ‡é‡å­æ€å°½å¯èƒ½æ¥è¿‘ï¼Œè¿™ä¸ªç›®æ ‡é‡å­æ€å¯¹åº”äºæˆ‘ä»¬è¦ç¼–ç çš„ç‰¹å®šæ¦‚ç‡åˆ†å¸ƒã€‚
- en: '![FigureÂ 7.1: Schematic representation of a Parameterised Quantum Circuit.
    ](img/file664.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 7.1: å‚æ•°åŒ–é‡å­ç”µè·¯çš„ç¤ºæ„è¡¨ç¤ºã€‚](img/file664.jpg)'
- en: 'FigureÂ 7.1: Schematic representation of a Parameterised Quantum Circuit.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ 7.1ï¼šå‚æ•°åŒ–é‡å­ç”µè·¯çš„ç¤ºæ„è¡¨ç¤ºã€‚
- en: 'In the following chapters, we will see how PQCs can be used as discriminative
    ML models (ChapterÂ [8](Chapter_8.xhtml#x1-1620008)), as generative ML models (ChapterÂ [9](Chapter_9.xhtml#x1-1850009)),
    and as optimisers (ChaptersÂ [10](Chapter_10.xhtml#x1-20200010) andÂ [11](Chapter_11.xhtml#x1-21700011)):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ¥ä¸‹æ¥çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°å¦‚ä½•å°†PQCä½œä¸ºåˆ¤åˆ«å¼æœºå™¨å­¦ä¹ æ¨¡å‹ï¼ˆç¬¬[8](Chapter_8.xhtml#x1-1620008)ç« ï¼‰ã€ç”Ÿæˆå¼æœºå™¨å­¦ä¹ æ¨¡å‹ï¼ˆç¬¬[9](Chapter_9.xhtml#x1-1850009)ç« ï¼‰ä»¥åŠä¼˜åŒ–å™¨ï¼ˆç¬¬[10](Chapter_10.xhtml#x1-20200010)ç« å’Œç¬¬[11](Chapter_11.xhtml#x1-21700011)ç« ï¼‰æ¥ä½¿ç”¨ï¼š
- en: In the case of the Variational Quantum Eigensolver, a PQC is used to construct
    the final quantum state ![ â€² |Ïˆ âŸ©](img/file665.jpg) that is close to the eigenstate
    of the problem Hamiltonian that corresponds to the smallest eigenvalue (the ground
    state energy that is linked to the minimum of the cost function).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨å˜åˆ†é‡å­ç‰¹å¾æ±‚è§£å™¨çš„æƒ…å†µä¸‹ï¼ŒPQCè¢«ç”¨æ¥æ„å»ºæœ€ç»ˆçš„é‡å­æ€![ â€² |Ïˆ âŸ©](img/file665.jpg)ï¼Œè¯¥æ€æ¥è¿‘äºé—®é¢˜å“ˆå¯†é¡¿é‡çš„æœ¬å¾æ€ï¼Œå¯¹åº”äºæœ€å°æœ¬å¾å€¼ï¼ˆä¸ä»£ä»·å‡½æ•°æœ€å°å€¼ç›¸å…³çš„åŸºæ€èƒ½é‡ï¼‰ã€‚
- en: When we build a quantum discriminative model â€“ a Quantum Neural Network trained
    as a classifier â€“ we are interested in measuring only a handful of qubits (or
    even just a single qubit). This should give us the binary representation of the
    "class label" for the given sample. The input (initial quantum state ![|Ïˆ âŸ©](img/file666.jpg))
    encodes the sample we want to classify.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬æ„å»ºä¸€ä¸ªé‡å­åˆ¤åˆ«æ¨¡å‹â€”â€”ä¸€ä¸ªä½œä¸ºåˆ†ç±»å™¨è®­ç»ƒçš„é‡å­ç¥ç»ç½‘ç»œæ—¶ï¼Œæˆ‘ä»¬åªå…³æ³¨æµ‹é‡å°‘æ•°å‡ ä¸ªé‡å­æ¯”ç‰¹ï¼ˆç”šè‡³åªæœ‰ä¸€ä¸ªé‡å­æ¯”ç‰¹ï¼‰ã€‚è¿™åº”è¯¥ç»™æˆ‘ä»¬æä¾›ä¸€ä¸ªäºŒè¿›åˆ¶è¡¨ç¤ºçš„â€œç±»æ ‡ç­¾â€ç”¨äºç»™å®šçš„æ ·æœ¬ã€‚è¾“å…¥ï¼ˆåˆå§‹é‡å­æ€![|Ïˆ
    âŸ©](img/file666.jpg)ï¼‰ç¼–ç äº†æˆ‘ä»¬æƒ³è¦åˆ†ç±»çš„æ ·æœ¬ã€‚
- en: When our objective is to build a quantum generative model â€“ the Quantum Circuit
    Born Machine â€“ we measure all qubits. This gives us a bitstring that is a generated
    sample from the probability distribution encoded in the final quantum state ![|Ïˆ
    â€²âŸ©](img/file667.jpg) constructed by the PQC. The initial state is initialised
    as ![|0âŸ©](img/file668.jpg)^(âŠ—n).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬çš„ç›®æ ‡æ˜¯æ„å»ºä¸€ä¸ªé‡å­ç”Ÿæˆæ¨¡å‹â€”â€”é‡å­ç”µè·¯Bornæœºæ—¶ï¼Œæˆ‘ä»¬æµ‹é‡æ‰€æœ‰çš„é‡å­æ¯”ç‰¹ã€‚è¿™å°†ç»™æˆ‘ä»¬ä¸€ä¸ªæ¯”ç‰¹ä¸²ï¼Œè¿™æ˜¯ä»æœ€ç»ˆé‡å­æ€![|Ïˆ â€²âŸ©](img/file667.jpg)ä¸­ç¼–ç çš„æ¦‚ç‡åˆ†å¸ƒç”Ÿæˆçš„æ ·æœ¬ã€‚åˆå§‹çŠ¶æ€åˆå§‹åŒ–ä¸º![|0âŸ©](img/file668.jpg)^(âŠ—n)ã€‚
- en: 'PQCs are invariably trained using hybrid quantum-classical protocols. The hybrid
    approach is shown schematically in FigureÂ [7.2](#7.2) and consists of three components:
    the user, the classical computer, and the quantum computerÂ Â [[29](Biblography.xhtml#XBenedetti2019)].'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: PQCé€šå¸¸ä½¿ç”¨æ··åˆé‡å­-ç»å…¸åè®®è¿›è¡Œè®­ç»ƒã€‚æ··åˆæ–¹æ³•åœ¨å›¾[7.2](#7.2)ä¸­ä»¥ç¤ºæ„å›¾çš„å½¢å¼å±•ç¤ºï¼Œç”±ä¸‰ä¸ªéƒ¨åˆ†ç»„æˆï¼šç”¨æˆ·ã€ç»å…¸è®¡ç®—æœºå’Œé‡å­è®¡ç®—æœº[[29](Biblography.xhtml#XBenedetti2019)]ã€‚
- en: '![Figurex1-151003r2: Training PQCs â€“ schematic process. ](img/file669.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Figurex1-151003r2: è®­ç»ƒPQC - ç¤ºæ„æµç¨‹ã€‚](img/file669.jpg)'
- en: 'FigureÂ 7.2: Training PQCs â€“ schematic process.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ 7.2ï¼šè®­ç»ƒPQC - ç¤ºæ„æµç¨‹ã€‚
- en: The user provides the model for the problem; the classical computer pre-processes
    the data and produces the initial set of parameters for the PQC; the quantum computer
    runs the PQC by preparing the quantum state as prescribed by the PQC and by performing
    measurements. Measurement outcomes are then post-processed by the classical computer,
    which updates the model parameters as per the chosen training algorithm (backpropagation
    of error with gradient descent, non-differentiable learning method, etc.) The
    overall algorithm is run in a closed loop between the classical and quantum computers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ç”¨æˆ·ä¸ºé—®é¢˜æä¾›æ¨¡å‹ï¼›ç»å…¸è®¡ç®—æœºé¢„å¤„ç†æ•°æ®å¹¶ç”ŸæˆPQCçš„åˆå§‹å‚æ•°é›†ï¼›é‡å­è®¡ç®—æœºé€šè¿‡æŒ‰ç…§PQCçš„è¦æ±‚å‡†å¤‡é‡å­æ€å¹¶è¿›è¡Œæµ‹é‡æ¥è¿è¡ŒPQCã€‚æµ‹é‡ç»“æœéšåç”±ç»å…¸è®¡ç®—æœºè¿›è¡Œåå¤„ç†ï¼Œç»å…¸è®¡ç®—æœºä¼šæ ¹æ®é€‰å®šçš„è®­ç»ƒç®—æ³•ï¼ˆå¦‚è¯¯å·®åå‘ä¼ æ’­ä¸æ¢¯åº¦ä¸‹é™ã€ä¸å¯å¾®å­¦ä¹ æ–¹æ³•ç­‰ï¼‰æ›´æ–°æ¨¡å‹å‚æ•°ã€‚æ•´ä½“ç®—æ³•åœ¨ç»å…¸è®¡ç®—æœºä¸é‡å­è®¡ç®—æœºä¹‹é—´ä»¥é—­ç¯å½¢å¼è¿è¡Œã€‚
- en: PQC is one of the most successful frameworks for applying NISQ computers to
    solving non-trivial real-world problems. It follows the paradigm of a hybrid quantum-classical
    computational protocol and can be used for experimenting with the wide range of
    quantum machine learning models.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: PQCæ˜¯å°†NISQè®¡ç®—æœºåº”ç”¨äºè§£å†³éå¹³å‡¡ç°å®ä¸–ç•Œé—®é¢˜çš„æœ€æˆåŠŸæ¡†æ¶ä¹‹ä¸€ã€‚å®ƒéµå¾ªæ··åˆé‡å­-ç»å…¸è®¡ç®—åè®®çš„èŒƒå¼ï¼Œå¹¶å¯ç”¨äºå®éªŒå¹¿æ³›çš„é‡å­æœºå™¨å­¦ä¹ æ¨¡å‹ã€‚
- en: 7.2 Angle Encoding
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2 è§’åº¦ç¼–ç 
- en: 'Let us go back to the Bloch sphere (FigureÂ [7.2](#x1-1520002)) that visualises
    the canonical representation of the qubit state â€“ a unit vector in the 2-dimensional
    complex vector space:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å›åˆ°å¸ƒæ´›èµ«çƒï¼ˆå›¾[7.2](#x1-1520002)ï¼‰ï¼Œå®ƒå¯è§†åŒ–äº†é‡å­æ¯”ç‰¹æ€çš„æ ‡å‡†è¡¨ç¤ºâ€”â€”äºŒç»´å¤å‘é‡ç©ºé—´ä¸­çš„å•ä½å‘é‡ï¼š
- en: '| ![ âŒŠ ( ) âŒ‹ cos ğœƒ- &#124;ÏˆâŸ© = &#124;&#124; (2 ) &#124;&#124;. âŒˆeiÏ•sin ğœƒ- âŒ‰
    2 ](img/file670.jpg) |  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| ![ âŒŠ ( ) âŒ‹ cos ğœƒ- &#124;ÏˆâŸ© = &#124;&#124; (2 ) &#124;&#124;. âŒˆeiÏ•sin ğœƒ- âŒ‰
    2 ](img/file670.jpg) |  |'
- en: The angles *ğœƒ* âˆˆ [0*,Ï€*] and *Ï•* âˆˆ [0*,*2*Ï€*] uniquely determine the position
    of the qubit on the unit sphere. Since we need two continuous variables to specify
    the qubit state, a single qubit can encode two real-valued features.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: è§’åº¦ *ğœƒ* âˆˆ [0*,Ï€*] å’Œ *Ï•* âˆˆ [0*,*2*Ï€*] å”¯ä¸€åœ°ç¡®å®šé‡å­æ¯”ç‰¹åœ¨å•ä½çƒä¸Šçš„ä½ç½®ã€‚ç”±äºæˆ‘ä»¬éœ€è¦ä¸¤ä¸ªè¿ç»­å˜é‡æ¥æŒ‡å®šé‡å­æ¯”ç‰¹çš„çŠ¶æ€ï¼Œå› æ­¤ä¸€ä¸ªé‡å­æ¯”ç‰¹å¯ä»¥ç¼–ç ä¸¤ä¸ªå®å€¼ç‰¹å¾ã€‚
- en: '![FigureÂ 7.3: Quantum state |Ïˆ âŸ© on the Bloch sphere. ](img/file672.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ 7.3ï¼šé‡å­æ€ |Ïˆ âŸ© åœ¨å¸ƒæ´›èµ«çƒä¸Šçš„è¡¨ç¤ºã€‚](img/file672.jpg)'
- en: 'FigureÂ 7.3: Quantum state ![|Ïˆ âŸ©](img/file671.jpg) on the Bloch sphere.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ 7.3ï¼šé‡å­æ€ ![|Ïˆ âŸ©](img/file671.jpg) åœ¨å¸ƒæ´›èµ«çƒä¸Šçš„è¡¨ç¤ºã€‚
- en: 7.2.1 The basic encoding scheme
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1 åŸºæœ¬ç¼–ç æ–¹æ¡ˆ
- en: 'We can illustrate this with the following schematic example: let us assume
    that we have an 8-feature dataset consisting ofÂ *N* samples and that all features
    *X*[1]*,â€¦,X*[8] are real-valued and such that their extremal values, *X*[i]^(min)
    and *X*[i]^(max), *i* = 1*,â€¦,*8, can be computed. Then, for every sample *j* =
    1*,â€¦,N* from the dataset, we can establish a one-to-one mapping between the values
    of the featuresÂ *X*[i]^j and the corresponding rotation anglesÂ *ğœƒ*[i]^j:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ç”¨ä»¥ä¸‹ç¤ºæ„ä¾‹å­æ¥è¯´æ˜è¿™ä¸€ç‚¹ï¼šå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªåŒ…å« *N* ä¸ªæ ·æœ¬çš„ 8 ç‰¹å¾æ•°æ®é›†ï¼Œæ‰€æœ‰ç‰¹å¾ *X*[1]*,â€¦,X*[8] éƒ½æ˜¯å®å€¼ï¼Œå¹¶ä¸”å¯ä»¥è®¡ç®—å‡ºå®ƒä»¬çš„æå€¼
    *X*[i]^(min) å’Œ *X*[i]^(max)ï¼Œ*i* = 1*,â€¦,*8ã€‚ç„¶åï¼Œå¯¹äºæ•°æ®é›†ä¸­æ¯ä¸ªæ ·æœ¬ *j* = 1*,â€¦,N*ï¼Œæˆ‘ä»¬å¯ä»¥å»ºç«‹ä¸€ä¸ªç‰¹å¾å€¼
    *X*[i]^j ä¸å¯¹åº”æ—‹è½¬è§’åº¦ *ğœƒ*[i]^j ä¹‹é—´çš„ä¸€å¯¹ä¸€æ˜ å°„å…³ç³»ï¼š
- en: '| ![ j Xj âˆ’ Xmin ğœƒi = --miax----iminÏ€, X i âˆ’ X i ](img/file673.jpg) |  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| ![ j Xj âˆ’ Xmin ğœƒi = --miax----iminÏ€, X i âˆ’ X i ](img/file673.jpg) |  |'
- en: where *X*[i]^(min) := min[j]*X*[i]^j and *X*[i]^(max) := max[j]*X*[i]^j. Rotation
    angles *ğœƒ*[i]^j generalise angles *ğœƒ* and *Ï•* in FigureÂ [7.2](#x1-1520002).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ *X*[i]^(min) := min[j]*X*[i]^j å’Œ *X*[i]^(max) := max[j]*X*[i]^jã€‚æ—‹è½¬è§’åº¦ *ğœƒ*[i]^j
    æ¨å¹¿äº†å›¾ [7.2](#x1-1520002) ä¸­çš„è§’åº¦ *ğœƒ* å’Œ *Ï•*ã€‚
- en: '![FigureÂ 7.4: Feature encoding â€“ rotations around y axis. States of qubits
    q1,â€¦,q4 are shown on the same Bloch sphere. The initial state of all qubits is
    |0âŸ© and the end states after rotations around the y-axis by angles ğœƒ1,â€¦,ğœƒ4 are
    denoted asÂ A, B, C, andÂ D. ](img/file675.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ 7.4ï¼šç‰¹å¾ç¼–ç  â€“ ç»• y è½´æ—‹è½¬ã€‚é‡å­æ¯”ç‰¹ q1,â€¦,q4 çš„çŠ¶æ€åœ¨åŒä¸€å¸ƒæ´›èµ«çƒä¸Šæ˜¾ç¤ºã€‚æ‰€æœ‰é‡å­æ¯”ç‰¹çš„åˆå§‹çŠ¶æ€ä¸º |0âŸ©ï¼Œç»• y è½´æ—‹è½¬è§’åº¦
    ğœƒ1,â€¦,ğœƒ4 åçš„æœ€ç»ˆçŠ¶æ€åˆ†åˆ«è¡¨ç¤ºä¸º Aã€Bã€C å’Œ Dã€‚](img/file675.jpg)'
- en: 'FigureÂ 7.4: Feature encoding â€“ rotations around y axis. States of qubits q[1],â€¦,q[4]
    are shown on the same Bloch sphere. The initial state of all qubits is ![|0âŸ©](img/file674.jpg)
    and the end states after rotations around the y-axis by angles ğœƒ[1],â€¦,ğœƒ[4] are
    denoted asÂ A, B, C, andÂ D.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ 7.4ï¼šç‰¹å¾ç¼–ç  â€“ ç»• y è½´æ—‹è½¬ã€‚é‡å­æ¯”ç‰¹ q[1],â€¦,q[4] åœ¨åŒä¸€å¸ƒæ´›èµ«çƒä¸Šçš„çŠ¶æ€ã€‚æ‰€æœ‰é‡å­æ¯”ç‰¹çš„åˆå§‹çŠ¶æ€ä¸º ![|0âŸ©](img/file674.jpg)ï¼Œç»•
    y è½´æ—‹è½¬è§’åº¦ ğœƒ[1],â€¦,ğœƒ[4] åçš„æœ€ç»ˆçŠ¶æ€åˆ†åˆ«è¡¨ç¤ºä¸º Aã€Bã€C å’Œ Dã€‚
- en: 'The 8-feature sample can be encoded in a 4-qubit state (unentangled). For example,
    starting with four quantum registers initialised as ![|0âŸ©](img/file676.jpg) in
    the computational basis, we can first perform rotations around the *y*-axis: rotation
    by *ğœƒ*[1] for qubit 1, rotation by *ğœƒ*[2] for qubit 2, and so on. This is shown
    schematically in FigureÂ [7.2.1](#x1-1530001) where qubits move from their initial
    state ![|0âŸ©](img/file677.jpg) to states *A*, *B*, *C*, and *D*.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 8 ç‰¹å¾æ ·æœ¬å¯ä»¥ç¼–ç ä¸ºä¸€ä¸ª 4 é‡å­æ¯”ç‰¹çŠ¶æ€ï¼ˆéçº ç¼ ï¼‰ã€‚ä¾‹å¦‚ï¼Œä»å››ä¸ªåˆå§‹åŒ–ä¸º ![|0âŸ©](img/file676.jpg) çš„é‡å­å¯„å­˜å™¨å¼€å§‹ï¼Œæˆ‘ä»¬å¯ä»¥é¦–å…ˆåœ¨
    *y* è½´ä¸Šè¿›è¡Œæ—‹è½¬ï¼šé‡å­æ¯”ç‰¹ 1 æŒ‰è§’åº¦ *ğœƒ*[1] æ—‹è½¬ï¼Œé‡å­æ¯”ç‰¹ 2 æŒ‰è§’åº¦ *ğœƒ*[2] æ—‹è½¬ï¼Œä¾æ­¤ç±»æ¨ã€‚è¿™åœ¨å›¾ [7.2.1](#x1-1530001)
    ä¸­ç¤ºæ„å±•ç¤ºï¼Œé‡å­æ¯”ç‰¹ä»å…¶åˆå§‹çŠ¶æ€ ![|0âŸ©](img/file677.jpg) ç§»åŠ¨åˆ°çŠ¶æ€ *A*ã€*B*ã€*C* å’Œ *D*ã€‚
- en: 7.2.2 Encoding two features per quantum register
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.2 æ¯ä¸ªé‡å­å¯„å­˜å™¨ç¼–ç ä¸¤ä¸ªç‰¹å¾
- en: 'After that, we encode the remaining features by performing rotations around
    the *z*-axis: rotation by *ğœƒ*[5] for qubit 1, rotation by *ğœƒ*[6] for qubit 2,
    and so on as shown in FigureÂ [7.5](#7.5).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹åï¼Œæˆ‘ä»¬é€šè¿‡åœ¨ *z* è½´ä¸Šè¿›è¡Œæ—‹è½¬æ¥ç¼–ç å‰©ä½™ç‰¹å¾ï¼šé‡å­æ¯”ç‰¹ 1 æŒ‰è§’åº¦ *ğœƒ*[5] æ—‹è½¬ï¼Œé‡å­æ¯”ç‰¹ 2 æŒ‰è§’åº¦ *ğœƒ*[6] æ—‹è½¬ï¼Œä¾æ­¤ç±»æ¨ï¼Œæ­£å¦‚å›¾
    [7.5](#7.5) ä¸­æ‰€ç¤ºã€‚
- en: '![FigureÂ 7.5: Feature encoding â€“ rotations around the z-axis. The initial states
    of qubits q1,â€¦,q4 are A,B,C,D. After rotation around the z-axis by angles ğœƒ5,â€¦,ğœƒ8,
    the final qubit states areÂ E,F,G,H. ](img/file678.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ 7.5ï¼šç‰¹å¾ç¼–ç  â€“ ç»• z è½´æ—‹è½¬ã€‚é‡å­æ¯”ç‰¹ q1,â€¦,q4 çš„åˆå§‹çŠ¶æ€åˆ†åˆ«ä¸º A,B,C,Dã€‚åœ¨ç»• z è½´æ—‹è½¬è§’åº¦ ğœƒ5,â€¦,ğœƒ8 åï¼Œæœ€ç»ˆçš„é‡å­æ¯”ç‰¹çŠ¶æ€ä¸º
    E,F,G,Hã€‚](img/file678.jpg)'
- en: 'FigureÂ 7.5: Feature encoding â€“ rotations around the z-axis. The initial states
    of qubits q[1],â€¦,q[4] are A,B,C,D. After rotation around the z-axis by angles
    ğœƒ[5],â€¦,ğœƒ[8], the final qubit states areÂ E,F,G,H.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ 7.5ï¼šç‰¹å¾ç¼–ç  â€“ ç»• z è½´æ—‹è½¬ã€‚é‡å­æ¯”ç‰¹ q[1],â€¦,q[4] çš„åˆå§‹çŠ¶æ€åˆ†åˆ«ä¸º A,B,C,Dã€‚åœ¨ç»• z è½´æ—‹è½¬è§’åº¦ ğœƒ[5],â€¦,ğœƒ[8]
    åï¼Œæœ€ç»ˆçš„é‡å­æ¯”ç‰¹çŠ¶æ€ä¸º E,F,G,Hã€‚
- en: 'The qubit states move fromÂ *A* toÂ *E*, fromÂ *B* toÂ *F*, fromÂ *C* toÂ *G*, and
    fromÂ *D* toÂ *H*. The corresponding quantum circuit looks as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: é‡å­æ¯”ç‰¹çŠ¶æ€ä»*A*è½¬ç§»åˆ°*E*ï¼Œä»*B*è½¬ç§»åˆ°*F*ï¼Œä»*C*è½¬ç§»åˆ°*G*ï¼Œä»*D*è½¬ç§»åˆ°*H*ã€‚å¯¹åº”çš„é‡å­ç”µè·¯å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '![FigureÂ 7.6: 4-qubit quantum circuit for 8-feature sample encoding. ](img/file679.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾7.6ï¼š8ç‰¹å¾æ ·æœ¬ç¼–ç çš„4é‡å­æ¯”ç‰¹é‡å­ç”µè·¯ã€‚](img/file679.jpg)'
- en: 'FigureÂ 7.6: 4-qubit quantum circuit for 8-feature sample encoding.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾7.6ï¼š8ç‰¹å¾æ ·æœ¬ç¼–ç çš„4é‡å­æ¯”ç‰¹é‡å­ç”µè·¯ã€‚
- en: 7.2.3 Mapping a classical data sample into a quantum state
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.3 å°†ç»å…¸æ•°æ®æ ·æœ¬æ˜ å°„åˆ°é‡å­çŠ¶æ€
- en: We can summarise the angle encoding scheme as follows. For the classical data
    sample *X*^j := (*X*[1]^j*,â€¦,X*[K]^j) âˆˆâ„^K, *j* = 1*,â€¦,N*, angle encoding works
    by constructing the map
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥å°†è§’åº¦ç¼–ç æ–¹æ¡ˆæ€»ç»“å¦‚ä¸‹ã€‚å¯¹äºç»å…¸æ•°æ®æ ·æœ¬*X*^j := (*X*[1]^j*,â€¦,X*[K]^j) âˆˆâ„^Kï¼Œ*j* = 1*,â€¦,N*ï¼Œè§’åº¦ç¼–ç é€šè¿‡æ„é€ æ˜ å°„æ¥å·¥ä½œ
- en: '![ K ( ( j) ( j) ) j âŠ— ğœƒi ğœƒi X â†¦âˆ’â†’ cos 2 |0âŸ©+ sin 2 |1âŸ© , i=1 ](img/file680.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![ K ( ( j) ( j) ) j âŠ— ğœƒi ğœƒi X â†¦âˆ’â†’ cos 2 |0âŸ©+ sin 2 |1âŸ© , i=1 ](img/file680.jpg)'
- en: 'where angles (*ğœƒ*[i]^j)[i=1,â€¦,K;j=1,â€¦,N] are given by the expressionÂ ([7.2.1](#x1-1530001)).
    This scheme only requires one rotation gate for each qubit, hence encodes as many
    features as the number of qubits. However, we know that a single quantum register
    can encode two real variables. The following scheme maps the classical sample
    into the quantum state with the help of an extra phase gate:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­è§’åº¦ï¼ˆ*ğœƒ*[i]^j)[i=1,â€¦,K;j=1,â€¦,N]ç”±è¡¨è¾¾å¼([7.2.1](#x1-1530001))ç»™å‡ºã€‚è¯¥æ–¹æ¡ˆä»…éœ€è¦ä¸ºæ¯ä¸ªé‡å­æ¯”ç‰¹æ—‹è½¬é—¨ï¼Œå› æ­¤å¯ä»¥ç¼–ç ä¸é‡å­æ¯”ç‰¹æ•°é‡ç›¸åŒæ•°é‡çš„ç‰¹å¾ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬çŸ¥é“å•ä¸ªé‡å­å¯„å­˜å™¨å¯ä»¥ç¼–ç ä¸¤ä¸ªå®æ•°å˜é‡ã€‚ä»¥ä¸‹æ–¹æ¡ˆåœ¨é™„åŠ ç›¸ä½é—¨çš„å¸®åŠ©ä¸‹å°†ç»å…¸æ ·æœ¬æ˜ å°„åˆ°é‡å­çŠ¶æ€ï¼š
- en: '![ âŠ—K ( ( ğœƒj ) (ğœƒj ) ) Xj â†¦âˆ’â†’ cos -2iâˆ’1 |0âŸ©+ exp (iğœƒ2i)sin -2iâˆ’1 |1âŸ© . i=1
    2 2 ](img/file681.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![ âŠ—K ( ( ğœƒj ) (ğœƒj ) ) Xj â†¦âˆ’â†’ cos -2iâˆ’1 |0âŸ©+ exp (iğœƒ2i)sin -2iâˆ’1 |1âŸ© . i=1
    2 2 ](img/file681.jpg)'
- en: This scheme allows us to encodeÂ 2*n* features withÂ *n* qubits.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: è¯¥æ–¹æ¡ˆå…è®¸æˆ‘ä»¬ä½¿ç”¨*n*ä¸ªé‡å­æ¯”ç‰¹ç¼–ç 2*n*ä¸ªç‰¹å¾ã€‚
- en: '*n* quantum registers have capacity to encode 2*n* continuous features with
    just two layers of one-qubit gates.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*ä¸ªé‡å­å¯„å­˜å™¨å…·æœ‰ä»…é€šè¿‡ä¸¤å±‚å•é‡å­æ¯”ç‰¹é—¨å°±èƒ½ç¼–ç 2*n*ä¸ªè¿ç»­ç‰¹å¾çš„èƒ½åŠ›ã€‚'
- en: 7.3 Amplitude Encoding
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3 æŒ¯å¹…ç¼–ç 
- en: 'So far we have not utilised the information encoding possibilities provided
    by entanglement although, in principle, most of the information in large quantum
    systems can be stored in correlations. In the case of our 8-feature dataset example
    considered in the previous section, we can reduce the number of necessary qubits
    to just three if we use entanglement. The first six rotation angles *ğœƒ*[1]*,â€¦,ğœƒ*[6]
    can still be used for the single-qubit rotations R[Y]*,*R[Z]. The last two, *ğœƒ*[7]
    and *ğœƒ*[8], can be used for controlled rotations that entangle qubits 1 and 2
    and qubits 2 and 3 as shown in FigureÂ [7.7](#7.7):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬è¿˜æ²¡æœ‰åˆ©ç”¨çº ç¼ æ‰€æä¾›çš„ä¿¡æ¯ç¼–ç å¯èƒ½æ€§ï¼Œå°½ç®¡ä»ç†è®ºä¸Šè®²ï¼Œå¤§å¤šæ•°å¤§è§„æ¨¡é‡å­ç³»ç»Ÿä¸­çš„ä¿¡æ¯å¯ä»¥å­˜å‚¨åœ¨å…³è”ä¸­ã€‚åœ¨å‰ä¸€èŠ‚ä¸­è€ƒè™‘çš„8ç‰¹å¾æ•°æ®é›†ç¤ºä¾‹ä¸­ï¼Œå¦‚æœä½¿ç”¨çº ç¼ ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ‰€éœ€é‡å­æ¯”ç‰¹çš„æ•°é‡å‡å°‘åˆ°ä»…ä¸‰ä¸ªã€‚å‰å…­ä¸ªæ—‹è½¬è§’åº¦*ğœƒ*[1]*ï¼Œâ€¦ï¼Œğœƒ*[6]ä»ç„¶å¯ä»¥ç”¨äºå•é‡å­æ¯”ç‰¹æ—‹è½¬R[Y]*ï¼Œ*R[Z]ã€‚æœ€åä¸¤ä¸ªè§’åº¦ï¼Œ*ğœƒ*[7]å’Œ*ğœƒ*[8]ï¼Œå¯ä»¥ç”¨äºå—æ§æ—‹è½¬ï¼Œçº ç¼ é‡å­æ¯”ç‰¹1å’Œ2ä»¥åŠé‡å­æ¯”ç‰¹2å’Œ3ï¼Œå¦‚å›¾[7.7](#7.7)æ‰€ç¤ºï¼š
- en: '![FigureÂ 7.7: 3-qubit quantum circuit for 8-feature sample encoding. ](img/file682.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾7.7ï¼š8ç‰¹å¾æ ·æœ¬ç¼–ç çš„3é‡å­æ¯”ç‰¹é‡å­ç”µè·¯ã€‚](img/file682.jpg)'
- en: 'FigureÂ 7.7: 3-qubit quantum circuit for 8-feature sample encoding.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾7.7ï¼š8ç‰¹å¾æ ·æœ¬ç¼–ç çš„3é‡å­æ¯”ç‰¹é‡å­ç”µè·¯ã€‚
- en: In principle, since the *n*-qubit state can be uniquely described by specifying
    2^n probability amplitudes, we only need *n* qubits to encode 2^n features. However,
    this superdense encoding is not always practical or desirable. The *amplitude*
    *encoding* was used in the seminal work by Harrow, Hassidim, and LloydÂ Â [[126](Biblography.xhtml#XHHL2009)],
    but obtaining the amplitude encoding is a non-trivial task for problems of realistic
    size and this, usually, is the main bottleneck for many quantum algorithmsÂ Â [[184](Biblography.xhtml#XLandman2021)].
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ä»ç†è®ºä¸Šè®²ï¼Œç”±äº*n*é‡å­æ¯”ç‰¹çŠ¶æ€å¯ä»¥é€šè¿‡æŒ‡å®š2^nä¸ªæ¦‚ç‡æŒ¯å¹…æ¥å”¯ä¸€æè¿°ï¼Œæˆ‘ä»¬åªéœ€è¦*n*ä¸ªé‡å­æ¯”ç‰¹å°±å¯ä»¥ç¼–ç 2^nä¸ªç‰¹å¾ã€‚ç„¶è€Œï¼Œè¿™ç§è¶…å¯†ç¼–ç å¹¶ä¸æ€»æ˜¯å®ç”¨æˆ–å¯å–çš„ã€‚*æŒ¯å¹…*
    *ç¼–ç *æ›¾åœ¨Harrowã€Hassidimå’ŒLloydçš„å¼€åˆ›æ€§å·¥ä½œä¸­ä½¿ç”¨[[126](Biblography.xhtml#XHHL2009)]ï¼Œä½†å¯¹äºç°å®è§„æ¨¡çš„é—®é¢˜ï¼Œè·å¾—æŒ¯å¹…ç¼–ç æ˜¯ä¸€é¡¹éå¹³å‡¡çš„ä»»åŠ¡ï¼Œè¿™é€šå¸¸æ˜¯è®¸å¤šé‡å­ç®—æ³•çš„ä¸»è¦ç“¶é¢ˆ[[184](Biblography.xhtml#XLandman2021)]ã€‚
- en: The amplitude encoding can be formalised in the following way. Consider an *N*-dimensional
    (with *N* = 2^n) data point x := (*x*[1]*,â€¦,x*[N]) âˆˆâ„‚^N. We can associate quantum
    amplitudes to the coordinates as
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: æŒ¯å¹…ç¼–ç å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼å½¢å¼åŒ–ã€‚è€ƒè™‘ä¸€ä¸ª*N*ç»´åº¦ï¼ˆ*N* = 2^nï¼‰çš„æ•°æ®ç‚¹x := (*x*[1]*ï¼Œâ€¦ï¼Œx*[N]) âˆˆâ„‚^Nã€‚æˆ‘ä»¬å¯ä»¥å°†é‡å­æŒ¯å¹…ä¸åæ ‡å…³è”ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '![ âˆ‘N |ÏˆxâŸ© = -1-- xi |iâŸ©, âˆ¥xâˆ¥ i=1 ](img/file683.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![ âˆ‘N |ÏˆxâŸ© = -1-- xi |iâŸ©, âˆ¥xâˆ¥ i=1 ](img/file683.jpg)'
- en: where âˆ¥xâˆ¥ := âˆ‘ [i=1]^N|*x*[i]|Â² is the normalisation factor. We can therefore
    encode the dataset D := (xÂ¹*,â€¦,*x^M) consisting ofÂ *M* points inÂ â„^N as
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ âˆ¥xâˆ¥ := âˆ‘ [i=1]^N|*x*[i]|Â² æ˜¯å½’ä¸€åŒ–å› å­ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å°†ç”± *M* ä¸ªç‚¹ç»„æˆçš„æ•°æ®é›† D := (xÂ¹*,â€¦,*x^M)
    ç¼–ç ä¸º
- en: '![ p 1 2âˆ‘ -- |DâŸ© = C-- xi |iâŸ©, D i=1 ](img/file684.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![ p 1 2âˆ‘ -- |DâŸ© = C-- xi |iâŸ©, D i=1 ](img/file684.jpg)'
- en: for some integerÂ *p*, where
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæŸä¸ªæ•´æ•° *p*ï¼Œå…¶ä¸­
- en: '![-- -- 1 1 2 2 M M MN x = (xi)i=1,...,2p = (x1,...,xN ,x1,...,x N,...,x1 ,...,x
    N ) âˆˆ â„ ](img/file685.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![-- -- 1 1 2 2 M M MN x = (xi)i=1,...,2p = (x1,...,xN ,x1,...,x N,...,x1 ,...,x
    N ) âˆˆ â„ ](img/file685.jpg)'
- en: is the concatenation of all the data points andÂ *C*[D] is a normalisation constant.
    Here the constraint is hence that 2^p â‰¥ *MN*, namely *p* â‰¥ log [2](*MN*). Note
    that there may again be some sparsity in the case where 2^p *> MN*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜¯æ‰€æœ‰æ•°æ®ç‚¹çš„æ‹¼æ¥ï¼Œä¸”Â *C*[D] æ˜¯ä¸€ä¸ªå½’ä¸€åŒ–å¸¸æ•°ã€‚å› æ­¤ï¼Œçº¦æŸæ¡ä»¶ä¸º 2^p â‰¥ *MN*ï¼Œå³ *p* â‰¥ log [2](*MN*)ã€‚æ³¨æ„ï¼Œåœ¨ 2^p
    *> MN* çš„æƒ…å†µä¸‹ï¼Œå¯èƒ½ä¼šå†æ¬¡å‡ºç°ç¨€ç–æ€§ã€‚
- en: The clear advantage is that it can storeÂ 2^n features with onlyÂ *n* qubits,
    but unfortunately has a depth ğ’ª(2*n*) and is hence hard to build.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜æ˜¾çš„ä¼˜ç‚¹æ˜¯å®ƒå¯ä»¥ç”¨ä»… *n* ä¸ªé‡å­æ¯”ç‰¹å­˜å‚¨ 2^n ä¸ªç‰¹å¾ï¼Œä½†ä¸å¹¸çš„æ˜¯å…¶æ·±åº¦ä¸º ğ’ª(2*n*)ï¼Œå› æ­¤å¾ˆéš¾æ„å»ºã€‚
- en: With the amplitude encoding, *n* quantum registers have capacity to encode 2^n
    continuous features. However, this requires construction of the deep quantum circuits
    with the circuit depth growing as ğ’ª(2*n*). This solution may not be practical
    for NISQ computers when dealing with a large number of features.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡å¹…åº¦ç¼–ç ï¼Œ*n* ä¸ªé‡å­å¯„å­˜å™¨å¯ä»¥ç¼–ç  2^n ä¸ªè¿ç»­ç‰¹å¾ã€‚ç„¶è€Œï¼Œè¿™éœ€è¦æ„å»ºæ·±åº¦é‡å­ç”µè·¯ï¼Œä¸”ç”µè·¯æ·±åº¦éšç€ ğ’ª(2*n*) å¢é•¿ã€‚å› æ­¤ï¼Œå½“å¤„ç†å¤§é‡ç‰¹å¾æ—¶ï¼Œå¯¹äº
    NISQ è®¡ç®—æœºè€Œè¨€ï¼Œè¿™ç§æ–¹æ¡ˆå¯èƒ½å¹¶ä¸å®é™…ã€‚
- en: 7.4 Binary Inputs into Basis States
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4 äºŒè¿›åˆ¶è¾“å…¥åˆ°åŸºæ€
- en: Consider a real number *x* âˆˆâ„ approximated with the binary representation
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘ä¸€ä¸ªå®æ•° *x* âˆˆâ„ï¼Œç”¨äºŒè¿›åˆ¶è¡¨ç¤ºæ³•è¿‘ä¼¼
- en: '| ![ ( ) ğ”¦âˆ‘âˆ’1 âˆ‘ğ”¡ x â‰ˆ ^x = (x ğ”¦,xğ”¦âˆ’1,â‹…â‹…â‹… ,xâˆ’ğ”¡) := (âˆ’ 1)xğ”¦( xj2j + x âˆ’j2âˆ’j) j=0
    j=1 â†¦âˆ’ â†’ &#124;xğ”¦xğ”¦âˆ’1â‹…â‹…â‹…xâˆ’ğ”¡âŸ© =: &#124;xâŸ©, ](img/file686.jpg) |  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| ![ ( ) ğ”¦âˆ‘âˆ’1 âˆ‘ğ”¡ x â‰ˆ ^x = (x ğ”¦,xğ”¦âˆ’1,â‹…â‹…â‹… ,xâˆ’ğ”¡) := (âˆ’ 1)xğ”¦( xj2j + x âˆ’j2âˆ’j) j=0
    j=1 â†¦âˆ’ â†’ &#124;xğ”¦xğ”¦âˆ’1â‹…â‹…â‹…xâˆ’ğ”¡âŸ© =: &#124;xâŸ©, ](img/file686.jpg) |  |'
- en: for some non-negative integers ğ”¦*,*ğ”¡, where *x*[ğ”¦] âˆˆ{0*,*1} accounts for the
    sign ofÂ *x* and (*x*[j])[j=0,â€¦,ğ”¦âˆ’1] âˆˆ{0*,*1}^(ğ”¦) and (*x*[j])[j=âˆ’1,â€¦,âˆ’ğ”¡] âˆˆ{0*,*1}^(ğ”¡)
    represent respectively the integer and decimal parts ofÂ *x*. Consider now a vector
    x := (*x*Â¹*,â€¦,x*^N) âˆˆâ„^N. We can concatenate all the binary approximations *x*Â¹*,â€¦,**x*^N
    into one vector
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºä¸€äº›éè´Ÿæ•´æ•°ğ”¦*ï¼Œ*ğ”¡ï¼Œå…¶ä¸­ *x*[ğ”¦] âˆˆ{0*,*1}è¡¨ç¤º *x* çš„ç¬¦å·ï¼Œä¸” (*x*[j])[j=0,â€¦,ğ”¦âˆ’1] âˆˆ{0*,*1}^(ğ”¦)
    å’Œ (*x*[j])[j=âˆ’1,â€¦,âˆ’ğ”¡] âˆˆ{0*,*1}^(ğ”¡)åˆ†åˆ«è¡¨ç¤º *x* çš„æ•´æ•°éƒ¨åˆ†å’Œå°æ•°éƒ¨åˆ†ã€‚ç°åœ¨è€ƒè™‘ä¸€ä¸ªå‘é‡ x := (*x*Â¹*,â€¦,x*^N)
    âˆˆâ„^Nã€‚æˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰äºŒè¿›åˆ¶è¿‘ä¼¼å€¼ *x*Â¹*,â€¦,**x*^N æ‹¼æ¥æˆä¸€ä¸ªå‘é‡ã€‚
- en: '![( 1 1 1 N N N ) (1+ğ”¦+ğ”¡)N xğ”¦,xğ”¦âˆ’ 1,â‹…â‹…â‹… ,xâˆ’ğ”¡,â‹…â‹…â‹… ,xğ”¦ ,x ğ”¦âˆ’1,â‹…â‹…â‹… ,xâˆ’ ğ”¡ âˆˆ {0,1}
    ](img/file687.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![( 1 1 1 N N N ) (1+ğ”¦+ğ”¡)N xğ”¦,xğ”¦âˆ’ 1,â‹…â‹…â‹… ,xâˆ’ğ”¡,â‹…â‹…â‹… ,xğ”¦ ,x ğ”¦âˆ’1,â‹…â‹…â‹… ,xâˆ’ ğ”¡ âˆˆ {0,1}
    ](img/file687.jpg)'
- en: to obtain a quantum state representation with (1 + ğ”¦ + ğ”¡)*N* qubits of the form
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ (1 + ğ”¦ + ğ”¡)*N* ä¸ªé‡å­æ¯”ç‰¹çš„å½¢å¼è·å¾—é‡å­æ€è¡¨ç¤º
- en: '![ 1 1 1 N N N âŸ© |xğ”¦xğ”¦âˆ’1â‹…â‹…â‹…xâˆ’ğ”¡ â‹…â‹…â‹…x ğ”¦ ,xğ”¦âˆ’1â‹…â‹…â‹…xâˆ’ğ”¡ . ](img/file688.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![ 1 1 1 N N N âŸ© |xğ”¦xğ”¦âˆ’1â‹…â‹…â‹…xâˆ’ğ”¡ â‹…â‹…â‹…x ğ”¦ ,xğ”¦âˆ’1â‹…â‹…â‹…xâˆ’ğ”¡ . ](img/file688.jpg)'
- en: Since the vector thus obtained only containsÂ 0 andÂ 1, starting from the quantum
    state ![|0âŸ©](img/file689.jpg)^(âŠ—(1+ğ”¦+ğ”¡)N), we only need to apply the NOT gateÂ X
    whenever the corresponding value is equal to one, so that the encoding circuit
    simply reads
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºç”±æ­¤è·å¾—çš„å‘é‡ä»…åŒ…å« 0 å’Œ 1ï¼Œä»é‡å­æ€ ![|0âŸ©](img/file689.jpg)^(âŠ—(1+ğ”¦+ğ”¡)N) å¼€å§‹ï¼Œæˆ‘ä»¬åªéœ€åœ¨ç›¸åº”å€¼ä¸º 1 æ—¶åº”ç”¨éé—¨
    Xï¼Œå› æ­¤ç¼–ç ç”µè·¯ä»…éœ€è¯»å–
- en: '![ âŠ—(1+ğ”¦+ğ”¡)N âŠ—N âŠ— ğ”¦ xl âŠ—(1+ğ”¦+ğ”¡)N |0âŸ© â†¦âˆ’ â†’ X k |0âŸ© . l=1 k=âˆ’ğ”¡ ](img/file690.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![ âŠ—(1+ğ”¦+ğ”¡)N âŠ—N âŠ— ğ”¦ xl âŠ—(1+ğ”¦+ğ”¡)N |0âŸ© â†¦âˆ’ â†’ X k |0âŸ© . l=1 k=âˆ’ğ”¡ ](img/file690.jpg)'
- en: While the algorithm is straightforward and only requires the use of the single-qubit
    quantum gateÂ X, it requires a large number of qubits and is in general not efficient
    in practice. Indeed, for a given dimensionÂ *N*, there are 2^N possible basis states.
    If a dataset contains onlyÂ *M* points withÂ *M* being much smaller thanÂ *N*, the
    quantum representation will therefore be sparse.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶è¯¥ç®—æ³•ç›´æ¥ä¸”åªéœ€è¦ä½¿ç”¨å•é‡å­æ¯”ç‰¹é—¨ Xï¼Œä½†å®ƒéœ€è¦å¤§é‡çš„é‡å­æ¯”ç‰¹ï¼Œå¹¶ä¸”é€šå¸¸åœ¨å®é™…ä¸­æ•ˆç‡è¾ƒä½ã€‚å®é™…ä¸Šï¼Œå¯¹äºç»™å®šçš„ç»´åº¦ *N*ï¼Œå­˜åœ¨ 2^N ç§å¯èƒ½çš„åŸºæ€ã€‚å¦‚æœä¸€ä¸ªæ•°æ®é›†åªåŒ…å«
    *M* ä¸ªç‚¹ï¼Œä¸” *M* è¿œå°äº *N*ï¼Œé‚£ä¹ˆé‡å­è¡¨ç¤ºå°†ä¼šéå¸¸ç¨€ç–ã€‚
- en: '**Example:** Consider a dataset D = (*x*Â¹*,x*Â²) with *x*Â¹*,x*Â² âˆˆ [âˆ’2*,*2],
    each approximated with four qubits:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç¤ºä¾‹ï¼š** è€ƒè™‘ä¸€ä¸ªæ•°æ®é›† D = (*x*Â¹*,x*Â²)ï¼Œå…¶ä¸­ *x*Â¹*,x*Â² âˆˆ [âˆ’2*,*2]ï¼Œæ¯ä¸ªç”¨å››ä¸ªé‡å­æ¯”ç‰¹è¿‘ä¼¼è¡¨ç¤ºï¼š'
- en: '![ 1 1( 1 1 ) x1 â‰ˆ (âˆ’ 1)x1(20x10 + 2âˆ’ 1x1âˆ’1 + 2âˆ’2x1âˆ’2) = (âˆ’ 1)x1 x10 +-x1âˆ’1
    +-x1âˆ’ 2 2 4 ](img/file691.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![ 1 1( 1 1 ) x1 â‰ˆ (âˆ’ 1)x1(20x10 + 2âˆ’ 1x1âˆ’1 + 2âˆ’2x1âˆ’2) = (âˆ’ 1)x1 x10 +-x1âˆ’1
    +-x1âˆ’ 2 2 4 ](img/file691.jpg)'
- en: and
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: å’Œ
- en: '![ 2 2 ( 1 1 ) x2 â‰ˆ (âˆ’ 1)x1(20x20 + 2âˆ’1x2âˆ’ 1 + 2âˆ’2x2âˆ’2) = (âˆ’ 1)x1 x20 +-x2âˆ’1
    +-x2âˆ’2 , 2 4 ](img/file692.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![ 2 2 ( 1 1 ) x2 â‰ˆ (âˆ’ 1)x1(20x20 + 2âˆ’1x2âˆ’ 1 + 2âˆ’2x2âˆ’2) = (âˆ’ 1)x1 x20 +-x2âˆ’1
    +-x2âˆ’2 , 2 4 ](img/file692.jpg)'
- en: with *x*[k]^i âˆˆ{0*,*1} for each *i* = 1*,*2 and *k* = âˆ’2*,*âˆ’1*,*0*,*1\. Their
    quantum embeddings therefore read ![|x1x1x1 x1 âŸ© 1 0 âˆ’ 1 âˆ’2](img/file693.jpg)
    and ![|x2x2x2 x2 âŸ© 1 0 âˆ’1 âˆ’ 2](img/file694.jpg), and the quantum circuit to encode
    the dataset therefore takes the form
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ¯ä¸ª*i* = 1*,*2 å’Œ *k* = âˆ’2*,*âˆ’1*,*0*,*1ï¼Œ*x*[k]^i âˆˆ{0*,*1}ã€‚å› æ­¤ï¼Œå®ƒä»¬çš„é‡å­åµŒå…¥ä¸ºï¼[|x1x1x1
    x1 âŸ© 1 0 âˆ’ 1 âˆ’2](img/file693.jpg) å’Œ ![|x2x2x2 x2 âŸ© 1 0 âˆ’1 âˆ’ 2](img/file694.jpg)ï¼Œå› æ­¤ç¼–ç æ•°æ®é›†çš„é‡å­ç”µè·¯é‡‡ç”¨å¦‚ä¸‹å½¢å¼ï¼š
- en: '![ [( 1 1 1 1 ) ( 2 2 2 2 )] |0âŸ©âŠ—8 â†¦âˆ’â†’ Xx1 âŠ— Xx0 âŠ— Xxâˆ’1 âŠ— Xxâˆ’2 âŠ— Xx1 âŠ— Xx0
    âŠ— Xxâˆ’1 âŠ— Xxâˆ’2 |0âŸ©âŠ—8\. ](img/file695.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![ [( 1 1 1 1 ) ( 2 2 2 2 )] |0âŸ©âŠ—8 â†¦âˆ’â†’ Xx1 âŠ— Xx0 âŠ— Xxâˆ’1 âŠ— Xxâˆ’2 âŠ— Xx1 âŠ— Xx0
    âŠ— Xxâˆ’1 âŠ— Xxâˆ’2 |0âŸ©âŠ—8\. ](img/file695.jpg)'
- en: 7.5 Superposition Encoding
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5 å åŠ ç¼–ç 
- en: As developed inÂ Â [[287](Biblography.xhtml#XTrugenberger2001),Â [294](Biblography.xhtml#XVentura2000)],
    it is possible to build such a superposition of data in time linear in the number
    of points and features. We consider again a dataset D := (xÂ¹*,â€¦,*x^M), with x^k
    := (*x*[1]^k*,â€¦,x*[n]^k) âˆˆ{0*,*1}^n for each *k* = 1*,â€¦,M*. We use a quantum system
    of the form
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚[[287](Biblography.xhtml#XTrugenberger2001), [294](Biblography.xhtml#XVentura2000)]ä¸­æ‰€è¿°ï¼Œå¯ä»¥åœ¨æ—¶é—´ä¸Šä¸æ•°æ®ç‚¹å’Œç‰¹å¾æ•°é‡æˆçº¿æ€§å…³ç³»åœ°æ„å»ºè¿™æ ·çš„æ•°æ®å åŠ ã€‚æˆ‘ä»¬å†æ¬¡è€ƒè™‘ä¸€ä¸ªæ•°æ®é›†
    D := (xÂ¹*,â€¦,*x^M)ï¼Œå…¶ä¸­ x^k := (*x*[1]^k*,â€¦,x*[n]^k) âˆˆ{0*,*1}^n å¯¹äºæ¯ä¸ª *k* = 1*,â€¦,M*ã€‚æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªé‡å­ç³»ç»Ÿï¼Œå…¶å½¢å¼ä¸ºï¼š
- en: '![|Ïˆ0âŸ© := |0âŸ©âŠ—n |00âŸ© |0âŸ©âŠ—n , ](img/file696.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![|Ïˆ0âŸ© := |0âŸ©âŠ—n |00âŸ© |0âŸ©âŠ—n , ](img/file696.jpg)'
- en: where the left-most part withÂ *n* qubits is called the loading register while
    the right-most one (also withÂ *n* qubits) is the storage register. The middle
    one is an ancilla register that will be used to control manipulations between
    the loading and storage registers. The encoding algorithm works recursively. We
    first apply an Hadamard gate to the second ancilla qubit and store the first data
    point xÂ¹ into the storage register. Since
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­æœ€å·¦è¾¹çš„éƒ¨åˆ†åŒ…å«*n*ä¸ªé‡å­æ¯”ç‰¹ï¼Œç§°ä¸ºåŠ è½½å¯„å­˜å™¨ï¼Œè€Œæœ€å³è¾¹çš„éƒ¨åˆ†ï¼ˆåŒæ ·åŒ…å«*n*ä¸ªé‡å­æ¯”ç‰¹ï¼‰æ˜¯å­˜å‚¨å¯„å­˜å™¨ã€‚ä¸­é—´éƒ¨åˆ†æ˜¯ä¸€ä¸ªè¾…åŠ©å¯„å­˜å™¨ï¼Œç”¨äºæ§åˆ¶åŠ è½½å¯„å­˜å™¨å’Œå­˜å‚¨å¯„å­˜å™¨ä¹‹é—´çš„æ“ä½œã€‚ç¼–ç ç®—æ³•æ˜¯é€’å½’å·¥ä½œçš„ã€‚æˆ‘ä»¬é¦–å…ˆå¯¹ç¬¬äºŒä¸ªè¾…åŠ©é‡å­æ¯”ç‰¹åº”ç”¨
    Hadamard é—¨ï¼Œå¹¶å°†ç¬¬ä¸€ä¸ªæ•°æ®ç‚¹ xÂ¹ å­˜å…¥å­˜å‚¨å¯„å­˜å™¨ã€‚ç”±äº
- en: '![(âŠ— n ) Xx1i |0âŸ©âŠ—n = |x1 â‹…â‹…â‹…x1âŸ© = |x1âŸ©, i=1 1 n ](img/file697.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![(âŠ— n ) Xx1i |0âŸ©âŠ—n = |x1 â‹…â‹…â‹…x1âŸ© = |x1âŸ©, i=1 1 n ](img/file697.jpg)'
- en: this can be achieved (after the Hadamard operation) by applying the unitary
    operator
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯ä»¥é€šè¿‡åº”ç”¨é…‰ç®—ç¬¦ï¼ˆåœ¨ Hadamard æ“ä½œä¹‹åï¼‰æ¥å®ç°ã€‚
- en: '![ ( n ) IâŠ—n âŠ— IâŠ— H âŠ— âŠ— Xx1i i=1 ](img/file698.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![ ( n ) IâŠ—n âŠ— IâŠ— H âŠ— âŠ— Xx1i i=1 ](img/file698.jpg)'
- en: controlled with the second ancilla qubit, and the resulting quantum state reads
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±ç¬¬äºŒä¸ªè¾…åŠ©é‡å­æ¯”ç‰¹æ§åˆ¶ï¼Œå¾—åˆ°çš„é‡å­æ€ä¸ºï¼š
- en: '![ âŠ—n âŠ—n âŠ—n 1âŸ© |Ïˆ âŸ© := |0âŸ©--|0âˆš0âŸ©-|0âŸ©---+ |0âŸ©---|âˆš01âŸ© |x-. 1 2 2 ](img/file699.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![ âŠ—n âŠ—n âŠ—n 1âŸ© |Ïˆ âŸ© := |0âŸ©--|0âˆš0âŸ©-|0âŸ©---+ |0âŸ©---|âˆš01âŸ© |x-. 1 2 2 ](img/file699.jpg)'
- en: This can easily be turned (see the proof of LemmaÂ [7](#x1-158003r7) below) into
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯ä»¥é€šè¿‡ï¼ˆå‚è§ä¸‹æ–‡å¼•ç†[7](#x1-158003r7)çš„è¯æ˜ï¼‰è½»æ¾è½¬åŒ–ä¸º
- en: '![ âŠ—n 1âŸ© âŠ—n âŠ—n |Ïˆ âŸ© = |0âŸ©--|âˆš00âŸ© |x--+ |0âŸ©---|0âˆš1âŸ©-|0âŸ©---. 1 2 2 ](img/file700.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![ âŠ—n 1âŸ© âŠ—n âŠ—n |Ïˆ âŸ© = |0âŸ©--|âˆš00âŸ© |x--+ |0âŸ©---|0âˆš1âŸ©-|0âŸ©---. 1 2 2 ](img/file700.jpg)'
- en: AfterÂ *m* steps, we arrive at a quantum state of the form
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨*m*æ­¥ä¹‹åï¼Œæˆ‘ä»¬å¾—åˆ°äº†å¦‚ä¸‹å½¢å¼çš„é‡å­æ€ï¼š
- en: '| ![ 1 âˆ‘m âŸ© âˆ˜ M--âˆ’-m-- &#124;Ïˆm âŸ© := âˆš--- &#124;0âŸ©âŠ—n &#124;00âŸ© &#124;xk + -------
    &#124;0âŸ©âŠ—n &#124;01 âŸ© &#124;0 âŸ©âŠ—n . M k=1 M ](img/file701.jpg) |  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| ![ 1 âˆ‘m âŸ© âˆ˜ M--âˆ’-m-- &#124;Ïˆm âŸ© := âˆš--- &#124;0âŸ©âŠ—n &#124;00âŸ© &#124;xk + -------
    &#124;0âŸ©âŠ—n &#124;01 âŸ© &#124;0 âŸ©âŠ—n . M k=1 M ](img/file701.jpg) |  |'
- en: 'The following lemma guarantees the validity of the algorithm:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹å¼•ç†ä¿è¯äº†ç®—æ³•çš„æœ‰æ•ˆæ€§ï¼š
- en: '**Lemma 7.** *There exists a unitary operator* U *such that*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**å¼•ç† 7.** *å­˜åœ¨ä¸€ä¸ªé…‰ç®—ç¬¦* U *ä½¿å¾—*'
- en: '![ m+1 âˆ˜ ------------- -1-- âˆ‘ âŠ—n kâŸ© M-âˆ’--(m--+-1) âŠ—n âŠ—n U |Ïˆm âŸ© = âˆšM--- |0âŸ©
    |00âŸ© |x + M |0âŸ© |01âŸ© |0âŸ© =: |Ïˆm+1 âŸ© k=1 ](img/file702.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![ m+1 âˆ˜ ------------- -1-- âˆ‘ âŠ—n kâŸ© M-âˆ’--(m--+-1) âŠ—n âŠ—n U |Ïˆm âŸ© = âˆšM--- |0âŸ©
    |00âŸ© |x + M |0âŸ© |01âŸ© |0âŸ© =: |Ïˆm+1 âŸ© k=1 ](img/file702.jpg)'
- en: '*Proof.* The proof is constructive and shows precisely what the operatorÂ U
    looks like.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*è¯æ˜ã€‚* è¯æ˜æ˜¯æ„é€ æ€§çš„ï¼Œç²¾ç¡®åœ°å±•ç¤ºäº†ç®—ç¬¦Uçš„å½¢æ€ã€‚'
- en: Construct the successive maps
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ„é€ è¿ç»­çš„æ˜ å°„
- en: '| ![ âˆ‘m âŸ© âˆ˜ -------- &#124;Ïˆ âŸ© = âˆš-1-- &#124;0âŸ©âŠ—n &#124;00 âŸ© &#124;xk + M-âˆ’--m-&#124;0âŸ©âŠ—n
    &#124;01âŸ© &#124;0âŸ©âŠ—n , m M k=1 M m âŸ© âˆ˜ -------- â†¦âˆ’â†’ âˆš-1--âˆ‘ &#124;xm+1 âŸ© &#124;00âŸ©
    &#124;xk + M--âˆ’-m-&#124;xm+1 âŸ© &#124;01âŸ© &#124;0âŸ©âŠ—n, M M km=1 âŸ© âˆ˜ -------- â†¦âˆ’â†’
    âˆš-1--âˆ‘ &#124;xm+1 âŸ© &#124;00âŸ© &#124;xk + M--âˆ’-m-&#124;xm+1 âŸ© &#124;01âŸ© &#124;xm+1
    âŸ©, M M km=1 âˆ˜ -------- --1- âˆ‘ m+1 âŸ© kâŸ© M--âˆ’-m- m+1 âŸ© m+1 âŸ© ^ âŸ© â†¦âˆ’â†’ âˆšM--- &#124;x
    &#124;00âŸ© &#124;x + M &#124;x &#124;11âŸ© &#124;x =: &#124;Ïˆm . k=1 ](img/file703.jpg)
    |'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![ âˆ‘m âŸ© âˆ˜ -------- &#124;Ïˆ âŸ© = âˆš-1-- &#124;0âŸ©âŠ—n &#124;00 âŸ© &#124;xk + M-âˆ’--m-&#124;0âŸ©âŠ—n
    &#124;01âŸ© &#124;0âŸ©âŠ—n , m M k=1 M m âŸ© âˆ˜ -------- â†¦âˆ’â†’ âˆš-1--âˆ‘ &#124;xm+1 âŸ© &#124;00âŸ©
    &#124;xk + M--âˆ’-m-&#124;xm+1 âŸ© &#124;01âŸ© &#124;0âŸ©âŠ—n, M M km=1 âŸ© âˆ˜ -------- â†¦âˆ’â†’
    âˆš-1--âˆ‘ &#124;xm+1 âŸ© &#124;00âŸ© &#124;xk + M--âˆ’-m-&#124;xm+1 âŸ© &#124;01âŸ© &#124;xm+1
    âŸ©, M M km=1 âˆ˜ -------- --1- âˆ‘ m+1 âŸ© kâŸ© M--âˆ’-m- m+1 âŸ© m+1 âŸ© ^ âŸ© â†¦âˆ’â†’ âˆšM--- &#124;x
    &#124;00âŸ© &#124;x + M &#124;x &#124;11âŸ© &#124;x =: &#124;Ïˆm . k=1 ](img/file703.jpg)
    |'
- en: The first one is easily achieved by applying the operator ![( ) âŠ—ni=1 Xxmi+1](img/file704.jpg)âŠ—I^(âŠ—2)
    âŠ—I^(âŠ—n) to ![|ÏˆmâŸ©](img/file705.jpg). The second step is realised with controlled
    gates using the second qubit of the ancilla register as control. The last one
    is trivial with a CNOT gate on the first ancilla qubit using the second ancilla
    qubit as control.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€æ­¥å¯ä»¥é€šè¿‡åº”ç”¨ç®—ç¬¦ ![( ) âŠ—ni=1 Xxmi+1](img/file704.jpg)âŠ—I^(âŠ—2) âŠ—I^(âŠ—n) åˆ° ![|ÏˆmâŸ©](img/file705.jpg)
    æ¥è½»æ¾å®ç°ã€‚ç¬¬äºŒæ­¥æ˜¯é€šè¿‡æ§åˆ¶é—¨ï¼Œåˆ©ç”¨è¾…åŠ©å¯„å­˜å™¨çš„ç¬¬äºŒä¸ªé‡å­æ¯”ç‰¹ä½œä¸ºæ§åˆ¶æ¥å®ç°ã€‚æœ€åä¸€æ­¥é€šè¿‡åœ¨ç¬¬ä¸€ä¸ªè¾…åŠ©é‡å­æ¯”ç‰¹ä¸Šä½¿ç”¨CNOTé—¨ï¼Œä»¥ç¬¬äºŒä¸ªè¾…åŠ©é‡å­æ¯”ç‰¹ä¸ºæ§åˆ¶å®ç°ï¼Œè¿‡ç¨‹éå¸¸ç®€å•ã€‚
- en: Now define the unitary gate
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ç°åœ¨å®šä¹‰è¿™ä¸ªå•ä½é—¨
- en: '![ ( âˆš----------- ) ^U := âˆš--1-----( M âˆ’ m âˆ’ 1 ----1-----) , M âˆ’ m âˆ’ 1 âˆš M
    âˆ’ m âˆ’ 1 ](img/file706.jpg)'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![ ( âˆš----------- ) ^U := âˆš--1-----( M âˆ’ m âˆ’ 1 ----1-----) , M âˆ’ m âˆ’ 1 âˆš M
    âˆ’ m âˆ’ 1 ](img/file706.jpg)'
- en: and note that its controlled (by the first ancilla qubitÂ *a*[1]) version [a[1]]U
    acts as
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å¹¶ä¸”è¯·æ³¨æ„ï¼Œæ§åˆ¶ç‰ˆæœ¬ï¼ˆç”±ç¬¬ä¸€ä¸ªè¾…åŠ©é‡å­æ¯”ç‰¹ *a*[1] æ§åˆ¶ï¼‰[a[1]]U çš„ä½œç”¨æ˜¯
- en: '| [a[1]]U![&#124;00âŸ©](img/file707.jpg) | = ![&#124;00âŸ©](img/file708.jpg)*,*
    |'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| [a[1]]U![&#124;00âŸ©](img/file707.jpg) | = ![&#124;00âŸ©](img/file708.jpg)*,*
    |'
- en: '| [a[1]]U![&#124;11âŸ©](img/file709.jpg) | = ![---1----- âˆšM--âˆ’-m--](img/file710.jpg)![&#124;1âŸ©](img/file711.jpg)âŠ—![(
    âˆš ----------- ) &#124;0âŸ© + M âˆ’ m âˆ’ 1 &#124;1âŸ©](img/file712.jpg) = ![ âˆš -----------
    &#124;10âŸ©+---M--âˆ’-m-âˆ’-1-&#124;11âŸ©- âˆšM--âˆ’-m--](img/file713.jpg)*.* |'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| [a[1]]U![&#124;11âŸ©](img/file709.jpg) | = ![---1----- âˆšM--âˆ’-m--](img/file710.jpg)![&#124;1âŸ©](img/file711.jpg)âŠ—![(
    âˆš ----------- ) &#124;0âŸ© + M âˆ’ m âˆ’ 1 &#124;1âŸ©](img/file712.jpg) = ![ âˆš -----------
    &#124;10âŸ©+---M--âˆ’-m-âˆ’-1-&#124;11âŸ©- âˆšM--âˆ’-m--](img/file713.jpg)*.* |'
- en: Applying it to the ancilla register ofÂ ![ âŸ© |^Ïˆm](img/file714.jpg) in StepÂ 1
    (and leaving all other qubits unchanged) yields
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å°†å…¶åº”ç”¨äºæ­¥éª¤ 1 ä¸­çš„è¾…åŠ©å¯„å­˜å™¨ ![ âŸ© |^Ïˆm](img/file714.jpg)ï¼ˆå¹¶ä¿æŒå…¶ä»–é‡å­æ¯”ç‰¹ä¸å˜ï¼‰å°†å¾—åˆ°
- en: '|  | = I^(âŠ—n) âŠ— [a[1]]UâŠ—I^(âŠ—n)![ âŸ© &#124;^Ïˆm](img/file715.jpg) |'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = I^(âŠ—n) âŠ— [a[1]]UâŠ—I^(âŠ—n)![ âŸ© &#124;^Ïˆm](img/file715.jpg) |'
- en: '|  | = ![âˆš-1-- M](img/file716.jpg)âˆ‘ [k=1]^m![&#124;xm+1 âŸ©](img/file717.jpg)![
    &#124;00âŸ©](img/file718.jpg)![ âŸ© &#124;xk](img/file719.jpg) |'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = ![âˆš-1-- M](img/file716.jpg)âˆ‘ [k=1]^m![&#124;xm+1 âŸ©](img/file717.jpg)![
    &#124;00âŸ©](img/file718.jpg)![ âŸ© &#124;xk](img/file719.jpg) |'
- en: '|  | + ![âˆ˜ M--âˆ’-m-- ------- M](img/file720.jpg)![ âŸ© &#124;xm+1](img/file721.jpg)![
    { &#124;10âŸ©+ âˆšM--âˆ’-m-âˆ’-1-&#124;11âŸ©} -------âˆš--------------- M âˆ’ m](img/file722.jpg)![
    âŸ© &#124;xm+1](img/file723.jpg) |'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | + ![âˆ˜ M--âˆ’-m-- ------- M](img/file720.jpg)![ âŸ© &#124;xm+1](img/file721.jpg)![
    { &#124;10âŸ©+ âˆšM--âˆ’-m-âˆ’-1-&#124;11âŸ©} -------âˆš--------------- M âˆ’ m](img/file722.jpg)![
    âŸ© &#124;xm+1](img/file723.jpg) |'
- en: '|  | = ![âˆš-1-- M](img/file724.jpg)âˆ‘ [k=1]^m![&#124;xm+1 âŸ©](img/file725.jpg)![
    &#124;00âŸ©](img/file726.jpg)![ âŸ© &#124;xk](img/file727.jpg) |'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = ![âˆš-1-- M](img/file724.jpg)âˆ‘ [k=1]^m![&#124;xm+1 âŸ©](img/file725.jpg)![
    &#124;00âŸ©](img/file726.jpg)![ âŸ© &#124;xk](img/file727.jpg) |'
- en: '|  | + ![ 1 âˆš---- M](img/file728.jpg)![ âŸ© &#124;xm+1](img/file729.jpg)![{ âˆš
    ----------- } &#124;10âŸ©+ M âˆ’ m âˆ’ 1 &#124;11âŸ©](img/file730.jpg)![ âŸ© &#124;xm+1](img/file731.jpg)
    |'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | + ![ 1 âˆš---- M](img/file728.jpg)![ âŸ© &#124;xm+1](img/file729.jpg)![{ âˆš
    ----------- } &#124;10âŸ©+ M âˆ’ m âˆ’ 1 &#124;11âŸ©](img/file730.jpg)![ âŸ© &#124;xm+1](img/file731.jpg)
    |'
- en: We then flip the first ancilla qubit toÂ 0 in the ![|10âŸ©](img/file732.jpg) case
    (easily achievable with SWAP and CNOT gates) and, regrouping the same ancilla
    terms together we obtain
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬åœ¨ ![|10âŸ©](img/file732.jpg) çš„æƒ…å†µä¸‹å°†ç¬¬ä¸€ä¸ªè¾…åŠ©é‡å­æ¯”ç‰¹ç¿»è½¬ä¸º 0ï¼ˆå¯ä»¥é€šè¿‡ SWAP å’Œ CNOT é—¨è½»æ¾å®ç°ï¼‰ï¼Œå¹¶å°†ç›¸åŒçš„è¾…åŠ©é¡¹é‡æ–°ç»„åˆåœ¨ä¸€èµ·ï¼Œå¾—åˆ°
- en: '![ m+âˆ‘1 âŸ© âŸ© âˆ˜ ------------- âŸ© âŸ© âˆš1-- |xm+1 |00âŸ© |xk + M--âˆ’-(m-+-1) |xm+1 |11âŸ©
    |xm+1 . M k=1 M ](img/file733.jpg)'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![ m+âˆ‘1 âŸ© âŸ© âˆ˜ ------------- âŸ© âŸ© âˆš1-- |xm+1 |00âŸ© |xk + M--âˆ’-(m-+-1) |xm+1 |11âŸ©
    |xm+1 . M k=1 M ](img/file733.jpg)'
- en: Resetting the registers as inÂ ([7.5](#x1-1580005)) to obtain
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å¦‚åŒåœ¨ ([7.5](#x1-1580005)) ä¸­æ‰€ç¤ºï¼Œé‡ç½®å¯„å­˜å™¨å¾—åˆ°
- en: '![ ------------- 1 mâˆ‘+1 âŸ© âˆ˜ M âˆ’ (m + 1) âˆš---- |0âŸ©âŠ—n |00âŸ© |xk + ------------
    |0 âŸ©âŠ—n |01âŸ© |0âŸ©âŠ—n M k=1 M ](img/file734.jpg)'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![ ------------- 1 mâˆ‘+1 âŸ© âˆ˜ M âˆ’ (m + 1) âˆš---- |0âŸ©âŠ—n |00âŸ© |xk + ------------
    |0 âŸ©âŠ—n |01âŸ© |0âŸ©âŠ—n M k=1 M ](img/file734.jpg)'
- en: finishes the proof of the lemma.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å®Œæˆå¼•ç†çš„è¯æ˜ã€‚
- en: â–¡
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: â–¡
- en: 7.6 Hamiltonian Simulation
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6 å“ˆå¯†é¡¿é‡æ¨¡æ‹Ÿ
- en: Hamiltonian encoding, popular in quantum machine learning, is inspired by the
    SchrÃ¶dinger equationÂ ([1.2.2](Chapter_1.xhtml#x1-370002)), which reads
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: å“ˆå¯†é¡¿é‡ç¼–ç ï¼Œé‡å­æœºå™¨å­¦ä¹ ä¸­çš„ä¸€ä¸ªçƒ­é—¨æ¦‚å¿µï¼Œçµæ„Ÿæ¥è‡ªäºè–›å®šè°”æ–¹ç¨‹ ([1.2.2](Chapter_1.xhtml#x1-370002))ï¼Œå…¶è¡¨è¾¾å¼ä¸º
- en: '![ d|Ïˆ-(t)âŸ©- iâ„ dt = â„‹ |Ïˆ (t)âŸ©, ](img/file735.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![ d|Ïˆ-(t)âŸ©- iâ„ dt = â„‹ |Ïˆ (t)âŸ©, ](img/file735.jpg)'
- en: for some HamiltonianÂ â„‹, whereÂ â„ is the Planck constant, and subject to some
    boundary condition at *t* = 0\. The solution to the equation reads
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæŸäº›å“ˆå¯†é¡¿é‡ â„‹ï¼Œå…¶ä¸­ â„ æ˜¯æ™®æœ—å…‹å¸¸æ•°ï¼Œå¹¶ä¸”åœ¨ *t* = 0 æ—¶æ»¡è¶³æŸäº›è¾¹ç•Œæ¡ä»¶ã€‚è¯¥æ–¹ç¨‹çš„è§£ä¸º
- en: '![ ( ) |Ïˆ (t)âŸ© = exp âˆ’ iâ„‹t-- |Ïˆ(0)âŸ©. â„ ](img/file736.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![ ( ) |Ïˆ (t)âŸ© = exp âˆ’ iâ„‹t-- |Ïˆ(0)âŸ©. â„ ](img/file736.jpg)'
- en: The idea of Hamiltonian encoding is to encode the initial data into the HamiltonianÂ â„‹.
    Consider a cloud of points X âˆˆâ„³[n,n](â„‚). IfÂ X is Hermitian, we can define the
    Hamiltonian matrix â„‹[X] := X, otherwise the augmented version
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: å“ˆå¯†é¡¿é‡ç¼–ç çš„æ€æƒ³æ˜¯å°†åˆå§‹æ•°æ®ç¼–ç åˆ°å“ˆå¯†é¡¿é‡ â„‹ ä¸­ã€‚è€ƒè™‘ä¸€ä¸ªç‚¹äº‘ X âˆˆâ„³[n,n](â„‚)ã€‚å¦‚æœ X æ˜¯å„ç±³çŸ©é˜µï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰å“ˆå¯†é¡¿é‡çŸ©é˜µ â„‹[X]
    := Xï¼Œå¦åˆ™ä½¿ç”¨æ‰©å±•ç‰ˆæœ¬
- en: '![ ( ) 0n,n X â„‹X := ( â€  ) X 0n,n ](img/file737.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![ ( ) 0n,n X â„‹X := ( â€  ) X 0n,n ](img/file737.jpg)'
- en: is Hermitian by construction.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: æŒ‰ç…§æ„é€ æ˜¯å„ç±³çš„ã€‚
- en: Our aim is, for a given precision levelÂ *ğœ€*, to find a state ![ âŸ© |^Ïˆ](img/file738.jpg)
    (or an algorithm generating this state) such that
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ç›®æ ‡æ˜¯ï¼Œå¯¹äºç»™å®šçš„ç²¾åº¦çº§åˆ«*ğœ€*ï¼Œæ‰¾åˆ°ä¸€ä¸ªæ€![ âŸ© |^Ïˆ](img/file738.jpg)ï¼ˆæˆ–ç”Ÿæˆæ­¤æ€çš„ç®—æ³•ï¼‰ï¼Œä½¿å¾—
- en: '![âˆ¥ âŸ© âˆ¥ âˆ¥âˆ¥|^Ïˆ âˆ’ |Ïˆ (t)âŸ©âˆ¥âˆ¥ â‰¤ ğœ€, ](img/file739.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![âˆ¥ âŸ© âˆ¥ âˆ¥âˆ¥|^Ïˆ âˆ’ |Ïˆ (t)âŸ©âˆ¥âˆ¥ â‰¤ ğœ€, ](img/file739.jpg)'
- en: for some given normÂ âˆ¥â‹…âˆ¥, whereÂ ![|Ïˆ (t)âŸ©](img/file740.jpg) solves the SchrÃ¶dinger
    equation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæŸä¸ªç»™å®šçš„èŒƒæ•°âˆ¥â‹…âˆ¥ï¼Œå…¶ä¸­![|Ïˆ (t)âŸ©](img/file740.jpg)è§£äº†è–›å®šè°”æ–¹ç¨‹ã€‚
- en: An important bottleneck of this method is the computation of exp![(â„‹Xt )](img/file741.jpg)
    (where we ignore the ratio âˆ’i*âˆ•*â„ for simplicity). Suppose that the HamiltonianÂ â„‹[X]
    can be written as a sum
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: è¯¥æ–¹æ³•çš„ä¸€ä¸ªé‡è¦ç“¶é¢ˆæ˜¯è®¡ç®—exp![(â„‹Xt)](img/file741.jpg)ï¼ˆä¸ºç®€ä¾¿èµ·è§æˆ‘ä»¬å¿½ç•¥äº†æ¯”ç‡âˆ’i*âˆ•*â„ï¼‰ã€‚å‡è®¾å“ˆå¯†é¡¿é‡â„‹[X]å¯ä»¥å†™æˆå’Œçš„å½¢å¼
- en: '![ âˆ‘p â„‹X = â„‹i i=1 ](img/file742.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![ âˆ‘p â„‹X = â„‹i i=1 ](img/file742.jpg)'
- en: of easy-to-compute Hamiltonians (â„‹[i])[i=1,â€¦,p]. If the latter do not commute,
    then the identity
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±æ˜“äºè®¡ç®—çš„å“ˆå¯†é¡¿é‡ï¼ˆâ„‹[i]ï¼‰[i=1,â€¦,p]ç»„æˆã€‚å¦‚æœåè€…ä¸å¯¹æ˜“ï¼Œé‚£ä¹ˆèº«ä»½
- en: '![ ( âˆ‘p ) âˆp exp â„‹it = eâ„‹it i=1 i=1 ](img/file743.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![ ( âˆ‘p ) âˆp exp â„‹it = eâ„‹it i=1 i=1 ](img/file743.jpg)'
- en: does not hold, but the first-order Suzuki-TrotterÂ Â [[220](Biblography.xhtml#XNaomichi-Suzuki),Â [286](Biblography.xhtml#XTrotter)]
    formula (used by Lloyd inÂ Â [[191](Biblography.xhtml#XLloydsUniv)])
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸æˆç«‹ï¼Œä½†ä¸€é˜¶é“ƒæœ¨-ç‰¹ç½—ç‰¹[[220](Biblography.xhtml#XNaomichi-Suzuki)ï¼Œ[286](Biblography.xhtml#XTrotter)]å…¬å¼ï¼ˆLloydåœ¨[[191](Biblography.xhtml#XLloydsUniv)]ä¸­ä½¿ç”¨ï¼‰
- en: '![ ( âˆ‘p ) âˆp exp â„‹it = eâ„‹it + ğ’ª (t2), i=1 i=1 ](img/file744.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![ ( âˆ‘p ) âˆp exp â„‹it = eâ„‹it + ğ’ª (t2), i=1 i=1 ](img/file744.jpg)'
- en: forÂ *t* small enough, allows us to bypass this issue.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºè¶³å¤Ÿå°çš„*t*ï¼Œæˆ‘ä»¬å¯ä»¥ç»•è¿‡è¿™ä¸ªé—®é¢˜ã€‚
- en: Indeed, even ifÂ *t* is not so small, we may pick *Î´ >* 0 small enough and use
    the factorisation
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®ä¸Šï¼Œå³ä½¿*t*å¹¶ä¸é‚£ä¹ˆå°ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥é€‰æ‹©*Î´ >* 0è¶³å¤Ÿå°å¹¶ä½¿ç”¨åˆ†è§£
- en: '![ âŒŠ ( ) âŒ‹ ( âˆ‘p ) âˆ‘ tâˆ•Î´ [ pâˆ ]tâˆ•Î´ exp â„‹it = âŒˆexp ( â„‹iÎ´) âŒ‰ = eâ„‹iÎ´ + ğ’ª (Î´2) ,
    i=1 i=1,...,p i=1 ](img/file745.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![ âŒŠ ( ) âŒ‹ ( âˆ‘p ) âˆ‘ tâˆ•Î´ [ pâˆ ]tâˆ•Î´ exp â„‹it = âŒˆexp ( â„‹iÎ´) âŒ‰ = eâ„‹iÎ´ + ğ’ª (Î´2) ,
    i=1 i=1,...,p i=1 ](img/file745.jpg)'
- en: which has a small error (albeit with the caveat that the operation needs to
    be computed many times). In general, any *n*-qubit HamiltonianÂ â„‹ can be decomposed
    in at mostÂ 4^n elementary Hamiltonians (of the Pauli form) as
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒå…·æœ‰è¾ƒå°çš„è¯¯å·®ï¼ˆå°½ç®¡éœ€è¦å¤šæ¬¡è®¡ç®—è¯¥æ“ä½œï¼‰ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œä»»ä½•*n*-é‡å­æ¯”ç‰¹å“ˆå¯†é¡¿é‡â„‹éƒ½å¯ä»¥åˆ†è§£ä¸ºæœ€å¤š4^nä¸ªåŸºç¡€å“ˆå¯†é¡¿é‡ï¼ˆå¸•åˆ©å½¢å¼ï¼‰ï¼Œå¦‚
- en: '![ âˆ‘ ( âŠ—n ) âŠ—n â„‹ = -1- Tr Ïƒi â„‹ Ïƒi , 2n i,...,iâˆˆ{I,X,Y,Z} k=1 k k=1 k 1 n ](img/file746.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![ âˆ‘ ( âŠ—n ) âŠ—n â„‹ = -1- Tr Ïƒi â„‹ Ïƒi , 2n i,...,iâˆˆ{I,X,Y,Z} k=1 k k=1 k 1 n ](img/file746.jpg)'
- en: whereÂ *Ïƒ*[i[k]] is a Pauli operator. Of course, 4^n appeals to Pauli operators
    may be too large in general, but local features of the Hamiltonian (such as sparseÂ Â [[34](Biblography.xhtml#XBerrySparse)]
    or diluted or degree-reductedÂ Â [[8](Biblography.xhtml#XAharonovZhou)] Hamiltonians)
    help reduce the complexity.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­*Ïƒ*[i[k]]æ˜¯ä¸€ä¸ªå¸•åˆ©ç®—ç¬¦ã€‚å½“ç„¶ï¼Œ4^nå¯¹å¸•åˆ©ç®—ç¬¦çš„è¦æ±‚é€šå¸¸å¯èƒ½è¿‡å¤§ï¼Œä½†å“ˆå¯†é¡¿é‡çš„å±€éƒ¨ç‰¹æ€§ï¼ˆå¦‚ç¨€ç–[[34](Biblography.xhtml#XBerrySparse)]ã€ç¨€é‡Šæˆ–åº¦æ•°é™ä½çš„[[8](Biblography.xhtml#XAharonovZhou)]å“ˆå¯†é¡¿é‡ï¼‰æœ‰åŠ©äºå‡å°‘å¤æ‚åº¦ã€‚
- en: '**Remark:** An alternative approach, especially for QML problems analysed in
    the next chapter, is to encode the data using Quantum Random Access Memory (QRAM),
    essentially with the bucket-brigade algorithm developed inÂ Â [[110](Biblography.xhtml#XGiovannettiQRAM)]
    (see alsoÂ Â [[140](Biblography.xhtml#XHongQRAM),Â [15](Biblography.xhtml#XMoscaQRAM)]),
    and we refer the interested reader toÂ Â [[65](Biblography.xhtml#XCilibertoQRAM_Summary)]
    for a good summary of the current state-of-the-art algorithms.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**å¤‡æ³¨ï¼š** å¦ä¸€ç§æ–¹æ³•ï¼Œå°¤å…¶æ˜¯å¯¹äºä¸‹ä¸€ç« åˆ†æçš„é‡å­æœºå™¨å­¦ä¹ ï¼ˆQMLï¼‰é—®é¢˜ï¼Œæ˜¯ä½¿ç”¨é‡å­éšæœºå­˜å–å­˜å‚¨å™¨ï¼ˆQRAMï¼‰å¯¹æ•°æ®è¿›è¡Œç¼–ç ï¼Œæœ¬è´¨ä¸Šä½¿ç”¨äº†ç”±[[110](Biblography.xhtml#XGiovannettiQRAM)]å¼€å‘çš„æ¡¶ä¼ é€’ç®—æ³•ï¼ˆå‚è§[[140](Biblography.xhtml#XHongQRAM)ï¼Œ[15](Biblography.xhtml#XMoscaQRAM)]ï¼‰ï¼Œæˆ‘ä»¬å°†æ„Ÿå…´è¶£çš„è¯»è€…å¼•å¯¼è‡³[[65](Biblography.xhtml#XCilibertoQRAM_Summary)]ï¼Œä»¥äº†è§£å½“å‰æœ€å…ˆè¿›ç®—æ³•çš„è‰¯å¥½æ€»ç»“ã€‚'
- en: Encoding classical data into a quantum computer has seen many advances recently
    and several competing techniques are now available depending on the problem under
    investigation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: å°†ç»å…¸æ•°æ®ç¼–ç åˆ°é‡å­è®¡ç®—æœºä¸­ï¼Œæœ€è¿‘å–å¾—äº†è®¸å¤šè¿›å±•ï¼Œç°åœ¨æœ‰å¤šç§ç«äº‰æ€§çš„æŠ€æœ¯å¯ä¾›é€‰æ‹©ï¼Œå…·ä½“ä½¿ç”¨å“ªç§æŠ€æœ¯å–å†³äºæ­£åœ¨ç ”ç©¶çš„é—®é¢˜ã€‚
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æ‘˜è¦
- en: In this chapter, we introduced the concept of a parameterised quantum circuit
    as a generic QML model. PQCs can be trained and used as discriminative and generative
    QML models as well as optimisers. They can also be used to encode classical data
    samples into the corresponding quantum states.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬ä»‹ç»äº†å‚æ•°åŒ–é‡å­ç”µè·¯çš„æ¦‚å¿µï¼Œä½œä¸ºé€šç”¨çš„QMLæ¨¡å‹ã€‚PQCå¯ä»¥è®­ç»ƒå¹¶ç”¨ä½œåˆ¤åˆ«å’Œç”ŸæˆQMLæ¨¡å‹ä»¥åŠä¼˜åŒ–å™¨ã€‚å®ƒä»¬è¿˜å¯ä»¥ç”¨æ¥å°†ç»å…¸æ•°æ®æ ·æœ¬ç¼–ç ä¸ºç›¸åº”çš„é‡å­æ€ã€‚
- en: We considered several popular data encoding methods. Arguably, the simplest
    and easiest to implement is the angle encoding algorithm â€“ we shall use this approach
    in the next chapter. Other methods also have their strong points, although they
    tend to be either more demanding in terms of the hardware capabilities or better
    suited for some niche applications.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è€ƒè™‘äº†å‡ ç§æµè¡Œçš„æ•°æ®ç¼–ç æ–¹æ³•ã€‚å¯ä»¥è¯´ï¼Œæœ€ç®€å•ä¸”æœ€æ˜“å®ç°çš„æ–¹æ³•æ˜¯è§’åº¦ç¼–ç ç®—æ³•â€”â€”æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€ç« ä¸­ä½¿ç”¨è¿™ç§æ–¹æ³•ã€‚å…¶ä»–æ–¹æ³•ä¹Ÿæœ‰å…¶ä¼˜ç‚¹ï¼Œå°½ç®¡å®ƒä»¬é€šå¸¸åœ¨ç¡¬ä»¶è¦æ±‚æ–¹é¢æ›´ä¸ºè‹›åˆ»ï¼Œæˆ–æ›´é€‚åˆæŸäº›ç‰¹å®šåº”ç”¨ã€‚
- en: In the next chapter, we apply what we learned so far to the task of building
    the quantum neural network trained as a classifier and compare its performance
    on the binary classification problem with standard classical machine learning
    models.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹ä¸€ç« ï¼Œæˆ‘ä»¬å°†åº”ç”¨åˆ°ç›®å‰ä¸ºæ­¢æ‰€å­¦çš„å†…å®¹ï¼Œæ„å»ºä¸€ä¸ªä½œä¸ºåˆ†ç±»å™¨è®­ç»ƒçš„é‡å­ç¥ç»ç½‘ç»œï¼Œå¹¶å°†å…¶åœ¨äºŒåˆ†ç±»é—®é¢˜ä¸Šçš„è¡¨ç°ä¸æ ‡å‡†ç»å…¸æœºå™¨å­¦ä¹ æ¨¡å‹è¿›è¡Œæ¯”è¾ƒã€‚
- en: Join our bookâ€™s Discord space
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: åŠ å…¥æˆ‘ä»¬ä¹¦ç±çš„ Discord ç©ºé—´
- en: 'Join our Discord community to meet like-minded people and learn alongside more
    than 2000 members at: [https://packt.link/quantum](https://packt.link/quantum)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: åŠ å…¥æˆ‘ä»¬çš„ Discord ç¤¾åŒºï¼Œä¸å¿—åŒé“åˆçš„äººäº¤æµï¼Œå¹¶ä¸è¶…è¿‡2000åæˆå‘˜ä¸€èµ·å­¦ä¹ ï¼Œç½‘å€ï¼š[https://packt.link/quantum](https://packt.link/quantum)
- en: '![PIC](img/file1.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](img/file1.png)'
