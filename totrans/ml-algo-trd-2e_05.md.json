["```py\ndef simulate_portfolios(mean_ret, cov, rf_rate=rf_rate, short=True):\n    alpha = np.full(shape=n_assets, fill_value=.05)\n    weights = dirichlet(alpha=alpha, size=NUM_PF)\n    if short:\n        weights *= choice([-1, 1], size=weights.shape)\n    returns = weights @ mean_ret.values + 1\n    returns = returns ** periods_per_year - 1\n    std = (weights @ monthly_returns.T).std(1)\n    std *= np.sqrt(periods_per_year)\n    sharpe = (returns - rf_rate) / std\n    return pd.DataFrame({'Annualized Standard Deviation': std,\n                         'Annualized Returns': returns,\n                         'Sharpe Ratio': sharpe}), weights \n```", "```py\ndef portfolio_std(wt, rt=None, cov=None):\n    \"\"\"Annualized PF standard deviation\"\"\"\n    return np.sqrt(wt @ cov @ wt * periods_per_year)\ndef portfolio_returns(wt, rt=None, cov=None):\n    \"\"\"Annualized PF returns\"\"\"\n    return (wt @ rt + 1) ** periods_per_year - 1\ndef portfolio_performance(wt, rt, cov):\n    \"\"\"Annualized PF returns & standard deviation\"\"\"\n    r = portfolio_returns(wt, rt=rt)\n    sd = portfolio_std(wt, cov=cov)\n    return r, sd \n```", "```py\ndef neg_sharpe_ratio(weights, mean_ret, cov):\n    r, sd = portfolio_performance(weights, mean_ret, cov)\n    return -(r - rf_rate) / sd\nweight_constraint = {'type': 'eq',\n                     'fun': lambda x: np.sum(np.abs(x)) - 1}\ndef max_sharpe_ratio(mean_ret, cov, short=False):\n    return minimize(fun=neg_sharpe_ratio,\n                    x0=x0,\n                    args=(mean_ret, cov),\n                    method='SLSQP',\n                    bounds=((-1 if short else 0, 1),) * n_assets,\n                    constraints=weight_constraint,\n                    options={'tol':1e-10, 'maxiter':1e4}) \n```", "```py\ndef min_vol_target(mean_ret, cov, target, short=False):\n    def ret_(wt):\n        return portfolio_returns(wt, mean_ret)\n    constraints = [{'type': 'eq', 'fun': lambda x: ret_(x) - target},\n                     weight_constraint]\n    bounds = ((-1 if short else 0, 1),) * n_assets\n    return minimize(portfolio_std, x0=x0, args=(mean_ret, cov),\n                    method='SLSQP', bounds=bounds,\n                    constraints=constraints,\n                    options={'tol': 1e-10, 'maxiter': 1e4}) \n```", "```py\ndef efficient_frontier(mean_ret, cov, ret_range):\n    return [min_vol_target(mean_ret, cov, ret) for ret in ret_range] \n```", "```py\ndef min_vol(mean_ret, cov, short=False):\n    return minimize(fun=portfolio_std,\n                    x0=x0,\n                    args=(mean_ret, cov),\n                    method='SLSQP',\n                    bounds=bounds = ((-1 if short else 0, 1),) * \n                          n_assets,\n                          constraints=weight_constraint,\n                          options={'tol': 1e-10, 'maxiter': 1e4}) \n```", "```py\nfrom sympy import symbols, solve, log, diff\nshare, odds, probability = symbols('share odds probability')\nValue = probability * log(1 + odds * share) + (1 - probability) * log(1 \n        - share)\nsolve(diff(Value, share), share)\n[(odds*probability + probability - 1)/odds] \n```", "```py\ndef norm_integral(f, m, st):\n    val, er = quad(lambda s: np.log(1+f*s)*norm.pdf(s, m, st), m-3*st, \n                   m+3*st)\n    return -val\ndef norm_dev_integral(f, m, st):\n    val, er = quad(lambda s: (s/(1+f*s))*norm.pdf(s, m, st), m-3*st, \n                   m+3*st)\n    return val\nm = .058\ns = .216\n# Option 1: minimize the expectation integral\nsol = minimize_scalar(norm_integral, args=(\n                m, s), bounds=[0., 2.], method='bounded')\nprint('Optimal Kelly fraction: {:.4f}'.format(sol.x))\nOptimal Kelly fraction: 1.1974 \n```", "```py\nmean_returns = monthly_returns.mean()\ncov_matrix = monthly_returns.cov()\nprecision_matrix = pd.DataFrame(inv(cov_matrix), index=stocks, columns=stocks)\nkelly_wt = precision_matrix.dot(mean_returns).values \n```", "```py\nvar = monthly_returns.var()\nrisk_parity_weights = var / var.sum() \n```", "```py\ndef compute_factors():\n    \"\"\"Create factor pipeline incl. mean reversion,\n        filtered by 30d Dollar Volume; capture factor ranks\"\"\"\n    mean_reversion = MeanReversion()\n    dollar_volume = AverageDollarVolume(window_length=30)\n    return Pipeline(columns={'longs'  : mean_reversion.bottom(N_LONGS),\n                             'shorts' : mean_reversion.top(N_SHORTS),\n                             'ranking': mean_reversion.rank(ascending=False)},\n                    screen=dollar_volume.top(VOL_SCREEN)) \n```", "```py\ndef before_trading_start(context, data):\n    \"\"\"Run factor pipeline\"\"\"\n    context.factor_data = pipeline_output('factor_pipeline')\n    record(factor_data=context.factor_data.ranking)\n    assets = context.factor_data.index\n    record(prices=data.current(assets, 'price')) \n```", "```py\ndef exec_trades(data, assets, target_percent):\n    \"\"\"Place orders for assets using target portfolio percentage\"\"\"\n    for asset in assets:\n        if data.can_trade(asset) and not get_open_orders(asset):\n            order_target_percent(asset, target_percent)\ndef rebalance(context, data):\n    \"\"\"Compute long, short and obsolete holdings; place trade orders\"\"\"\n    factor_data = context.factor_data\n    assets = factor_data.index\n    longs = assets[factor_data.longs]\n    shorts = assets[factor_data.shorts]\n    divest = context.portfolio.positions.keys() - longs.union(shorts)\n    exec_trades(data, assets=divest, target_percent=0)\n    exec_trades(data, assets=longs, target_percent=1 / N_LONGS if N_LONGS \n                else 0)\n    exec_trades(data, assets=shorts, target_percent=-1 / N_SHORTS if N_SHORTS \n                else 0) \n```", "```py\ndef initialize(context):\n    \"\"\"Setup: register pipeline, schedule rebalancing,\n        and set trading params\"\"\"\n    attach_pipeline(compute_factors(), 'factor_pipeline')\n    schedule_function(rebalance,\n                      date_rules.week_start(),\n                      time_rules.market_open(),\n                      calendar=calendars.US_EQUITIES)\n    set_commission(us_equities=commission.PerShare(cost=0.00075, \n                                                   min_trade_cost=.01))\n    set_slippage(us_equities=slippage.VolumeShareSlippage(volume_limit=0.0025, price_impact=0.01)) \n```", "```py\ndef rebalance(context, data):\n    \"\"\"Compute long, short and obsolete holdings; place orders\"\"\"\n    factor_data = context.factor_data\n    assets = factor_data.index\n    longs = assets[factor_data.longs]\n    shorts = assets[factor_data.shorts]\n    divest = context.portfolio.positions.keys() - longs.union(shorts)\n    exec_trades(data, positions={asset: 0 for asset in divest})\n    # get price history\n    prices = data.history(assets, fields='price',\n                          bar_count=252+1, # 1 yr of returns \n                          frequency='1d')\n    if len(longs) > 0:\n        long_weights = optimize_weights(prices.loc[:, longs])\n        exec_trades(data, positions=long_weights)\n    if len(shorts) > 0:\n        short_weights = optimize_weights(prices.loc[:, shorts], short=True)\n        exec_trades(data, positions=short_weights) \n```", "```py\ndef optimize_weights(prices, short=False):\n    returns = expected_returns.mean_historical_return(prices=prices, \n                                                      frequency=252)\n    cov = risk_models.sample_cov(prices=prices, frequency=252)\n    # get weights that maximize the Sharpe ratio\n    ef = EfficientFrontier(expected_returns=returns, \n                           cov_matrix=cov, \n                           weight_bounds=(0, 1), \n                           gamma=0)\n\n    weights = ef.max_sharpe()\n    if short:\n        return {asset: -weight for asset, weight in ef.clean_weights().items()}\n    else:\n        return ef.clean_weights() \n```", "```py\nfrom alphalens.performance import create_pyfolio_input\nqmin, qmax = factor_data.factor_quantile.min(), \n             factor_data.factor_quantile.max()\ninput_data = create_pyfolio_input(alphalens_data,\n                                  period='1D',\n                                  capital=100000,\n                                  long_short=False,\n                                  equal_weight=False,\n                                  quantiles=[1, 5],\n                                  benchmark_period='1D')\nreturns, positions, benchmark = input_data \n```", "```py\nreturns, positions, transactions = \n         extract_rets_pos_txn_from_zipline(backtest) \n```", "```py\nfrom pyfolio.plotting import plot_rolling_returns\nplot_rolling_returns(returns=returns,\n                     factor_returns=benchmark_rets,\n                     live_start_date='2016-01-01',\n                     cone_std=(1.0, 1.5, 2.0)) \n```", "```py\nfrom pyfolio.timeseries import show_perf_stats\nshow_perf_stats(returns=returns, \n                factor_returns=benchmark_rets, \n                positions=positions, \n                transactions=transactions, \n                live_start_date=oos_date) \n```", "```py\nfig, ax = plt.subplots(nrows=2, ncols=2, figsize=(16, 10))\naxes = ax.flatten()\nplot_drawdown_periods(returns=returns, ax=axes[0])\nplot_rolling_beta(returns=returns, factor_returns=benchmark_rets, \n                  ax=axes[1])\nplot_drawdown_underwater(returns=returns, ax=axes[2])\nplot_rolling_sharpe(returns=returns) \n```", "```py\ninteresting_times = extract_interesting_date_ranges(returns=returns)\ninteresting_times['Fall2015'].to_frame('pf') \\\n .join(benchmark_rets) \\\n .add(1).cumprod().sub(1) \\\n .plot(lw=2, figsize=(14, 6), title='Post-Brexit Turmoil') \n```"]