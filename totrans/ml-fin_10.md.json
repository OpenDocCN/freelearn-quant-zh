["```py\nimport numpy as np\nimport matplotlib.pyplot as plt% matplotlib inline\n```", "```py\ndef run_sim(x):\n    truth = np.random.uniform(size=100) < x\n    first_random = np.random.randint(2,size=100)\n    second_random = np.random.randint(2,size=100)\n    res = np.sum(first_random*truth + (1-first_random)*second_random)/100\n    return res\n```", "```py\ndef sample(data = 0.54):\n    x = np.random.uniform()\n    if run_sim(x) == data:\n        return x\n```", "```py\nfrom JobLib import Parallel, delayed\n```", "```py\nt = Parallel(n_jobs=-1)(delayed(sample)() for i in range(100000))\nt = np.array(t,dtype=float)\nshare = np.sum(np.isnan(t))/len(t)*100\nprint(f'{share:.2f}% are throwaways')\n```", "```py\n98.01% are throwaways\n\n```", "```py\nt_flat = t[~np.isnan(t)]\nplt.hist(t_flat, bins=30,density=True)\nplt.title('Distribution of possible TPPs')\nplt.xlim(0,1);\n```", "```py\ndef sample(data = 0.54):\n    x = np.random.uniform(low=0,high=0.5)\n    if run_sim(x) == data:\n        return x\n```", "```py\nt = Parallel(n_jobs=-1)(delayed(sample)() for i in range(100000))\nt = np.array(t,dtype=float)\n# Optional\nshare = np.sum(np.isnan(t))/len(t)*100\nprint(f'{share:.2f}% are throwaways')\n```", "```py\n99.10% are throwaways\n\n```", "```py\nt_cut = t[~np.isnan(t)]\nplt.hist(t_cut, bins=15,density=True)\nplt.title('Distribution of possible TPPs')\nplt.xlim(0,1);\n```", "```py\nflat_prior = np.random.uniform(size=1000000)\nplt.hist(flat_prior,bins=10,density=True, label='Prior')\nplt.hist(t_flat, bins=30,density=True, label='Posterior')\nplt.title('Distribution of $x$ with no assumptions')\nplt.legend()\nplt.xlim(0,1);\n```", "```py\ncut_prior = np.random.uniform(low=0,high=0.5,size=1000000)\nplt.hist(cut_prior,bins=10,density=True, label='Prior')\nplt.hist(t_cut, bins=15,density=True, label='Posterior')\nplt.title('Distribution of $x$ assuming TPP <50%')\nplt.legend()\nplt.xlim(0,1);\n```", "```py\n# REPETITION FROM FIRST SECTION\ndef run_sim(x):\n    truth = np.random.uniform(size=100) < x\n    first_random = np.random.randint(2,size=100)\n    second_random = np.random.randint(2,size=100)\n    res = np.sum(first_random*truth + (1-first_random)*second_random)/100\n    return res\n# REPETITION FROM FIRST SECTION\ndef sample(x,data = 0.54):\n    if run_sim(x) == data:\n        return x\n```", "```py\ndef propose(x):\n    return np.random.randn() * 0.1 + x\n```", "```py\ndef likelihood(x):\n    t = Parallel(n_jobs=-1)(delayed(sample)(x) for i in range(10000))\n    t = np.array(t,dtype=float)\n    return (1 - np.sum(np.isnan(t))/len(t))\n```", "```py\ndef prior(x):\n    return 1 #Flat prior\n```", "```py\ndef posterior(x):    \n    return likelihood(x) * prior(x)\n```", "```py\nx = 0.5\npi_x = posterior(x)\n```", "```py\ntrace = [x]\npi_trace = [pi_x]\n```", "```py\n    for i in range(1000): #Main Loop\n\n        x_cand = propose(x)\n\n        pi_x_cand = posterior(x_cand)\n\n        alpha = np.min([1,pi_x_cand/(pi_x + 0.00001)]) # Save division\n\n        u = np.random.uniform() \n\n        (x, pi_x) = (x_cand,pi_x_cand) if u<alpha else (x,pi_x)\n        trace.append(x)\n        pi_trace.append(pi_x)\n\n        if i % 10 == 0:\n            print(f'Epoch {i}, X = {x:.2f}, pi = {pi_x:.2f}')\n    ```", "```py\nEpoch 0, X = 0.50, pi = 0.00Epoch 10, X = 0.46, pi = 0.04...Epoch 990, X = 0.50, pi = 0.06g\n\n```", "```py\nplt.hist(trace,bins=30)\nplt.title('Metropolis Hastings Outcome')\nplt.xlim(0,1);\n```", "```py\nplt.plot(trace)\nplt.title('MH Trace');\n```", "```py\nplt.scatter(x=trace,y=pi_trace)\nplt.xlabel('Proposed X')\nplt.ylabel('Posterior Probability')\nplt.title('X vs Pi');\n```", "```py\ndf = pd.read_csv('../input/S&P.csv')\ndf['Date'] = pd.to_datetime(df['Date'])\n```", "```py\nclose = pd.Series(df.Close.values,index=pd.DatetimeIndex(df.Date))\nclose = close[::-1]\n```", "```py\nclose.plot(title='S&P 500 From Inception');\n```", "```py\nSP500\n\n```", "```py\nclose = close['1990-01-01':]\n```", "```py\nreturns = pd.Series(np.diff(close.values),index=close.index[1:])\nreturns.plot();\n```", "```py\nimport pymc3 as pm\nfrom pymc3.distributions.timeseries import GaussianRandomWalk\n```", "```py\nwith pm.Model() as model:\n    step_size = pm.Exponential('sigma', 50.)      #1\n    s = GaussianRandomWalk('s', sd=step_size,     #2\n                           shape=len(returns))\n\n    nu = pm.Exponential('nu', .1)                 #3\n\n    r = pm.StudentT('r', nu=nu,                   #4\n                    lam=pm.math.exp(-2*s),\n                    observed=returns.values)\n```", "```py\nwith model:\n    trace = pm.sample(tune=2000, nuts_kwargs=dict(target_accept=.9))\n```", "```py\npm.traceplot(trace, varnames=['sigma', 'nu']);\nTracePlot\n```", "```py\nplt.plot(returns.values)\nplt.plot(np.exp(trace[s].T), 'r', alpha=.03);\nplt.xlabel('time')\nplt.ylabel('returns')\nplt.legend(['S&P500', 'Stochastic Vol.']);\n```"]