["```py\n    import numpy as np\n    import pandas as pd\n    import yfinance as yf \n    ```", "```py\n    df = yf.download(\"IBM\",\n                     start=\"2021-01-01\",\n                     end=\"2022-01-31\",\n                     adjusted=True) \n    ```", "```py\n    returns = df[\"Adj Close\"].pct_change().dropna()\n    returns.plot(title=\"IBM's returns\") \n    ```", "```py\n    train = returns[\"2021\"]\n    test = returns[\"2022\"] \n    ```", "```py\n    T = len(test)\n    N = len(test)\n    S_0 = df.loc[train.index[-1], \"Adj Close\"]\n    N_SIM = 100\n    mu = train.mean()\n    sigma = train.std() \n    ```", "```py\n     def  simulate_gbm(s_0, mu, sigma, n_sims, T, N, \n     random_seed=42):\n        np.random.seed(random_seed)\n\n        dt = T/N\n        dW = np.random.normal(scale=np.sqrt(dt), size=(n_sims, N))\n        W = np.cumsum(dW, axis=1)\n\n        time_step = np.linspace(dt, T, N)\n        time_steps = np.broadcast_to(time_step, (n_sims, N))\n\n        S_t = (\n            s_0 * np.exp((mu - 0.5 * sigma**2) * time_steps + sigma * W)\n        )\n        S_t = np.insert(S_t, 0, s_0, axis=1)\n\n        return S_t \n    ```", "```py\n    gbm_simulations = simulate_gbm(S_0, mu, sigma, N_SIM, T, N)\n    sim_df = pd.DataFrame(np.transpose(gbm_simulations),\n                          index=train.index[-1:].union(test.index)) \n    ```", "```py\n    res_df = sim_df.mean(axis=1).to_frame()\n    res_df = res_df.join(df[\"Adj Close\"])\n    res_df.columns = [\"simulation_average\", \"adj_close_price\"] \n    ```", "```py\n    ax = sim_df.plot(\n        alpha=0.3, legend=False, title=\"Simulation's results\"\n    )\n    res_df.plot(ax=ax, color = [\"red\", \"blue\"]) \n    ```", "```py\n%timeit gbm_simulations = simulate_gbm(S_0, mu, sigma, N_SIM, T, N) \n```", "```py\n71 µs ± 126 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each) \n```", "```py\ndef  simulate_gbm(s_0, mu, sigma, n_sims, T, N, random_seed=42, \n antithetic_var=False):\n    np.random.seed(random_seed)\n\n    # time increment\n    dt = T/N\n\n    # Brownian\n    if antithetic_var:\n        dW_ant = np.random.normal(scale = np.sqrt(dt),\n                                  size=(int(n_sims/2), N + 1))\n        dW = np.concatenate((dW_ant, -dW_ant), axis=0)\n    else:\n        dW = np.random.normal(scale = np.sqrt(dt),\n                              size=(n_sims, N + 1))\n\n    # simulate the evolution of the process\n    S_t = s_0 * np.exp(np.cumsum((mu - 0.5*sigma**2)*dt + sigma*dW,\n                                 axis=1))\n    S_t[:, 0] = s_0\n\n    return S_t \n```", "```py\n%timeit gbm_simulations = simulate_gbm(S_0, mu, sigma, N_SIM, T, N) \n```", "```py\n50.3 µs ± 275 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each) \n```", "```py\n%timeit gbm_simulations = simulate_gbm(S_0, mu, sigma, N_SIM, T, N, antithetic_var=True) \n```", "```py\n38.2 µs ± 623 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each) \n```", "```py\n    import numpy as np\n    from scipy.stats import norm\n    from chapter_10_utils import simulate_gbm \n    ```", "```py\n    S_0 = 100\n    K = 100\n    r = 0.05\n    sigma = 0.50\n    T = 1 \n    N = 252 \n    dt = T / N \n    N_SIMS = 1_000_000 \n    discount_factor = np.exp(-r * T) \n    ```", "```py\n     def  black_scholes_analytical(S_0, K, T, r, sigma, type=\"call\"):\n        d1 = (\n            np.log(S_0 / K) + (r + 0.5*sigma**2) * T) / (sigma*np.sqrt(T)\n        )\n        d2 = d1 - sigma * np.sqrt(T)\n        if type == \"call\":\n            N_d1 = norm.cdf(d1, 0, 1)\n            N_d2 = norm.cdf(d2, 0, 1)\n            val = S_0 * N_d1 - K * np.exp(-r * T) * N_d2\n        elif type == \"put\":\n            N_d1 = norm.cdf(-d1, 0, 1)\n            N_d2 = norm.cdf(-d2, 0, 1)\n            val = K * np.exp(-r * T) * N_d2 - S_0 * N_d1\n        else:\n            raise ValueError(\"Wrong input for type!\")\n\n        return val \n    ```", "```py\n    black_scholes_analytical(S_0=S_0, K=K, T=T, \n                             r=r, sigma=sigma, \n                             type=\"call\") \n    ```", "```py\n    gbm_sims = simulate_gbm(s_0=S_0, mu=r, sigma=sigma,\n                            n_sims=N_SIMS, T=T, N=N) \n    ```", "```py\n    premium = (\n        discount_factor * np.mean(np.maximum(0, gbm_sims[:, -1] - K))\n    )\n    premium \n    ```", "```py\nblack_scholes_analytical(S_0=S_0, K=K, T=T, r=r, sigma=sigma, type=\"put\") \n```", "```py\ndef  european_option_simulation(S_0, K, T, r, sigma, n_sims,\n  type=\"call\", random_seed=42):\n    np.random.seed(random_seed)\n    rv = np.random.normal(0, 1, size=n_sims)\n    S_T = S_0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * rv)\n    if type == \"call\":\n        payoff = np.maximum(0, S_T - K)\n    elif type == \"put\":\n        payoff = np.maximum(0, K - S_T)\n    else:\n        raise ValueError(\"Wrong input for type!\")\n\n    premium = np.mean(payoff) * np.exp(-r * T)\n    return premium \n```", "```py\neuropean_option_simulation(S_0, K, T, r, sigma, N_SIMS, type=\"put\") \n```", "```py\n    import numpy as np\n    from chapter_10_utils import (simulate_gbm,\n                                  black_scholes_analytical,\n                                  lsmc_american_option) \n    ```", "```py\n    S_0 = 36\n    K = 40\n    r = 0.06\n    sigma = 0.2\n    T = 1 # 1 year\n    N = 50\n    dt = T / N\n    N_SIMS = 10 ** 5\n    discount_factor = np.exp(-r * dt)\n    OPTION_TYPE = \"put\"\n    POLY_DEGREE = 5 \n    ```", "```py\n    gbm_sims = simulate_gbm(s_0=S_0, mu=r, sigma=sigma, \n                            n_sims=N_SIMS, T=T, N=N) \n    ```", "```py\n    payoff_matrix = np.maximum(K - gbm_sims, np.zeros_like(gbm_sims)) \n    ```", "```py\n    value_matrix = np.zeros_like(payoff_matrix)\n    value_matrix[:, -1] = payoff_matrix[:, -1] \n    ```", "```py\n    for t in range(N - 1, 0 , -1):\n        regression = np.polyfit(\n            gbm_sims[:, t], \n            value_matrix[:, t + 1] * discount_factor, \n            POLY_DEGREE\n        )\n        continuation_value = np.polyval(regression, gbm_sims[:, t])\n        value_matrix[:, t] = np.where(\n            payoff_matrix[:, t] > continuation_value,\n            payoff_matrix[:, t],\n            value_matrix[:, t + 1] * discount_factor\n        ) \n    ```", "```py\n    option_premium = np.mean(value_matrix[:, 1] * discount_factor)\n    option_premium \n    ```", "```py\n    black_scholes_analytical(S_0=S_0, K=K, T=T, r=r, sigma=sigma,\n                             type=\"put\") \n    ```", "```py\n    european_call_price = black_scholes_analytical(\n        S_0=S_0, K=K, T=T, r=r, sigma=sigma\n    )\n    american_call_price = lsmc_american_option(\n        S_0=S_0, K=K, T=T, N=N, r=r, \n        sigma=sigma, n_sims=N_SIMS, \n        option_type=\"call\", \n        poly_degree=POLY_DEGREE\n    )\n    print(f\"European call's price: {european_call_price:.3f}\")\n    print(f\"American call's price: {american_call_price:.3f}\") \n    ```", "```py\n    import QuantLib as ql \n    ```", "```py\n    calendar = ql.UnitedStates()\n    day_counter = ql.ActualActual() \n    ```", "```py\n    valuation_date = ql.Date(1, 1, 2020)\n    expiry_date =  ql.Date(1, 1, 2021)\n    ql.Settings.instance().evaluationDate = valuation_date \n    ```", "```py\n    if OPTION_TYPE == \"call\":\n        option_type_ql = ql.Option.Call\n    elif OPTION_TYPE == \"put\":\n        option_type_ql = ql.Option.Put\n\n    exercise = ql.AmericanExercise(valuation_date, expiry_date)\n    payoff = ql.PlainVanillaPayoff(option_type_ql, K) \n    ```", "```py\n    u = ql.SimpleQuote(S_0)\n    r = ql.SimpleQuote(r)\n    sigma = ql.SimpleQuote(sigma) \n    ```", "```py\n    underlying = ql.QuoteHandle(u)\n    volatility = ql.BlackConstantVol(0, ql.TARGET(),\n                                     ql.QuoteHandle(sigma),\n                                     day_counter)\n    risk_free_rate = ql.FlatForward(0, ql.TARGET(),\n                                    ql.QuoteHandle(r),\n                                    day_counter) \n    ```", "```py\n    bs_process = ql.BlackScholesProcess(\n        underlying,\n        ql.YieldTermStructureHandle(risk_free_rate),\n        ql.BlackVolTermStructureHandle(volatility),\n    ) \n    ```", "```py\n    engine = ql.MCAmericanEngine(\n        bs_process, \"PseudoRandom\", timeSteps=N, \n        polynomOrder=POLY_DEGREE, \n        seedCalibration=42, \n        requiredSamples=N_SIMS\n    ) \n    ```", "```py\n    option = ql.VanillaOption(payoff, exercise)\n    option.setPricingEngine(engine) \n    ```", "```py\n    option_premium_ql = option.NPV()\n    option_premium_ql \n    ```", "```py\nT = day_counter.yearFraction(valuation_date, expiry_date) \nprint(f'Time to expiry in years: {T}') \n```", "```py\nTime to expiry in years: 1.0 \n```", "```py\nu_0 = u.value() # original value\nh = 0.01\nu.setValue(u_0 + h)\nP_plus_h = option.NPV()\nu.setValue(u_0 - h)\nP_minus_h = option.NPV()\nu.setValue(u_0) # set back to the original value\ndelta = (P_plus_h - P_minus_h) / (2 * h) \n```", "```py\n    import numpy as np\n    from chapter_10_utils import simulate_gbm \n    ```", "```py\n    S_0 = 55\n    K = 60\n    BARRIER = 65\n    r = 0.06\n    sigma = 0.2\n    T = 1\n    N = 252\n    dt = T / N\n    N_SIMS = 10 ** 5\n    OPTION_TYPE = \"call\"\n    discount_factor = np.exp(-r * T) \n    ```", "```py\n    gbm_sims = simulate_gbm(s_0=S_0, mu=r, sigma=sigma,\n                            n_sims=N_SIMS, T=T, N=N) \n    ```", "```py\n    max_value_per_path = np.max(gbm_sims, axis=1) \n    ```", "```py\n    payoff = np.where(max_value_per_path > BARRIER,\n                      np.maximum(0, gbm_sims[:, -1] - K),\n                      0) \n    ```", "```py\n    premium = discount_factor * np.mean(payoff)\n    premium \n    ```", "```py\n    import numpy as np\n    import pandas as pd\n    import yfinance as yf\n    import seaborn as sns \n    ```", "```py\n    RISKY_ASSETS = [\"AMD\", \"INTC\"]\n    SHARES = [5, 5]\n    START_DATE = \"2020-01-01\"\n    END_DATE = \"2020-12-31\"\n    T = 1\n    N_SIMS = 10 ** 5 \n    ```", "```py\n    df = yf.download(RISKY_ASSETS, start=START_DATE,\n                     end=END_DATE, adjusted=True) \n    ```", "```py\n    returns = df[\"Adj Close\"].pct_change().dropna()\n    returns.plot(title=\"Intel's and AMD's daily stock returns in 2020\") \n    ```", "```py\n    cov_mat = returns.cov() \n    ```", "```py\n    chol_mat = np.linalg.cholesky(cov_mat) \n    ```", "```py\n    rv = np.random.normal(size=(N_SIMS, len(RISKY_ASSETS)))\n    correlated_rv = np.transpose(\n        np.matmul(chol_mat, np.transpose(rv))\n    ) \n    ```", "```py\n    r = np.mean(returns, axis=0).values\n    sigma = np.std(returns, axis=0).values\n    S_0 = df[\"Adj Close\"].values[-1, :]\n    P_0 = np.sum(SHARES * S_0) \n    ```", "```py\n    S_T = S_0 * np.exp((r - 0.5 * sigma ** 2) * T +\n                       sigma * np.sqrt(T) * correlated_rv) \n    ```", "```py\n    P_T = np.sum(SHARES * S_T, axis=1)\n    P_diff = P_T - P_0 \n    ```", "```py\n    P_diff_sorted = np.sort(P_diff)\n    percentiles = [0.01, 0.1, 1.]\n    var = np.percentile(P_diff_sorted, percentiles)\n    for x, y in zip(percentiles, var):\n        print(f'1-day VaR with {100-x}% confidence: ${-y:.2f}') \n    ```", "```py\n    1-day VaR with 99.99% confidence: $2.04\n    1-day VaR with 99.9% confidence: $1.48\n    1-day VaR with 99.0% confidence: $0.86 \n    ```", "```py\n    ax = sns.distplot(P_diff, kde=False)\n    ax.set_title(\"\"\"Distribution of possible 1-day changes\n     in portfolio value 1-day 99% VaR\"\"\", \n                  fontsize=16)\n    ax.axvline(var[2], 0, 10000) \n    ```", "```py\nvar = np.percentile(P_diff_sorted, 5)\nexpected_shortfall = P_diff_sorted[P_diff_sorted<=var].mean() \n```"]