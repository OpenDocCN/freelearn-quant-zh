- en: '11'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quantum Approximate Optimisation Algorithm
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name suggests, the Quantum Approximate Optimisation Algorithm (QAOA)
    is an optimisation algorithm. It is motivated by and draws upon two optimisation
    algorithms considered in previous chapters: AQC and VQE. From AQC it borrows the
    concept of solving an optimisation problem through encoding the corresponding
    objective function in the problem Hamiltonian and then evolving the system in
    such a way that the ground state of the final Hamiltonian provides the solution
    we are after (in a bitstring format). From VQE it borrows the variational principle
    applied to the parameterised quantum circuit. Roughly speaking, QAOA is a gate-model
    version of an optimisation solver that otherwise could have been tackled with
    an analog AQC approach. We can also look at QAOA as a special case of VQE with
    the constraints on the form of the Hamiltonian.'
  prefs: []
  type: TYPE_NORMAL
- en: QAOA was introduced in the pioneering work by Farhi, Goldstone, and GutmannÂ Â [[96](Biblography.xhtml#XFarhi2014)]
    in 2014 and its potential for establishing quantum supremacy was investigated
    by Farhi and Harrow inÂ Â [[99](Biblography.xhtml#XFarhi2016)]. QAOA and its sister
    algorithm that generalises it, the Quantum Alternating Operator Ansatz (with the
    same acronym!), have been tested on a number of financial use cases. Here we can
    mention the work by Hodson, Ruck, Ong, Garvin, and DulmaÂ Â [[138](Biblography.xhtml#XHodson2019)]
    on portfolio rebalancing experiments and the one by Barkoutsos, Nannicini, Robert,
    Tavernelli, and WoernerÂ Â [[26](Biblography.xhtml#XBarkoutsos2019)] using Conditional
    Value-at-Risk (CVaR) as the QAOA objective function. The algorithm has significant
    potential and promises to become a standard tool in the arsenal of quantum computing
    methods aimed at financial applications.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1 Time Evolution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider again the description of the dynamics of quantum mechanical systems,
    briefly covered in ChapterÂ [1](Chapter_1.xhtml#x1-220001) (as one of the postulates
    of quantum mechanics) and ChapterÂ [2](Chapter_2.xhtml#x1-480002) (where we introduced
    the principles of Adiabatic Quantum Computing). These dynamics are governed by
    the SchrÃ¶dinger equationÂ ([1.2.2](Chapter_1.xhtml#x1-370002)):'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ d &#124;Ïˆ (t)âŸ© iâ„--dt--- = â„‹ &#124;Ïˆ(t)âŸ©, ](img/file1116.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: with some initial conditionÂ ![|Ïˆ(0)âŸ©](img/file1117.jpg), whereÂ ![|Ïˆ (t)âŸ©](img/file1118.jpg)
    is the quantum state at timeÂ *t* andÂ â„‹ is the time-independent Hamiltonian. Its
    solution is given byÂ ([1.2.2](Chapter_1.xhtml#x1-370002)), namely
  prefs: []
  type: TYPE_NORMAL
- en: '| ![&#124;Ïˆ (t)âŸ© = ğ’°(0,t) &#124;Ïˆ(0)âŸ©, ](img/file1119.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'where the operatorÂ ğ’°(0*,t*) is obtained from the HamiltonianÂ â„‹ byÂ ([1.2.2](Chapter_1.xhtml#x1-370002)):'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ( iâ„‹t) ğ’° (0,t) = exp âˆ’ ---- . â„ ](img/file1120.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: We work with units whereÂ â„ is set toÂ 1, so that the system dynamics reads
  prefs: []
  type: TYPE_NORMAL
- en: '| ![&#124;Ïˆ(t)âŸ© = eâˆ’ iâ„‹t &#124;Ïˆ (0 )âŸ©. ](img/file1121.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: If the initial state of the system ![|Ïˆ(0)âŸ©](img/file1122.jpg) is known then
    the state of the system at time *t* is also known and is determined by the action
    of the HamiltonianÂ â„‹ over the period of timeÂ *t*.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the solutionÂ ([11.1](#x1-2180001)) assumes that the system Hamiltonian
    is time-independent. At the same time, AQC works with time-dependent Hamiltonians
    of the formÂ ([2.2](Chapter_2.xhtml#x1-500002)):'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ( t ) t â„‹ (t) = 1 âˆ’ T- â„‹0 + T-â„‹F , ](img/file1123.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'for some *initial* HamiltonianÂ â„‹[0] and some *final* or *problem* (encoding
    the optimisation problem) HamiltonianÂ â„‹[F] . How do we reconcile this mismatch?
    The answer is that we can *approximate*Â Â [[272](Biblography.xhtml#XStechly2020)]
    the time-dependent HamiltonianÂ â„‹(*t*) that transforms the state over [0*,T*] by
    a sequence of time-independent Hamiltonians:'
  prefs: []
  type: TYPE_NORMAL
- en: '![â„‹1, â„‹2, ..., â„‹m, ](img/file1124.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'transforming the state over the corresponding shorter time intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: '![[t0 = 0,t1], [t1,t2], ..., [tmâˆ’1,tm = T ]. ](img/file1125.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A good analogy is the approximation of a continuous function (e.g., sin(â‹…))
    by a piecewise linear function as shown in FigureÂ [11.1](#11.1). The more granular
    the time intervals [*t*[iâˆ’1]*,t*[i]], the better the approximation.
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 11.1: Piecewise linear approximation of tâ†¦â†’sin(t). ](img/file1127.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 11.1: Piecewise linear approximation of t![â†¦â†’](img/file1126.jpg)sin(t).'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can approximate the operatorÂ ğ’°(0*,T*) as
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ğ’° (0,T) â‰ˆ ğ’°(tmâˆ’ 1,tm )ğ’°(tmâˆ’2,tmâˆ’ 1) â‹…â‹…â‹…ğ’° (t2,t1)ğ’°(t0,t1). ](img/file1128.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: Again, larger values ofÂ *n* give a better approximation.
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of a quantum mechanical system over a long time interval can be
    modelled as a sequence of time-independent Hamiltonians transforming the system
    state over the corresponding shorter time intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2 The Suzuki-Trotter Expansion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A particularly useful approximation ofÂ ğ’°(0*,T*) can be obtained using the Suzuki-Trotter
    expansionÂ Â [[279](Biblography.xhtml#XSuzuki1993)]. If ğ’œ[1]*,*ğ’œ[2]*,â€¦,*ğ’œ[k] are
    operators that do not necessarily commute, then
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ( ) [ ( ğ’œ ) ( ğ’œ ) (ğ’œ ) ]m exp ğ’œ1 + ğ’œ2 + ...+ ğ’œk = lim exp -1- exp -2-
    â‹…â‹…â‹…exp --k . m â†’âˆ m m m ](img/file1129.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: Recall that two operatorsÂ ğ’œ andÂ â„¬ are said to commute if ğ’œâ„¬ = â„¬ğ’œ. Many operators
    introduced in previous chapters do not commute, for example, rotations around
    different axes do not, and the end result (the end quantum state) depends on how
    rotations are ordered.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in ChapterÂ [1](Chapter_1.xhtml#x1-220001), the expectation values
    of Hermitian operators are real and correspond to physical observables (e.g.,
    the expectation of a Hermitian Hamiltonian is the physically observable energy).
    If operators commute we can *measure* them in an arbitrary order and obtain the
    same answer. There is no uncertainty in the values of the corresponding physical
    observables.
  prefs: []
  type: TYPE_NORMAL
- en: The Suzuki-Trotter expansion, however, does not require operators to commute
    to remain valid. This has important implications for QAOA as we shall see below.
    If ğ’°(0*,T*) has the form exp([ğ’œ + â„¬]*T*) then we can use the Suzuki-Trotter expansion
    to obtain
  prefs: []
  type: TYPE_NORMAL
- en: '![ [ ( ) ( ) ] ğ’œT-- â„¬T- m exp([ğ’œ + â„¬]T) = mliâ†’mâˆ exp m exp m , ](img/file1130.jpg)'
  prefs: []
  type: TYPE_IMG
- en: namely the time evolution of [ğ’œ + â„¬]*T* can be approximated by applying alternativelyÂ ğ’œ
    andÂ â„¬ over time intervals of lengthÂ *Tâˆ•m*.
  prefs: []
  type: TYPE_NORMAL
- en: In ChapterÂ [3](Chapter_3.xhtml#x1-630003), we introduced detailed specifications
    of the AQC, where the HamiltoniansÂ â„‹[0] andÂ â„‹[F] have the general form
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ âˆ‘n âˆ‘n âˆ‘n âˆ‘n â„‹0 = Ïƒix and â„‹F = aiÏƒiz + bijÏƒizÏƒjz, i=1 i=1 i=1 j=i+1 ](img/file1131.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: for some coefficientsÂ (*a*[i])[i=1,â€¦,n] and (*b*[ij])[i,j=1,â€¦,n]. We also refer
    the interested reader toÂ Â [[304](Biblography.xhtml#Xwurtz2106counterdiabaticity)]
    for a precise connection between QAOA and AQC, in particular in the case of a
    finite number of stepsÂ *m*.
  prefs: []
  type: TYPE_NORMAL
- en: The initial HamiltonianÂ â„‹[0] is the operatorÂ ğ’œ â€“ called the *mixing* Hamiltonian
    â€“ and the final HamiltonianÂ â„‹[F] is the operatorÂ â„¬ â€“ called the *phase* Hamiltonian.
    Recall from ChapterÂ [10](Chapter_10.xhtml#x1-20200010) that the Pauli operatorsÂ *Ïƒ*[x],
    *Ïƒ*[y], andÂ *Ïƒ*[z] are represented by the quantum gatesÂ X, Y, andÂ Z, and the superscript
    inÂ *Ïƒ*[x]^i refers to the qubit on which it acts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial state is set in the equal superposition state of all possible solutionsÂ Â [[122](Biblography.xhtml#XHadfield2019)]:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ 1 ( ) 1 2âˆ‘nâˆ’1 |Ïˆ(0)âŸ© = âˆš-n- |0...00âŸ© + |0 ...01âŸ©+ ...+ |1...11âŸ© = âˆš-n- |iâŸ©,
    2 2 i=0 ](img/file1132.jpg)'
  prefs: []
  type: TYPE_IMG
- en: which is the ground state ofÂ ğ’œ and can be easily constructed fromÂ ![|0âŸ©](img/file1133.jpg)^(âŠ—n)
    by applying the Hadamard gate H to every qubit, i.e.,
  prefs: []
  type: TYPE_NORMAL
- en: '![|Ïˆ(0)âŸ© = HâŠ—n |0âŸ©âŠ—n . ](img/file1134.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Remark:** For a one-qubit system, ğ’œ is theÂ X gate and the initial state is'
  prefs: []
  type: TYPE_NORMAL
- en: '![ 1 |Ïˆ(0)âŸ© = âˆš--(|0âŸ© + |1âŸ©) = |+âŸ© . 2 ](img/file1135.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we know from ChapterÂ [10](Chapter_10.xhtml#x1-20200010), state ![|+âŸ©](img/file1136.jpg)
    is the eigenstate ofÂ X with eigenvalue equal toÂ 1, namely X![|+ âŸ©](img/file1137.jpg)
    = ![|+âŸ©](img/file1138.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: 11.3 The Algorithm Specification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now everything is in place for the formulation of the QAOA procedureÂ Â [[122](Biblography.xhtml#XHadfield2019)].
  prefs: []
  type: TYPE_NORMAL
- en: '![--------------------------------------------------------------------- -Algorithm---9:-Quantum--Approximate-Optimisation-Algorithm-----------
    Input: ğ’œ and â„¬. 1: A parameterised quantum state |Ïˆ(Î², Î³)âŸ©, Î² := (Î²1,...,Î²m ),
    Î³ := (Î³ ,...,Î³ ), is created by alternately applying the operators ğ’œ 1 m and â„¬
    for m rounds, where the duration in round i (i = 1,...,m ) is specified by the
    parameters Î² and Î³ respectively: i i ( âŠ—n) |Ïˆ (Î², Î³)âŸ© = eâˆ’ iÎ²mğ’œe âˆ’iÎ³mâ„¬ â‹…â‹…â‹…eâˆ’iÎ²2ğ’œeâˆ’
    iÎ³2â„¬eâˆ’iÎ²1ğ’œe âˆ’iÎ³1â„¬ H âŠ—n |0âŸ© . 2: A computational basis (z- basis) measurement is
    performed on the obtained state, which returns a candidate solution. Repeating
    the above state preparation and measurement, the expected value of the cost function
    f over the returned solution samples is given by âŸ¨fâŸ© = âŸ¨Ïˆ(Î²,Î³)|â„¬ |Ïˆ(Î²,Î³ )âŸ© , which
    can be statistically estimated from the samples produced (as explained in Chapter
    10 ). 3: The above steps may then be repeated with the updated sets of time parameters
    Î² and Î³ â€“ the variational part of the algorithm â€“ within the classical optimisation
    loop that aims to minimise the expectation of the cost function âŸ¨fâŸ©. Result: The
    algorithm returns the best found solution. ---------------------------------------------------------------------
    ](img/file1139.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is important to apply operators exp(âˆ’i*Î²*ğ’œ) and exp(âˆ’i*Î³*â„¬) alternately
    to ensure that we are not trapped in a local minimum. It is also important thatÂ ğ’œ
    andÂ â„¬ do not commuteÂ Â [[272](Biblography.xhtml#XStechly2020)]. Indeed, by applying
    only exp(âˆ’i*Î³*â„¬), we are facing ending in an eigenstate of the phase Hamiltonian.
    If this happens, we will be trapped there: any further application of a linear
    operator to its eigenvector may change its length but not its direction. The same
    applies to alternating between two commuting operators: ifÂ ğ’œ andÂ â„¬ commute, then
    we can come up with a set of basis states that are eigenstates of bothÂ ğ’œ andÂ â„¬,
    and once we get into one of these eigenstates we remain trapped in it. However,
    sinceÂ *Ïƒ*[x] andÂ *Ïƒ*[z] do not commute, there is always a chance to escape from
    the local minimum.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ongoing exploration of QAOA potential started with the foundational paper
    by Farhi, Goldstone, and GutmannÂ Â [[96](Biblography.xhtml#XFarhi2014)] where it
    outperformed classical algorithms on the Max-Cut problem on connected 3-regular
    graphs. A regular graph is one where each vertex has the same number of neighbours.
    In the case of a 3-regular graph (also known as a *cubic* graph), each vertex
    is connected with three other vertices. We consider the Max-Cut problem in the
    next section in its most general formulation. It was a decisive result that prompted
    active development of classical algorithms and, eventually, one with asymptotically
    much better performance was constructed by Barak *etÂ al*Â Â [[25](Biblography.xhtml#XBarak2015)].
    This, in turn, triggered further investigations: the performance comparison between
    QAOA and the best classical algorithms was studied by Hastings inÂ Â [[128](Biblography.xhtml#XHastings2019)],
    and Bravyi, Kliesch, Koenig and TangÂ Â [[44](Biblography.xhtml#XBravyi2019)] established
    that the locality and the symmetry of QAOA severely limit its performance. To
    overcome these limitations, they proposed a non-local version that significantly
    outperforms standard QAOA for a frustrated Ising model on random 3-regular graphs.'
  prefs: []
  type: TYPE_NORMAL
- en: 11.4 The Max-Cut Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Max-Cut problem is one of the special cases of the graph partitioning problem
    introduced in ChapterÂ [3](Chapter_3.xhtml#x1-630003). The objective is to divide
    the vertices of the graph into two groups such that either the maximum possible
    number of edges going between the two groups are "cut" (if all edges have the
    same weight) or the total weight of these edges is maximised (if they have different
    weights).
  prefs: []
  type: TYPE_NORMAL
- en: The problem of maximisation of the total weight (or number of edges being cut)
    can be formulated as the minimisation of a cost function, which is the sum of
    the costs of all individual edges. Each individual costÂ *c*[ij], associated with
    the edge connecting verticesÂ *i* andÂ *j*, is given by
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ 1 cij = -wij(1 âˆ’ sisj), 2 ](img/file1140.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: whereÂ *s*[i] andÂ *s*[j] are classical spin variables taking values {âˆ’1*,*+1}
    andÂ *w*[ij] is the weight associated with the edge connecting verticesÂ *i* andÂ *j*.
    The two groups of vertices are those where the spin variables take the same values
    (either âˆ’1 or +1). We can see fromÂ ([11.4](#x1-2210004)) that whenÂ *s*[i] andÂ *s*[j]
    have the same sign, the costÂ *c*[ij] is zero; however, whenÂ *s*[i] andÂ *s*[j]
    have opposite signs, the costÂ *c*[ij] is equal to the weightÂ *w*[ij].
  prefs: []
  type: TYPE_NORMAL
- en: The cost function for the whole graph then has the form
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ âˆ‘ 1 L (s) = 2wij(1âˆ’ sisj), {ij}âˆˆG ](img/file1141.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: where s := (*s*[1]*,â€¦,s*[n]) is the set of decision variables associated with
    the *n*-node graphÂ *G* and the sum goes over all pairs of nodes connected by the
    graph edges.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many possible applications of the Max-Cut problem in finance, for
    example *client clustering* or *client segmentation*, where the task can be formulated
    by creating a graph containing a node for each client and an edge between each
    pair of clients. The weight of an edge connecting any two clients is determined
    by the relative closeness of clientsâ€™ characteristics: the closer the clients,
    the smaller the weight of the edge that connects them. The clusters that are formed
    by finding maximum weight cuts have the property that clients in one cluster are
    more dissimilar from clients in other clusters.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the flagship application of Max-Cut in finance is portfolio optimisation.
    Dees, StankoviÄ‡, Constantinides, and MandiÂ Â [[81](Biblography.xhtml#XDees2019)]
    have shown that the graph-theoretic portfolio partitioning technique can help
    devise robust and tractable asset allocation schemes by virtue of a rigorous graph
    framework for considering smaller, computationally feasible, and economically
    meaningful clusters of assets, based on graph cuts. Barkoutsos, Nannicini, Robert,
    Tavernelli, and WoernerÂ Â [[26](Biblography.xhtml#XBarkoutsos2019)] improved variational
    quantum optimisation using a Conditional Value-at-Risk technique â€“ ubiquitous
    in financial risk management. A portfolio optimisation QAOA use case addressed
    by solving the maximum independent set problem on a quantum simulator was presented
    inÂ Â [[276](Biblography.xhtml#XSuchara2021)]. It is also necessary to mention portfolio
    rebalancing experiments using the Quantum Alternating Operator Ansatz conducted
    by Hodson, Ruck, Ong, Garvin, and DulmaÂ Â [[138](Biblography.xhtml#XHodson2019)].
  prefs: []
  type: TYPE_NORMAL
- en: 11.4.1 QAOA gates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The mixing HamiltonianÂ ğ’œ and the phase HamiltonianÂ â„¬ corresponding to the cost
    functionÂ ([11.4](#x1-2210004)) read
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ n âˆ‘ i âˆ‘ 1- ( i j) ğ’œ = Ïƒx and â„¬ = 2 wij 1âˆ’ Ïƒ zÏƒ z , i=1 {ij}âˆˆG ](img/file1142.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: where the spin variables *s* are replaced by the corresponding Pauli operatorsÂ *Ïƒ*.
    We therefore need to find the quantum gate representation of the operators
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ( ) ( i) 1 i j exp âˆ’ iÎ²Ïƒx and exp âˆ’2-iÎ³Ïƒ zÏƒz . ](img/file1143.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'To do so, we require the following (see also LemmaÂ [1](Chapter_1.xhtml#x1-30002r1),
    albeit with a slightly different proof):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Theorem 9.** *WithÂ *â„ *denoting the identity operator, the following holds
    for any* *unitary Hermitian operatorÂ *â„‹ *and any* *ğœƒ* âˆˆâ„*:*'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ( ) ( ) ( ) 1- ğœƒ- ğœƒ- R ğœƒ(â„‹) â‰¡ exp âˆ’ 2iğœƒâ„‹ = cos 2 â„ âˆ’ isin 2 â„‹. ](img/file1144.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: '*Proof.* SinceÂ â„‹ is a unitary Hermitian operator its eigenvalues are +1 and
    âˆ’1 (ChapterÂ [1](Chapter_1.xhtml#x1-220001)). Let ğ’«[Â±] be projectors onto the eigenspace
    of eigenvaluesÂ Â±1 respectively, so that'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![â„ = ğ’«+ + ğ’« âˆ’ , â„‹ = ğ’«+ âˆ’ ğ’«âˆ’ . ](img/file1145.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'When a function (in this case *R*[ğœƒ]) is applied to a matrix (in this case
    â„‹) it is applied to each of the eigenvalues:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ( ) ( ) R (â„‹ ) = exp âˆ’ 1-iğœƒ(+1 ) ğ’« + exp âˆ’ 1iğœƒ (âˆ’ 1) ğ’« ğœƒ 2 + 2 âˆ’ ( 1 )
    ( 1 ) = exp âˆ’ --iğœƒ ğ’«+ + exp -iğœƒ ğ’«âˆ’ . 2 2 ](img/file1146.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: FromÂ ([11.4.1](#x1-222001r1)) we have
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ 1 1 ğ’«+ = -(â„ + â„‹ ) and ğ’«âˆ’ = --(â„ âˆ’ â„‹ ). 2 2 ](img/file1147.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: SubstitutingÂ ([11.4.1](#x1-222001r1)) intoÂ ([11.4.1](#x1-222001r1)) yields
  prefs: []
  type: TYPE_NORMAL
- en: '| *R*[ğœƒ](â„‹) | = ![1- 2](img/file1148.jpg)exp![( ) 1- âˆ’ 2iğœƒ](img/file1149.jpg)(â„
    + â„‹) + ![1- 2](img/file1150.jpg)exp![( ) 1- 2iğœƒ](img/file1151.jpg)(â„âˆ’â„‹) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = ![1- 2](img/file1152.jpg)![[ ( ) ( )] exp âˆ’ 1iğœƒ + exp 1iğœƒ 2 2](img/file1153.jpg)â„
    + ![1- 2](img/file1154.jpg)![[ ( ) ( )] exp âˆ’ 1iğœƒ âˆ’ exp 1iğœƒ 2 2](img/file1155.jpg)â„‹
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | = cos![( ) ğœƒ- 2](img/file1156.jpg)â„âˆ’ isin![( ) ğœƒ- 2](img/file1157.jpg)â„‹*.*
    |'
  prefs: []
  type: TYPE_TB
- en: â–¡
  prefs: []
  type: TYPE_NORMAL
- en: 'We can useÂ ([9](#x1-222001r9)) to write down expressions for the operatorsÂ ([11.4.1](#x1-2220001))
    in matrix form. We start with the first operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![exp(âˆ’ iÎ² Ïƒx) = cos(Î²)IâŒŠ âˆ’ isinâŒ‹(Î²)X âŒŠ âŒ‹ = cos(Î²)âŒˆ1 0âŒ‰ âˆ’ isin(Î²)âŒˆ0 1âŒ‰ 0
    1 1 0 âŒŠ âŒ‹ cos(Î² ) âˆ’ isin(Î²) = âŒˆ âŒ‰. âˆ’ isin(Î²) cos(Î² ) ](img/file1158.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: Since the operatorÂ R[X](*ğœƒ*) has the following matrix representation
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ âŒŠ âŒ‹ (ğœƒ) (ğœƒ) RX(ğœƒ) = âŒˆ cos 2( ) âˆ’ isin( 2) âŒ‰ , âˆ’ isin ğœƒ2 cos ğœƒ2 ](img/file1159.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: (see, for example, ChapterÂ [6](Chapter_6.xhtml#x1-1190006) or TheoremÂ [9](#x1-222001r9)),
    we have
  prefs: []
  type: TYPE_NORMAL
- en: '![exp(âˆ’ iÎ² Ïƒx) = RX(2Î² ), ](img/file1160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: so that opeator exp(âˆ’i*Î²Ïƒ*[x]^i) should be represented in the circuit by the
    gate R[X](2*Î²*) placed on the quantum registerÂ *i*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can proceed now with the gate representation of operator exp![(âˆ’ 1iÎ³Ïƒ Ïƒ
    ) 2 z z](img/file1161.jpg), where *Ïƒ*[z]*Ïƒ*[z] represents the tensor product of
    twoÂ *Ïƒ*[z] operators acting on two different qubits:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ( 1 ) (Î³ ) ( Î³) exp âˆ’ -iÎ³ÏƒzÏƒz = cos -- I âŠ— I âˆ’ isin -- ZâŠ— Z 2 âŒŠ âŒ‹2 âŒŠ 2
    âŒ‹ 1 0 0 0 1 0 0 0 ( )&#124;&#124; &#124;&#124; ( ) &#124;&#124; &#124;&#124; =
    cos Î³- &#124;&#124; 0 1 0 0 &#124;&#124;âˆ’ isin Î³- &#124;&#124;0 âˆ’ 1 0 0&#124;&#124;
    2 &#124; 0 0 1 0 &#124; 2 &#124;0 0 âˆ’ 1 0&#124; âŒˆ âŒ‰ âŒˆ âŒ‰ 0 0 0 1 0 0 0 1 âŒŠ (Î³)
    (Î³) âŒ‹ &#124;cos 2 âˆ’ isin 2 ( ) 0 ( ) 0 0 &#124; &#124;&#124; 0 cos Î³2 + isin Î³2
    0 0 &#124;&#124; = &#124;&#124; (Î³ ) (Î³) &#124;&#124; âŒˆ 0 0 cos 2 + isin 2 ( )
    0 ( )âŒ‰ 0 0 0 cos Î³ âˆ’ isin Î³ âŒŠ âŒ‹ 2 2 eâˆ’iÎ³âˆ•2 0 0 0 &#124;&#124; iÎ³âˆ•2 &#124;&#124;
    = &#124;&#124; 0 e 0 0 &#124;&#124; . &#124;âŒˆ 0 0 eiÎ³âˆ•2 0 &#124;âŒ‰ âˆ’iÎ³âˆ•2 0 0 0
    e ](img/file1162.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: Where we used the fact that
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( 1 ) ( Î³) (Î³ ) exp âˆ’ -iÎ³ = cos -- âˆ’ isin -- 2 2 2 ](img/file1163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( 1 ) ( Î³) (Î³ ) exp -iÎ³ = cos -- + isin -- . 2 2 2 ](img/file1164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following lemma provides a quantum circuit for the operator exp![( 1 )
    âˆ’2iÎ³ÏƒzÏƒz](img/file1165.jpg):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lemma 8.** *The operator* exp![( ) âˆ’ 12iÎ³ ÏƒizÏƒjz](img/file1166.jpg) *can
    be represented by the* *following circuit:*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file1167.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Proof.* FromÂ ([6.3.3](Chapter_6.xhtml#x1-130014r3)), we can write'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ âŒŠ âŒ‹ âŒŠ âŒ‹ eâˆ’iÎ³âˆ•2 0 âˆ’iÎ³âˆ•2 1 0 RZ(Î³ ) = âŒˆ iÎ³âˆ•2âŒ‰ = e âŒˆ iÎ³âŒ‰ . 0 e 0 e ](img/file1168.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: The multiplier exp![( 1 ) âˆ’ 2iÎ³](img/file1169.jpg) is an unobservable global
    phase and can be ignored. Now,
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ âŒŠ âŒ‹ 1 0 0 0 âŒŠ âŒ‹ âŒŠ âŒ‹ &#124; &#124; âŒˆ1 0âŒ‰ âŒˆ1 0 âŒ‰ &#124;&#124; 0 eiÎ³ 0 0
    &#124;&#124; RZ(Î³ )âŠ— RZ(Î³) = iÎ³ âŠ— iÎ³ = &#124;&#124; iÎ³ &#124;&#124; . 0 e 0 e
    âŒˆ 0 0 e 0 âŒ‰ 0 0 0 e2iÎ³ ](img/file1170.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: Finally, the matrix representation of the CR[z](âˆ’2*Î³*) gate is
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ âŒŠ âŒ‹ &#124; 1 0 0 0 &#124; &#124; 0 1 0 0 &#124; CRZ(âˆ’ 2Î³ ) = &#124;&#124;
    &#124;&#124; , &#124;âŒˆ 0 0 1 0 &#124;âŒ‰ 0 0 0 eâˆ’ 2iÎ³ ](img/file1171.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: and the matrix representation of the whole circuit shown in the lemma is
  prefs: []
  type: TYPE_NORMAL
- en: '| ![âŒŠ âŒ‹ âŒŠ âŒ‹ âŒŠ âŒ‹ 1 0 0 0 1 0 0 0 eâˆ’ iÎ³âˆ•2 0 0 0 &#124;&#124; iÎ³ &#124;&#124;
    &#124;&#124; &#124;&#124; &#124;&#124; iÎ³âˆ•2 &#124;&#124; &#124;&#124;0 e 0 0 &#124;&#124;
    &#124;&#124;0 1 0 0 &#124;&#124; = eiÎ³âˆ•2&#124;&#124; 0 e 0 0 &#124;&#124;. &#124;0
    0 eiÎ³ 0 &#124; &#124;0 0 1 0 &#124; &#124; 0 0 eiÎ³âˆ•2 0 &#124; âŒˆ 2iÎ³âŒ‰ âŒˆ âˆ’2iÎ³âŒ‰ âŒˆ
    âˆ’ iÎ³âˆ•2âŒ‰ 0 0 0 e 0 0 0 e 0 0 0 e ](img/file1172.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: Again, the global phase can be ignored and we arrive at the same matrix expression
    we obtained for exp![( ) âˆ’ 12iÎ³Ïƒz Ïƒz](img/file1173.jpg). â–¡
  prefs: []
  type: TYPE_NORMAL
- en: 11.4.2 QAOA circuit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As pointed out in ChaptersÂ [8](Chapter_8.xhtml#x1-1620008) andÂ [9](Chapter_9.xhtml#x1-1850009),
    existing quantum processors often have limited qubit connectivity, so that we
    need to use a particular embedding scheme in order to map the Max-Cut graph onto
    the QPU graph. The simplest case is a one-to-one mapping of the graph nodes and
    the connectivity edges. FigureÂ [11.2](#11.2) displays one such graph (implemented
    in Rigettiâ€™s Aspen system) consisting of eight nodes (embedded in qubits 1*,â€¦,*8)
    and eight edges. NodesÂ 1, 3, 5, and 7 each have one connection and nodesÂ 2, 4,
    6, and 8 each have three connections.
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 11.2: Embedding of the Max-Cut optimisation problem on Rigettiâ€™s Aspen
    system. ](img/file1174.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 11.2: Embedding of the Max-Cut optimisation problem on Rigettiâ€™s Aspen
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: The corresponding QAOA circuit is shown in FigureÂ [11.3](#11.3).
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 11.3: QAOA circuit for the Max-Cut problem. ](img/file1175.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 11.3: QAOA circuit for the Max-Cut problem.'
  prefs: []
  type: TYPE_NORMAL
- en: The circuit consists of four distinct layers. The first one is a layer of Hadamard
    gates creating an equal superposition of statesÂ ![|0âŸ©](img/file1176.jpg) andÂ ![|1
    âŸ©](img/file1177.jpg) â€“ transformation of the basis statesÂ ![|0âŸ©](img/file1178.jpg)
    into the basis statesÂ ![|+ âŸ©](img/file1179.jpg). The second layer represents the
    action of the phase Hamiltonian controlled by the adjustable parameterÂ *Î³*. The
    third layer represents the action of the mixing Hamiltonian controlled by the
    adjustable parameterÂ *Î²*. The final layer consists of measurement operators. The
    second and third layers can be applied multiple times with different values of
    parametersÂ *Î³* andÂ *Î²*.
  prefs: []
  type: TYPE_NORMAL
- en: The optimal solution found by the QAOA using `Qiskit` quantum simulator for
    the case of equal weights (*w*[ij] = 1 for all {*i,j*}âˆˆ *G*) is shown in FigureÂ [11.4](#11.4).
    The optimal solution reads as the bitstring 10011001, and is represented by the
    dashed curve that separates nodes into two equal subsets and cuts across all edges
    of the graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 11.4: Visualisation of the Max-Cut problem solution. ](img/file1180.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 11.4: Visualisation of the Max-Cut problem solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the graph nodes (qubits) {1*,*4*,*5*,*8} belong to group "1" and the graph
    nodes {2*,*3*,*6*,*7} belong to group "0".
  prefs: []
  type: TYPE_NORMAL
- en: In the case of unequal weights the circuit layout remains the same but the adjustable
    gate parameters reflect the relative magnitude of the weights assigned to different
    edges. For example, if the weight assigned to the connection between nodes 1 and
    2 is increased from 1 to 5 and all other weights remain equal to 1, then the phase
    Hamiltonian term that corresponds to the connection between nodes 1 and 2 changes
    from exp![(âˆ’ 1iÎ³Ïƒ Ïƒ ) 2 z z](img/file1181.jpg) to exp![( ) âˆ’ 52iÎ³ÏƒzÏƒz](img/file1182.jpg),
    and the corresponding segment of the quantum circuit changes to the one shown
    in FigureÂ [11.5](#11.5), with the rest of the circuit remaining the same.
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 11.5: Weight w12 increases from 1 to 5\. ](img/file1183.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 11.5: Weight *w*[12] increases from 1 to 5\.'
  prefs: []
  type: TYPE_NORMAL
- en: QAOA can successfully solve NP-hard combinatorial optimisation problems in their
    QUBO formulations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we studied a quantum optimisation algorithm inspired by the
    principles of adiabatic evolution of quantum systems. In this regard, QAOA can
    be seen as a quantum gate model counterpart of the AQC approach to solve classically
    hard optimisation problems.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the Suzuki-Trotter expansion, which provides an approximation of
    the time evolution of quantum mechanical systems and which lies at the heart of
    the algorithm. We illustrated QAOA implementation (gates and circuit) on the Max-Cut
    problem, which has many applications in finance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the sources of power of parameterised quantum
    circuits.
  prefs: []
  type: TYPE_NORMAL
