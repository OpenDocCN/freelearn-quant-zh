- en: Chapter 4.  Time Series Modeling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time series forecasting analysis is one of the most important components of
    quantitative finance. R software gives a lot of time series and forecasting packages
    to support time series analysis. There are sufficient packages in R to convert
    the equally spaced and unequally spaced series in time series. Also, there are
    sufficient packages in R to build forecasting models such as autoregressive integrated
    moving average and generalized autoregressive conditional heteroscedasticity.
    In this chapter, we are going to give brief flavors of converting any series into
    time series and forecasting models.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: General time series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting data to time series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: zoo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: xts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARIMA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GARCH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EGARCH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VGARCH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic conditional correlation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General time series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A time series is the sequence of data usually collected at regular intervals.
    There are a lot of domains where information is stored in time series form and
    needs to be analyzed for future planning.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the financial domain, we have the daily/monthly data available
    for unemployment, GDP, daily exchange rates, share prices, and so on. So all the
    investors or the people working in financial institutions need to plan their future
    strategy and so they want to analyze the time series data. Thus time series play
    a crucial role in the financial domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time series data is very unpredictable in nature and to understand the data
    we need to decompose the time series data into various components, as given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trend**: This is a pattern of long-term movements in the mean of time series
    data. The trend may be linear or nonlinear and keeps changing across time. There
    is no sure process to identify the exact trend but if it is behaving monotonously
    then it is possible to estimate with a certain acceptable degree of error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Seasonal effects**: These are cyclical fluctuations related to the periodical
    cycle. So, for example, the sale of a particular product spikes during a particular
    month/quarter of the year. The seasonality can be identified by plotting the series
    and inspecting it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cycles (Ct)**: Apart from seasonal cycles, there are certain cycles which
    are associated with business cycles which need to be taken care of when doing
    time series analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Residuals**: Time series consist of systematic patterns and random noise
    (error), which makes it difficult to identify the pattern. Generally, time series
    techniques involve certain ways of filtering the noise in order to make the pattern
    more salient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some of the techniques of forecasting, the time series is assumed to be stationary.
    The stationarity is required because for forecasting we are assuming the mean
    and variance to be static as that will be required for future forecasting analysis.
    If the series is nonstationary then we difference it to first make it stationary
    and then proceed further.
  prefs: []
  type: TYPE_NORMAL
- en: Converting data to time series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A time series is a sequence of data points where each data point is associated
    with a particular time.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the adjusted close of a stock is the closing price of a stock on
    a particular day. The time series data is stored in an R object called a time
    series object and it is created by using the function `ts()` in R.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic syntax of `ts` is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data`: It is a vector or matrix containing the data values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`: It is the starting point or time of first observation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end`: It is the time point of last observation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frequency`: It is the number of data points per unit time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us consider a vector which is given by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now convert it into a time series object, which can be done with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting data to time series](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Table showing time series object'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us plot this data by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following output plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting data to time series](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Time series plot using ts object'
  prefs: []
  type: TYPE_NORMAL
- en: 'The frequency parameter in the `ts()` function identifies at which time the
    interval data is measured:'
  prefs: []
  type: TYPE_NORMAL
- en: Frequency = 12 means that data is at monthly level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequency = 4 means that data is at quarterly level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequency = 6 means data points for every 10 minutes of an hour
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequency = 5 means that data is at daily level business days
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: zoo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ts` object has its limitations in representing the time series. It is used
    for representing equally spaced data. It cannot be used to represent the daily
    level stock prices as stock prices are equally spaced between Monday to Friday,
    but it is not the same case for Friday to Monday and in case there is market holidays
    on weekdays. This type of unequally spaced data cannot be represented by a `ts`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '`zoo` is flexible and fully equipped to handle unequally spaced data, equally
    spaced data, and numerically indexed data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first install and load the `zoo` library. This can be done by executing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now we will discuss how to represent different time series scenarios using `zoo`.
  prefs: []
  type: TYPE_NORMAL
- en: Please note we will be using a common dataset for all the examples.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a zoo object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to create a `zoo` object, an ordered time index and data are required.
    So we are going to construct a `zoo` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first import a few rows of our sample dataset, which can be done with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Date` | `Volume` | `Adj.Close` | `Return` |'
  prefs: []
  type: TYPE_TB
- en: '| 12/14/2016 | 4144600 | 198.69 | 0.27 |'
  prefs: []
  type: TYPE_TB
- en: '| 12/13/2016 | 6816100 | 198.15 | 2.97 |'
  prefs: []
  type: TYPE_TB
- en: '| 12/12/2016 | 615800 | 192.43 | 0.13 |'
  prefs: []
  type: TYPE_TB
- en: 'Now let us try to convert this DataFrame into a `zoo` object. This can be done
    by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon execution, it generates the following `zoo` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | `Volume` | `Adj.Close` |'
  prefs: []
  type: TYPE_TB
- en: '| 12/12/2016 | 615800 | 192.43 |'
  prefs: []
  type: TYPE_TB
- en: '| 12/13/2016 | 6816100 | 198.15 |'
  prefs: []
  type: TYPE_TB
- en: '| 12/14/2016 | 4144600 | 198.69 |'
  prefs: []
  type: TYPE_TB
- en: Reading an external file using zoo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The function `read.zoo` is a wrapper which can be used to read an external dataset,
    which assumes that the first column is the index and rest of the columns are data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us read a dataset using `zoo` which has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Date` | `Volume` | `Adj Close` | `Return` |'
  prefs: []
  type: TYPE_TB
- en: '| 12/14/2016 | 4144600 | 198.69 | 0.27 |'
  prefs: []
  type: TYPE_TB
- en: 'We execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us an output with the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | `Volume` | `Adj.Close` | `Return` |'
  prefs: []
  type: TYPE_TB
- en: '| 2016-12-14 | 4144600 | 198.69 | 0.27 |'
  prefs: []
  type: TYPE_TB
- en: Advantages of a zoo object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are some of the examples that show the advantageous behavior of a `zoo`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Subsetting the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Subsetting can be done on an index using the `window()` function by executing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | `Volume` | `Adj.Close` | `Return` |'
  prefs: []
  type: TYPE_TB
- en: '| 11/1/2016 | 7014900 | 190.79 | -3.51 |'
  prefs: []
  type: TYPE_TB
- en: '| 11/2/2016 | 4208700 | 188.02 | -1.45 |'
  prefs: []
  type: TYPE_TB
- en: '| 11/3/2016 | 2641400 | 187.42 | -0.32 |'
  prefs: []
  type: TYPE_TB
- en: Merging zoo objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us form two `zoo` objects with a common index and then merge them. This
    can be done by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The final output is given in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | `zVolume` | `zAdj.Close` |'
  prefs: []
  type: TYPE_TB
- en: '| 12/12/2016 | 615800 | 192.43 |'
  prefs: []
  type: TYPE_TB
- en: '| 12/13/2016 | 6816100 | 198.15 |'
  prefs: []
  type: TYPE_TB
- en: '| 12/14/2016 | 4144600 | 198.69 |'
  prefs: []
  type: TYPE_TB
- en: Plotting zoo objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can plot your data across time. A sample is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Plotting zoo objects](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Time series plot using zoo object'
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of a zoo object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An index in a `zoo` object cannot have `Date` classed variables, whereas the
    index of an `xts` object has to be a known and supported `time` or `Date` class.
    Also, in `zoo,` we cannot add arbitrary attributes which can be done in `xts`.
  prefs: []
  type: TYPE_NORMAL
- en: xts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`xts` is an extensible time series object which carries all the features of
    a `zoo` object. It consists of a matrix and index which has to be time-based.
    There are two ways of constructing `xts` objects: one is by calling `as.xts` and
    another is constructing the `xts` object from scratch.'
  prefs: []
  type: TYPE_NORMAL
- en: Construction of an xts object using as.xts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us read a few lines of our sample data through `zoo` and construct the
    `xts` object by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | `Volume` | `Adj.Close` | `Return` |'
  prefs: []
  type: TYPE_TB
- en: '| 12/12/2016 | 615800 | 192.43 | 0.13 |'
  prefs: []
  type: TYPE_TB
- en: '| 12/13/2016 | 6816100 | 198.15 | 2.97 |'
  prefs: []
  type: TYPE_TB
- en: '| 12/14/2016 | 4144600 | 198.69 | 0.27 |'
  prefs: []
  type: TYPE_TB
- en: 'The composition of the `xts` object can be given by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An `xts` object on 2016-12-12/2016-12-14 contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Constructing an xts object from scratch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us first form a matrix and date sequence of same order and then convert
    it into an `xts` object. This can be done by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the `xts` object, as displayed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | `a` | `b` |'
  prefs: []
  type: TYPE_TB
- en: '| 2/2/2016 | 5 | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| 3/2/2016 | 6 | 8 |'
  prefs: []
  type: TYPE_TB
- en: The special aspects of an `xts` object is that it behaves like a matrix with
    time associated with each observation. The subsets will always preserve the matrix
    form and the attributes of the `xts` objects are always retained. Also, since
    `xts` is a subclass of `zoo`, it gets all the power of the `zoo` library.
  prefs: []
  type: TYPE_NORMAL
- en: Linear filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in time series analysis is to decompose the time series in trend,
    seasonality, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: One of the methods of extracting trend from the time series is linear filters.
  prefs: []
  type: TYPE_NORMAL
- en: One of the basic examples of linear filters is moving average with equal weights.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of linear filters are weekly average, monthly average, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function used for finding filters is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, `x` is the time series data and `filter` is the coefficients needed to
    be given to find the moving average.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us convert the `Adj.Close` of our `StockData` in time series and find
    the weekly and monthly moving average and plot it. This can be done by executing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linear filters](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Example of moving average using linear filter'
  prefs: []
  type: TYPE_NORMAL
- en: AR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AR stands for **autoregressive model**. Its basic concept is that future values
    depend on past values and they are estimated using a weighted average of the past
    values. The order of the AR model can be estimated by plotting the autocorrelation
    function and partial autocorrelation function of the series. In time series autocorrelation
    function measures correlation between series and it''s lagged values. Whereas
    partial autocorrelation function measures correlation of a time series with its
    own lagged values, controlling for the values of the time series at all shorter
    lags. So first let us plot the `acf` and `pcf` of the series. Let us first plot
    the `acf` plot by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the autocorrelation plot as displayed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AR](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: acf plot of price'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us plot `pacf` by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the partial autocorrelation plot as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AR](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: pacf plot of price'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding plots are autocorrelation and partial autocorrelation plots of
    the series considered. Now let us come to identify the order of AR. Since here
    there is no differencing and `acf` is decaying slowly, whereas `pacf` cuts off
    after one lag, so the order of AR is 1\. Similarly, if `pacf` cuts off after second
    lag and `acf` is decaying slowly, then the order of AR is 2.
  prefs: []
  type: TYPE_NORMAL
- en: MA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MA stands for **moving average** and in MA modeling we do not take into account
    the past values of the actual series. We consider the moving average of the past
    few forecast errors in this process. For identifying the orders of MA, we also
    need to plot `acf` and `pacf`. So let us plot the `acf` and `pacf` of the volume
    of `StockData` to evaluate the order of MA. `acf` can be plotted by executing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following `acf` plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MA](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: acf plot of volume'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us plot the `pacf` plot of volume by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MA](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: pacf plot of volume'
  prefs: []
  type: TYPE_NORMAL
- en: After evaluating the preceding plots, the `acf` cuts sharply after `lag1` so
    the order of MA is 1.
  prefs: []
  type: TYPE_NORMAL
- en: ARIMA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ARIMA stands for **autoregressive integrated moving average** models. Generally,
    it is defined by the equation **ARIMA**(*p*, *d*, *q*).
  prefs: []
  type: TYPE_NORMAL
- en: Here,
  prefs: []
  type: TYPE_NORMAL
- en: '*p* is the order of the autoregressive model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*d* is the order required for making the series stationary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*q* is the order of moving average'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The very first step in ARIMA is to plot the series, as we need a stationary
    series for forecasting.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let us first plot the graph of the series by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ARIMA](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Plot of price data'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, upon inspection, the series seems to be nonstationary, so we need
    to make it stationary by differencing. This can be done by executing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following plot for the differenced series:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ARIMA](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Plot of differenced price data'
  prefs: []
  type: TYPE_NORMAL
- en: This is a stationary series, as the means and variance seem to be constant across
    time. Also, we can check the stationarity using the `Dickey-Fuller` test. Thus
    we have identified the value of *d* for our ARIMA model, which is 1\. Now let
    us plot the autocorrelation function and partial autocorrelation function of the
    differenced series for identifying the values of *p* and *q*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `acf` plot is given by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![ARIMA](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: acf plot of differenced series'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pacf` plot is given by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the `pacf` plot for the differenced series:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ARIMA](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: pacf plot of differenced series'
  prefs: []
  type: TYPE_NORMAL
- en: This clearly shows that the AR and MA order is 0 and 1 respectively and hence
    the best candidate model is ARIMA(0,1,1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us estimate the coefficients of the identified ARIMA model, which can
    be done by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates coefficients of the identified ARIMA model as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ARIMA](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: Fitted summary of ARIMA (0,1,1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us try to predict the forecast and plot it, which can be done by executing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ARIMA](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: The future forecast with confidence interval'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now plot the forecasted value along with the confidence interval by executing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ARIMA](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: Plot of forecasted value along with the confidence interval'
  prefs: []
  type: TYPE_NORMAL
- en: 'Model adequacy can be checked by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ARIMA](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: Model adequacy check statistics for fitted model'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the Pvalue is greater than 0.05, there is no significant autocorrelation
    in the residuals at lags 1-20:'
  prefs: []
  type: TYPE_NORMAL
- en: GARCH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GARCH** stands for **generalized autoregressive conditional heteroscedasticity**.
    One of the assumptions in OLS estimation is that variance of error should be constant.
    However, in financial time series data, some periods are comparatively more volatile,
    which contributes to rise in strengths of the residuals, and also these spikes
    are not randomly placed due to the autocorrelation effect, also known as volatility
    clustering, that is, periods of high volatility tend to group together. This is
    where GARCH is used to forecast volatility measures, which can be used to forecast
    residuals in the model. We are not going to go into great depth but we will show
    how GARCH is executed in R.'
  prefs: []
  type: TYPE_NORMAL
- en: There are various packages available in R for GARCH modeling. We will be using
    the `rugarch` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first install and load the `rugarch` package, which can be done by executing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us define the specs for the GARCH model and try to estimate the coefficients
    by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![GARCH](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: Summary of coefficients estimate of GARCH'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main arguments for GARCH modeling are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Variance model**: List containing the variance model specifications, especially
    which GARCH model to use and what should be the orders of *p* and *q* in ARCH
    (*q*) and GARCH (*p*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mean model**: List containing the mean model specifications: arma order the
    autoregressive (AR) and moving average (MA) orders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distribution model**: The conditional density to use for the innovations.
    Valid choices are `norm` for the normal distibution, `snorm` for the skew-normal
    distribution, `std` for the student `-t`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can generate our forecast according to our requirement, which is given
    by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![GARCH](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.18: GARCH model forecast'
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of options in the GARCH model and we can use it according to
    our requirement.
  prefs: []
  type: TYPE_NORMAL
- en: EGARCH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EGARCH stands for exponential GARCH. EGARCH is an improved form of GARCH and
    models some of the market scenarios better.
  prefs: []
  type: TYPE_NORMAL
- en: For example, negative shocks (events, news, and so on) tend to impact volatility
    more than positive shocks.
  prefs: []
  type: TYPE_NORMAL
- en: This model differs from the traditional GARCH in structure due to the log of
    variance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take an example to show how to execute EGARCH in R. First define `spec`
    for EGARCH and estimate the coefficients, which can be done by executing the following
    code on the `snp` data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the coefficients as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![EGARCH](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.19: Parameter estimates of EGARCH'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us try to forecast, which can be done by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![EGARCH](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.20: Forecast prediction of EGARCH'
  prefs: []
  type: TYPE_NORMAL
- en: VGARCH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: VGARCH stands for vector GARCH or multivariate GARCH. In the financial domain,
    the assumption is that financial volatilities move together over time across assets
    and markets. Acknowledging this aspect through a multivariate modeling framework
    leads to a better model separate univariate model. It helps in making better decision
    tools in various areas, such as asset pricing, portfolio selection, option pricing,
    and hedging and risk management. There are multiple options in R for building
    in multivariate mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us consider an example of multivariate GARCH in R for the last year of
    data from the `S&P500` and DJI index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![VGARCH](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.21: Future prediction of multivariate GARCH'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic conditional correlation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multivariate GARCH models, which are linear in squares and cross products of
    the data, are generally used to estimate the correlations changing with time.
    Now this can be estimated using **dynamic conditional correlation** (**DCC**),
    which is a combination of a univariate GARCH model and parsimonious parametric
    models for the correlation. It has been observed that they perform well in a variety
    of situations. This method has the flexibility of univariate GARCH and does not
    have the complexity of multivariate GARCH.
  prefs: []
  type: TYPE_NORMAL
- en: Now let us see how to execute DCC in R.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need to install and load the packages `rmgarch` and `PerformanceAnalytics`.
    This can be done by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now let us consider returns of the last year for the `S&P 500` and DJI indexes
    and try to get DCC for these returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us set the specification for DCC by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us fit the model, which can be done by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamic conditional correlation](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.22: Fitted summary of DCC'
  prefs: []
  type: TYPE_NORMAL
- en: Since the forecast has been already shown in the most topic, there is no point
    discussing it again here.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please give an example of converting a data series into a time series using
    the `ts()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are `zoo` and `xts` different from the `ts()` function? Give an example
    of constructing `xts` and `zoo` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you read a file using `zoo`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you check stationarity in time series?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you identify an AR(2) model in R?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you identify an MA(2) model in R?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide an example for the given below model and execute it in R.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: GARCH,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: EGARCH,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: VGARCH
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How do you identify an ARIMA(1,1,1) model in R?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide an example for the given model and execute it in R.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed how to decompose a time series into its various
    components, such as trend, seasonality, cyclicity, and residuals. Also, I have
    discussed how to convert any series into a time series in R and how to execute
    the various forecasting models, such as linear filters, AR, MA, ARMA, ARIMA, GARCH,
    EGARCH, VGARCH, and DCC, in R and make forecast predictions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, different concepts of trading using R will be discussed,
    starting with trend, followed by strategy, followed by pairs trading using three
    different methods. Capital asset pricing, the multi factor model, and portfolio
    construction will also be discussed. Machine learning technologies for building
    trading strategy will also be discussed.
  prefs: []
  type: TYPE_NORMAL
