- en: Chapter 4.  Time Series Modeling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 时间序列建模
- en: Time series forecasting analysis is one of the most important components of
    quantitative finance. R software gives a lot of time series and forecasting packages
    to support time series analysis. There are sufficient packages in R to convert
    the equally spaced and unequally spaced series in time series. Also, there are
    sufficient packages in R to build forecasting models such as autoregressive integrated
    moving average and generalized autoregressive conditional heteroscedasticity.
    In this chapter, we are going to give brief flavors of converting any series into
    time series and forecasting models.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列预测分析是量化金融中最重要的组成部分之一。R软件提供了许多时间序列和预测包来支持时间序列分析。R中有足够的包可以将等距和不等距的系列转换为时间序列。此外，R中还有足够的包可以构建预测模型，如自回归积分滑动平均（ARIMA）和广义自回归条件异方差（EGARCH）。在本章中，我们将简要介绍如何将任何系列转换为时间序列并构建预测模型。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: General time series
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般时间序列
- en: Converting data to time series
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据转换为时间序列
- en: zoo
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: zoo
- en: xts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: xts
- en: Linear filters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性滤波器
- en: AR
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AR
- en: MA
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MA
- en: ARIMA
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARIMA
- en: GARCH
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GARCH
- en: EGARCH
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EGARCH
- en: VGARCH
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VGARCH
- en: Dynamic conditional correlation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态条件相关性
- en: General time series
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般时间序列
- en: A time series is the sequence of data usually collected at regular intervals.
    There are a lot of domains where information is stored in time series form and
    needs to be analyzed for future planning.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列是通常在固定间隔收集的数据序列。许多领域的数据都是以时间序列的形式存储的，并需要进行分析以便未来的规划。
- en: For example, in the financial domain, we have the daily/monthly data available
    for unemployment, GDP, daily exchange rates, share prices, and so on. So all the
    investors or the people working in financial institutions need to plan their future
    strategy and so they want to analyze the time series data. Thus time series play
    a crucial role in the financial domain.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在金融领域，我们有每日/每月的失业率、GDP、日汇率、股价等数据。因此，所有投资者或金融机构的工作人员都需要规划未来的战略，因此他们希望分析时间序列数据。因此，时间序列在金融领域起着至关重要的作用。
- en: 'Time series data is very unpredictable in nature and to understand the data
    we need to decompose the time series data into various components, as given here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列数据本质上是非常不可预测的，为了理解数据，我们需要将时间序列数据分解成多个组成部分，如下所示：
- en: '**Trend**: This is a pattern of long-term movements in the mean of time series
    data. The trend may be linear or nonlinear and keeps changing across time. There
    is no sure process to identify the exact trend but if it is behaving monotonously
    then it is possible to estimate with a certain acceptable degree of error.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**趋势**：这是时间序列数据均值的长期波动模式。趋势可能是线性或非线性的，并且随着时间的推移不断变化。没有确定的方法可以精确识别趋势，但如果它表现出单调性，那么可以在一定可接受的误差范围内进行估算。'
- en: '**Seasonal effects**: These are cyclical fluctuations related to the periodical
    cycle. So, for example, the sale of a particular product spikes during a particular
    month/quarter of the year. The seasonality can be identified by plotting the series
    and inspecting it.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**季节效应**：这些是与周期性循环相关的波动。例如，某个产品的销售在每年的特定月份/季度可能会激增。季节性可以通过绘制序列并检查其图形来识别。'
- en: '**Cycles (Ct)**: Apart from seasonal cycles, there are certain cycles which
    are associated with business cycles which need to be taken care of when doing
    time series analysis.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**周期（Ct）**：除了季节性周期外，还有一些与商业周期相关的周期，这些周期在进行时间序列分析时需要考虑。'
- en: '**Residuals**: Time series consist of systematic patterns and random noise
    (error), which makes it difficult to identify the pattern. Generally, time series
    techniques involve certain ways of filtering the noise in order to make the pattern
    more salient.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**残差**：时间序列由系统性模式和随机噪声（误差）组成，这使得识别模式变得困难。通常，时间序列技术涉及某些去噪方法，以便使模式更加突出。'
- en: In some of the techniques of forecasting, the time series is assumed to be stationary.
    The stationarity is required because for forecasting we are assuming the mean
    and variance to be static as that will be required for future forecasting analysis.
    If the series is nonstationary then we difference it to first make it stationary
    and then proceed further.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些预测技术中，时间序列假设是平稳的。平稳性是必需的，因为在进行预测时，我们假设均值和方差是静态的，这将是未来预测分析所需要的。如果序列是非平稳的，那么我们需要对其进行差分以使其变为平稳，然后再继续分析。
- en: Converting data to time series
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据转换为时间序列
- en: A time series is a sequence of data points where each data point is associated
    with a particular time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列是一个数据点序列，其中每个数据点都与特定的时间相关联。
- en: For example, the adjusted close of a stock is the closing price of a stock on
    a particular day. The time series data is stored in an R object called a time
    series object and it is created by using the function `ts()` in R.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，股票的调整收盘价是股票在特定日期的收盘价格。时间序列数据存储在一个名为时间序列对象的R对象中，并通过使用R中的`ts()`函数创建。
- en: 'The basic syntax of `ts` is given here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`ts`的基本语法如下：'
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里：
- en: '`data`: It is a vector or matrix containing the data values'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：它是包含数据值的向量或矩阵'
- en: '`start`: It is the starting point or time of first observation'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`：它是第一次观察的起始点或时间'
- en: '`end`: It is the time point of last observation'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end`：它是最后一次观察的时间点'
- en: '`frequency`: It is the number of data points per unit time'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frequency`：它是每单位时间的数据点数量'
- en: 'Let us consider a vector which is given by the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个向量，代码如下：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now convert it into a time series object, which can be done with the following
    code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将其转换为时间序列对象，可以使用以下代码完成：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Converting data to time series](img/00054.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![将数据转换为时间序列](img/00054.jpeg)'
- en: 'Figure 4.1: Table showing time series object'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：显示时间序列对象的表格
- en: 'Let us plot this data by using the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码绘制此数据：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This generates the following output plot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出图：
- en: '![Converting data to time series](img/00055.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![将数据转换为时间序列](img/00055.jpeg)'
- en: 'Figure 4.2: Time series plot using ts object'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：使用ts对象的时间序列图
- en: 'The frequency parameter in the `ts()` function identifies at which time the
    interval data is measured:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ts()`函数中的频率参数确定数据的时间间隔：'
- en: Frequency = 12 means that data is at monthly level
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频率 = 12 表示数据为月度级别
- en: Frequency = 4 means that data is at quarterly level
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频率 = 4 表示数据为季度级别
- en: Frequency = 6 means data points for every 10 minutes of an hour
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频率 = 6 表示每小时有每10分钟的一个数据点
- en: Frequency = 5 means that data is at daily level business days
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频率 = 5 表示数据为每日工作日级别
- en: zoo
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: zoo
- en: The `ts` object has its limitations in representing the time series. It is used
    for representing equally spaced data. It cannot be used to represent the daily
    level stock prices as stock prices are equally spaced between Monday to Friday,
    but it is not the same case for Friday to Monday and in case there is market holidays
    on weekdays. This type of unequally spaced data cannot be represented by a `ts`
    object.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`ts`对象在表示时间序列时有其局限性。它用于表示等间隔数据。它不能用于表示日常股票价格，因为股票价格在周一到周五之间是等间隔的，但从周五到周一，或者在工作日有市场假期时，就不相同。这类不等间隔的数据无法通过`ts`对象表示。'
- en: '`zoo` is flexible and fully equipped to handle unequally spaced data, equally
    spaced data, and numerically indexed data.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`zoo`是灵活的，完全能够处理不等间隔数据、等间隔数据和数值索引数据。'
- en: 'Let us first install and load the `zoo` library. This can be done by executing
    the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先安装并加载`zoo`库。这可以通过执行以下代码完成：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we will discuss how to represent different time series scenarios using `zoo`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将讨论如何使用`zoo`表示不同的时间序列场景。
- en: Please note we will be using a common dataset for all the examples.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将在所有示例中使用一个常见的数据集。
- en: Constructing a zoo object
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造一个zoo对象
- en: In order to create a `zoo` object, an ordered time index and data are required.
    So we are going to construct a `zoo` object.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个`zoo`对象，必须提供有序的时间索引和数据。因此，我们将构造一个`zoo`对象。
- en: 'Let us first import a few rows of our sample dataset, which can be done with
    the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先导入我们样本数据集的几行，可以使用以下代码完成：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This gives the following output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '| `Date` | `Volume` | `Adj.Close` | `Return` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `Date` | `Volume` | `Adj.Close` | `Return` |'
- en: '| 12/14/2016 | 4144600 | 198.69 | 0.27 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 12/14/2016 | 4144600 | 198.69 | 0.27 |'
- en: '| 12/13/2016 | 6816100 | 198.15 | 2.97 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 12/13/2016 | 6816100 | 198.15 | 2.97 |'
- en: '| 12/12/2016 | 615800 | 192.43 | 0.13 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 12/12/2016 | 615800 | 192.43 | 0.13 |'
- en: 'Now let us try to convert this DataFrame into a `zoo` object. This can be done
    by executing the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试将这个DataFrame转换为`zoo`对象。这可以通过执行以下代码完成：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Upon execution, it generates the following `zoo` object:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，它生成以下`zoo`对象：
- en: '|  | `Volume` | `Adj.Close` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|  | `Volume` | `Adj.Close` |'
- en: '| 12/12/2016 | 615800 | 192.43 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 12/12/2016 | 615800 | 192.43 |'
- en: '| 12/13/2016 | 6816100 | 198.15 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 12/13/2016 | 6816100 | 198.15 |'
- en: '| 12/14/2016 | 4144600 | 198.69 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 12/14/2016 | 4144600 | 198.69 |'
- en: Reading an external file using zoo
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用zoo读取外部文件
- en: The function `read.zoo` is a wrapper which can be used to read an external dataset,
    which assumes that the first column is the index and rest of the columns are data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `read.zoo` 是一个包装器，可用于读取外部数据集，假设第一列是索引，其他列是数据。
- en: 'Now let us read a dataset using `zoo` which has the following format:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用 `zoo` 读取一个数据集，该数据集的格式如下：
- en: '| `Date` | `Volume` | `Adj Close` | `Return` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `Date` | `Volume` | `Adj Close` | `Return` |'
- en: '| 12/14/2016 | 4144600 | 198.69 | 0.27 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 12/14/2016 | 4144600 | 198.69 | 0.27 |'
- en: 'We execute the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行以下代码：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This gives us an output with the following format:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出如下格式的输出：
- en: '|  | `Volume` | `Adj.Close` | `Return` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|  | `Volume` | `Adj.Close` | `Return` |'
- en: '| 2016-12-14 | 4144600 | 198.69 | 0.27 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 2016-12-14 | 4144600 | 198.69 | 0.27 |'
- en: Advantages of a zoo object
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`zoo` 对象的优势'
- en: Here are some of the examples that show the advantageous behavior of a `zoo`
    object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些展示 `zoo` 对象优势的例子。
- en: Subsetting the data
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据子集化
- en: 'Subsetting can be done on an index using the `window()` function by executing
    the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `window()` 函数对索引进行子集化，方法是执行以下代码：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This gives the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '|  | `Volume` | `Adj.Close` | `Return` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|  | `Volume` | `Adj.Close` | `Return` |'
- en: '| 11/1/2016 | 7014900 | 190.79 | -3.51 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 11/1/2016 | 7014900 | 190.79 | -3.51 |'
- en: '| 11/2/2016 | 4208700 | 188.02 | -1.45 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 11/2/2016 | 4208700 | 188.02 | -1.45 |'
- en: '| 11/3/2016 | 2641400 | 187.42 | -0.32 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 11/3/2016 | 2641400 | 187.42 | -0.32 |'
- en: Merging zoo objects
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并 zoo 对象
- en: 'Let us form two `zoo` objects with a common index and then merge them. This
    can be done by executing the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们形成两个具有共同索引的 `zoo` 对象，然后将它们合并。可以通过执行以下代码完成此操作：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The final output is given in the following table:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最终输出如下表所示：
- en: '|  | `zVolume` | `zAdj.Close` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|  | `zVolume` | `zAdj.Close` |'
- en: '| 12/12/2016 | 615800 | 192.43 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 12/12/2016 | 615800 | 192.43 |'
- en: '| 12/13/2016 | 6816100 | 198.15 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 12/13/2016 | 6816100 | 198.15 |'
- en: '| 12/14/2016 | 4144600 | 198.69 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 12/14/2016 | 4144600 | 198.69 |'
- en: Plotting zoo objects
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制 zoo 对象
- en: 'You can plot your data across time. A sample is shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以跨时间绘制你的数据。这里展示了一个示例：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This generates the following plot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下图表：
- en: '![Plotting zoo objects](img/00056.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![绘制 zoo 对象](img/00056.jpeg)'
- en: 'Figure 4.3: Time series plot using zoo object'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：使用 zoo 对象的时间序列图
- en: Disadvantages of a zoo object
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`zoo` 对象的缺点'
- en: An index in a `zoo` object cannot have `Date` classed variables, whereas the
    index of an `xts` object has to be a known and supported `time` or `Date` class.
    Also, in `zoo,` we cannot add arbitrary attributes which can be done in `xts`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`zoo` 对象中的索引不能具有 `Date` 类变量，而 `xts` 对象的索引必须是已知且受支持的 `time` 或 `Date` 类。此外，在
    `zoo` 中，不能添加任意属性，而在 `xts` 中可以添加。'
- en: xts
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: xts
- en: '`xts` is an extensible time series object which carries all the features of
    a `zoo` object. It consists of a matrix and index which has to be time-based.
    There are two ways of constructing `xts` objects: one is by calling `as.xts` and
    another is constructing the `xts` object from scratch.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`xts` 是一种可扩展的时间序列对象，包含了 `zoo` 对象的所有特性。它由一个矩阵和时间为基础的索引构成。构建 `xts` 对象有两种方式：一种是调用
    `as.xts`，另一种是从头开始构建 `xts` 对象。'
- en: Construction of an xts object using as.xts
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 as.xts 构造 xts 对象
- en: 'Let us read a few lines of our sample data through `zoo` and construct the
    `xts` object by executing the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 `zoo` 读取几行示例数据，并通过执行以下代码构建 `xts` 对象：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This gives the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '|  | `Volume` | `Adj.Close` | `Return` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|  | `Volume` | `Adj.Close` | `Return` |'
- en: '| 12/12/2016 | 615800 | 192.43 | 0.13 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 12/12/2016 | 615800 | 192.43 | 0.13 |'
- en: '| 12/13/2016 | 6816100 | 198.15 | 2.97 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 12/13/2016 | 6816100 | 198.15 | 2.97 |'
- en: '| 12/14/2016 | 4144600 | 198.69 | 0.27 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 12/14/2016 | 4144600 | 198.69 | 0.27 |'
- en: 'The composition of the `xts` object can be given by the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`xts` 对象的组成可以通过以下代码给出：'
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This generates the following output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: 'An `xts` object on 2016-12-12/2016-12-14 contains the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 2016-12-12/2016-12-14 的 `xts` 对象包含如下内容：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Constructing an xts object from scratch
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从头构建 xts 对象
- en: 'Let us first form a matrix and date sequence of same order and then convert
    it into an `xts` object. This can be done by executing the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先形成一个矩阵和日期序列，确保它们具有相同的顺序，然后将其转换为 `xts` 对象。可以通过执行以下代码完成此操作：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This gives the `xts` object, as displayed here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出 `xts` 对象，如下所示：
- en: '|  | `a` | `b` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|  | `a` | `b` |'
- en: '| 2/2/2016 | 5 | 7 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 2/2/2016 | 5 | 7 |'
- en: '| 3/2/2016 | 6 | 8 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 3/2/2016 | 6 | 8 |'
- en: The special aspects of an `xts` object is that it behaves like a matrix with
    time associated with each observation. The subsets will always preserve the matrix
    form and the attributes of the `xts` objects are always retained. Also, since
    `xts` is a subclass of `zoo`, it gets all the power of the `zoo` library.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`xts`对象的特殊之处在于，它表现得像一个矩阵，并且每个观测值都关联了一个时间。子集将始终保持矩阵形式，且`xts`对象的属性始终保留。而且，由于`xts`是`zoo`的子类，因此它具备`zoo`库的所有功能。'
- en: Linear filters
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性滤波器
- en: The first step in time series analysis is to decompose the time series in trend,
    seasonality, and so on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列分析的第一步是将时间序列分解为趋势、季节性等成分。
- en: One of the methods of extracting trend from the time series is linear filters.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从时间序列中提取趋势的一种方法是线性滤波器。
- en: One of the basic examples of linear filters is moving average with equal weights.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 线性滤波器的一个基本示例是具有相等权重的移动平均。
- en: Examples of linear filters are weekly average, monthly average, and so on.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 线性滤波器的示例包括每周平均、每月平均等。
- en: 'The function used for finding filters is given as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 用于查找滤波器的函数如下所示：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, `x` is the time series data and `filter` is the coefficients needed to
    be given to find the moving average.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`x`是时间序列数据，而`filter`是用于计算移动平均的系数。
- en: 'Now let us convert the `Adj.Close` of our `StockData` in time series and find
    the weekly and monthly moving average and plot it. This can be done by executing
    the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将`StockData`的`Adj.Close`转换为时间序列，并计算每周和每月的移动平均并绘制出来。这可以通过执行以下代码完成：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This generates the following plot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了以下的图表：
- en: '![Linear filters](img/00057.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![线性滤波器](img/00057.jpeg)'
- en: 'Figure 4.4: Example of moving average using linear filter'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：使用线性滤波器的移动平均示例
- en: AR
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AR
- en: 'AR stands for **autoregressive model**. Its basic concept is that future values
    depend on past values and they are estimated using a weighted average of the past
    values. The order of the AR model can be estimated by plotting the autocorrelation
    function and partial autocorrelation function of the series. In time series autocorrelation
    function measures correlation between series and it''s lagged values. Whereas
    partial autocorrelation function measures correlation of a time series with its
    own lagged values, controlling for the values of the time series at all shorter
    lags. So first let us plot the `acf` and `pcf` of the series. Let us first plot
    the `acf` plot by executing the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: AR 代表**自回归模型**。其基本概念是未来的值依赖于过去的值，并通过加权平均的方式估算过去的值。AR模型的阶数可以通过绘制时间序列的自相关函数和部分自相关函数来估算。时间序列的自相关函数衡量的是序列与其滞后值之间的相关性，而部分自相关函数则衡量的是时间序列与其滞后值之间的相关性，同时控制所有短期滞后值的影响。所以，首先让我们绘制序列的`acf`和`pcf`。我们先通过执行以下代码绘制`acf`图：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This generates the autocorrelation plot as displayed here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了如下所示的自相关图：
- en: '![AR](img/00058.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![AR](img/00058.jpeg)'
- en: 'Figure 4.5: acf plot of price'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：价格的acf图
- en: 'Now let us plot `pacf` by executing the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过执行以下代码绘制`pacf`：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This generates the partial autocorrelation plot as shown here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了部分自相关图，如下所示：
- en: '![AR](img/00059.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![AR](img/00059.jpeg)'
- en: 'Figure 4.6: pacf plot of price'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：价格的pacf图
- en: The preceding plots are autocorrelation and partial autocorrelation plots of
    the series considered. Now let us come to identify the order of AR. Since here
    there is no differencing and `acf` is decaying slowly, whereas `pacf` cuts off
    after one lag, so the order of AR is 1\. Similarly, if `pacf` cuts off after second
    lag and `acf` is decaying slowly, then the order of AR is 2.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图是所考虑序列的自相关和部分自相关图。现在让我们来确定AR的阶数。由于这里没有差分，并且`acf`衰减缓慢，而`pacf`在一个滞后后截断，因此AR的阶数是1。类似地，如果`pacf`在第二个滞后后截断，而`acf`衰减缓慢，则AR的阶数是2。
- en: MA
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MA
- en: 'MA stands for **moving average** and in MA modeling we do not take into account
    the past values of the actual series. We consider the moving average of the past
    few forecast errors in this process. For identifying the orders of MA, we also
    need to plot `acf` and `pacf`. So let us plot the `acf` and `pacf` of the volume
    of `StockData` to evaluate the order of MA. `acf` can be plotted by executing
    the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: MA 代表**移动平均**，在MA建模中，我们不考虑实际序列的过去值。我们考虑的是过去几期预测误差的移动平均。在确定MA的阶数时，我们也需要绘制`acf`和`pacf`。因此，让我们绘制`StockData`的成交量的`acf`和`pacf`，以评估MA的阶数。`acf`可以通过执行以下代码绘制：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This gives the following `acf` plot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了以下的`acf`图：
- en: '![MA](img/00060.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![MA](img/00060.jpeg)'
- en: 'Figure 4.7: acf plot of volume'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7：交易量的 acf 图
- en: 'Let us plot the `pacf` plot of volume by executing the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过执行以下代码绘制交易量的 `pacf` 图：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This gives the following plot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了以下图：
- en: '![MA](img/00061.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![MA](img/00061.jpeg)'
- en: 'Figure 4.8: pacf plot of volume'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8：交易量的 pacf 图
- en: After evaluating the preceding plots, the `acf` cuts sharply after `lag1` so
    the order of MA is 1.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估前述图后，`acf` 在 `lag1` 后急剧下降，因此 MA 的阶数为 1。
- en: ARIMA
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARIMA
- en: ARIMA stands for **autoregressive integrated moving average** models. Generally,
    it is defined by the equation **ARIMA**(*p*, *d*, *q*).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA 代表 **自回归积分滑动平均**模型。通常，它由方程 **ARIMA**(*p*, *d*, *q*) 定义。
- en: Here,
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，
- en: '*p* is the order of the autoregressive model'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*p* 是自回归模型的阶数'
- en: '*d* is the order required for making the series stationary'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*d* 是使序列平稳所需的阶数'
- en: '*q* is the order of moving average'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*q* 是移动平均模型的阶数'
- en: The very first step in ARIMA is to plot the series, as we need a stationary
    series for forecasting.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA 的第一步是绘制序列，因为我们需要一个平稳序列来进行预测。
- en: 'So let us first plot the graph of the series by executing the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们先通过执行以下代码绘制序列图：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This generates the following plot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了以下图：
- en: '![ARIMA](img/00062.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![ARIMA](img/00062.jpeg)'
- en: 'Figure 4.9: Plot of price data'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9：价格数据图
- en: 'Clearly, upon inspection, the series seems to be nonstationary, so we need
    to make it stationary by differencing. This can be done by executing the following
    code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，检查后，序列似乎是非平稳的，因此我们需要通过差分使其平稳。这可以通过执行以下代码完成：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This generates the following plot for the differenced series:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这为差分序列生成了以下图：
- en: '![ARIMA](img/00063.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![ARIMA](img/00063.jpeg)'
- en: 'Figure 4.10: Plot of differenced price data'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：差分价格数据图
- en: This is a stationary series, as the means and variance seem to be constant across
    time. Also, we can check the stationarity using the `Dickey-Fuller` test. Thus
    we have identified the value of *d* for our ARIMA model, which is 1\. Now let
    us plot the autocorrelation function and partial autocorrelation function of the
    differenced series for identifying the values of *p* and *q*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个平稳序列，因为其均值和方差似乎在时间上保持不变。此外，我们还可以通过 `Dickey-Fuller` 检验来检查序列的平稳性。因此，我们已经确定了我们
    ARIMA 模型中的 *d* 值，即 1。现在让我们绘制差分序列的自相关函数和偏自相关函数，以确定 *p* 和 *q* 的值。
- en: 'The `acf` plot is given by executing the following code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`acf` 图是通过执行以下代码生成的：'
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![ARIMA](img/00064.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![ARIMA](img/00064.jpeg)'
- en: 'Figure 4.11: acf plot of differenced series'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11：差分序列的 acf 图
- en: 'The `pacf` plot is given by executing the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`pacf` 图是通过执行以下代码生成的：'
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This generates the `pacf` plot for the differenced series:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这为差分序列生成了 `pacf` 图：
- en: '![ARIMA](img/00065.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![ARIMA](img/00065.jpeg)'
- en: 'Figure 4.12: pacf plot of differenced series'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12：差分序列的 pacf 图
- en: This clearly shows that the AR and MA order is 0 and 1 respectively and hence
    the best candidate model is ARIMA(0,1,1).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地表明 AR 和 MA 阶数分别为 0 和 1，因此最好的候选模型是 ARIMA(0,1,1)。
- en: 'Now let us estimate the coefficients of the identified ARIMA model, which can
    be done by executing the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们估计所识别的 ARIMA 模型的系数，可以通过执行以下代码来完成：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This generates coefficients of the identified ARIMA model as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了所识别 ARIMA 模型的系数，如下所示：
- en: '![ARIMA](img/00066.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![ARIMA](img/00066.jpeg)'
- en: 'Figure 4.13: Fitted summary of ARIMA (0,1,1)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13：ARIMA (0,1,1) 的拟合总结
- en: 'Now let us try to predict the forecast and plot it, which can be done by executing
    the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试预测并绘制预测结果，可以通过执行以下代码来完成：
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This generates the following output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了以下输出：
- en: '![ARIMA](img/00067.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![ARIMA](img/00067.jpeg)'
- en: 'Figure 4.14: The future forecast with confidence interval'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14：带置信区间的未来预测图
- en: 'Now plot the forecasted value along with the confidence interval by executing
    the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过执行以下代码绘制预测值及其置信区间：
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This generates the following plot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了以下图：
- en: '![ARIMA](img/00068.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![ARIMA](img/00068.jpeg)'
- en: 'Figure 4.15: Plot of forecasted value along with the confidence interval'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15：预测值及其置信区间图
- en: 'Model adequacy can be checked by executing the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过执行以下代码检查模型的适应性：
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This generates the following output:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了以下输出：
- en: '![ARIMA](img/00069.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![ARIMA](img/00069.jpeg)'
- en: 'Figure 4.16: Model adequacy check statistics for fitted model'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16：拟合模型的模型适应性检查统计量
- en: 'Since the Pvalue is greater than 0.05, there is no significant autocorrelation
    in the residuals at lags 1-20:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 P 值大于 0.05，因此在滞后 1-20 中残差没有显著的自相关：
- en: GARCH
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GARCH
- en: '**GARCH** stands for **generalized autoregressive conditional heteroscedasticity**.
    One of the assumptions in OLS estimation is that variance of error should be constant.
    However, in financial time series data, some periods are comparatively more volatile,
    which contributes to rise in strengths of the residuals, and also these spikes
    are not randomly placed due to the autocorrelation effect, also known as volatility
    clustering, that is, periods of high volatility tend to group together. This is
    where GARCH is used to forecast volatility measures, which can be used to forecast
    residuals in the model. We are not going to go into great depth but we will show
    how GARCH is executed in R.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**GARCH**代表**广义自回归条件异方差**。OLS估计中的一个假设是误差的方差应为常数。然而，在金融时间序列数据中，某些时期的波动性相对较高，这会导致残差的强度增加，而且这些波动并非随机出现，而是由于自相关效应（也称为波动聚类），即高波动时期往往会集中在一起。这正是GARCH用于预测波动率的地方，这些预测可以用于预测模型中的残差。我们不会深入讨论，但我们将展示如何在R中执行GARCH。'
- en: There are various packages available in R for GARCH modeling. We will be using
    the `rugarch` package.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中有各种包可用于GARCH建模，我们将使用`rugarch`包。
- en: 'Let us first install and load the `rugarch` package, which can be done by executing
    the following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先安装并加载`rugarch`包，可以通过执行以下代码来完成：
- en: '[PRE29]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now let us define the specs for the GARCH model and try to estimate the coefficients
    by running the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为GARCH模型定义规格，并通过运行以下代码来尝试估计系数：
- en: '[PRE30]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This gives the following output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下输出：
- en: '![GARCH](img/00070.jpeg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![GARCH](img/00070.jpeg)'
- en: 'Figure 4.17: Summary of coefficients estimate of GARCH'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17：GARCH系数估计摘要
- en: 'The main arguments for GARCH modeling are as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: GARCH建模的主要参数如下：
- en: '**Variance model**: List containing the variance model specifications, especially
    which GARCH model to use and what should be the orders of *p* and *q* in ARCH
    (*q*) and GARCH (*p*).'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方差模型**：包含方差模型规格的列表，特别是使用哪个GARCH模型以及ARCH（*q*）和GARCH（*p*）的阶数应是多少。'
- en: '**Mean model**: List containing the mean model specifications: arma order the
    autoregressive (AR) and moving average (MA) orders.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**均值模型**：包含均值模型规格的列表：arma阶数，即自回归（AR）和移动平均（MA）阶数。'
- en: '**Distribution model**: The conditional density to use for the innovations.
    Valid choices are `norm` for the normal distibution, `snorm` for the skew-normal
    distribution, `std` for the student `-t`, and so on.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布模型**：用于创新的条件密度。有效的选择包括`norm`（正态分布）、`snorm`（偏态正态分布）、`std`（学生t分布）等。'
- en: 'Now we can generate our forecast according to our requirement, which is given
    by the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以根据需求生成预测，以下是相关代码：
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![GARCH](img/00071.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![GARCH](img/00071.jpeg)'
- en: 'Figure 4.18: GARCH model forecast'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18：GARCH模型预测
- en: There are a lot of options in the GARCH model and we can use it according to
    our requirement.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: GARCH模型有许多选项，我们可以根据需求使用。
- en: EGARCH
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EGARCH
- en: EGARCH stands for exponential GARCH. EGARCH is an improved form of GARCH and
    models some of the market scenarios better.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: EGARCH代表指数GARCH。EGARCH是GARCH的一种改进形式，能够更好地模拟一些市场情景。
- en: For example, negative shocks (events, news, and so on) tend to impact volatility
    more than positive shocks.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，负面冲击（事件、新闻等）往往对波动率的影响大于正面冲击。
- en: This model differs from the traditional GARCH in structure due to the log of
    variance.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型与传统的GARCH模型在结构上有所不同，因为它采用了方差的对数。
- en: 'Let us take an example to show how to execute EGARCH in R. First define `spec`
    for EGARCH and estimate the coefficients, which can be done by executing the following
    code on the `snp` data:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来展示如何在R中执行EGARCH。首先为EGARCH定义`spec`并估计系数，可以通过在`snp`数据上执行以下代码来完成：
- en: '[PRE32]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This gives the coefficients as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下系数：
- en: '![EGARCH](img/00072.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![EGARCH](img/00072.jpeg)'
- en: 'Figure 4.19: Parameter estimates of EGARCH'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19：EGARCH的参数估计
- en: 'Now let us try to forecast, which can be done by executing the following code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试进行预测，可以通过执行以下代码来完成：
- en: '[PRE33]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This gives the following output:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下输出：
- en: '![EGARCH](img/00073.jpeg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![EGARCH](img/00073.jpeg)'
- en: 'Figure 4.20: Forecast prediction of EGARCH'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20：EGARCH预测结果
- en: VGARCH
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VGARCH
- en: VGARCH stands for vector GARCH or multivariate GARCH. In the financial domain,
    the assumption is that financial volatilities move together over time across assets
    and markets. Acknowledging this aspect through a multivariate modeling framework
    leads to a better model separate univariate model. It helps in making better decision
    tools in various areas, such as asset pricing, portfolio selection, option pricing,
    and hedging and risk management. There are multiple options in R for building
    in multivariate mode.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: VGARCH 代表向量 GARCH 或多元 GARCH。在金融领域，假设金融波动性随着时间的推移在不同的资产和市场之间共同波动。通过多元建模框架认识到这一点，有助于建立比单变量模型更好的模型。它有助于在多个领域做出更好的决策工具，如资产定价、投资组合选择、期权定价以及对冲和风险管理。R
    中有多种选项可以用来构建多元模式。
- en: 'Let us consider an example of multivariate GARCH in R for the last year of
    data from the `S&P500` and DJI index:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个 R 中多元 GARCH 的示例，使用 `S&P500` 和 DJI 指数的去年的数据：
- en: '[PRE34]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This gives the following output:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '![VGARCH](img/00074.jpeg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![VGARCH](img/00074.jpeg)'
- en: 'Figure 4.21: Future prediction of multivariate GARCH'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21：多元 GARCH 的未来预测
- en: Dynamic conditional correlation
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态条件相关性
- en: Multivariate GARCH models, which are linear in squares and cross products of
    the data, are generally used to estimate the correlations changing with time.
    Now this can be estimated using **dynamic conditional correlation** (**DCC**),
    which is a combination of a univariate GARCH model and parsimonious parametric
    models for the correlation. It has been observed that they perform well in a variety
    of situations. This method has the flexibility of univariate GARCH and does not
    have the complexity of multivariate GARCH.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 多元 GARCH 模型是线性的，涉及数据的平方和交叉积，通常用于估计随时间变化的相关性。现在可以使用**动态条件相关性**（**DCC**）来估计，这是一种将单变量
    GARCH 模型与用于相关性的简洁参数化模型结合的方法。已经观察到，在各种情境下它表现良好。这种方法具备单变量 GARCH 的灵活性，并且没有多元 GARCH
    的复杂性。
- en: Now let us see how to execute DCC in R.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在 R 中执行 DCC。
- en: 'First we need to install and load the packages `rmgarch` and `PerformanceAnalytics`.
    This can be done by executing the following code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装并加载 `rmgarch` 和 `PerformanceAnalytics` 包。可以通过执行以下代码来完成：
- en: '[PRE35]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now let us consider returns of the last year for the `S&P 500` and DJI indexes
    and try to get DCC for these returns.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑 `S&P 500` 和 DJI 指数的去年的回报，并尝试为这些回报计算 DCC。
- en: 'Now let us set the specification for DCC by executing the following code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过执行以下代码设置 DCC 的规范：
- en: '[PRE36]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now let us fit the model, which can be done by executing the following code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们拟合模型，可以通过执行以下代码来完成：
- en: '[PRE37]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This gives the following output:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '![Dynamic conditional correlation](img/00075.jpeg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![动态条件相关性](img/00075.jpeg)'
- en: 'Figure 4.22: Fitted summary of DCC'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.22：DCC 的拟合摘要
- en: Since the forecast has been already shown in the most topic, there is no point
    discussing it again here.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于预测已在之前的主题中展示，因此在此不再讨论。
- en: Questions
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Please give an example of converting a data series into a time series using
    the `ts()` function.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请给出一个使用 `ts()` 函数将数据序列转换为时间序列的示例。
- en: How are `zoo` and `xts` different from the `ts()` function? Give an example
    of constructing `xts` and `zoo` objects.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`zoo` 和 `xts` 与 `ts()` 函数有何不同？请给出构造 `xts` 和 `zoo` 对象的示例。'
- en: How do you read a file using `zoo`?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用 `zoo` 读取文件？
- en: How do you check stationarity in time series?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何检查时间序列的平稳性？
- en: How do you identify an AR(2) model in R?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 R 中识别 AR(2) 模型？
- en: How do you identify an MA(2) model in R?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 R 中识别 MA(2) 模型？
- en: Provide an example for the given below model and execute it in R.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个给定模型的示例并在 R 中执行。
- en: GARCH,
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GARCH，
- en: EGARCH,
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: EGARCH，
- en: VGARCH
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: VGARCH
- en: How do you identify an ARIMA(1,1,1) model in R?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 R 中识别 ARIMA(1,1,1) 模型？
- en: Provide an example for the given model and execute it in R.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个给定模型的示例并在 R 中执行。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have discussed how to decompose a time series into its various
    components, such as trend, seasonality, cyclicity, and residuals. Also, I have
    discussed how to convert any series into a time series in R and how to execute
    the various forecasting models, such as linear filters, AR, MA, ARMA, ARIMA, GARCH,
    EGARCH, VGARCH, and DCC, in R and make forecast predictions.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何将时间序列分解成其各个组件，如趋势、季节性、周期性和残差。此外，我还讨论了如何在 R 中将任何序列转换为时间序列，并如何执行各种预测模型，如线性滤波器、AR、MA、ARMA、ARIMA、GARCH、EGARCH、VGARCH
    和 DCC，并进行预测。
- en: In the next chapter, different concepts of trading using R will be discussed,
    starting with trend, followed by strategy, followed by pairs trading using three
    different methods. Capital asset pricing, the multi factor model, and portfolio
    construction will also be discussed. Machine learning technologies for building
    trading strategy will also be discussed.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，将讨论使用 R 进行交易的不同概念，首先是趋势，其次是策略，再其次是使用三种不同方法的配对交易。还将讨论资本资产定价、多因子模型和投资组合构建。还将讨论用于构建交易策略的机器学习技术。
