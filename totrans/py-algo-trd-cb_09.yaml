- en: Algorithmic Trading - Backtesting
  prefs: []
  type: TYPE_NORMAL
- en: After building algorithmic trading strategies, as we did in the previous chapter,
    the first step is to backtest them over a given duration of time for a given strategy
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Backtesting is a method of evaluating the performance of a trading strategy
    by virtually executing it over past data and analyzing its risk and return metrics.
    Real money is not used here. Typical backtesting metrics include **Profit and
    Loss** (**P&L**), maximum drawdown, count of total trades, winning trades, losing
    trades, long trades and short trades, average profit per winning and losing trade,
    and more. Until these metrics meet the necessary requirements, the entire process
    should be repeated with incremental changes being made to strategy parameters
    and/or strategy implementation.
  prefs: []
  type: TYPE_NORMAL
- en: If a strategy performs well on past data, it is likely to perform well on live
    data also. Similarly, if a strategy is performing poorly on past data, it is likely
    to perform poorly on live data. This is the underlying premise of backtesting.
    You can keep changing the strategy configuration or implementation until the backtesting
    yields results as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Backtesting also helps validate the strategy behavior before we use the strategy
    for real money. This means it helps to ensure that the strategy behaves as expected
    for various marketing scenarios from the past.
  prefs: []
  type: TYPE_NORMAL
- en: 'For backtesting, a strategy configuration is required. It consists of multiple
    parameters, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start and end timestamps**: The time duration for which backtesting should
    be run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Financial instrument(s)**: One or more financial instruments for which backtesting
    should be performed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Candle interval**: One of many possible candle intervals; for example, 1
    minute, 15 minutes, 1 hour, or 1 day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategy-specific parameters**: Values for custom parameters defined in the
    strategy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategy mode**: One of intraday or delivery. Intraday strategies punch intraday
    orders, which are squared off at the end of the day. Delivery strategies punch
    delivery orders. These don''t square off at the end of the day and get carried
    forward to the next trading day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A backtesting engine is required to perform backtesting on a given strategy.
    In this chapter, you will use the backtesting engine provided by AlgoBulls ([https://algobulls.com](https://algobulls.com)),
    an algorithmic trading platform that makes its services available via its developer
    options. It provides a Python package called `pyalgotrading` ([https://github.com/algobulls/pyalgotrading](https://github.com/algobulls/pyalgotrading))
    to make these services available.
  prefs: []
  type: TYPE_NORMAL
- en: 'You coded two algorithmic trading strategies in [Chapter 8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml),
    *Algorithmic Trading Strategies – Coding Step by Step*. Recall that the strategy
    descriptions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EMA-Regular-Order strategy**: This strategy is based on the technical indicator
    EMA and regular orders. (The first six recipes of [Chapter 8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml),
    *Algorithmic Trading Strategies – Coding Step by Step*.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MACD-Bracket-Order strategy**: This strategy is based on the technical indicator
    MACD and bracket orders. (The remaining six recipes of [Chapter 8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml),
    *Algorithmic Trading Strategies – Coding Step by Step*.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These strategies are also available as part of a Python package called `pyalgostrategypool`.
    You can install it using pip using the `$ pip install pyalgostrategypool` command.
    You can also check them out on GitHub ([https://github.com/algobulls/pyalgostrategypool](https://github.com/algobulls/pyalgostrategypool)).
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, you uploaded these two strategies to your AlgoBulls
    account. In this chapter, you will fetch these strategies from your AlgoBulls
    account and perform backtesting on them. After backtesting, you will gather the
    strategy execution logs and various reports, namely, the P&L report, the statistics
    report, and the order history. These logs and reports help validate the strategy's
    performance and prepare it for the next level, which is paper trading, before
    we finally go and do real trading. By using `pyalgotrading`, you ensure that you
    focus on developing and validating the strategy via backtesting, without worrying
    about the ecosystem needed for the strategy execution.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter includes step-by-step recipes for the aforementioned strategies,
    from setting up connections with the AlgoBulls platform, fetching the strategy,
    and running backtesting jobs, to fetching the execution logs and various types
    of reports.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: EMA-Regular-Order strategy – fetching the strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EMA-Regular-Order strategy – backtesting the strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EMA-Regular-Order strategy – fetching backtesting logs in real time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EMA-Regular-Order strategy – fetching a backtesting report – P&L table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EMA-Regular-Order strategy – fetching a backtesting report – statistics table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EMA-Regular-Order strategy – fetching a backtesting report – order history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MACD-Bracket-Order strategy – fetching the strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MACD-Bracket-Order strategy – backtesting the strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MACD-Bracket-Order strategy – fetching backtesting logs in real time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MACD-Bracket-Order strategy – fetching a backtesting report – P&L table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MACD-Bracket-Order strategy – fetching a backtesting report – statistics table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MACD-Bracket-Order strategy – fetching a backtesting report – order history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following to successfully execute the recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.7+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python packages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pyalgotrading` (`$ pip install pyalgotrading`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latest Jupyter notebook for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Python-Algorithmic-Trading-Cookbook/tree/master/Chapter09](https://github.com/PacktPublishing/Python-Algorithmic-Trading-Cookbook/tree/master/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: EMA-Regular-Order strategy – fetching the strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will fetch the `StrategyEMARegularOrder` strategy class
    from your account on the AlgoBulls platform, which you uploaded while going through
    the *EMA-Regular-Order strategy – uploading the strategy* recipe in [Chapter 8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml), *Algorithmic
    Trading Strategies – Coding Step by Step*, on the AlgoBulls trading platform.
    This recipe starts with setting up a connection to the AlgoBulls platform, querying
    all available strategies in your account, and fetching the details of the required
    strategy class, `StrategyEMARegularOrder`.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have gone through the first six recipes of the previous chapter
    to get a complete picture of the strategy class we will be using; that is, `StrategyEMARegularOrder`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We execute the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new AlgoBulls connection object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Fetch the authorization URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We got the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Log into the preceding link with your AlgoBulls credentials, fetch your token,
    and set it here (refer to *Appendix II* for more details):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Fetch and display all the strategies you have created and uploaded so far:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We got the following output. Your output may differ (make sure you have followed
    the recipes from [Chapter 8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml), *Algorithmic
    Trading Strategies **– Coding Step by Step*, to get a similar output):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fe744d8-77bd-445d-b79d-288a8259ec5c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fetch and display the strategy code of the first strategy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We got the following output (your output may differ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Before backtesting your strategy, you can inspect your strategy to ensure you
    have the right strategy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We got the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The complete output is not shown here. Please visit the following link to read
    the complete output: [https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_ema_regular_order.py](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_ema_regular_order.py).
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, you import the necessary modules. In *step 2*, an instance of the
    `AlgoBullsConnection` class is created, named `algobulls_connection`. In *step
    3*, you get the authorization URL using the `get_authorization_url()` method of
    the `algobulls_connection` object. This prints the authorization URL. You should
    visit this URL from your web browser to sign into the AlgoBulls platform and fetch
    your developer access token. (You can find more details, along with screenshots,
    in *Appendix II* in regard to fetching developer access tokens from the AlgoBulls
    platform.) You copy the access token and set it in *step 4* using the `set_access_token()`
    method of `algobulls_connection`. If the token is accepted, a successful connection
    is set up with the AlgoBulls platform.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, you fetch all the strategies you have created and uploaded to the
    AlgoBulls platform so far. You use the `get_all_strategies()` method for this
    step and assign it to a new variable, `all_strategies`. This variable is a `pandas.DataFrame`
    object that has `strategyCode` and `strategyName` columns. This table holds information
    on the strategy codes and the strategy names you uploaded previously. If you followed
    the E*MA-Regular-Order strategy – uploading the strategy on AlgoBulls trading
    platform* recipe from [Chapter 8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml),
    *Algorithmic Trading Strategies – Coding Step by Step*, you will find a strategy
    called **EMA-Regular-Order strategy**. In *step 6*, you assign the strategy code
    of the strategy, **EMA-Regular-Order strategy**, to a new variable called `strategy_code1`.
    The strategy code is shown in the output of this step. This strategy code is unique
    for every strategy on the AlgoBulls platform.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in *step 7*, you ensure that the strategy being referred to by `strategy_code1`
    is indeed the one you uploaded earlier (in the *EMA-Regular-Order strategy – uploading
    the strategy on AlgoBulls trading platform* recipe of [Chapter 8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml), *Algorithmic
    Trading Strategies – Coding Step by Step*). You use the `get_strategy_details()`
    method of the `algobulls_connection` object to inspect the strategy. This method
    takes the strategy code as an argument. You pass `strategy_code1` here. This method
    returns the entire class code as a string. You assign it to a new variable, `strategy_details1`,
    and display it.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to change the class code being referred to by `strategy_code1`,
    as shown in *step 7*, please refer to the *There's more…* section of the *EMA-Regular-Order
    strategy – uploading the strategy on AlgoBulls trading platform* recipe, in [Chapter
    8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml), *Algorithmic Trading Strategies –
    Coding Step by Step*.
  prefs: []
  type: TYPE_NORMAL
- en: EMA-Regular-Order strategy – backtesting the strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will perform backtesting on the **EMA-Regular-Order strategy**.
    You must have fetched this strategy from your account in the AlgoBulls platform
    in the preceding recipe. You will leverage the backtesting functionality facilitated
    by `pyalgotrading` for this recipe, which, in turn, submits a backtesting job
    on the AlgoBulls platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once submitted, backtesting will be run by the AlgoBulls backtesting engine.
    You can query the status anytime to find the state of the backtesting job. The
    job goes through the following states, in the given order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`STARTING` (intermediate state)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STARTED` (stable state)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STOPPING` (intermediate state)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STOPPED` (stable state)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On submitting a job, it starts with an intermediate state, `STARTING`. In this
    state, the AlgoBulls backtesting engine fetches the strategy and get the execution
    environment ready, which may take a couple of minutes. Once done, the job moves
    to the `STARTED` state. Strategy backtesting happens in this stage. Here, it stays
    as long as it takes for backtesting to complete. Once done, the job moves to an
    intermediate state, `STOPPING`. In this state, the AlgoBulls backtesting engine
    cleans up the resources that have been allocated to this job, which usually takes
    less than a minute. Finally, the job moves to the `STOPPED` state.
  prefs: []
  type: TYPE_NORMAL
- en: If you have already submitted a strategy backtesting job, you cannot submit
    another job for the same strategy until the first job completes. This means you
    have to wait for the first job to move to the `STOPPED` state. If the first job
    is long-running and you would like to stop it immediately, you can submit a stop
    job request via `pyalgotrading`. You need to ensure the job is in the `STARTED` state
    before submitting the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following state machine diagram demonstrates the various states and transitions
    of a backtesting job during its lifetime on the AlgoBulls platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d95a8413-5cde-4d44-89d7-81da5c752fe0.png)'
  prefs: []
  type: TYPE_IMG
- en: After submitting a backtesting job, you can fetch logs and reports for the strategy
    execution, in real time. The logs and reports help validate the strategy's performance
    and debug any potential issues.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have gone through the first six recipes of the previous chapter to
    get a complete picture of the strategy class we will be using; that is, `StrategyEMARegularORder`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the `algobulls_connection` and `strategy_code1` objects are available
    in your Python namespace. Refer to the previous recipe to set up the `algobulls_connection`
    and `strategy_code1` objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We execute the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Search for an instrument by using its trading symbol as a keyword. Assign the
    returned object to `instruments`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output (your output may differ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Get `value` for the instrument of choice from `instruments`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Submit a backtesting job for `strategy_code1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status of the submitted job backtesting job:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After some time, check the status of the submitted job once more:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, you import the `datetime` class from the `datetime` module and
    all the constants from the `pyalgotrading.constants` module. In *step 2*, you
    fetch the instrument that would like to backtest the strategy for, **EMA-Regular-Order
    strategy**, using the `search_instrument()` method of the `algobulls_connection`
    object. The `search_instrument()` method accepts a search string as an argument,
    which should be the trading symbol, in part or complete, of the instrument you
    are interested in. You pass `'SBIN'` here. This function returns a list with details
    of instruments that match the search string. There could be multiple instruments
    that could have the search string in their trading symbols. In *step 3*, you fetch
    the value of the first matched instrument and assign it to a new variable, `instrument`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 4*, you submit a backtesting job using the `backtest()` method of
    the `algobulls_connection()` object. It takes the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`strategy_code`: Strategy code of the strategy for which backtesting has to
    be performed. This should be a string. You pass `strategy_code1` here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start_timestamp`: Timestamp of the past from which backtesting should be started.
    This should be a `datetime.datetime` object. Here, you pass an object holding
    the value 1st July 2020 9:15 hours – `dt(year=2020, month=7, day=1, hour=9, minute=15)`.
    Refer to the *Creating datetime objects* recipe in [Chapter 1](efb7347f-05e4-4856-9ede-88bdcf393efa.xhtml), *Handling
    and Manipulating Date, Time, and Time Series Data*, for details on creating a
    `datetime` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end_timestamp`: The timestamp of the past when backtesting should be performed.
    This object should hold a timestamp value ahead of the timestamp value held by
    `start_timestamp`. This should be a `datetime.datetime` instance. Here, you pass
    an object holding the value 7th July 2020 15:30 hours – `dt(year=2020, month=7,
    day=7, hour=15, minute=30)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`instrument`: Financial instrument for which backtesting should be run. Historical
    data would be fetched for this instrument. This should be a string. You pass `instrument`
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lots`: Number of lots for which backtesting should be performed. This should
    be an integer. The quantity is calculated by the strategy as *number of lots*
    ×* lot size of the financial instrument*. (See the *EMA-Regular-Order strategy
    – coding the strategy_enter_position method* recipe in the previous chapter).
    You pass `1` here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strategy_parameters`: Parameter names and values expected by the strategy.
    This should be a dictionary, with `parameter-name` and `parameter-value` as key-value
    pairs. You pass the following parameters here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeperiod1: 5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeperiod2: 12 `'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Recall that the parameters for the EMA-Regular-Order strategy were defined
    in its `__init__()` method, as shown in the first recipe of the previous chapter).
  prefs: []
  type: TYPE_NORMAL
- en: '`candle_interval`: The candle interval for the historical data fetched for
    backtesting. This should be an enum of the `CandleInterval` type. You pass `CandleInterval.MINUTES_15`
    here. (The `CandleInterval` enum provides various enums for candle intervals,
    some of which are `MINUTE_1`, `MINUTES_3` , `MINUTES_5`, `MINUTES_10`, `MINUTES_15`,
    `MINUTES_30`, `HOUR`, and `DAY`.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the job submission is successful, you will see `Success` message printed
    by the `backtest()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Once a job is submitted, it takes a while to start. After starting, it may take
    some time to finish, depending on the complexity of the strategy and the duration
    of backtesting specified using the `start_timestamp` and `end_timestamp` arguments.
    A few days of backtesting may finish in seconds, while a few months of backtesting
    may take minutes.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, you fetch the job status using the `get_backtesting_job_status()`
    method of the `algobulls_connection` object. You pass `strategy_code1` as the
    argument here. This method returns a dictionary with a single key-value pair –
    the *data* and the *job* status. If you query the status immediately after placing
    the job, you get `'STARTING'` as the status. In *step 6*, you query the status
    again after some time, and if the job has started, you get  `'STARTED'` as the
    status.
  prefs: []
  type: TYPE_NORMAL
- en: A successful submission implies that the minimum inputs needed to backtest a
    strategy have been passed in the required format. However, this does not ensure
    that the strategy will run without errors. The strategy's execution may still
    run into errors during backtesting. To debug execution issues, you would need
    to fetch the output logs, which is explained in the *MACD-Bracket-Order strategy
    – fetching backtesting logs in real time* recipe. Possible reasons for errors
    could be either bugs in the strategy class Python code or an incomplete `strategy_parameters`
    dictionary being passed to the `backtest()` function.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a job is running for a long time and you would like to stop it before its
    completion, you can use the `stop_backtesting_job()` method of the `algobulls_connection`
    object. This method accepts strategy code as an argument. You pass `strategy_code1`
    here. This method submits a stop request to the AlgoBulls backtesting engine.
    If the request is accepted, you will see a `Success` message here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you query the status after submitting the stop request, you''ll get the
    status as `''STOPPING``:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you query the status again after some time, and if the job has stopped,
    you''ll get the status as `''STOPPED''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: EMA-Regular-Order strategy – fetching backtesting logs in real time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After submitting a backtesting job on the AlgoBulls platform, the AlgoBulls
    backtesting engine starts executing the strategy. During the execution, every
    event that occurs and every decision taken by the AlgoBulls backtesting engine
    are recorded with exact timestamps in the form of textual logs. Examples of recorded
    activities include the given strategy config, every new candle generated at regular
    intervals, trades punched by your strategy, the entry and exit of positions created
    by these trades, waits for new candles, and so on. These logs are quintessential
    in validating the strategy behavior and debugging behavior or performance issues
    that are frequently encountered while developing a strategy.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will fetch the backtesting logs for your strategy. The logs
    start coming up as soon as your submitted backtesting job reaches the `'STARTED'`
    state (refer to the previous recipe for more information on the states of a backtesting
    job). The AlgoBulls platform allows you to fetch logs in real time, even while
    the backtesting job is still going on. You can get insights into the strategy's
    execution without having to wait for the backtesting job to complete, which is
    helpful when jobs are long-running. The `pyalgotrading` package provides a simple
    method that can be used to fetch the execution logs for a given strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have gone through the first six recipes of the previous chapter to
    get a complete picture of the strategy class we will be using; that is, `StrategyEMARegularOrder`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the `algobulls_connection` and `strategy_code1` objects are available
    in your Python namespace. Refer to the first recipe of this chapter to set up
    the `algobulls_connection` and `strategy_code1` objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We execute the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fetch the backtesting execution logs for `strategy_code1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output (your output may differ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Fetch the backtesting execution logs for `strategy_code1` again after some
    time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output (your output may differ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete output is not shown here. Please visit the following link to read
    the complete output: [https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_ema_regular_order/logs.txt](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_ema_regular_order/logs.txt).'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, you use the `get_backtesting_logs()` method of the `algobulls_connection`
    object to fetch the strategy backtesting logs in real time. This method accepts
    the strategy code as an argument. You pass `strategy_code1` here. The return data
    is a string. If you try this step immediately after submitting the job, you get
    a string, which says the logs are not ready yet (`[2020-07-30 17:27:25] Logs not
    available yet. Please retry in sometime.`). This happens if the backtesting job
    is in the `'STARTING'` state.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, you fetch the logs again after some time. If the job is out of
    the `'STARTING'` state, you start getting your strategy execution logs. You get
    the entire backtesting logs every time you call the `get_backtesting_logs()` function.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the backtesting job moves to the `'STOPPED'` state, no new logs are generated.
    You can fetch the complete logs any time before you submit the next backtesting
    job for the same strategy. If a new backtesting job is submitted (for the same
    strategy), these logs will no longer be accessible via the `get_backtesting_logs()`
    method. You can save the fetched logs to a file if you'd like to refer to it at
    a later date.
  prefs: []
  type: TYPE_NORMAL
- en: EMA-Regular-Order strategy – fetching a backtesting report – profit and loss
    table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After submitting a backtesting job on the AlgoBulls platform, the AlgoBulls
    backtesting engine starts executing the strategy. During its execution, along
    with the logs, the AlgoBulls backtesting engine also generates a P&L table in
    real time. This table holds information on every trade that's been punched by
    the strategy. It also contains details on the mappings between entry and exit
    orders, the trade P&L, and the cumulative P&L, sorted chronologically, with the
    latest order first. This table gives us an insight into the overall strategy's
    performance with the help of individual and cumulative P&L numbers. The entry-exit
    order mapping also helps validate the strategy behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will fetch the P&L table report for your strategy. This
    report is available as soon as the first trade is punched in by your strategy
    after you submit a backtesting job. The AlgoBulls platform allows you to fetch
    the P&L table in real time, even while the backtesting job is still going on.
    You can get insights into the strategy performance without having to wait for
    the backtesting job to complete, which is helpful when jobs are long-running.
    The `pyalgotrading` package provides a simple method that's used to fetch the
    P&L table for a given strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have gone through the first six recipes of the previous chapter to
    get a complete picture of the strategy class we will be using; that is, `StrategyEMARegularOrder`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the `algobulls_connection` and `strategy_code1` objects are available
    in your Python namespace. Refer to the first recipe of this chapter to set up
    the `algobulls_connection` and `strategy_code1` objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fetch the backtesting P&L report for `strategy_code1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We got the following output. Your output may differ (note that the following
    output has been split into multiple tables for representation purposes. You will
    see a single wide table in your Jupyter Notebook):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7ac60ab-88ea-4692-b0b8-1cc75e334a0e.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, you use the `get_backtesting_report_pnl_table()` method of
    the `algobulls_connection` object to fetch the backtesting P&L table in real time.
    This method accepts strategy code as an argument. You pass `strategy_code1` here.
    The return data is a `pandas.DataFrame` object with multiple columns, described
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`instrument`: Financial instrument for which the trade was entered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entry_timestamp`: The timestamp at which the entry order was placed. (Note
    that it may remain in the `''OPEN''` state for a while before it goes to the `''COMPLETE''`
    state. The time for this state transition can be found using the order history
    table, as explained in the sixth recipe of this chapter.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entry_transaction_type`: Entry order transaction type (either `BUY` or `SELL`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entry_quantity`: Entry order quantity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entry_price`: The price at which the entry order gets executed and goes to
    the `''COMPLETE''` state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exit_timestamp`: The timestamp at which the exit order was placed. (Note that
    it may remain in the `''OPEN''` state for a while before it goes to the `''COMPLETE''`
    state.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exit_transaction_type`: Exit order transaction type (either `BUY` or `SELL`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exit_quantity`: Exit order quantity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exit_price`: The price at which the exit order gets executed and goes to the `''COMPLETE''`
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pnl_absolute`: Difference between the exit order execution price and the entry
    order execution price. Mathematically, this is (*exit_price* - *entry_price*)**exit_quantity*
    for a long trade and (*entry_price* - *exit_price*)**exit_quantity* for a short
    trade. A positive value would imply that the trade is a profit-making trade. A
    negative value would imply that the trade is a loss-making trade.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pnl_percentage`: The percentage of profit or loss with respect to the entry
    price. Mathematically, this is *pnl_absolute* / *entry_price* / *exit_quantity*
    × *100*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pnl_cumulative_absolute`: Cumulative profit or loss. Mathematically, this
    is the sum of all the `pnl_absolute` values of the previous trades. This number
    gives us direct insight into the strategy performance against the simulation time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pnl_cumulative_percentage`: The percentage of cumulative profit or loss with
    respect to the entry price. Mathematically, this is *pnl_cumulative* / *entry_price* /
    *exit quantity* × *100*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the backtesting job moves to the `'STOPPED'` state, the P&L table report
    will not update anymore. You can fetch the complete P&L report any time before
    you submit the next backtesting job for the same strategy. If a new backtesting
    job is submitted (for the same strategy), this report will no longer be accessible
    via the `get_backtesting_report_pnl_table()` method. You can save the fetched
    report as a `.csv` file if you'd like to refer to it at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: EMA-Regular-Order strategy — fetching a backtesting report – statistics table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After submitting a backtesting job on the AlgoBulls platform, the AlgoBulls
    backtesting engine starts executing the strategy. During its execution, along
    with the logs and P&L table, the AlgoBulls backtesting engine also generates a
    summary from the P&L table in real time. This summary is a table of statistics
    containing various statistical numbers such as `Net P&L` (absolute and percentage),
    `Max Drawdown` (absolute and percentage), count of total trades, winning trades,
    losing trades, long trades and short trades, maximum gain and minimum gain (or
    maximum loss), and average profit per winning and losing trade. This table gives
    an instant overview of the overall strategy's performance.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will fetch the statistics table report for your strategy.
    This report is available as soon as the first trade is punched in by your strategy
    after you submit a backtesting job. The AlgoBulls platform allows you to fetch
    the statistics table in real time, even while the backtesting job is still going
    on. You can get insights into the strategy performance without having to wait
    for the backtesting job to complete, which is helpful when jobs are long-running.
    The `pyalgotrading` package provides a simple method that's used to fetch the
    statistics table for a given strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have gone through the first six recipes of the previous chapter
    to get a complete picture of the strategy class we will be using; that is, `StrategyEMARegularOrder`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the `algobulls_connection` and `strategy_code1` objects are available
    in your Python namespace. Refer to the first recipe of this chapter to set up
    the `algobulls_connection` and `strategy_code1` objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fetch the backtesting statistics report for `strategy_code1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We got the following output (your output may differ):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1aeeb6bb-6b75-4caa-91cb-bad95e57b3b7.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, you use the `get_backtesting_report_statistics()` method of
    the `algobulls_connection` object to fetch the backtesting statistics table in
    real time. This method accepts the strategy code as an argument. You pass `strategy_code1`
    here. The return data is a `pandas.DataFrame` object with two columns – `highlight_type`
    and `highlight_value` – and multiple rows. The rows are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Net PnL`: The cumulative backtesting P&L. This is also the `pnl_cumulative_absolute`
    value of the first entry in the P&L table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Net PnL %`: The cumulative backtesting P&L percentage. This is also the `pnl_cumulative_percentage`
    value of the first entry in the P&L table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Max Drawdown`: The lowest value in the `pnl_cumulative` column of the P&L
    table. This indicates the maximum loss your strategy has encountered during the
    execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Max Drawdown %`: Mathematically, this is *(Max Drawdown)* / *(corresponding
    entry_price) / exit_quantity *× *100*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number of Trades`: Total trades (entry and exit counted as one) during the
    session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number of Wins`: Count of trades where the trade P&L was non-negative.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number of Losses`: Count of trades where the trade P&L was negative.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number of Long Trades`: Count of trades where the entry transaction type was
    `''BUY''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number of Short Trades`: Count of trades where the entry transaction type
    was `''SELL''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Max Gain`: P&L of the trade with the maximum P&L value among all trades.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Min Gain`: P&L of the trade with the minimum P&L value among all trades.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Avg. Profit per winning trade`: Mathematically, this is *(Total P&L of winning
    trades)* / *(Count of winning trades)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Avg. Profit per losing trade`: Mathematically, this is *(Total P&L of losing
    trades)* / *(Count of losing trades)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the statistics table is fetched while the backtesting job is still running,
    the aforementioned numbers would be intermediate numbers, based on the trades
    completed up until that time. The numbers may change as more trades are punched
    in, until the backtesting job completes.
  prefs: []
  type: TYPE_NORMAL
- en: Once the backtesting job moves to the `'STOPPED'` state, the statistics table
    will not change anymore. You can fetch the complete statistics table any time
    before you submit the next backtesting job for the same strategy. If a new backtesting
    job is submitted (for the same strategy), this table will no longer be accessible
    via the `get_backtesting_report_statistics()` method. You can save the fetched
    report table to a `.csv` file if you'd like to refer to it at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: EMA-Regular-Order strategy – fetching a backtesting report – order history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After submitting a backtesting job on the AlgoBulls platform, the AlgoBulls
    backtesting engine starts executing the strategy. During its execution, along
    with the logs, the P&L table and the statistics table of the AlgoBulls backtesting
    engine generate an order history log in real time. This log contains state transitions
    of every order, along with the timestamps and additional information (if any)
    for each order state. The order history log is crucial for understanding how long
    it has taken for a trade to go from an `'OPEN'` state to `'COMPLETE'` or `'CANCELLED'`.
    For example, the `MARKET` orders would immediately go from `'OPEN'` to `'COMPLETE'` but
    the `LIMIT` orders may take a while, based on the market conditions, to go from
    `'OPEN'` to `'COMPLETE'` – they may even get to `'CANCELLED'`. All this information
    is available in the order history log. (Refer to the state machine diagrams in
    [Chapter 6](077b54a1-c9c4-424c-912a-11f28db3797f.xhtml), *Placing Regular Orders
    on the Exchange*, for more information on order state transitions.)
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will fetch the order history log for your strategy. This
    log is available as soon as the first trade is punched in by your strategy, after
    you submit a backtesting job. The AlgoBulls platform allows you to fetch the order
    history log in real time, even while the backtesting job is still going on. This
    helps us get details for orders in their end states, without having to wait for
    the backtesting job to complete. The `pyalgotrading` package provides a simple
    method we can use to fetch the order history log for a given strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have gone through the first six recipes of the previous chapter
    to get a complete picture of the strategy class we will be using; that is, `StrategyEMARegularOrder`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the `algobulls_connection` and `strategy_code1` objects are available
    in your Python namespace. Refer to the first recipe of this chapter to set up
    the `algobulls_connection` and `strategy_code1` objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fetch the backtesting order history report for `strategy_code1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We got the following output (your output may differ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete output is not shown here. Please visit this link to read the complete
    output: [https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_ema_regular_order/oms_order_history.log](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_ema_regular_order/oms_order_history.log).'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, you use the `get_backtesting_report_order_history()` method
    of the `algobulls_connection` object to fetch order history logs in real time.
    This method accepts strategy code as an argument. You pass `strategy_code1` here.
    The return data is a string, described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For every order, the log contains the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A descriptive table of the order, with the following mentioned columns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INST`: Financial instrument of the order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIME`: Time at which the order was placed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ID`: The unique ID of the order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TT`: The order transaction type (`BUY` or `SELL`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of this table is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This information will help you find this exact order in the strategy execution
    log.
  prefs: []
  type: TYPE_NORMAL
- en: 'An order state transition table, with the following columns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIME`: Timestamp at which the order enters the state represented by the `''STATE''`
    column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STATE`: The order enters this `''STATE''` at the timestamp mentioned in the
    `''TIME''` column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MSG`: An additional message from the **Order Management System** (**OMS**)
    for any unexpected state transitions. For example, orders that go to the `REJECTED`
    state have a message from the OMS stating the reason for their rejection. This
    column is usually empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of this table is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: From this table, you can see that, upon placing the order at 9:45 a.m., it transitions
    to the `'COMPLETE'` state immediately. This is expected as the order is a regular
    market order.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the backtesting job moves to the `'STOPPED'` state, no new order history
    logs are generated. You can fetch the complete order history logs any time before
    you submit the next backtesting job for the same strategy. If a new backtesting
    job is submitted (for the same strategy), these logs will no longer be accessible
    via the `get_backtesting_report_order_history()` method. You can save the fetched
    logs to a file if you'd like to refer to them at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: MACD-Bracket-Order strategy – fetching the strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will fetch the `StrategyMACDBracketOrder` strategy class
    from your account on the AlgoBulls platform, which you uploaded while going through
    the last recipe in the previous chapter. This recipe starts with setting up a
    connection to the AlgoBulls platform, querying all available strategies in your
    account, and fetching details of the required strategy class, `StrategyMACDBracketOrder`.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have gone through the last six recipes of the previous chapter
    to get a complete picture of the strategy class we will be using; that is, `StrategyMACDBracketOrder`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We execute the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new AlgoBulls connection object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Fetch the authorization URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Log into the preceding link with your AlgoBulls credentials, fetch your token,
    and set it here (refer to *Appendix II* for more details):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Fetch and display all the strategies you have created and uploaded so far:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output may differ (make sure you have followed
    the recipes in the previous chapter to get a similar output):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4744cb5-ad14-4fc5-98d1-ead69ecca5b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fetch and display the strategy code of the second strategy, **MACD-Bracket-Order
    strategy**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output (your output may differ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Before backtesting your strategy, you can inspect your strategy to ensure you
    have the right strategy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The complete output is not shown here. Please visit the following link to read
    the complete output: [https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_macd_bracket_order.py](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_macd_bracket_order.py).
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You import the necessary modules in *step 1*. In *step 2*, you create an instance
    of the `AlgoBullsConnection` class, named `algobulls_connection`. In *step 3*,
    you get the authorization URL using the `get_authorization_url()` method of the
    `algobulls_connection` object. This prints the authorization URL. You should visit
    this URL from your web browser to sign into the AlgoBulls platform and fetch your
    developer access token. (You can find more details, along with screenshots, in
    *Appendix II* on fetching developer access token from the AlgoBulls platform.)
    You copy the access token and set it in *step 4* using the `set_access_token()`
    method of `algobulls_connection`. If the token is accepted, a successful connection
    is set up with the AlgoBulls platform.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, you fetch all the strategies you have created and uploaded on the
    AlgoBulls platform so far. You use the `get_all_strategies()` method for this
    step and assign it to a new variable, `all_strategies`. This variable is a `pandas.DataFrame`
    object with `strategyCode` and `strategyName` columns. This table holds information
    about the strategy codes and the strategy names you have uploaded previously.
    If you followed the *MACD-Bracket-Order strategy – uploading the strategy on AlgoBulls
    Trading Platform* recipe from [Chapter 8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml),
    *Algorithmic Trading Strategies – Coding Step by Step*, you will find a strategy
    called **MACD-Regular-Order strategy**. In *step 6*, you assign the strategy code
    of the strategy, **MACD-Regular-Order strategy**, to a new variable called `strategy_code2`.
    The strategy code is shown in the output of this step. This strategy code is unique
    to every strategy on the AlgoBulls platform.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in *step 7*, you ensure that the strategy being referred to by `strategy_code2`
    is indeed the one you uploaded earlier (in the last recipe of the previous chapter).
    You use the `get_strategy_details()` method of the `algobulls_connection` object
    to inspect the strategy. This method takes strategy code as an argument. You pass
    `strategy_code2` here. This method returns the entire class code as a string.
    You assign it to a new variable, `strategy_details2`, and display it.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to change the class code being referred to by `strategy_code2`,
    as shown in *step 7*, please refer to the *There's more…* section of the last
    recipe in [Chapter 8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml), *Algorithmic
    Trading Strategies – Coding Step by Step*.
  prefs: []
  type: TYPE_NORMAL
- en: MACD-Bracket-Order strategy – backtesting the strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will perform backtesting on the **MACD-Bracket-Order strategy**.
    You must have fetched this strategy from your account on the AlgoBulls platform
    in the previous recipe of this chapter. You will leverage the backtesting functionality
    facilitated by `pyalgotrading` for this recipe, which, in turn, submits a backtesting
    job on the AlgoBulls platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once submitted, backtesting will be run by the AlgoBulls backtesting engine.
    You can query the status at any time to find out the state of the backtesting
    job. The job goes through the following states, in the given order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`STARTING` (Intermediate state)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STARTED` (Stable state)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STOPPING` (Intermediate state)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STOPPED` (Stable state)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On submitting a job, it starts with an intermediate state, `'STARTING'`. In
    this state, the AlgoBulls backtesting engine fetches the strategy and get the
    execution environment ready, which may take a couple of minutes. Once done, the
    job moves to the `'STARTED'` state. Strategy backtesting happens at this stage.
    Here, it stays as long as it takes for backtesting to complete. Once done, the
    job moves to an intermediate state, `'STOPPING'`. In this state, the AlgoBulls
    backtesting engine cleans up the resources that have been allocated to this job,
    which usually takes less than a minute. Finally, the job moves to the `'STOPPED'`
    state.
  prefs: []
  type: TYPE_NORMAL
- en: If you have already submitted a backtesting job for a strategy, you cannot submit
    another job for the same strategy until the first job completes. This means you
    have to wait for the first job to move to the `'STOPPED'` state. If the first
    job is long-running and you would like to stop it immediately, you can submit
    a stop job request via `pyalgotrading`. You need to ensure the job is in the `'STARTED'`
    state before submitting the request.
  prefs: []
  type: TYPE_NORMAL
- en: After submitting a backtesting job, you can fetch logs and reports for the strategy
    execution in real time. The logs and reports help validate the strategy's performance
    and debug any potential issues.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to the second recipe of this chapter to see the state machine
    diagram of a backtesting job. It demonstrates the various states and transitions
    of a backtesting job during its lifetime on the AlgoBulls platform.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have gone through the last six recipes of the previous chapter
    to get a complete picture of the strategy class we will be using; that is, `StrategyMACDBracketOrder`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the `algobulls_connection` and `strategy_code2` objects are available
    in your Python namespace. Refer to the preceding recipe of this chapter to set
    up the `algobulls_connection` and `strategy_code2` object.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We execute the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Search for an instrument using its trading symbol as a keyword. Assign the
    returned object to `instruments`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output (your output may differ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Get `value` for the instrument of choice from `instruments`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Submit a backtesting job for `strategy_code2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status of the submitted backtesting job:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status of the submitted backtesting job again after some time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, you import the `datetime` class from the `datetime` module and
    all the required constants from the `pyalgotrading.constants` module. In *step
    2*, you fetch the instrument that you would like to backtest the strategy for,
    the **MACD-Bracket-Order strategy**, using the `search_instrument()` method of
    the `algobulls_connection` object. The `search_instrument()` method accepts a
    search string as an argument, which should be the trading symbol, in part or complete,
    of the instrument you are interested in. You pass `'TATASTEEL'` here. This function
    returns a list with details of the instruments that match the search string. There
    could be multiple instruments that have the search string in their trading symbols.
    In *step 3*, you fetch the value of the first matched instrument and assign it
    to a new variable, `instrument`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 4*, you submit a backtesting job using the `backtest()` method of
    the `algobulls_connection()` object. It takes the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`strategy_code`: Strategy code of the strategy for which backtesting has to
    be performed. This should be a string. You pass `strategy_code2` here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start_timestamp`: Timestamp of the past from which backtesting should be started.
    This should be a `datetime.datetime` object. Here, you pass an object holding
    the value 1st July 2020 9:15 hours – `dt(year=2020, month=7, day=1, hour=9, minute=15)`. Refer
    to the first recipe of [Chapter 1](efb7347f-05e4-4856-9ede-88bdcf393efa.xhtml), 
    *Handling and Manipulating Date, Time, and Time Series Data*, for details on creating
    a `datetime` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end_timestamp`: Timestamp of the past for when backtesting should be performed.
    This object should hold a timestamp value ahead of the `timestamp` value held
    by `start_timestamp`. This should be a `datetime.datetime` instance. Here, you
    pass an object holding the value 7th July 2020 15:30 hours - `dt(year=2020, month=7,
    day=7, hour=15, minute=30)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`instrument`: A financial instrument for which backtesting should be run. Historical
    data will be fetched for this instrument. This should be a string. You pass `instrument`
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lots`: Number of lots for which backtesting should be performed. This should
    be an integer. The quantity is calculated by the strategy as *number of lots *×
    *lot size of the financial instrument*. (See the *MACD-Bracket-Order strategy
    – coding the strategy_select_instruments_for_entry method* recipe in [Chapter
    8](b68a08c7-e8d9-469d-8beb-d0dce9465ec3.xhtml), *Algorithmic Trading Strategies
    - Coding Step by Step*.) You pass `1` here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strategy_parameters`: Parameter names and values expected by the strategy.
    This should be a dictionary, with `parameter-name` and `parameter-value` as key-value
    pairs. You pass the following parameters here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fastma_period: 26`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slowma_period: 6 `'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`signal_period: 9`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target_trigger: 0.01`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stoploss_trigger: 0.01`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trailing_stoploss_trigger: 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Recall that the parameters for the MACD-Bracket-Order strategy were defined
    in its `__init__()` method in the first recipe of the previous chapter).
  prefs: []
  type: TYPE_NORMAL
- en: '`candle_interval`: The candle interval for the historical data fetched for
    backtesting. This should be an enum of the `CandleInterval` type. You pass `CandleInterval.MINUTES_15`
    here. (The `CandleInterval` enum provides various enums for candle intervals,
    some of which are `MINUTE_1`, `MINUTES_3` , `MINUTES_5`, `MINUTES_10`, `MINUTES_15`,
    `MINUTES_30`, `HOUR`, and `DAY`.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the job submission is successful, you will see `Success` messages being printed
    by the `backtest()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Once a job has been submitted, it takes a while to start. After starting, it
    may take some time to finish, depending on the complexity of the strategy and
    duration of backtesting specified using the `start_timestamp` and `end_timestamp`
    arguments. A few days of backtesting may finish in seconds, while a few months
    of backtesting may take minutes.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, you fetch the job status using the `get_backtesting_job_status()`
    method of the `algobulls_connection` object. You pass `strategy_code2` as the
    argument here. This method returns a dictionary with a single key-value pair –
    the data and the job status. If you query the status immediately after placing
    the job, you get `'STARTING'` as the status. In *step 6*, you query the status
    again after some time, and if the job starts, you get a status of `'STARTED'`.
  prefs: []
  type: TYPE_NORMAL
- en: A successful submission implies that the minimum inputs needed to backtest a
    strategy have been passed in the required format. However, this does not ensure
    that the strategy will run without errors. The strategy's execution may still
    run into errors during backtesting. To debug execution issues, you will need to
    fetch the output logs, which will be explained in the next recipe. Possible reasons
    for errors could be bugs in the strategy class' Python code or an incomplete `strategy_parameters`
    dictionary being passed to the `backtest()` function.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a job is running for a long time and you would like to stop it before its
    completion, you can use the `stop_backtesting_job()` method of the `algobulls_connection`
    object. This method accepts strategy code as an argument. You pass `strategy_code2`
    here. This method submits a stop request to the AlgoBulls backtesting engine.
    If the request is accepted, you will see a `Success` message here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If you query the status after submitting the stop request, you will get a status
    of `''STOPPING``:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If you query the status again after some time, and if the job has stopped,
    you will get a status of `''STOPPED''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: MACD-Bracket-Order strategy – fetching backtesting logs in real time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After submitting a backtesting job on the AlgoBulls platform, the AlgoBulls
    backtesting engine starts executing the strategy. During its execution, every
    event that occurs and the decisions that have been made by the AlgoBulls backtesting
    engine are recorded with exact timestamps in the form of textual logs. Examples
    of recorded activities include the given strategy config, every new candle generated
    at regular intervals, trades punched in by your strategy, the entry and exit of
    positions created by these trades, waits for new candles, and so on. These logs
    are quintessential for validating the strategy's behavior and debugging behavioral
    or performance issues that are frequently encountered while developing a strategy.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will fetch backtesting logs for your strategy. The logs
    start coming up as soon as your submitted backtesting job reaches the `'STARTED'`
    state. The AlgoBulls platform allows you to fetch logs in real time, even while
    the backtesting job is still going on. You can get insights into the strategy
    execution without having to wait for the backtesting job to complete, which is
    helpful when jobs are long-running. The `pyalgotrading` package provides a simple
    method for fetching the execution logs for a given strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have gone through the last six recipes of the previous chapter
    to get a complete picture of the strategy class we will be using; that is, `StrategyMACDBracketOrder`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the `algobulls_connection` and `strategy_code2` objects are available
    in your Python namespace. Refer to the *MACD-Bracket-Order strategy – fetching
    the strategy* recipe of this chapter to set up the `algobulls_connection` and
    `strategy_code2` objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We execute the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fetch the backtesting execution logs for `strategy_code2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output (your output may differ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Fetch the backtesting execution logs for `strategy_code2` again after some
    time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output (your output may differ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete output is not shown here. Please visit the following link to read
    the complete output: [https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_macd_bracket_order/logs.txt](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_macd_bracket_order/logs.txt).'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, you use the `get_backtesting_logs()` method of the `algobulls_connection`
    object to fetch the strategy backtesting logs in real time. This method accepts
    strategy code as an argument. You pass `strategy_code2` here. The return data
    is a string. If you try this step immediately after submitting the job, you'll
    get a string that states that the logs are not ready yet (`[2020-07-30 17:27:25]
    Logs not available yet. Please retry in sometime.`). This happens if the backtesting
    job is in the `'STARTING'` state.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, you fetch the logs again after some time. If the job is out of
    the `'STARTING'` state, you start getting your strategy execution logs. You get
    the entire backtesting log every time you call the `get_backtesting_logs()` function.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the backtesting job moves to the `'STOPPED'` state, no new logs are generated.
    You can fetch the complete logs at any time before you submit the next backtesting
    job for the same strategy. If a new backtesting job is submitted (for the same
    strategy), these logs will no longer be accessible via the `get_backtesting_logs()`
    method. You can save the fetched logs to a file if you'd like to refer to it at
    a later date.
  prefs: []
  type: TYPE_NORMAL
- en: MACD-Bracket-Order strategy – fetching a backtesting report – profit and loss
    table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After submitting a backtesting job on the AlgoBulls platform, the AlgoBulls
    backtesting engine starts executing the strategy. During its execution, along
    with the logs, the AlgoBulls backtesting engine also generates a P&L table in
    real time. This table holds information on every trade that's been punched in
    by the strategy. It also contains details on the mappings between entry and exit
    orders, the trade P&L, and the cumulative P&L, sorted chronologically, with the
    latest order first.
  prefs: []
  type: TYPE_NORMAL
- en: This table gives us insights into the strategy's overall performance with the
    help of individual and cumulative P&L numbers. The entry-exit order mapping also
    helps validate the strategy's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will fetch the P&L table report for your strategy. This
    report is available as soon as the first trade is punched in by your strategy
    after you submit a backtesting job. The AlgoBulls platform allows you to fetch
    the P&L table in real time, even while the backtesting job is still going on.
    You can get insights into the strategy's performance without having to wait for
    the backtesting job to complete, which is helpful when jobs are long-running.
    The `pyalgotrading` package provides a simple method you can use to fetch the
    P&L table for a given strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have gone through the last six recipes of the previous chapter
    to get a complete picture of the strategy class we will be using; that is, `StrategyMACDBracketOrder`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the `algobulls_connection` and `strategy_code2` objects are available
    in your Python namespace. Refer to the *MACD-Bracket-Order strategy – fetching
    the strategy* recipe of this chapter to set up the `algobulls_connection` and
    `strategy_code2` objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fetch the backtesting P&L report for `strategy_code2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We got the following output. Your output may differ (note that the following
    output has been split into multiple tables for representation purposes. You will
    see a single wide table in your Jupyter Notebook):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf72229d-6054-416d-899c-1d7c20edbdbc.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, you use the `get_backtesting_report_pnl_table()` method of
    the `algobulls_connection` object to fetch the backtesting P&L table in real time.
    This method accepts strategy code as an argument. You pass `strategy_code2` here.
    The return data is a `pandas.DataFrame` object with multiple columns, described
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`instrument`: Financial instrument for which the trade was entered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entry_timestamp`: The timestamp at which the entry order was placed. (Note
    that it may remain in the `''OPEN''` state for a while before it goes to `''COMPLETE''`
    state. The time for this state transition can be found using the order history
    table, as explained in the last recipe of this chapter.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entry_transaction_type`: Entry order transaction type (either `BUY` or `SELL`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entry_quantity`: Entry order quantity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entry_price`: Price at which the entry order gets executed and goes to the `''COMPLETE''`
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exit_timestamp`: The timestamp at which the exit order was placed. (Note that
    it may remain in the `''OPEN''` state for a while before it goes to the `''COMPLETE''`
    state.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exit_transaction_type`: Exit order transaction type (either `BUY` or `SELL`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exit_quantity`: Exit order quantity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exit_price`: Price at which the exit order gets executed and goes to the `''COMPLETE''`
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pnl_absolute`: Difference between the exit order execution price and the entry
    order execution price. Mathematically, this can be represented as (*exit_price*
    - *entry_price*)**exit_quantity* for a long trade and (*entry_price* - *exit_price*)**exit_quantity*
    for a short trade. A positive value would imply that the trade is a profit-making
    trade. A negative value would imply that the trade is a loss-making trade.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pnl_percentage`: Percentage of profit or loss with respect to the entry price.
    Mathematically, this is *pnl_absolute* / *entry_price / exit_quantity *× *100*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pnl_cumulative_absolute`: Cumulative profit or loss. Mathematically, this
    is the sum of all the `pnl_absolute` values of the previous trades. This number
    gives us direct insight into the strategy''s performance against the simulation
    time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pnl_cumulative_percentage`: Percentage of cumulative profit or loss with respect
    to the entry price. Mathematically, this is *pnl_cumulative* / *entry_price* /
    *exit_quantity* ×* 100*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the backtesting job moves to the `'STOPPED'` state, the P&L table report
    won't update anymore. You can fetch the complete P&L report any time before you
    submit the next backtesting job for the same strategy. If a new backtesting job
    is submitted (for the same strategy), this report will no longer be accessible
    via the `get_backtesting_report_pnl_table()` method. You can save the fetched
    report as a `.csv` file if you'd like to refer to it at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: MACD-Bracket-Order strategy – fetching a backtesting report – statistics table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After submitting a backtesting job on the AlgoBulls platform, the AlgoBulls
    backtesting engine starts executing the strategy. During its execution, along
    with the logs and P&L table, the AlgoBulls backtesting engine also generates a
    summary from the P&L table in real time. This summary is a table of statistics
    containing various statistical numbers such as `Net P&L` (absolute and percentage),
    `Max Drawdown` (absolute and percentage), count of total trades, winning trades,
    losing trades, long trades and short trades, maximum gain and minimum gain (or
    maximum loss), and the average profit per winning and losing trade. This table
    gives us an instant overview of the strategy's overall performance.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will fetch the statistics table report for your strategy.
    This report is available as soon as the first trade is punched in by your strategy
    after you submit a backtesting job. The AlgoBulls platform allows you to fetch
    the statistics table in real time, even while the backtesting job is still going
    on. You can get insights into the strategy performance without having to wait
    for the backtesting job to complete, which is helpful when jobs are long-running.
    The `pyalgotrading` package provides a simple method we can use to fetch the statistics
    table for a given strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have gone through the last six recipes of the previous chapter
    to get a complete picture of the strategy class we will be using; that is, `StrategyMACDBracketOrder`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the `algobulls_connection` and `strategy_code2` objects are available
    in your Python namespace. Refer to the *MACD-Bracket-Order strategy – fetching
    the strategy* recipe of this chapter to set up the `algobulls_connection` and
    `strategy_code2` objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fetch the backtesting statistics report for `strategy_code2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output (your output may differ):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33bc6676-32d5-4886-abf6-a038f92559d7.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, you use the `get_backtesting_report_statistics()` method of
    the `algobulls_connection` object to fetch the backtesting statistics table in
    real time. This method accepts strategy code as an argument. You pass `strategy_code2`
    here. The return data is a `pandas.DataFrame` object with two columns – `Highlight`
    and `Value` – and multiple rows. The rows are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Net PnL`: The cumulative backtesting P&L. This is also the `pnl_cumulative_absolute`
    value of the first entry in the P&L table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Net PnL %`: The cumulative backtesting P&L percentage. This is also the `pnl_cumulative_percentage`
    value of the first entry in the P&L table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Max Drawdown`: The lowest value in the `pnl_cumulative` column of the P&L
    table. This indicates the maximum loss your strategy has encountered during the
    execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Max Drawdown %`: Mathematically, this is *(Max Drawdown)* / *(corresponding
    entry_price) / exit_quantity *× *100*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number of Trades`: Total trades (entry and exit counted as one) during the
    session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number of Wins`: Count of trades where the trade P&L was non-negative.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number of Losses`: Count of trades where the trade P&L was negative.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number of Long Trades`: Count of trades where the entry transaction type was
    `''BUY''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number of Short Trades`: Count of trades where the entry transaction type
    was `''SELL''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Max Gain`: P&L of the trade with the maximum P&L value among all trades.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Min Gain`: P&L of the trade with the minimum P&L value among all trades.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Avg. Profit per winning trade`: Mathematically, this is *(Total P&L of winning
    trades)* / *(Count of winning trades)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Avg. Profit per losing trade`: Mathematically, this is *(Total P&L of losing
    trades)* / *(Count of losing trades)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the statistics table is fetched while the backtesting job is still running,
    the aforementioned numbers will be intermediate numbers, based on the trades that
    had been completed up until that time. The numbers may change as more trades are
    punched in, until the backtesting job completes.
  prefs: []
  type: TYPE_NORMAL
- en: Once the backtesting job moves to the `'STOPPED'` state, the statistics table
    will not change anymore. You can fetch the complete statistics table any time
    before you submit the next backtesting job for the same strategy. If a new backtesting
    job is submitted (for the same strategy), this table will no longer be accessible
    via the `get_backtesting_report_statistics()` method. You can save the fetched
    report as a `.csv` file if you'd like to refer to it at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: MACD-Bracket-Order strategy – fetching a backtesting report – order history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After submitting a backtesting job on the AlgoBulls platform, the AlgoBulls
    backtesting engine starts executing the strategy. During its execution, along
    with the logs, the P&L table, and the statistics table, the AlgoBulls backtesting
    engine also generates an order history log in real time. This log contains the
    state transitions of every order, along with the timestamps and additional information
    (if any) for each order state. The order history log is crucial in understanding
    how long it has taken for a trade to go from an `'OPEN'` to `'COMPLETE'` or `'CANCELLED'` state.
    For example, `MARKET` orders would immediately go from `'OPEN'` to `'COMPLETE'` but
    `LIMIT` orders may take a while, based on the market conditions, to go from `'OPEN'`
    to `'COMPLETE'` – they may even get `'CANCELLED'`. All this information is available
    in the order history log. (Refer to the state machine diagrams in [Chapter 6](077b54a1-c9c4-424c-912a-11f28db3797f.xhtml),
    *Placing Regular Orders on the Exchange*, for more information on order state
    transitions.)
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will fetch the order history log for your strategy. This
    log is available as soon as the first trade is punched in by your strategy after
    you submit a backtesting job. The AlgoBulls platform allows you to fetch the order
    history log in real time, even while the backtesting job is still going on. This
    helps us get details for orders in the end states, without having to wait for
    the backtesting job to complete. The `pyalgotrading` package provides a simple
    method we can use to fetch the order history log for a given strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have gone through the last recipes of the previous chapter to
    get a complete picture of the strategy class we will be using; that is, `StrategyMACDBracketOrder`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the `algobulls_connection` and `strategy_code2` objects are available
    in your Python namespace. Refer to the *MACD-Bracket-Order strategy – fetching
    the strategy* recipe of this chapter to set up the `algobulls_connection` and
    `strategy_code2` objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fetch the backtesting order history report for `strategy_code2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output (your output may differ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete output is not shown here. Please visit the following link to read
    the complete output: [https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_macd_bracket_order/oms_order_history.log](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/sample/backtesting/strategy_macd_bracket_order/oms_order_history.log).'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, you use the `get_backtesting_report_order_history()` method
    of the `algobulls_connection` object to fetch order history logs in real time.
    This method accepts strategy code as an argument. You pass `strategy_code2` here.
    The return data is a string, described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For every order, the log contains the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A descriptive table of the order, with the following mentioned columns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INST`: Financial instrument of the order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIME`: Time at which the order was placed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ID`: The unique ID of the order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TT`: The order transaction type (`BUY` or `SELL`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of the table is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This information will help you find this exact order in the strategy execution
    log.
  prefs: []
  type: TYPE_NORMAL
- en: 'An order state transition table, with the following columns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIME`: Timestamp at which the order enters the state represented by the `''STATE''`
    column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STATE`: The order enters this `''STATE''` column at the timestamp mentioned
    in the `''TIME''` column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MSG`: Additional message from OMS for any unexpected state transitions; for
    example, orders that go to the `REJECTED` state have a message from the OMS stating
    the reason for their rejection. This column is usually empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of the table is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: From this table, you can see that upon placing the order at 10:00 a.m., it transitions
    to the `'OPEN PENDING'` state. It stays there for 2.5 hours before transitioning
    to the `'COMPLETE'` state. This is expected as the order is a bracket limit order.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the backtesting job moves to the `'STOPPED'` state, no new order history
    logs are generated. You can fetch the complete order history logs any time before
    you submit the next backtesting job for the same strategy. If a new backtesting
    job is submitted (for the same strategy), these logs will no longer be accessible
    via the `get_backtesting_report_order_history()` method. You can save the fetched
    logs to a file if you'd like to refer to them at a later date.
  prefs: []
  type: TYPE_NORMAL
