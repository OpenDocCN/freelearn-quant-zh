["```py\ns = talib.BBANDS(df.close,     # No. of periods (2 to 100000)\n                 timeperiod=20,\n                 nbdevup=2,    # Deviation multiplier for lower band\n                 nbdevdn=2,    # Deviation multiplier for upper band\n                 matype=1)     # default: SMA \n```", "```py\nbb_bands = ['upper', 'middle', 'lower']\ndf = price_sample.loc['2012', ['close']]\ndf = df.assign(**dict(zip(bb_bands, s)))\nax = df.loc[:, ['close'] + bb_bands].plot(figsize=(16, 5), lw=1); \n```", "```py\nfig, ax = plt.subplots(figsize=(16,5))\ndf.upper.div(df.close).plot(ax=ax, label='bb_up')\ndf.lower.div(df.close).plot(ax=ax, label='bb_low')\ndf.upper.div(df.lower).plot(ax=ax, label='bb_squeeze')\nplt.legend()\nfig.tight_layout(); \n```", "```py\ndef compute_bb_indicators(close, timeperiod=20, matype=0):\n    high, mid, low = talib.BBANDS(close, \n                                  timeperiod=20,\n                                  matype=matype)\n    bb_up = high / close -1\n    bb_low = low / close -1\n    squeeze = (high - low) / close\n    return pd.DataFrame({'BB_UP': bb_up, \n                         'BB_LOW': bb_low, \n                         'BB_SQUEEZE': squeeze}, \n                        index=close.index)\ndata = (data.join(data\n                  .groupby(level='ticker')\n                  .close\n                  .apply(compute_bb_indicators))) \n```", "```py\ndf = price_sample.loc['2012', ['close', 'high', 'low']]\ndf['SAR'] = talib.SAR(df.high, df.low, \n                      acceleration=0.02, # common value\n                      maximum=0.2)       \ndf[['close', 'SAR']].plot(figsize=(16, 4), style=['-', '--']); \n```", "```py\ndf = price_sample.loc['2012': '2013', ['high', 'low', 'close']]\ndf['PLUS_DM'] = talib.PLUS_DM(df.high, df.low, timeperiod=10)\ndf['MINUS_DM'] = talib.MINUS_DM(df.high, df.low, timeperiod=10) \n```", "```py\ndf['ADX'] = talib.ADX(df.high, \n                      df.low, \n                      df.close, \n                      timeperiod=14) \n```", "```py\nfastk, fastd = talib.STOCHRSI(df.close,\n                              timeperiod=14, \n                              fastk_period=14, \n                              fastd_period=3, \n                              fastd_matype=0)\ndf['fastk'] = fastk\ndf['fastd'] = fastd \n```", "```py\nslowk, slowd = talib.STOCH(df.high,\n                           df.low,\n                           df.close,\n                           fastk_period=14,\n                           slowk_period=3,\n                           slowk_matype=0,\n                           slowd_period=3,\n                           slowd_matype=0)\ndf['STOCH'] = slowd / slowk \n```", "```py\nfactor_data = (web.DataReader('F-F_Research_Data_5_Factors_2x3_daily', 'famafrench', \n                              start=2005)[0].rename(columns={'Mkt-RF': 'MARKET'}))\nfactor_data.index.names = ['date']\nfactors = factor_data.columns[:-1]\nt = 1\nret = f'ret_{t:02}'\nwindows = [21, 63, 252]\nfor window in windows:\n    print(window)\n    betas = []\n    for ticker, df in data.groupby('ticker', group_keys=False):\n        model_data = df[[ret]].merge(factor_data, on='date').dropna()\n        model_data[ret] -= model_data.RF\n        rolling_ols = RollingOLS(endog=model_data[ret], \n                                 exog=sm.add_constant(model_data[factors]),\n                                 window=window)\n        factor_model = rolling_ols.fit(params_only=True).params.rename(\n            columns={'const':'ALPHA'})\n        result = factor_model.assign(ticker=ticker).set_index(\n            'ticker', append=True).swaplevel()\n        betas.append(result)\n    betas = pd.concat(betas).rename(columns=lambda x: f'{x}_{window:02}')\n    data = data.join(betas) \n```", "```py\ndef rank(df):\n    \"\"\"Return the cross-sectional percentile rank\n     Args:\n         :param df: tickers in columns, sorted dates in rows.\n     Returns:\n         pd.DataFrame: the ranked values\n     \"\"\"\n    return df.rank(axis=1, pct=True) \n```", "```py\ndef ts_weighted_mean(df, period=10):\n    \"\"\"\n    Linear weighted moving average implementation.\n    :param df: a pandas DataFrame.\n    :param period: the LWMA period\n    :return: a pandas DataFrame with the LWMA.\n    \"\"\"\n    return (df.apply(lambda x: WMA(x, timeperiod=period))) \n```", "```py\ndef ts_corr(x, y, window=10):\n    \"\"\"\n    Wrapper function to estimate rolling correlations.\n    :param x, y: pandas DataFrames.\n    :param window: the rolling window.\n    :return: DataFrame with time-series min for past 'window' days.\n    \"\"\"\n    return x.rolling(window).corr(y) \n```", "```py\nrank(ts_argmax(power(((returns < 0) ? ts_std(returns, 20) : close), 2.), 5)) \n```", "```py\ndef alpha001(c, r):\n    \"\"\"(rank(ts_argmax(power(((returns < 0)\n        ? ts_std(returns, 20)\n        : close), 2.), 5)) -0.5)\"\"\"\n    c[r < 0] = ts_std(r, 20)\n    return (rank(ts_argmax(power(c, 2), 5)).mul(-.5)\n            .stack().swaplevel()) \n```", "```py\n-(low - close) * power(open, 5) / ((low - high) * power(close, 5)) \n```", "```py\ndef alpha054(o, h, l, c):\n    \"\"\"-(low - close) * power(open, 5) / ((low - high) * power(close, 5))\"\"\"\n    return (l.sub(c).mul(o.pow(5)).mul(-1)\n            .div(l.sub(h).replace(0, -0.0001).mul(c ** 5))\n            .stack('ticker')\n            .swaplevel()) \n```"]