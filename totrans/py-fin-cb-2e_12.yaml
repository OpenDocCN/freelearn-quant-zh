- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Backtesting Trading Strategies
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回测交易策略
- en: In the previous chapters, we gained the knowledge necessary to create trading
    strategies. On the one hand, we could use technical analysis to identify trading
    opportunities. On the other, we could use some of the other techniques we have
    already covered in the book. We could try to use knowledge about factor models
    or volatility forecasting. Or, we could use portfolio optimization techniques
    to determine the optimal quantity of assets for our investment. One crucial thing
    that is still missing is evaluating how such a strategy would have performed if
    we had implemented it in the past. That is the goal of backtesting, which we explore
    in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们获得了创建交易策略所需的知识。一方面，我们可以利用技术分析来识别交易机会；另一方面，我们可以使用书中已覆盖的其他一些技术。我们可以尝试使用因子模型或波动率预测的知识，或者使用投资组合优化技术来确定我们投资的最佳资产数量。仍然缺少的一个关键点是评估如果我们在过去实施这样的策略，它会如何表现。这就是回测的目标，本章将深入探讨这一点。
- en: '**Backtesting** can be described as a realistic simulation of our trading strategy,
    which assesses its performance using historical data. The underlying idea is that
    the backtest performance should be indicative of future performance when the strategy
    is actually used on the market. Naturally, this will not always be the case and
    we should keep that in mind when experimenting.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**回测**可以被描述为对我们的交易策略进行的现实模拟，通过使用历史数据来评估其表现。其基本思想是，回测的表现应能代表未来当策略真正应用于市场时的表现。当然，这种情况并不总是如此，我们在实验时应该牢记这一点。'
- en: There are multiple ways of approaching backtesting, however, we should always
    remember that a backtest should faithfully represent how markets operate, how
    trades are executed, what orders are available, and so on. For example, forgetting
    to account for transaction costs can quickly turn a “profitable” strategy into
    a failed experiment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 回测有多种方法，但我们应该始终记住，回测应该真实地反映市场如何运作、交易如何执行、可用的订单是什么等等。例如，忘记考虑交易成本可能会迅速将一个“有利可图”的策略变成一个失败的实验。
- en: 'We have already mentioned the generic uncertainty around predictions in the
    ever-changing financial markets. However, there are also some implementation aspects
    that can bias the results of backtests and increase the risk of confusing in-sample
    performance with generalizable patterns that will also hold out of sample. We
    briefly mention some of those below:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过，在不断变化的金融市场中，预测的普遍不确定性。然而，还有一些实施方面的因素可能会影响回测结果，增加将样本内表现与可推广的模式混淆的风险。我们简要提到以下一些因素：
- en: '**Look-ahead bias**: This potential flaw emerges when we develop a trading
    strategy using historical data before it was actually known/available. Some examples
    include corrections of reported financial statements after their publication,
    stock splits, or reverse splits.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前瞻偏差**：这种潜在的缺陷出现在我们使用历史数据开发交易策略时，数据在实际使用之前就已知或可用。一些例子包括在财务报告发布后进行的修正、股票拆分或反向拆分。'
- en: '**Survivorship bias**: This bias arises when we backtest only using data about
    securities that are currently active/tradeable. By doing so, we omit the assets
    that have disappeared over time (due to bankruptcy, delisting, acquisition, and
    so on). Most of the time, those assets did not perform well and our strategies
    can be skewed by failing to include those, as those assets could have been picked
    up in the past when they were still available in the markets.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存活偏差**：这种偏差出现在我们仅使用当前仍然活跃/可交易的证券数据进行回测时。通过这样做，我们忽略了那些随着时间的推移消失的资产（例如破产、退市、收购等）。大多数时候，这些资产表现不佳，而我们的策略可能会因未能包括这些资产而发生偏差，因为这些资产在过去仍然可在市场中被选择。'
- en: '**Outlier detection and treatment**: The main challenge is to discern the outliers
    that are not representative of the analyzed period as opposed to the ones that
    are an integral part of the market behavior.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常值检测与处理**：主要的挑战是辨别那些不代表分析期的异常值，而不是那些市场行为中不可或缺的一部分。'
- en: '**Representative sample period**: As the goal of the backtest is to provide
    an indication of future performance, the sample data should reflect the current,
    and potentially also future, market behavior. By not spending enough time on this
    part, we can miss some crucial market regime aspects such as volatility (too few/many
    extreme events) or volume (too few data points).'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代表性样本周期**：由于回测的目标是提供对未来表现的指示，因此样本数据应该反映当前的市场行为，并且可能还要反映未来的市场行为。如果在这一部分花费的时间不够，我们可能会错过一些关键的市场环境特征，比如波动性（极端事件过少/过多）或交易量（数据点过少）。'
- en: '**Meeting investment objectives and constraints over time**: It can happen
    that a strategy leads to good performance at the very end of the evaluation period.
    However, in some periods when it was active, it resulted in unacceptably high
    losses or volatility. We could potentially track those by using rolling performance/risk
    metrics, for example, the value-at-risk or the Sharpe/Sortino ratio.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随着时间推移实现投资目标和约束**：有时，一个策略可能在评估期的最后阶段表现良好。然而，在它活跃的某些阶段，可能会导致不可接受的高损失或高波动性。我们可以通过使用滚动绩效/风险指标来跟踪这些情况，例如风险价值（value-at-risk）或夏普比率/索提诺比率（Sharpe/Sortino
    ratio）。'
- en: '**Realistic trading environment**: We have already mentioned that failing to
    include transaction costs can greatly impact the end result of a backtest. What
    is more, real-life trading involves further complications. For example, it might
    not be possible to execute all trades at all times or at the target price. Some
    of the things to consider are **slippage** (the difference between the expected
    price of a trade and the price at which the trade is executed), the availability
    of a counterparty for short positions, broker fees, and so on. The realistic environment
    also accounts for the fact that we might make a trading decision based on the
    close prices of one day, but the trade will be (potentially) executed based on
    the open prices of the next trading day. It can happen that the order we prepare
    will not be executed due to large price differences.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**现实的交易环境**：我们已经提到过，忽略交易成本可能会极大地影响回测的最终结果。更重要的是，现实中的交易还涉及更多的复杂因素。例如，可能无法在任何时候或以目标价格执行所有交易。需要考虑的一些因素包括**滑点**（交易预期价格与实际执行价格之间的差异）、空头头寸的对手方可用性、经纪费用等。现实环境还考虑到一个事实，即我们可能基于某一日的收盘价做出交易决策，但交易可能（有可能）会基于下一交易日的开盘价执行。由于价格差异较大，我们准备的订单可能无法执行。'
- en: '**Multiple testing**: When running multiple backtests, we might discover spurious
    results or a strategy that overfits the test sample and produces suspiciously
    positive results that are unlikely to hold for out-of-sample data encountered
    during live trading. Also, we might leak prior knowledge of what works and what
    does not into the design of strategies, which can lead to further overfitting.
    Some things that we can consider are: reporting the number of trials, calculating
    the minimum backtest length, using some sort of optimal stopping rule, or calculating
    metrics that account for the effect of multiple testing (for example, the deflated
    Sharpe ratio).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多重测试**：在进行多个回测时，我们可能会发现虚假的结果，或者某个策略过度拟合了测试样本，导致产生不太可能在实际交易中有效的异常正面结果。此外，我们可能会在策略设计中泄露出关于什么有效、什么无效的先验知识，这可能导致进一步的过度拟合。我们可以考虑的一些方法包括：报告试验次数、计算最小回测长度、使用某种最优停止规则，或者计算考虑多重测试影响的指标（例如，通货膨胀的夏普比率）。'
- en: 'In this chapter, we show how to run backtests of various trading strategies
    using two approaches: vectorized and event-driven. We will go into the details
    of each of the approaches later on, but now we can state that the first one works
    well for a quick test to see if there is any potential in the strategy. On the
    other hand, the latter is more suited for thorough and rigorous testing, as it
    tries to account for many of the potential issues mentioned above.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了如何使用两种方法——向量化和事件驱动——对各种交易策略进行回测。我们稍后会详细介绍每种方法，但现在我们可以说，第一种方法适合于快速测试，以了解策略是否有潜力。另一方面，第二种方法更适合于进行彻底且严格的测试，因为它试图考虑上述提到的许多潜在问题。
- en: The key learning of this chapter is how to set up a backtest using popular Python
    libraries. We will be showing a few examples of strategies built on the basis
    of popular technical indicators or a strategy using mean-variance portfolio optimization.
    With that knowledge, you can backtest any strategy you can come up with.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的关键学习内容是如何使用流行的Python库来设置回测。我们将展示一些基于流行技术指标构建的策略示例，或使用均值方差投资组合优化的策略。掌握这些知识后，你可以回测任何自己想到的策略。
- en: 'We present the following recipes in this chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了以下几个回测示例：
- en: Vectorized backtesting with pandas
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pandas进行矢量化回测
- en: Event-driven backtesting with backtrader
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用backtrader进行事件驱动回测
- en: Backtesting a long/short strategy based on the RSI
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回测基于RSI的多空策略
- en: Backtesting a buy/sell strategy based on Bollinger bands
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回测基于布林带的买卖策略
- en: Backtesting a moving average crossover strategy using crypto data
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加密数据回测移动平均交叉策略
- en: Backtesting a mean-variance portfolio optimization
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回测均值方差投资组合优化
- en: Vectorized backtesting with pandas
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pandas进行矢量化回测
- en: As we mentioned in the introduction to this chapter, there are two approaches
    to carrying out backtests. The simpler one is called **vectorized backtesting**.
    In this approach, we multiply a signal vector/matrix (containing an indicator
    of whether we are entering or closing a position) by the vector of returns. By
    doing so, we calculate the performance over a certain period of time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章的介绍中提到的，回测有两种方法。较简单的一种叫做**矢量化回测**。在这种方法中，我们将信号向量/矩阵（包含我们是开仓还是平仓的指标）与回报向量相乘。通过这样做，我们可以计算某一时间段内的表现。
- en: 'Due to its simplicity, this approach cannot deal with many of the issues we
    described in the introduction, for example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其简单性，这种方法无法处理我们在介绍中提到的许多问题，例如：
- en: We need to manually align the timestamps to avoid look-ahead bias.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要手动对齐时间戳，以避免未来数据偏倚。
- en: There is no explicit position sizing.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有明确的头寸大小控制。
- en: All performance measurements are calculated manually at the very end of the
    backtest.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的性能度量都在回测的最后手动计算。
- en: Risk-management rules like stop-loss are not easy to incorporate.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像止损这样的风险管理规则不容易纳入。
- en: That is why we should use vectorized backtesting mostly if we are dealing with
    simple trading strategies and want to explore their initial potential in a few
    lines of code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们处理的是简单的交易策略并希望用少量代码探索其初步潜力，我们应该主要使用矢量化回测。
- en: 'In this recipe, we backtest a very simple strategy with the following set of
    rules:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们回测了一个非常简单的策略，规则集如下：
- en: We enter a long position if the close price is above the 20-day Simple Moving
    Average (SMA)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当收盘价高于20日简单移动平均线（SMA）时，我们会开仓做多。
- en: We close the position when the close price goes below the 20-day SMA
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当收盘价跌破20日SMA时，我们会平仓。
- en: Short selling is not allowed
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许卖空。
- en: The strategy is unit agnostic (we can enter a position of 1 share or 1000 shares)
    because we only care about the percentage change in the prices
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该策略与单位无关（我们可以持有1股或1000股），因为我们只关心价格的百分比变化
- en: We backtest this strategy using Apple’s stock and its historical prices from
    the years 2016 to 2021.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用苹果公司股票及其2016到2021年的历史价格对该策略进行回测。
- en: How to do it…
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Execute the following steps to backtest a simple strategy using the vectorized
    approach:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以使用矢量化方法回测一个简单的策略：
- en: 'Import the libraries:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关库：
- en: '[PRE0]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Download Apple’s stock prices from the years 2016 to 2021 and keep only the
    adjusted close price:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载2016到2021年间苹果公司的股票价格，并只保留调整后的收盘价：
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Calculate the log returns and the 20-day SMA of the close prices:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算收盘价的对数收益率和20日SMA：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a position indicator:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个头寸指标：
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using the following snippet, we count how many times we entered a long position:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下代码片段，我们计算了进入多头头寸的次数：
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The answer is 56.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 答案是56。
- en: 'Visualize the strategy over 2021:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化2021年的策略：
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Executing the snippet generates the following figure:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行该代码片段会生成以下图形：
- en: '![](../Images/B18112_12_01.png)'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](../Images/B18112_12_01.png)'
- en: 'Figure 12.1: The preview of our trading strategy based on the simple moving
    average'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.1：基于简单移动平均线的交易策略预览
- en: In *Figure 12.1,* we can clearly see how our strategy works—in the periods when
    the close price is above the 20-day SMA, we do have an open position. This is
    indicated by the value of 1 in the column containing the position information.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 *图 12.1* 中，我们可以清楚地看到策略的运作——当收盘价高于 20 日 SMA 时，我们确实持有仓位。这由包含持仓信息的列中的值 1 所表示。
- en: 'Calculate the strategy’s daily and cumulative returns:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算该策略的每日和累计收益：
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the buy-and-hold strategy for comparison:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加买入并持有策略进行比较：
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Plot the strategies’ cumulative returns:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制策略的累计收益：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Executing the snippet generates the following figure:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行该代码片段生成了如下图表：
- en: '![](../Images/B18112_12_02.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_12_02.png)'
- en: 'Figure 12.2: The cumulative returns of our strategy and the buy-and-hold benchmark'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2：我们的策略和买入并持有基准的累计收益
- en: In *Figure 12.2,* we can see the cumulative returns of both strategies. The
    initial conclusion could be that the simple strategy outperformed the buy-and-hold
    strategy over the considered time period. However, this form of a simplified backtest
    does not consider quite a lot of crucial aspects (for example, trading using the
    close price, it assumes lack of slippage and transaction costs, and so on) that
    can dramatically change the final outcome. In the *There’s more...* section, we
    will see how quickly the results change when we account for transaction costs
    alone.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 12.2* 中，我们可以看到两种策略的累计收益。初步结论可能是，简单策略在考虑的时间段内表现优于买入并持有策略。然而，这种简化的回测形式并未考虑许多关键方面（例如，使用收盘价交易、假设没有滑点和交易成本等），这些因素可能会显著改变最终结果。在
    *更多内容...* 部分，我们将看到当我们仅考虑交易成本时，结果如何迅速发生变化。
- en: How it works…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: At the very beginning, we imported the libraries and downloaded Apple’s stock
    prices from the years 2016 to 2021\. We only kept the adjusted close price for
    the backtest.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们导入了相关库并下载了 2016 到 2021 年间苹果公司的股票价格。我们只保留了调整后的收盘价用于回测。
- en: In *Step 3*, we calculated the log returns and the 20-day SMA. To calculate
    the technical indicator, we used the `rolling` method of a `pandas` DataFrame.
    However, we could have just as well used the already explored `TA-Lib` library.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 3 步* 中，我们计算了对数收益和 20 日 SMA。为了计算该技术指标，我们使用了 `pandas` DataFrame 的 `rolling`
    方法。然而，我们也可以使用之前探讨过的 `TA-Lib` 库来实现。
- en: We calculated the log returns, as they have a convenient property of summing
    up over time. If we held the position for 10 days and are interested in the final
    return of the position, we can simply sum up the log returns from those 10 days.
    For more information, please refer to *Chapter 2*, *Data Preprocessing*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算了对数收益，因为它具有随着时间累加的便利性。如果我们持有仓位 10 天并关注该仓位的最终收益，我们可以简单地将这 10 天的对数收益相加。如需更多信息，请参见
    *第 2 章*，*数据预处理*。
- en: In *Step 4*, we created a column with information on whether we have an open
    position (long only) or not. As we have decided, we enter the position when the
    close price is above the 20-day SMA. We exit the position when the close price
    goes below the SMA. We have also encoded this column in the DataFrame as an integer.
    In *Step 5*, we plotted the close price, the 20-day SMA, and the column with the
    position flag. To make the plot more readable, we only plotted the data from 2021.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 4 步* 中，我们创建了一个列，用于标明我们是否有开仓（仅多头）或者没有开仓。正如我们决定的那样，当收盘价高于 20 日 SMA 时，我们开仓。当收盘价低于
    SMA 时，我们平仓。我们还将该列编码为整数。在 *第 5 步* 中，我们绘制了收盘价、20 日 SMA 和包含持仓标志的列。为了使图表更加易读，我们只绘制了
    2021 年的数据。
- en: '*Step 6* is the most important one in the vectorized backtest. There, we calculated
    the strategy’s daily and cumulative returns. To calculate the daily return, we
    multiplied the log return of that day with the shifted position flag. The position
    vector is shifted by 1 to avoid the look-ahead bias. In other words, the flag
    is generated using all the information up to and including time *t*. We can only
    use that information to open a position on the next trading day, that is, at time
    *t+1*.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 6 步* 是向量化回测中最重要的一步。在这一部分，我们计算了策略的每日和累计收益。为了计算每日收益，我们将当天的对数收益与平移后的持仓标志相乘。为了避免未来数据偏差，持仓向量被平移了
    1 天。换句话说，标志是利用截至并包括时间 *t* 的所有信息生成的。我们只能利用这些信息在下一个交易日（即时间 *t+1*）开仓。'
- en: An inquisitive reader might already spot another bias that is occurring with
    our backtest. We are correctly assuming that we can only buy on the next trading
    day, however, the log return is calculated as we have bought on day *t+1* using
    the close price of time *t*, which can be very untrue depending on the market
    conditions. We will see how to overcome this issue with event-driven backtesting
    in the next recipes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一位好奇的读者可能已经发现我们回测中出现的另一种偏差。我们正确地假设只能在下一个交易日买入，然而，日志回报是按我们在 *t+1* 日使用 *t* 日的收盘价买入来计算的，这在某些市场条件下可能非常不准确。我们将在接下来的示例中看到如何通过事件驱动回测来克服这个问题。
- en: Then, we used the `cumsum` method to calculate the cumulative sum of the log
    returns, which corresponds to the cumulative return. Lastly, we applied the exponent
    function using the `apply` method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用了 `cumsum` 方法计算日志回报的累计和，这对应于累计回报。最后，我们通过 `apply` 方法应用了指数函数。
- en: In *Step 7*, we calculated the cumulative returns of a buy-and-hold strategy.
    For this one, we simply used the log returns for the calculations, skipping the
    step in which we multiplied the returns with the position flag.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 7* 中，我们计算了买入持有策略的累计回报。对于这个策略，我们只是使用了日志回报进行计算，省略了将回报与持仓标志相乘的步骤。
- en: In the last step, we plotted the cumulative returns of both strategies.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们绘制了两种策略的累计回报。
- en: There’s more...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: From the initial backtest, it seems that the simple strategy is outperforming
    the buy-and-hold strategy. But we have also seen that over the 6 years, we have
    entered a long position 56 times. The total number of trades doubles, as we also
    exited those positions. Depending on the broker, this can result in quite significant
    transaction costs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从最初的回测结果来看，简单策略的表现优于买入持有策略。但我们也看到，在这 6 年中，我们已经进场 56 次。总交易次数翻倍，因为我们还退出了这些仓位。根据经纪商的不同，这可能导致相当可观的交易成本。
- en: Given that transaction costs are frequently quoted in fixed percentages, we
    can simply calculate by how much the portfolio has changed between successive
    time steps, calculate the transaction costs on that basis, and then subtract them
    directly from our strategy’s returns.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于交易成本通常以固定百分比报价，我们可以简单地计算投资组合在连续时间步之间的变化量，基于此计算交易成本，然后直接从策略回报中减去这些成本。
- en: In the steps below, we show how to account for the transaction costs in a vectorized
    backtest. For simplicity, we assume that the transaction costs are 1%.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的步骤中，我们展示了如何在向量化回测中考虑交易成本。为了简单起见，我们假设交易成本为 1%。
- en: 'Execute the following steps to account for transaction costs in the vectorized
    backtest:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在向量化回测中考虑交易成本：
- en: 'Calculate daily transaction costs:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每日交易成本：
- en: '[PRE9]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this snippet, we calculated if there is a change in our portfolio (absolute
    value, as we can enter or exit a position) and then multiplied that value by the
    transaction costs expressed as a percentage.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们计算了投资组合是否发生变化（绝对值，因为我们可能会进场或退出仓位），然后将该值乘以以百分比表示的交易成本。
- en: 'Calculate the strategy’s performance accounting for transaction costs:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算考虑交易成本后的策略表现：
- en: '[PRE10]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Plot the cumulative returns of all the strategies:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制所有策略的累计回报：
- en: '[PRE11]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Executing the snippet generates the following figure:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行代码片段会生成以下图形：
- en: '![](../Images/B18112_12_03.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_12_03.png)'
- en: 'Figure 12.3: Cumulative returns of all strategies, including the one with transaction
    costs'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3：所有策略的累计回报，包括考虑交易成本的策略
- en: After accounting for transaction costs, the performance decreased significantly
    and is worse than that of the buy-and-hold. And to be entirely fair, we should
    also account for the initial and terminal transaction costs in the buy-and-hold
    strategy, as we had to buy and sell the asset once.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑交易成本后，表现明显下降，甚至不如买入持有策略。而且为了公平起见，我们也应该考虑买入持有策略中的初始和终端交易成本，因为我们必须进行一次买入和一次卖出。
- en: Event-driven backtesting with backtrader
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 backtrader 进行事件驱动回测
- en: The second approach to backtesting is called **event-driven backtesting**. In
    this approach, a backtesting engine simulates the time dimension of the trading
    environment (you can think about it as a `for` loop going through the time and
    executing all the actions sequentially). This imposes more structure on the backtest,
    including the use of historical calendars to define when trades can actually be
    executed, when prices are available, and so on.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 回测的第二种方法称为**事件驱动回测**。在这种方法中，回测引擎模拟交易环境的时间维度（你可以把它看作一个遍历时间的 `for` 循环，顺序执行所有操作）。这对回测施加了更多结构，包括使用历史日历来定义交易实际执行的时间、价格何时可用等。
- en: Event-driven backtesting aims to simulate all the actions and constraints encountered
    when executing a certain strategy while allowing for much more flexibility than
    the vectorized approach. For example, this approach allows for simulating potential
    delays in orders’ execution, slippage costs, and so on. In an ideal scenario,
    a strategy encoded for an event-driven backtest could be easily converted into
    one working with live trading engines.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 基于事件驱动的回测旨在模拟执行某个策略时遇到的所有操作和约束，同时比向量化方法提供更多灵活性。例如，这种方法允许模拟订单执行中的潜在延迟、滑点成本等。在理想情况下，为事件驱动回测编写的策略可以轻松转换为适用于实时交易引擎的策略。
- en: 'Nowadays, there are quite a few event-driven backtesting libraries available
    for Python. In this chapter, we introduce one of the most popular ones—`backtrader`.
    Key features of this framework include:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，有相当多的事件驱动回测库可供 Python 使用。本章介绍了其中一个最流行的库——`backtrader`。该框架的主要特性包括：
- en: A vast amount of available technical indicators (`backtrader` also provides
    a wrapper around the popular TA-Lib library) and performance measures.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供大量可用的技术指标（`backtrader` 还提供了对流行的 TA-Lib 库的封装）和绩效衡量标准。
- en: Ease of building and applying new indicators.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易构建和应用新的指标。
- en: Multiple data sources are available (including Yahoo Finance and Nasdaq Data
    Link), with the possibility to load external files.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供多个数据源（包括 Yahoo Finance 和 Nasdaq Data Link），并支持加载外部文件。
- en: Simulating many aspects of real brokers, such as different types of orders (market,
    limit, and stop), slippage, commission, going long/short, and so on.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟许多真实经纪商的方面，如不同类型的订单（市价单、限价单、止损单）、滑点、佣金、做多/做空等。
- en: Comprehensive and interactive visualization of the prices, TA indicators, trading
    signals, performance, and so on.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对价格、技术指标、交易信号、绩效等进行全面和互动式的可视化。
- en: Live trading with selected brokers.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与选定的经纪商进行实时交易。
- en: 'For this recipe, we consider a basic strategy based on the simple moving average.
    As a matter of fact, it is almost identical to the one we backtested in the previous
    recipe using the vectorized approach. The logic of the strategy is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们考虑了一个基于简单移动平均的基础策略。实际上，它几乎与我们在前一个食谱中使用向量化方法回测的策略完全相同。该策略的逻辑如下：
- en: When the close price becomes higher than the 20-day SMA, buy one share.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当收盘价高于 20 日均线时，买入一股。
- en: When the close price becomes lower than the 20-day SMA and we have a share,
    sell it.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当收盘价低于 20 日均线且我们持有股票时，卖出它。
- en: We can only have a maximum of one share at any given time.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在任何给定时间只能持有最多一股。
- en: No short selling is allowed.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许卖空。
- en: We run the backtesting of this strategy using Apple’s stock prices from the
    year 2021.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 2021 年的苹果股票价格进行该策略的回测。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe (and in the rest of the chapter), we will be using two helper
    functions used for printing logs—`get_action_log_string` and `get_result_log_string`.
    Additionally, we will use a custom `MyBuySell` observer to display the position
    markers in different colors. You can find the definitions of those helpers in
    the `strategy_utils.py` file available on GitHub.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中（以及本章的其余部分），我们将使用两个用于打印日志的辅助函数——`get_action_log_string` 和 `get_result_log_string`。此外，我们将使用一个自定义的
    `MyBuySell` 观察者来以不同颜色显示持仓标记。你可以在 GitHub 上的 `strategy_utils.py` 文件中找到这些辅助函数的定义。
- en: 'At the time of writing, the version of `backtrader` available at PyPI (the
    Python Package Index) is not the latest. Installing with a simple `pip install
    backtrader` command will install a version containing quite a few issues, for
    example, with loading the data from Yahoo Finance. To overcome this, you should
    install the latest version from GitHub. You can do so using the following snippet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本文时，PyPI（Python 包索引）上提供的 `backtrader` 版本并非最新版本。通过简单的 `pip install backtrader`
    命令安装时，会安装一个包含一些问题的版本，例如，无法正确加载来自 Yahoo Finance 的数据。为了解决这个问题，您应该从 GitHub 安装最新版本。您可以使用以下代码片段来完成安装：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Execute the following steps to backtest a simple strategy using the event-driven
    approach:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来使用事件驱动的方法回测一个简单的策略：
- en: 'Import the libraries:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入库：
- en: '[PRE13]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Download data from Yahoo Finance:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Yahoo Finance 下载数据：
- en: '[PRE14]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To make the code more readable, we first present the general outline of the
    class defining the trading strategy and then introduce the separate methods in
    the following substeps.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了使代码更具可读性，我们首先展示定义交易策略的类的一般轮廓，然后在以下子步骤中介绍各个方法。
- en: 'The template of the strategy is presented below:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 策略的模板如下所示：
- en: '[PRE15]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `__init__` method is defined as:'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__init__` 方法定义如下：'
- en: '[PRE16]'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `log` method is defined as:'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`log` 方法定义如下：'
- en: '[PRE17]'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `notify_order` method is defined as:'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`notify_order` 方法定义如下：'
- en: '[PRE18]'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `notify_trade` method is defined as:'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`notify_trade` 方法定义如下：'
- en: '[PRE19]'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `next` method is defined as:'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`next` 方法定义如下：'
- en: '[PRE20]'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `start` and `stop` methods are defined as follows:'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`start` 和 `stop` 方法定义如下：'
- en: '[PRE21]'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Set up the backtest:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置回测：
- en: '[PRE22]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the backtest:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行回测：
- en: '[PRE23]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Running the snippet generates the following (abbreviated) log:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行该代码片段会生成以下（简化的）日志：
- en: '[PRE24]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The log contains information about all the created and executed trades, as well
    as the operation results in case the position was closed.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 日志包含关于所有已创建和执行的交易的信息，以及在头寸被关闭时的操作结果。
- en: 'Plot the results:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制结果：
- en: '[PRE25]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Running the snippet generates the following plot:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行该代码片段会生成以下图表：
- en: '![](../Images/B18112_12_04.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_12_04.png)'
- en: 'Figure 12.4: Summary of our strategy’s behavior/performance over the backtested
    period'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4：回测期间我们策略行为/表现的总结
- en: In *Figure 12.4,* we can see Apple’s stock price, the 20-day SMA, the buy and
    sell orders, and the evolution of our portfolio’s value over time. As we can see,
    this strategy made $48 over the backtest’s duration. While considering the performance,
    please bear in mind that the strategy is only operating with a single stock, while
    keeping most of the available resources in cash.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 12.4* 中，我们可以看到苹果公司的股票价格、20日简单移动平均线（SMA）、买卖订单，以及我们投资组合价值随时间的变化。正如我们所见，该策略在回测期间赚取了
    48 美元。在考虑绩效时，请记住，该策略仅操作单一股票，同时将大部分可用资源保持为现金。
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key idea of working with `backtrader` is that there is the main brain of
    the backtest—`Cerebro`—and by using different methods, we provide it with historical
    data, the designed trading strategy, additional metrics we want to calculate (for
    example, the portfolio value over the investment horizon, or the overall Sharpe
    ratio), information about commissions/slippage, and so on.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `backtrader` 的关键概念是，回测的核心大脑是 `Cerebro`，通过使用不同的方法，我们为它提供历史数据、设计的交易策略、我们希望计算的附加指标（例如投资期内的投资组合价值，或者整体的夏普比率）、佣金/滑点信息等。
- en: 'There are two ways of creating strategies: using signals (`bt.Signal`) or defining
    a full strategy (`bt.Strategy`). Both yield the same results, however, the lengthier
    approach (created using `bt.Strategy`) provides more logging of what is actually
    happening in the background. This makes it easier to debug and keep track of all
    operations (the level of detail included in the logging depends on our needs).
    That is why we start by showing that approach in this recipe.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建策略有两种方式：使用信号（`bt.Signal`）或定义完整的策略（`bt.Strategy`）。这两种方式会产生相同的结果，然而，较长的方式（通过
    `bt.Strategy` 创建）会提供更多关于实际发生的操作的日志记录。这使得调试更容易，并且能够跟踪所有操作（日志的详细程度取决于我们的需求）。因此，我们在本篇中首先展示这种方法。
- en: You can find the equivalent strategy built using the signal approach in the
    book’s GitHub repository.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的 GitHub 仓库中找到使用信号方法构建的等效策略。
- en: After importing the libraries and helper functions in *Step 1*, we downloaded
    price data from Yahoo Finance using the `bt.feeds.YahooFinanceData` function.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中导入库和辅助函数之后，我们使用 `bt.feeds.YahooFinanceData` 函数从 Yahoo Finance 下载了价格数据。
- en: You can also add data from a CSV file, a `pandas` DataFrame, Nasdaq Data Link,
    and other sources. For a list of available options, please refer to the documentation
    of `bt.feeds`. We show how to load data from a `pandas` DataFrame in the Notebook
    on GitHub.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从CSV文件、`pandas` DataFrame、纳斯达克数据链接（Nasdaq Data Link）以及其他来源添加数据。有关可用选项的列表，请参考`bt.feeds`的文档。我们在GitHub的Notebook中展示了如何从`pandas`
    DataFrame加载数据。
- en: 'In *Step 3*, we defined the trading strategy as a class inheriting from `bt.Strategy`.
    Inside the class, we defined the following methods (we were actually overwriting
    them to make them tailor-made for our needs):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们将交易策略定义为继承自`bt.Strategy`的类。在类中，我们定义了以下方法（我们实际上是覆盖了这些方法，以便根据我们的需求量身定制）：
- en: '`__init__`: In this method, we defined the objects that we would like to keep
    track of. In our example, these were the close price, a placeholder for the order,
    and the TA indicator (SMA).'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__`：在此方法中，我们定义了希望跟踪的对象。在我们的示例中，这些对象包括收盘价、订单的占位符和技术分析指标（SMA）。'
- en: '`log`: This method is defined for logging purposes. It logs the date and the
    provided string. We used the helper functions `get_action_log_string` and `get_result_log_string`
    to create the strings with various order-related information.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log`：此方法用于日志记录，记录日期和提供的字符串。我们使用辅助函数`get_action_log_string`和`get_result_log_string`来创建包含各种订单相关信息的字符串。'
- en: '`notify_order`: This method reports the status of the order (position). In
    general, on day *t*, the indicator can suggest opening/closing a position based
    on the close price (assuming we are working with daily data). Then, the (market)
    order will be carried out on the next trading day (using the open price of time
    *t+1*). However, there is no guarantee that the order will be executed, as it
    can be canceled or we might have insufficient cash. This method also removes any
    pending order by setting `self.order = None`.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notify_order`：此方法报告订单（仓位）的状态。通常，在第*t*天，指标可以根据收盘价建议开盘/平仓（假设我们使用的是日数据）。然后，市场订单将在下一个交易日（使用*t+1*时刻的开盘价）执行。然而，无法保证订单会被执行，因为它可能会被取消或我们可能没有足够的现金。此方法还通过设置`self.order
    = None`来取消任何挂单。'
- en: '`notify_trade`: This method reports the results of trades (after the positions
    are closed).'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notify_trade`：此方法报告交易结果（在仓位关闭后）。'
- en: '`next`: This method contains the trading strategy’s logic. First, we checked
    whether there was an order already pending, and did nothing if there was. The
    second check was to see whether we already had a position (enforced by our strategy,
    this is not a must) and if we did not, we checked whether the close price was
    higher than the moving average. A positive outcome resulted in an entry to the
    log and the placing of a buy order using `self.order = self.buy()`. This is also
    the place where we can choose the stake (number of assets we want to buy). The
    default is 1 (equivalent to using `self.buy(size=1)`).'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`：此方法包含了交易策略的逻辑。首先，我们检查是否已有挂单，如果有则不做任何操作。第二个检查是查看是否已有仓位（由我们的策略强制执行，这不是必须的），如果没有仓位，我们检查收盘价是否高于移动平均线。如果结果是正面的，我们将进入日志并使用`self.order
    = self.buy()`下达买入订单。这也是我们选择购买数量（我们想要购买的资产数量）的地方。默认值为1（等同于使用`self.buy(size=1)`）。'
- en: '`start`/`stop`: These methods are executed at the very beginning/end of the
    backtest and can be used, for example, for reporting the portfolio value.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`/`stop`：这些方法在回测的开始/结束时执行，可以用于报告投资组合的价值等操作。'
- en: 'In *Step 4*, we set up the backtest, that is, we executed a series of operations
    connected to Cerebro:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们设置了回测，即执行了一系列与Cerebro相关的操作：
- en: We created the instance of `bt.Cerebro` and set `stdstats=False`, in order to
    suppress a lot of default elements of the plot. By doing so, we avoided cluttering
    the output. Instead, we manually picked the interesting elements (observers and
    indicators).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了`bt.Cerebro`的实例并设置`stdstats=False`，以抑制许多默认的图表元素。这样，我们避免了输出的冗余，而是手动选择了感兴趣的元素（观察者和指标）。
- en: We added the data using the `adddata` method.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`adddata`方法添加了数据。
- en: We set up the amount of available money using the `setcash` method of the `broker`.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`broker`的`setcash`方法设置了可用资金的数量。
- en: We added the strategy using the `addstrategy` method.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`addstrategy`方法添加了策略。
- en: 'We added the observers using the `addobserver` method. We selected two observers:
    the custom `BuySell` observer used for displaying the buy/sell decisions on the
    plot (denoted by green and red triangles), and the `Value` observer used for tracking
    the evolution of the portfolio’s value over time.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `addobserver` 方法添加了观察者。我们选择了两个观察者：自定义的 `BuySell` 观察者，用于在图表上显示买入/卖出决策（由绿色和红色三角形表示），以及
    `Value` 观察者，用于跟踪投资组合价值随时间的变化。
- en: The last steps involved running the backtest with `cerebro.run()` and plotting
    the results with `cerebro.plot()`. In the latter step, we disabled displaying
    the volume charts to avoid cluttering the graph.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是通过 `cerebro.run()` 运行回测，并通过 `cerebro.plot()` 绘制结果。在这一步骤中，我们禁用了显示交易量图表，以避免图表杂乱。
- en: 'Some additional points about backtesting with `backtrader`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用 `backtrader` 进行回测的几点补充说明：
- en: By design, `Cerebro` should only be used once. If we want to run another backtest,
    we should create a new instance, not add something to it after starting the calculations.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据设计，`Cerebro` 应该只使用一次。如果我们想要运行另一个回测，应该创建一个新的实例，而不是在开始计算后再往其中添加内容。
- en: In general, a strategy built using `bt.Signal` uses only one signal. However,
    we can combine multiple signals based on different conditions by using `bt.SignalStrategy`
    instead.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，使用 `bt.Signal` 构建的策略只使用一个信号。然而，我们可以通过使用 `bt.SignalStrategy` 来基于不同的条件组合多个信号。
- en: When we do not specify otherwise, all orders are placed for one unit of the
    asset.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们没有特别指定，所有订单都将以一个单位的资产进行。
- en: '`backtrader` automatically handles the warm-up period. In this case, no trade
    can be carried out until there are enough data points to calculate the 20-day
    SMA. When considering multiple indicators at once, `backtrader` automatically
    selects the longest necessary period.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backtrader` 会自动处理热身期。在此期间，无法进行交易，直到有足够的数据点来计算 20 天的简单移动平均线（SMA）。当同时考虑多个指标时，`backtrader`
    会自动选择最长的必要周期。'
- en: There’s more...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is worth mentioning that `backtrader` has parameter optimization capabilities,
    which we present in the code that follows. The code is a modified version of the
    strategy from this recipe, in which we optimize the number of days used for calculating
    the SMA.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，`backtrader` 具有参数优化功能，以下代码展示了这一功能。该代码是本策略的修改版本，我们优化了用于计算 SMA 的天数。
- en: When tuning the values of the strategy’s parameters, you can create a simpler
    version of the strategy that does not log that much information (start value,
    creating/executing orders, and so on.). You can find an example of the modified
    strategy in the script `sma_strategy_optimization.py`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在调整策略参数值时，您可以创建一个简化版的策略，不记录过多信息（例如起始值、创建/执行订单等）。您可以在 `sma_strategy_optimization.py`
    脚本中找到修改后策略的示例。
- en: 'The following list provides details of modifications to the code (we only show
    the relevant ones, as the bulk of the code is identical to the code used before):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表提供了代码修改的详细信息（我们只展示相关部分，因为大部分代码与之前使用的代码相同）：
- en: 'Instead of using `cerebro.addstrategy`, we use `cerebro.optstrategy`, and provide
    the defined strategy object and the range of parameter values:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不使用 `cerebro.addstrategy`，而是使用 `cerebro.optstrategy`，并提供定义的策略对象和参数值范围：
- en: '[PRE26]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We modify the `stop` method to also log the considered value of the `ma_period`
    parameter.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们修改了 `stop` 方法，使其也记录 `ma_period` 参数的考虑值。
- en: 'We increase the number of CPU cores when running the extended backtesting:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行扩展回测时，我们增加了 CPU 核心数：
- en: '[PRE27]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We present the results in the following summary (please bear in mind that the
    order of parameters can be shuffled when using multiple cores):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下总结中展示了结果（请记住，当使用多个核心时，参数的顺序可能会被打乱）：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We see that the strategy performed best when we used 27 days for calculating
    the SMA.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现，当使用 27 天计算 SMA 时，策略表现最佳。
- en: We should always keep in mind that tuning the hyperparameters of a strategy
    comes together with a higher risk of overfitting!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终牢记，调整策略的超参数会带来更高的过拟合风险！
- en: See also
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'You can refer to the following book for more information about algorithmic
    trading and building successful trading strategies:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下书籍，以获取有关算法交易和构建成功交易策略的更多信息：
- en: 'Chan, E. (2013). *Algorithmic Trading: Winning Strategies and Their Rationale*
    (Vol. 625). John Wiley & Sons.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Chan, E. (2013). *Algorithmic Trading: Winning Strategies and Their Rationale*
    (第 625 卷)。John Wiley & Sons 出版社。'
- en: Backtesting a long/short strategy based on the RSI
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于 RSI 的多空策略回测
- en: The **relative strength index** (**RSI**) is an indicator that uses the closing
    prices of an asset to identify oversold/overbought conditions. Most commonly,
    the RSI is calculated using a 14-day period, and it is measured on a scale from
    0 to 100 (it is an oscillator). Traders usually buy an asset when it is oversold
    (if the RSI is below 30), and sell when it is overbought (if the RSI is above
    70). More extreme high/low levels, such as 80-20, are used less frequently and,
    at the same time, imply stronger momentum.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**相对强弱指数** (**RSI**) 是一个利用资产的收盘价来识别超买/超卖状态的指标。通常，RSI使用14天的时间段进行计算，范围从0到100（它是一个振荡器）。交易者通常在RSI低于30时买入资产（超卖），在RSI高于70时卖出资产（超买）。较极端的高/低水平，如80-20，使用得较少，并且通常意味着更强的市场动能。'
- en: 'In this recipe, we build a trading strategy with the following rules:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们构建了一个遵循以下规则的交易策略：
- en: We can go long and short.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以同时做多仓和空仓。
- en: For calculating the RSI, we use 14 periods (trading days).
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算RSI时，我们使用14个周期（交易日）。
- en: Enter a long position if the RSI crosses the lower threshold (standard value
    of 30) upward; exit the position when the RSI becomes larger than the middle level
    (value of 50).
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当RSI突破下限（标准值为30）向上时，进入多仓；当RSI大于中位数（值为50）时，退出仓位。
- en: Enter a short position if the RSI crosses the upper threshold (standard value
    of 70) downward; exit the position when the RSI becomes smaller than 50.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当RSI突破上限（标准值为70）向下时，进入空仓；当RSI小于50时，退出仓位。
- en: Only one position can be open at a time.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次只能开一个仓位。
- en: We evaluate the strategy on Meta’s stock in 2021 and apply a commission of 0.1%.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在2021年对Meta的股票进行策略评估，并应用0.1%的佣金。
- en: How to do it…
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Execute the following steps to implement and backtest a strategy based on the
    RSI:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现并回测基于RSI的策略：
- en: 'Import the libraries:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入库：
- en: '[PRE29]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define the signal strategy based on `bt.SignalStrategy`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于`bt.SignalStrategy`定义信号策略：
- en: '[PRE30]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Download data:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载数据：
- en: '[PRE31]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Set up and run the backtest:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置并运行回测：
- en: '[PRE32]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After running the snippet, we see the following output:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码片段后，我们看到以下输出：
- en: '[PRE33]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Plot the results:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制结果：
- en: '[PRE34]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Running the snippet generates the following plot:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码片段生成如下图表：
- en: '![](../Images/B18112_12_05.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_12_05.png)'
- en: 'Figure 12.5: Summary of our strategy’s behavior/performance over the backtested
    period'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：我们策略在回测期间的行为/表现总结
- en: We look at the triangles in pairs. The first triangle in a pair indicates opening
    a position (going long if the triangle is green and facing up; going short if
    the triangle is red and facing down). The next triangle in the opposite direction
    indicates closing of a position. We can match the opening and closing of positions
    with the RSI located in the lower part of the chart. Sometimes, there are multiple
    triangles of the same color in sequence. That is because the RSI fluctuates around
    the line of opening a position, crossing it multiple times. But the actual position
    is only opened on the first instance of a signal (no accumulation is the default
    setting of all backtests).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察成对的三角形。每对中的第一个三角形表示开仓（如果三角形是绿色且朝上，则开多仓；如果三角形是红色且朝下，则开空仓）。接下来的相反方向的三角形表示平仓。我们可以将开仓和平仓与图表下方的RSI对照。有时，同色的三角形会连续出现。这是因为RSI在开仓线附近波动，多次穿越该线。但实际的开仓仅发生在信号首次出现时（默认情况下，所有回测不进行累积）。
- en: How it works...
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In this recipe, we presented the second approach to defining strategies in `backtrader`,
    that is, using signals. A signal is represented as a number, for example, the
    difference between the current data point and some TA indicator. If the signal
    is positive, it is an indication to go long (buy). A negative one is an indication
    to take a short position (sell). The value of 0 means there is no signal.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们展示了在`backtrader`中定义策略的第二种方法，即使用信号。信号表现为一个数字，例如当前数据点与某个技术分析指标的差值。如果信号为正，表示开多仓（买入）。如果信号为负，表示开空仓（卖出）。信号值为0表示没有信号。
- en: After importing the libraries and the helper functions, we defined the trading
    strategy using `bt.SignalStrategy`. As this is a strategy involving multiple signals
    (various entry/exit conditions), we had to use `bt.SignalStrategy` instead of
    simply `bt.Signal`. First, we defined the indicator (RSI), with selected arguments.
    We also added the second instance of the RSI indicator, just to show that `backtrader`
    provides an easy way to use indicators from the popular TA-Lib library (the library
    must be installed for the code to work). The trading strategy does not depend
    on this second indicator—it is only plotted for reference. In general, we could
    add an arbitrary number of indicators.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 导入库和辅助函数后，我们使用`bt.SignalStrategy`定义了交易策略。由于这是一个涉及多个信号（各种进出场条件）的策略，我们不得不使用`bt.SignalStrategy`而不是简单的`bt.Signal`。首先，我们定义了指标（RSI），并选择了相应的参数。我们还添加了第二个RSI指标实例，仅仅是为了展示`backtrader`提供了一个简便的方式来使用流行的TA-Lib库中的指标（必须安装该库才能使代码正常工作）。该交易策略并不依赖于第二个指标——它仅用于参考绘图。通常来说，我们可以添加任意数量的指标。
- en: Even when adding indicators for reference only, their existence influences the
    “warm-up period.” For example, if we additionally included a 200-day SMA indicator,
    no trade would be carried out before there exists at least one value for the SMA
    indicator.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 即使仅添加指标作为参考，它们的存在也会影响“预热期”。例如，如果我们额外包括了一个200日SMA指标，则在SMA指标至少有一个值之前，任何交易都不会执行。
- en: The next step was to define signals. To do so, we used the `bt.CrossUp`/`bt.CrossDown`
    indicators, which returned 1 if the first series (price) crossed the second (upper
    or lower RSI threshold) from below/above, respectively. For entering a short position,
    we made the signal negative, by adding a minus in front of the `bt.CrossDown`
    indicator.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义信号。为此，我们使用了`bt.CrossUp`/`bt.CrossDown`指标，当第一个系列（价格）从下方/上方穿越第二个系列（RSI的上限或下限）时，分别返回1。为了进入空仓，我们通过在`bt.CrossDown`指标前加上负号来使信号变为负值。
- en: We can disable printing any indicator, by adding `plot=False` to the function
    call.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在函数调用中添加`plot=False`来禁用任何指标的打印。
- en: 'The following is a description of the available signal types:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可用信号类型的描述：
- en: '`LONGSHORT`: This type takes into account both long and short indications from
    the signal.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LONGSHORT`: 此类型同时考虑了来自信号的多仓和空仓指示。'
- en: '`LONG`: Positive signals indicate going long; negative ones are used for closing
    the long position.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LONG`: 正向信号表示开多仓；负向信号用于平多仓。'
- en: '`SHORT`: Negative signals indicate going short; positive ones are used for
    closing the short position.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHORT`: 负向信号表示开空仓；正向信号用于平空仓。'
- en: '`LONGEXIT`: A negative signal is used to exit a long position.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LONGEXIT`: 负向信号用于平多仓。'
- en: '`SHORTEXIT`: A positive signal is used to exit a short position.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHORTEXIT`: 正向信号用于平空仓。'
- en: 'Exiting positions can be more complex, which in turn enables users to build
    more sophisticated strategies. We describe the logic below:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 平仓可能更为复杂，这反过来允许用户构建更复杂的策略。我们在下面描述了其逻辑：
- en: '`LONG`: If there is a `LONGEXIT` signal, it is used for exiting the long position,
    instead of the behavior mentioned above. If there is a `SHORT` signal and no `LONGEXIT`
    signal, the `SHORT` signal is used to close the long position before opening a
    short one.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LONG`: 如果出现`LONGEXIT`信号，则用于平多仓，而不是上面提到的行为。如果出现`SHORT`信号且没有`LONGEXIT`信号，则使用`SHORT`信号先平多仓，然后再开空仓。'
- en: '`SHORT`: If there is a `SHORTEXIT` signal, it is used for exiting the short
    position, instead of the behavior mentioned above. If there is a `LONG` signal
    and no `SHORTEXIT` signal, the `LONG` signal is used to close the short position
    before opening a long one.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHORT`: 如果出现`SHORTEXIT`信号，则用于平空仓，而不是上面提到的行为。如果出现`LONG`信号且没有`SHORTEXIT`信号，则使用`LONG`信号先平空仓，然后再开多仓。'
- en: As you might have already realized, the signal is calculated for every time
    point (as visualized at the bottom of the plot), which effectively creates a continuous
    stream of positions to be opened/closed (the signal value of 0 is not very likely
    to happen). That is why, by default, `backtrader` disables accumulation (the constant
    opening of new positions, even when we have one already opened) and concurrency
    (generating new orders without hearing back from the broker whether the previously
    submitted ones were executed successfully).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经意识到的，信号会在每个时间点计算（如图表底部所示），这实际上会创建一个连续的开盘/平仓信号流（信号值为0的情况不太可能发生）。因此，`backtrader`默认禁用累积（即使已有仓位，也不断开新仓）和并发（在没有收到经纪商反馈之前生成新订单）。
- en: 'As the last step of defining the strategy, we added tracking of all the signals,
    by using the `signal_add` method. For exiting the positions, the conditions we
    used (RSI value higher/lower than 50) resulted in a Boolean, which we had to negate
    when exiting a long position: in Python, `-True` has the same meaning as `-1`.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义策略的最后一步，我们通过使用`signal_add`方法跟踪所有信号。对于平仓，我们使用的条件（RSI值高于/低于50）会产生一个布尔值，当退出多头仓位时，我们必须将其取反：在Python中，`-True`与`-1`的意义相同。
- en: In *Step 3*, we downloaded Meta’s stock prices from 2021.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们下载了2021年Meta的股票价格。
- en: 'Then, we set up the backtest. Most of the steps should already be familiar,
    that is why we focus only on the new ones:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置了回测。大部分步骤应该已经很熟悉了，因此我们只关注新的部分：
- en: Adding a sizer using the `addsizer` method—we did not have to do it at this
    point, as by default, `backtrader` uses the stake of 1, that is, 1 unit of the
    asset will be purchased/sold. However, we wanted to show at which point we can
    modify the order size when creating a trading strategy using the signal approach.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`addsizer`方法添加一个Sizer——在这一点上我们不必这么做，因为`backtrader`默认使用1的头寸，也就是说，每次交易会买卖1单位资产。然而，我们希望展示在使用信号法创建交易策略时，在哪个时刻可以修改订单大小。
- en: Setting up the commission to 0.1% using the `setcommission` method of the `broker`.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`broker`的`setcommission`方法将佣金设置为0.1%。
- en: We also accessed and printed the portfolio’s current value before and after
    running the backtest. To do so, we used the `getvalue` method of `broker`.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还在回测运行前后访问并打印了投资组合的当前价值。为此，我们使用了`broker`的`getvalue`方法。
- en: In the very last step, we plotted the results of the backtest.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们绘制了回测结果。
- en: There’s more…
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: In this recipe, we have introduced a couple of new concepts to the backtesting
    framework—sizers and commission. There are a few more useful things we can experiment
    with using those two components.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们向回测框架引入了几个新概念——Sizer和佣金。使用这两个组件，我们可以进行更多有趣的实验。
- en: Going “all-in”
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全部押注
- en: 'Before, our simple strategy only went long or short with a single unit of the
    asset. However, we can easily modify this behavior to use all the available cash.
    We simply add the `AllInSizer` sizer using the `addsizer` method:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们的简单策略仅仅是以单个单位的资产进行多头或空头操作。然而，我们可以轻松修改这一行为，利用所有可用的现金。我们只需通过`addsizer`方法添加`AllInSizer`
    Sizer：
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Running the backtest generates the following result:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 运行回测生成了以下结果：
- en: '[PRE36]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The result is clearly better than what we achieved using only a single unit
    at a time.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显然比我们每次只使用单个单位时的表现要好。
- en: Fixed commission per share
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每股固定佣金
- en: In our initial backtest of the RSI-based strategy, we used a 0.1% commission
    fee. However, some brokers might have a different commission scheme, for example,
    a fixed commission per share.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对基于RSI的策略进行初步回测时，我们使用了0.1%的佣金费用。然而，一些经纪商可能有不同的佣金方案，例如，每股固定佣金。
- en: 'To incorporate such information, we need to define a custom class storing the
    commission scheme. We can inherit from `bt.CommInfoBase` and add the required
    information:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了融入这些信息，我们需要定义一个自定义类来存储佣金方案。我们可以从`bt.CommInfoBase`继承并添加所需的信息：
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The most important aspects of the definition are the fixed commission of $0.03
    per share and the way that the commission is calculated in the `_getcommission`
    method. We take the absolute value of the size and multiply it by the fixed commission.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 定义中的最重要的方面是每股固定佣金为0.03美元以及在`_getcommission`方法中计算佣金的方式。我们取大小的绝对值，并将其乘以固定佣金。
- en: 'We can then easily input that information into the backtest. Building on top
    of the previous example with the “all-in” strategy, the code would look as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以轻松地将这些信息输入回测。在前面的“全部投入”策略示例的基础上，代码如下所示：
- en: '[PRE38]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With the following result:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These numbers lead to the conclusion that the 0.01% commission was actually
    higher than 3 cents per share.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字得出结论：0.01%的佣金实际上比每股3美分还要高。
- en: Fixed commission per order
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每单固定佣金
- en: Other brokers might offer a fixed commission per order. In the following snippet,
    we define a custom commission scheme in which we pay $2.5 per order, regardless
    of its size.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 其他经纪商可能会提供每单固定的佣金。在以下代码片段中，我们定义了一个自定义佣金方案，每单支付2.5美元，不管订单大小。
- en: 'We changed the value of the `commission` parameter and the way commission is
    calculated in the `_getcommission` method. This time, this method always returns
    the $2.5 we specified before:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更改了`commission`参数的值以及在`_getcommission`方法中佣金的计算方式。这一次，该方法始终返回我们之前指定的2.5美元：
- en: '[PRE40]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We do not include the backtest setup, as it would be almost identical to the
    previous one. We only need to pass a different class using the `addcommissioninfo`
    method. The result of the backtest is:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不包括回测设置，因为它几乎与之前的相同。我们只需要通过`addcommissioninfo`方法传递一个不同的类。回测结果是：
- en: '[PRE41]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: See also
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'Below, you might find useful references to `backtrader`''s documentation:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些有用的`backtrader`文档参考：
- en: 'To read more about sizers: [https://www.backtrader.com/docu/sizers-reference/](https://www.backtrader.com/docu/sizers-reference/)'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于资金分配器的信息：[https://www.backtrader.com/docu/sizers-reference/](https://www.backtrader.com/docu/sizers-reference/)
- en: 'To read more about commission schemes and the available parameters: [https://www.backtrader.com/docu/commission-schemes/commission-schemes/](https://www.backtrader.com/docu/commission-schemes/commission-schemes/
    )'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于佣金方案和可用参数的信息：[https://www.backtrader.com/docu/commission-schemes/commission-schemes/](https://www.backtrader.com/docu/commission-schemes/commission-schemes/)
- en: Backtesting a buy/sell strategy based on Bollinger bands
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于布林带的买卖策略回测
- en: Bollinger bands are a statistical method, used for deriving information about
    the prices and volatility of a certain asset over time. To obtain the Bollinger
    bands, we need to calculate the moving average and standard deviation of the time
    series (prices), using a specified window (typically 20 days). Then, we set the
    upper/lower bands at K times (typically 2) the moving standard deviation above/below
    the moving average.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 布林带是一种统计方法，用于推导某一资产在一段时间内的价格和波动性信息。为了得到布林带，我们需要计算时间序列（价格）的移动平均和标准差，使用指定的窗口（通常为20天）。然后，我们将上/下布林带设置为移动标准差的K倍（通常为2），分别位于移动平均值的上下方。
- en: 'The interpretation of the bands is quite simple: the bands widen with an increase
    in volatility and contract with a decrease in volatility.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 布林带的解释非常简单：带宽随着波动性的增加而变宽，随着波动性的减少而收窄。
- en: 'In this recipe, we build a simple trading strategy that uses Bollinger bands
    to identify underbought and oversold levels and then trade based on those areas.
    The rules of the strategy are as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们构建了一个简单的交易策略，利用布林带识别超买和超卖的水平，然后基于这些区域进行交易。策略规则如下：
- en: Buy when the price crosses the lower Bollinger band upward.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当价格向上突破下布林带时，进行买入。
- en: Sell (only if stocks are in possession) when the price crosses the upper Bollinger
    band downward.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当价格向下突破上布林带时，卖出（仅当持有股票时）。
- en: All-in strategy—when creating a buy order, buy as many shares as possible.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全部投入策略——在创建买入订单时，尽可能购买尽量多的股票。
- en: Short selling is not allowed.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许卖空。
- en: We evaluate the strategy on Microsoft’s stock in 2021\. Additionally, we set
    the commission to be equal to 0.1%.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们评估了2021年微软股票的策略。此外，我们将佣金设置为0.1%。
- en: How to do it...
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Execute the following steps to implement and backtest a strategy based on the
    Bollinger bands:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来实现并回测一个基于布林带的策略：
- en: 'Import the libraries:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入库：
- en: '[PRE42]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To make the code more readable, we first present the general outline of the
    class defining the trading strategy and then introduce the separate methods in
    the following substeps.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了让代码更具可读性，我们首先展示定义交易策略的类的大致框架，然后在接下来的子步骤中介绍各个方法。
- en: 'Define the strategy based on the Bollinger bands:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于布林带定义策略：
- en: '[PRE43]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When defining strategies using the strategy approach, there is quite some boilerplate
    code. That is why in the following substeps, we only mention the methods that
    are different from the ones we have previously explained. You can also find the
    strategy’s entire code in the book’s GitHub repository:'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用策略方法定义策略时，有相当多的样板代码。因此，在以下子步骤中，我们只提及与之前解释的不同的方法。你也可以在本书的GitHub仓库中找到策略的完整代码：
- en: 'The `__init__` method is defined as:'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__init__`方法定义如下：'
- en: '[PRE44]'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `next_open` method is defined as:'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`next_open`方法定义如下：'
- en: '[PRE45]'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Download data:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载数据：
- en: '[PRE46]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Set up the backtest:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置回测：
- en: '[PRE47]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Run the backtest:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行回测：
- en: '[PRE48]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Running the backtest generates the following (abbreviated) log:'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行回测生成以下（简化版）日志：
- en: '[PRE49]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Plot the results:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制结果：
- en: '[PRE50]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Running the snippet generates the following plot:'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码片段会生成以下图表：
- en: '![](../Images/B18112_12_06.png)'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](../Images/B18112_12_06.png)'
- en: 'Figure 12.6: Summary of our strategy’s behavior/performance over the backtested
    period'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.6：我们策略在回测期间的行为/表现总结
- en: We can see that the strategy managed to make money, even after accounting for
    commission costs. The flat periods in the portfolio’s value represent periods
    when we did not have an open position.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到，即使考虑到佣金成本，策略也能赚钱。投资组合价值中的平坦期代表我们没有持仓的时期。
- en: 'Investigate different returns metrics:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调查不同的回报度量：
- en: '[PRE51]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Running the code generates the following output:'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码生成以下输出：
- en: '[PRE52]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Extract daily portfolio returns and plot them:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取每日投资组合回报并绘制：
- en: '[PRE53]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![](../Images/B18112_12_07.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_12_07.png)'
- en: 'Figure 12.7: Daily portfolio returns of the strategy based on Bollinger bands'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：基于布林带的策略的每日投资组合回报
- en: We can see that the flat periods in the portfolio’s returns in *Figure 12.7*
    correspond to the periods during which we had no open positions, as can be seen
    in *Figure 12.6*.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，投资组合回报中的平坦期（见*图12.7*）与我们没有持仓的时期相对应，正如在*图12.6*中所示。
- en: How it works...
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are a lot of similarities between the code used for creating the Bollinger
    bands-based strategy and that used in the previous recipes. That is why we only
    discuss the novelties and refer you to the *Event-driven backtesting with backtrader*
    recipe for more details.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 创建基于布林带的策略所用的代码与之前配方中的代码有很多相似之处。这就是为什么我们只讨论新颖之处，并将更多细节参考给*基于事件驱动的回测（使用backtrader）*配方的原因。
- en: As we were going all-in in this strategy, we had to use a method called `cheat_on_open`.
    This means that we calculated the signals using day *t*’s close price, but calculated
    the number of shares we wanted to buy based on day *t+1*’s open price. To do so,
    we had to set `cheat_on_open=True` when instantiating the `Cerebro` object.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这个策略中进行了全力投资，因此我们必须使用一种名为`cheat_on_open`的方法。这意味着我们使用*第t*天的收盘价计算信号，但根据*第t+1*天的开盘价计算我们希望购买的股份数量。为此，在实例化`Cerebro`对象时，我们需要设置`cheat_on_open=True`。
- en: As a result, we also defined a `next_open` method instead of `next` within the
    `Strategy` class. This clearly indicated to `Cerebro` that we were cheating on
    open. Before creating a potential buy order, we manually calculated the maximum
    number of shares we could buy using the open price from day *t+1*.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们还在`Strategy`类中定义了一个`next_open`方法，而不是使用`next`。这明确地向`Cerebro`表明我们在开盘时进行了作弊。在创建潜在的买单之前，我们手动计算了使用*第t+1天*的开盘价可以购买的最大股份数量。
- en: 'When calculating the buy/sell signals based on the Bollinger bands, we used
    the `CrossOver` indicator. It returned the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于布林带计算买入/卖出信号时，我们使用了`CrossOver`指标。它返回了以下内容：
- en: 1 if the first data (price) crossed the second data (indicator) upward
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一组数据（价格）上穿第二组数据（指标），则返回1
- en: -1 if the first data (price) crossed the second data (indicator) downward
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一组数据（价格）下穿第二组数据（指标），则返回-1
- en: 'We can also use `CrossUp` and `CrossDown` functions when we want to consider
    crossing from only one direction. The buy signal would look like this: `self.buy_signal
    = bt.ind.CrossUp(self.datas[0], self.b_band.lines.bot)`.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`CrossUp`和`CrossDown`函数，当我们只希望考虑单向穿越时。买入信号如下：`self.buy_signal = bt.ind.CrossUp(self.datas[0],
    self.b_band.lines.bot)`。
- en: 'The last addition included utilizing analyzers—`backtrader` objects that help
    to evaluate what is happening with the portfolio. In this recipe, we used two
    analyzers:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的补充内容包括使用分析器——`backtrader`对象，帮助评估投资组合的表现。在此配方中，我们使用了两个分析器：
- en: '`Returns`: A collection of different logarithmic returns, calculated over the
    entire timeframe: total compound return, the average return over the entire period,
    and the annualized return.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Returns`：一组不同的对数收益率，计算覆盖整个时间范围：总复合收益率、整个期间的平均收益率和年化收益率。'
- en: '`TimeReturn`: A collection of returns over time (using a provided timeframe,
    in this case, daily data).'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimeReturn`：一组随时间变化的收益率（使用提供的时间范围，在本例中为每日数据）。'
- en: 'We can obtain the same result as from the `TimeReturn` analyzer by adding an
    observer with the same name: `cerebro.addobserver(bt.observers.TimeReturn)`. The
    only difference is that the observer will be plotted on the main results plot,
    which is not always desired.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加一个同名观察器来获得与`TimeReturn`分析器相同的结果：`cerebro.addobserver(bt.observers.TimeReturn)`。唯一的区别是观察器会显示在主要结果图表上，这并非总是我们所希望的。
- en: There’s more…
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: 'We have already seen how to extract the daily returns from the backtest. This
    creates a perfect opportunity to combine that information with the functionalities
    of the `quantstats` library. Using the following snippet, we can calculate a variety
    of metrics to evaluate our portfolio’s performance in detail. Additionally, we
    compare the performance of our strategy to a simple buy-and-hold strategy (which,
    for simplicity, does not include the transaction costs):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何从回测中提取每日收益率。这为将这些信息与`quantstats`库的功能结合提供了一个绝佳机会。使用以下代码片段，我们可以计算多种指标，详细评估我们的投资组合表现。此外，我们还会将策略表现与简单的买入并持有策略进行对比（为了简化，买入并持有策略没有包括交易成本）：
- en: '[PRE54]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Running the snippet generates the following report:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该代码片段将生成以下报告：
- en: '[PRE55]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: For brevity’s sake, we only present the few main pieces of information available
    in the report.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为简洁起见，我们只展示报告中可用的几条主要信息。
- en: In *Chapter 11*, *Asset Allocation*, we mentioned that an alternative library
    to `quantstats` is `pyfolio`. The latter has the potential disadvantage of not
    being actively maintained anymore. However, `pyfolio` is nicely integrated with
    `backtrader`. We can easily add a dedicated analyzer (`bt.analyzers.PyFolio`).
    For an example of implementation, please see the book’s GitHub repository.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第11章*，*资产配置*中，我们提到过，`quantstats`的一个替代库是`pyfolio`。后者的潜在缺点是它已经不再积极维护。然而，`pyfolio`与`backtrader`的集成非常好。我们可以轻松添加一个专用分析器（`bt.analyzers.PyFolio`）。有关实现的示例，请参见本书的GitHub仓库。
- en: Backtesting a moving average crossover strategy using crypto data
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用加密数据回测移动平均交叉策略
- en: 'So far, we have created and backtested a few strategies on stocks. In this
    recipe, we cover another popular asset class—cryptocurrencies. There are a few
    key differences in handling crypto data:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建并回测了几种股票策略。在本篇中，我们讨论了另一类流行的资产——加密货币。处理加密数据时有一些关键的区别：
- en: Cryptos can be traded 24/7
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密货币可以进行24/7交易。
- en: Cryptos can be traded using fractional units
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密货币可以使用部分单位进行交易。
- en: As we want our backtests to closely resemble real-life trading, we should account
    for those crypto-specific characteristics in our backtests. Fortunately, the `backtrader`
    framework is very flexible and we can slightly adjust our already-established
    approach to handle this new asset class.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望回测尽可能接近真实交易，因此我们应当在回测中考虑这些加密货币特有的特点。幸运的是，`backtrader`框架非常灵活，我们可以稍微调整已有的方法来处理这种新资产类别。
- en: Some brokers also allow for buying fractional shares of stocks.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 一些经纪商也允许购买股票的部分股份。
- en: 'In this recipe, we backtest a moving average crossover strategy with the following
    rules:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本篇中，我们回测了一种移动平均交叉策略，规则如下：
- en: We are only interested in Bitcoin and use daily data from 2021.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只关心比特币，并使用来自2021年的每日数据。
- en: We use two moving averages with window sizes of 20-days (fast one) and 50-days
    (slow one).
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用两种不同的移动平均线，窗口期分别为20天（快速）和50天（慢速）。
- en: If the fast MA crosses over the slow one upward, we allocate 70% of available
    cash to buying BTC.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果快速移动平均线向上穿越慢速移动平均线，我们将把70%的可用现金分配用于购买比特币。
- en: If the fast MA crosses over the slow one downward, we sell all the BTC we have.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果快速移动平均线下穿慢速移动平均线，我们会卖出所有持有的比特币。
- en: Short selling is not allowed.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许进行卖空交易。
- en: How to do it…
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Execute the following steps to implement and backtest a strategy based on the
    moving average crossover:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来实现并回测基于移动平均交叉的策略：
- en: 'Import the libraries:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的库：
- en: '[PRE56]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Define the commission scheme allowing for fractional trades:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义允许进行部分交易的佣金方案：
- en: '[PRE57]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: To make the code more readable, we first present the general outline of the
    class defining the trading strategy and then introduce the separate methods in
    the following substeps.
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了提高代码的可读性，我们首先展示定义交易策略的类的大纲，然后在以下的子步骤中介绍各个独立的方法。
- en: 'Define the SMA crossover strategy:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义SMA交叉策略：
- en: '[PRE58]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `__init__` method is defined as:'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__init__`方法定义如下：'
- en: '[PRE59]'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `next` method is defined as:'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`next`方法定义如下：'
- en: '[PRE60]'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Download the `BTC-USD` data:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载`BTC-USD`数据：
- en: '[PRE61]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Set up the backtest:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置回测：
- en: '[PRE62]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Run the backtest:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行回测：
- en: '[PRE63]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Running the snippet generates the following (abbreviated) log:'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码片段会生成以下（简化的）日志：
- en: '[PRE64]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the excerpt from the full log, we can see that we are now operating with
    fractional positions. Also, the strategy has generated quite significant returns—we
    have approximately quadrupled the initial portfolio’s value.
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在完整日志的摘录中，我们可以看到现在我们正使用分数仓位进行操作。此外，策略已经产生了相当可观的回报——我们大约将初始投资组合的价值翻了四倍。
- en: 'Plot the results:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制结果：
- en: '[PRE65]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Running the snippet generates the following plot:'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码片段会生成以下图表：
- en: '![](../Images/B18112_12_08.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B18112_12_08.png)'
- en: 'Figure 12.8: Summary of our strategy’s behavior/performance over the backtested
    period'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：我们的策略在回测期间的行为/表现总结
- en: We have already established that we have generated >300% returns using our strategy.
    However, we can also see in *Figure 12.8* that the great performance might simply
    be due to the gigantic increase in BTC’s price over the considered period.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经证明，使用我们的策略，我们获得了超过300%的回报。然而，我们也可以在*图12.8*中看到，出色的表现可能仅仅是因为在考虑的期间内，比特币（BTC）价格的大幅上涨。
- en: Using code identical to the code used in the previous recipe, we can compare
    the performance of our strategy to the simple buy-and-hold strategy. This way,
    we can verify how our active strategy performed compared to a static benchmark.
    We present the abbreviated performance comparison below, while the code can be
    found in the book’s GitHub repository.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与之前示例中相同的代码，我们可以将我们的策略与简单的买入并持有策略进行比较。通过这种方式，我们可以验证我们的主动策略与静态基准的表现差异。下面展示的是简化的表现对比，代码可以在书中的GitHub仓库找到。
- en: '[PRE66]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Unfortunately, our strategy did not outperform the benchmark over the analyzed
    timeframe. This confirms our initial suspicion that the good performance is connected
    to the increase in BTC’s price over the considered period.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们的策略在分析的时间框架内并没有超过基准。这证实了我们最初的怀疑，即优异的表现与在考虑的期间内比特币价格的上涨有关。
- en: How it works…
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: After importing the libraries, we defined a custom commission scheme in order
    to allow for fractional shares. Before, when we created a custom commission scheme,
    we inherited from `bt.CommInfoBase` and we modified the `_getcommission` method.
    This time, we inherited from `bt.CommissionInfo` and modified the `getsize` method
    to return a fractional value depending on the available cash and the asset’s price.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入库之后，我们定义了一个自定义的佣金方案，以允许分数股份。在之前创建自定义佣金方案时，我们是从`bt.CommInfoBase`继承，并修改了`_getcommission`方法。这一次，我们从`bt.CommissionInfo`继承，并修改了`getsize`方法，以根据可用现金和资产价格返回分数值。
- en: In *Step 3* (and its substeps) we defined the moving average crossover strategy.
    By this recipe, most of the code will already look very familiar. A new thing
    we have applied here is the different type of order, that is, `order_target_percent`.
    Using this type of order indicates that we want the given asset to be X% of our
    portfolio.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*（及其子步骤）中，我们定义了移动平均交叉策略。通过这个示例，大部分代码应该已经非常熟悉。我们在这里应用的一个新概念是不同类型的订单，也就是`order_target_percent`。使用这种类型的订单表示我们希望给定资产在我们的投资组合中占有X%的比例。
- en: It is a very convenient method because we leave the exact order size calculations
    to `backtrader`. If, at the moment of issuing the order, we are below the specified
    target percentage, we will buy more of the asset. If we are above it, we will
    sell some amount of the asset.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常方便的方法，因为我们将精确的订单大小计算交给了`backtrader`。如果在发出订单时，我们低于指定的目标百分比，我们将购买更多的资产；如果我们超过了该比例，我们将卖出一部分资产。
- en: For exiting the position, we indicate that we want BTC to be 0% of our portfolio,
    which is equivalent to selling all we have. By using `order_target_percent` with
    the target of zero, we do not have to track/access the current number of units
    we possess.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 为了退出仓位，我们表示希望比特币（BTC）在我们的投资组合中占0%，这相当于卖出我们所有持有的比特币。通过使用目标为零的`order_target_percent`，我们无需跟踪/访问当前持有的单位数量。
- en: In *Step 4*, we downloaded the daily BTC prices (in USD) from 2021\. In the
    following steps, we set up the backtest, ran it, and plotted the results. The
    only thing worth mentioning is that we had to add the custom commission scheme
    (containing the fractional share logic) using the `addcommissioninfo` method.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '在*步骤 4*中，我们下载了2021年每日的BTC价格（以美元计）。在接下来的步骤中，我们设置了回测，运行了回测，并绘制了结果。唯一值得提到的是，我们需要使用`addcommissioninfo`方法添加自定义佣金方案（包含部分股份逻辑）。  '
- en: There’s more…
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '还有更多内容…  '
- en: 'In the recipe, we have introduced the target order. `backtrader` offers three
    types of target orders:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '在本示例中，我们介绍了目标订单。`backtrader` 提供了三种类型的目标订单：  '
- en: '`order_target_percent`: Indicates the percentage of the current portfolio’s
    value we want to have in the given asset'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`order_target_percent`：表示我们希望在给定资产中拥有的当前投资组合价值的百分比。'
- en: '`order_target_size`: Indicates the target number of units of a given asset
    we want to have in the portfolio'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`order_target_size`：表示我们希望在投资组合中拥有的给定资产的目标单位数。  '
- en: '`order_target_value`: Indicates the asset’s target value in monetary units
    that we want to have in the portfolio'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`order_target_value`：表示我们希望在投资组合中拥有的资产目标金额（以货币单位表示）。  '
- en: Target orders are very useful when we know the target percentage/value/size
    of a given asset, but do not want to spend additional time calculating whether
    we should buy additional units or sell them to arrive at the target.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '目标订单在我们知道给定资产的目标百分比/价值/数量时非常有用，但不想花额外的时间计算是否应该购买更多单位或卖出它们以达到目标。  '
- en: There is also one more important thing to mention about fractional shares. In
    this recipe, we have defined a custom commission scheme that accounts for the
    fractional shares and then we used the target orders to buy/sell the asset. This
    way, when the engine was calculating the number of units to trade in order to
    arrive at the target, it knew it could use fractional values.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '还有一件关于部分股份的重要事情需要提到。在这个示例中，我们定义了一个自定义的佣金方案，考虑了部分股份的情况，然后使用目标订单来买入/卖出资产。这样，当引擎计算出为了达到目标需要交易的单位数量时，它知道可以使用部分值。  '
- en: However, there is another way of using fractional shares without defining a
    custom commission scheme. We simply need to manually calculate the number of shares
    we want to buy/sell and create an order with a given stake. We did something very
    similar in the previous recipe, but there, we rounded the potential fractional
    values to an integer. For an implementation of the SMA crossover strategy with
    manual fractional order size calculations, please refer to the book’s GitHub repository.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，还有一种不需要定义自定义佣金方案的方式来使用部分股份。我们只需手动计算我们想要买入/卖出的股份数量，并创建一个给定份额的订单。在前一个示例中，我们做了类似的操作，但那时我们将潜在的部分值四舍五入为整数。有关手动部分订单大小计算的SMA交叉策略实现，请参考本书的GitHub仓库。  '
- en: Backtesting a mean-variance portfolio optimization
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '对均值方差投资组合优化的回测  '
- en: In the previous chapter, we covered asset allocation and mean-variance optimization.
    Combining mean-variance optimization with a backtest would be an interesting exercise,
    especially because it involves working with multiple assets at once.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '在前一章中，我们讨论了资产配置和均值方差优化。将均值方差优化与回测结合起来将是一个有趣的练习，特别是因为它涉及同时处理多个资产。  '
- en: 'In this recipe, we backtest the following allocation strategy:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个示例中，我们回测了以下配置策略：  '
- en: We consider the FAANG stocks.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们考虑FAANG股票。  '
- en: Every Friday after the market closes, we find the tangency portfolio (maximizing
    the Sharpe ratio). Then, we create target orders to match the calculated optimal
    weights on Monday when the market opens.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '每周五市场收盘后，我们找到切线投资组合（最大化Sharpe比率）。然后，在市场周一开盘时，我们创建目标订单来匹配计算出的最佳权重。  '
- en: We assume we need to have at least 252 data points to calculate the expected
    returns and the covariance matrix (using the Ledoit-Wolf approach).
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们假设需要至少252个数据点来计算预期收益和协方差矩阵（使用Ledoit-Wolf方法）。  '
- en: For this exercise, we download the prices of the FAANG stocks from 2020 to 2021\.
    Due to the warm-up period we set up for calculating the weights, the trading actually
    happens only in 2021.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '对于这个练习，我们下载了2020到2021年的FAANG股票价格。由于我们为计算权重设置的预热期，实际的交易只发生在2021年。  '
- en: Getting ready
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '准备工作  '
- en: As we will be working with fractional shares in this recipe, we need to use
    the custom commission scheme (`FractionalTradesCommission`) defined in the previous
    recipe.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '由于在这个示例中我们将处理部分股份，我们需要使用在前一个示例中定义的自定义佣金方案（`FractionalTradesCommission`）。  '
- en: How to do it…
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '如何操作…  '
- en: 'Execute the following steps to implement and backtest a strategy based on the
    mean-variance portfolio optimization:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来实现并回测基于均值-方差投资组合优化的策略：
- en: 'Import the libraries:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入库：
- en: '[PRE67]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: To make the code more readable, we first present the general outline of the
    class defining the trading strategy and then introduce the separate methods in
    the following substeps.
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了提高代码的可读性，我们首先展示定义交易策略的类的一般框架，然后在以下子步骤中引入各个方法。
- en: 'Define the strategy:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义策略：
- en: '[PRE68]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `next` method is defined as:'
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`next`方法定义如下：'
- en: '[PRE69]'
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Download the prices of the FAANG stocks and store the data feeds in a list:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载FAANG股票的价格并将数据源存储在列表中：
- en: '[PRE70]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Set up the backtest:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置回测：
- en: '[PRE71]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Run the backtest:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行回测：
- en: '[PRE72]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Running the backtest generates the following log:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 运行回测后会生成如下日志：
- en: '[PRE73]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We will not spend time evaluating the strategy, as this would be very similar
    to what we did in the previous recipe. Thus, we leave it as a potential exercise
    for the reader. It could also be interesting to test the performance of this strategy
    against a benchmark *1/n* portfolio.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会花时间评估策略，因为这与我们在前一个示例中做的非常相似。因此，我们将其作为潜在的练习留给读者。测试该策略的表现是否优于基准*1/n*投资组合也是一个有趣的思路。
- en: It is worth mentioning that some of the orders failed. We will describe the
    reason for it in the following section.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，一些订单没有成功执行。我们将在下一节中描述原因。
- en: How it works…
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: After importing the libraries, we defined the strategy using mean-variance optimization.
    In the `__init__` method, we defined a counter that we used to determine if we
    had enough data points to run the optimization routine. The selected 252 days
    is arbitrary and you can experiment with different values.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入库后，我们使用均值-方差优化定义了策略。在`__init__`方法中，我们定义了一个计数器，用来判断是否有足够的数据点来执行优化过程。选择252天是随意的，你可以尝试不同的值。
- en: 'In the `next` method, there are multiple new components:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在`next`方法中，有多个新的组件：
- en: We first add 1 to the day counter and check if we have enough observations.
    If not, we simply proceed to the next trading day.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先将天数计数器加1，并检查是否有足够的观察数据。如果没有，我们就简单地跳到下一个交易日。
- en: We extract the current date from the price data and check if it is a Friday.
    If not, we proceed to the next trading day.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从价格数据中提取当前日期并检查是否为星期五。如果不是，我们就继续到下一个交易日。
- en: We calculate the current allocation by accessing the position size of each asset
    and multiplying it by the close price of the given day. Lastly, we divide each
    asset’s worth by the total portfolio’s value and print the weights.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过访问每个资产的头寸大小并将其乘以给定日期的收盘价来计算当前的配置。最后，我们将每个资产的价值除以总投资组合的价值，并打印权重。
- en: We need to extract the last 252 data points for each stock for our optimization
    routine. The `self.datas` object is an iterable containing all the data feeds
    we pass to `Cerebro` when setting up the backtest. We create a dictionary and
    populate it with arrays containing the 252 data points. We extract those using
    the `get` method. Then, we create a `pandas` DataFrame from the dictionary containing
    the prices.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要提取每只股票的最后252个数据点来进行优化过程。`self.datas`对象是一个可迭代的集合，包含我们在设置回测时传递给`Cerebro`的所有数据源。我们创建一个字典，并用包含252个数据点的数组填充它。然后，我们使用`get`方法提取这些数据。接着，我们从字典中创建一个包含价格的`pandas`数据框。
- en: We find the weights maximizing the Sharpe ratio using the `pypfopt` library.
    Please refer to the previous chapter for more details. We also print the new weights.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`pypfopt`库找到了最大化夏普比率的权重。更多细节请参考前一章节。我们还打印了新的权重。
- en: For each of the assets, we place a target order (using the `order_target_percent`
    method) with the target being the optimal portfolio weight. As we are working
    with multiple assets this time, we need to indicate for which asset we are placing
    an order. We do so by specifying the `data` argument.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个资产，我们使用`order_target_percent`方法下达目标订单，目标是最优投资组合权重。由于这次我们使用多个资产，因此需要指明为哪个资产下单。我们通过指定`data`参数来实现这一点。
- en: Under the hood, `backtrader` uses the `array` module for storing the matrix-like
    objects.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在背后，`backtrader`使用`array`模块来存储类似矩阵的对象。
- en: In *Step 3*, we created a list containing all the data feeds. We simply iterated
    over the tickers of the FAANG stocks, downloaded the data for each one of them,
    and appended the object to the list.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3步*中，我们创建了一个包含所有数据源的列表。我们简单地遍历了FAANG股票的代码，下载了每只股票的数据，并将该对象添加到列表中。
- en: In *Step 4*, we set up the backtest. A lot of the steps are already very familiar
    by now, including setting up the fractional shares commission scheme. The new
    component was adding the data, as we iteratively added each of the downloaded
    data feeds using the already covered `adddata` method. At this point, we also
    had to provide the name of the data feeds using the `name` argument.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4步*中，我们设置了回测。许多步骤现在已经非常熟悉，包括设置分数股的佣金方案。新的部分是添加数据，我们通过已经涵盖过的`adddata`方法，逐步添加每个下载的数据源。在这一过程中，我们还需要使用`name`参数提供数据源的名称。
- en: In the very last step, we ran the backtest. As we have mentioned before, the
    new thing we can observe here is the failing orders. These are caused by the fact
    that we are calculating the portfolio weights on Friday using the close prices
    and preparing the orders on the same day. On Monday’s market open, the prices
    are different, and not all the orders can be executed. We tried to account for
    that using fractional shares and setting the commission to 0, but the differences
    can still be too big for this simple approach to work. A possible solution would
    be to always keep some cash on the side to cover the potential price differences.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们运行了回测。正如我们之前提到的，新的情况是订单失败。这是因为我们在周五使用收盘价计算投资组合权重，并在同一天准备订单。然而，在周一的市场开盘时，价格发生了变化，导致并非所有订单都能执行。我们尝试使用分数股和将佣金设置为0来解决这一问题，但价格差异可能仍然过大，使得这种简单方法无法正常工作。一种可能的解决方案是始终保留一些现金，以应对潜在的价格差异。
- en: To do so, we could assume that we purchase the stocks with ~90% of our portfolio’s
    worth while keeping the rest in cash. For that, we could use the `order_target_value`
    method. We could calculate the target value for each asset using the portfolio
    weights and 90% of the monetary value of our portfolio. Alternatively, we could
    use the `DiscreteAllocation` approach of `pypfopt`, which we mentioned in the
    previous chapter.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可以假设用我们投资组合的约90%的价值购买股票，而将剩余部分保持为现金。为了实现这一点，我们可以使用`order_target_value`方法。我们可以使用投资组合的权重和投资组合价值的90%来计算每个资产的目标价值。或者，我们也可以使用`pypfopt`中的`DiscreteAllocation`方法，正如我们在前一章提到的那样。
- en: Summary
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have extensively covered the topic of backtesting. We started
    with the simpler approach, that is, vectorized backtesting. While it is not as
    rigorous and robust as the event-driven approach, it is often faster to implement
    and execute, due to its vectorized nature. Afterward, we combined the exploration
    of the event-driven backtesting framework with the knowledge we obtained in the
    previous chapters, for example, calculating various technical indicators and finding
    the optimal portfolio weights.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了回测的话题。我们从较简单的方式——矢量化回测开始。尽管它不像事件驱动方法那样严格和稳健，但由于其矢量化特性，通常实现和执行速度更快。之后，我们将事件驱动回测框架的探索与前几章获得的知识结合起来，例如计算各种技术指标和寻找最优的投资组合权重。
- en: 'We spent the most time using the `backtrader` library, due to its popularity
    and flexibility when it comes to implementing various scenarios. However, there
    are many alternative backtesting libraries on the market. You might also want
    to investigate the following:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了最多时间使用`backtrader`库，因为它在实现各种场景时具有广泛的应用和灵活性。然而，市场上有许多其他的回测库。你可能还想研究以下内容：
- en: '`vectorbt` ([https://github.com/polakowo/vectorbt](https://github.com/polakowo/vectorbt)):
    A `pandas`-based library for efficient backtesting of trading strategies at scale.
    The author of the library also offers a pro (paid) version of the library with
    more features and improved performance.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vectorbt` ([https://github.com/polakowo/vectorbt](https://github.com/polakowo/vectorbt)):
    一个基于`pandas`的库，用于大规模高效回测交易策略。该库的作者还提供了一个专业版（收费），具有更多功能和更高性能。'
- en: '`bt` ([https://github.com/pmorissette/bt](https://github.com/pmorissette/bt)):
    A library offering a framework based on reusable and flexible blocks containing
    the strategy’s logic. It supports multiple instruments and outputs detailed statistics
    and charts.'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bt` ([https://github.com/pmorissette/bt](https://github.com/pmorissette/bt)):
    一个提供基于可复用和灵活模块的框架的库，模块包含策略的逻辑。它支持多种工具，并输出详细的统计数据和图表。'
- en: '`backtesting.py` ([https://github.com/kernc/backtesting.py](https://github.com/kernc/backtesting.py)):
    A backtesting framework built on top of `backtrader`.'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backtesting.py` ([https://github.com/kernc/backtesting.py](https://github.com/kernc/backtesting.py)):
    一个建立在`backtrader`之上的回测框架。'
- en: '`fastquant` ([https://github.com/enzoampil/fastquant](https://github.com/enzoampil/fastquant)):
    A wrapper library around `backtrader` that aims to reduce the amount of boilerplate
    code we need to write in order to run a backtest for popular trading strategies,
    for example, the moving average crossover.'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fastquant` ([https://github.com/enzoampil/fastquant](https://github.com/enzoampil/fastquant)):
    一个围绕`backtrader`的包装库，旨在减少为流行交易策略（例如移动平均交叉）运行回测时需要编写的样板代码量。'
- en: '`zipline` ([https://github.com/quantopian/zipline](https://github.com/quantopian/zipline)
    / [https://github.com/stefan-jansen/zipline-reloaded](https://github.com/stefan-jansen/zipline-reloaded)):
    The library used to be the most popular (based on GitHub stars) and probably the
    most complex of the open-source backtesting libraries. However, as we have already
    mentioned, Quantopian was closed and the library is not maintained anymore. You
    can use the fork (`zipline-reloaded`) maintained by Stefan Jansen.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zipline` ([https://github.com/quantopian/zipline](https://github.com/quantopian/zipline)
    / [https://github.com/stefan-jansen/zipline-reloaded](https://github.com/stefan-jansen/zipline-reloaded)):
    该库曾是最受欢迎的回测库（基于GitHub星标），也可能是最复杂的开源回测库之一。然而，正如我们已经提到的，Quantopian已经关闭，该库也不再维护。你可以使用由Stefan
    Jansen维护的分支（`zipline-reloaded`）。'
- en: 'Backtesting is a fascinating field and there is much more to learn about it.
    Below, you can also find some very interesting references for more robust approaches
    to backtesting:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 回测是一个非常有趣的领域，值得深入学习。以下是一些非常有趣的参考资料，介绍了更稳健的回测方法：
- en: Bailey, D. H., Borwein, J., Lopez de Prado, M., & Zhu, Q. J. (2016). “The probability
    of backtest overfitting.” *Journal of Computational Finance, forthcoming*.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bailey, D. H., Borwein, J., Lopez de Prado, M., & Zhu, Q. J. (2016). “回测过拟合的概率。”
    *计算金融杂志，待刊*。
- en: 'Bailey, D. H., & De Prado, M. L. (2014). “The deflated Sharpe ratio: correcting
    for selection bias, backtest overfitting, and non-normality.” *The Journal of
    Portfolio Management*, *40* (5), 94-107.'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bailey, D. H., & De Prado, M. L. (2014). “调整夏普比率：修正选择偏差、回测过拟合和非正态性。” *投资组合管理杂志*,
    *40* (5), 94-107。
- en: 'Bailey, D. H., Borwein, J., Lopez de Prado, M., & Zhu, Q. J. (2014). “Pseudo-mathematics
    and financial charlatanism: The effects of backtest overfitting on out-of-sample
    performance.” *Notices of the American Mathematical Society*, *61* (5), 458-471.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bailey, D. H., Borwein, J., Lopez de Prado, M., & Zhu, Q. J. (2014). “伪数学与金融江湖术士：回测过拟合对样本外表现的影响。”
    *美国数学会通报*, *61* (5), 458-471。
- en: De Prado, M. L. (2018). *Advances in Financial Machine Learning*. John Wiley
    & Sons.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: De Prado, M. L. (2018). *金融机器学习的进展*. 约翰·威利与子公司。
