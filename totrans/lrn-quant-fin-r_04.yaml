- en: Chapter 3. Econometric and Wavelet Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In financial analytics, we need techniques to do predictive modeling for forecasting
    and finding the drivers for different target variables. In this chapter, we will
    discuss types of regression and how we can build a regression model in R for building
    predictive models. Also we will discuss, how we can implement a variable selection
    method and other aspects associated with regression. This chapter will not contain
    theoretical description but will just guide you in how to implement a regression
    model in R in the financial space. Regression analysis can be used for doing forecast
    on cross-sectional data in the financial domain. We will also cover frequency
    analysis of the data, and how transformations such as Fast Fourier, wavelet, Hilbert,
    haar transformations in time, and frequency domains help to remove noise in the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple linear regression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multivariate linear regression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multicollinearity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ANOVA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stepwise variable selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ranking of variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wavelet analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast Fourier transformation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hilbert transformation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple linear regression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In simple linear regression, we try to predict one variable in terms of a second
    variable called a predictor variable. The variable we are trying to predict is
    called the dependent variable and is denoted by *y,* and the independent variable
    is denoted by *x*. In simple linear regression, we assume a linear relationship
    between the dependent attribute and predictor attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need to plot the data to understand the linear relationship between
    the dependent variable and independent variable. Here our, data consists of two
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`YPrice`: Dependent variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XPrice`: Predictor variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, we are trying to predict `Yprice` in terms of `XPrice`. `StockXprice`
    is the independent variable and `StockYprice` is the dependent variable. For every
    element of `StockXprice`, there is an element of `StockYprice`, which implies
    one-to-one mapping between elements of `StockXprice` and `StockYprice`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few lines of data used for the following analysis are displayed using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '|  | `StockYPrice` | `StockXPrice` |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 80.13 | 72.86 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 79.57 | 72.88 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 79.93 | 71.72 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 81.69 | 71.54 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 80.82 | 71 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 81.07 | 71.78 |'
  prefs: []
  type: TYPE_TB
- en: Scatter plot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we will plot scatter plot between *y* and *x,* to understand the type
    of linear relationship between *x* and *y*. The following code, when executed,
    gives the following scatter plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, our dependent variable is `YPrice` and predictor variable is `Xprice`.
    Please note this example is just for illustration purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scatter plot](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Scatter plot of two variables'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have examined the relationship between the dependent variable and predictor
    variable, we try fit the best straight line through the points which represent
    the predicted *Y* value for all the given predictor variables. A simple linear
    regression is represented by the following equation describing the relationship
    between the dependent and predictor variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scatter plot](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here ![Scatter plot](img/00032.jpeg) and ![Scatter plot](img/00033.jpeg) are
    parameters and ![Scatter plot](img/00034.jpeg) is the error term. ![Scatter plot](img/00032.jpeg) is
    also known as the intercept and ![Scatter plot](img/00033.jpeg) as the coefficient
    of the predictor variable; it is obtained by minimizing the sum of squares of
    the error term ![Scatter plot](img/00034.jpeg). All the statistical software gives
    the option of estimating the coefficients and so does R.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fit the linear regression model using the `lm` function in R as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `Data` is the input data given and `Yprice` and `Xprice` are the dependent
    and predictor variables respectively. Once we have fitted the model, we can extract
    our parameters using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding result gives the value of the intercept and coefficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So now we can write our model as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This can give the predicted value for any given `Xprice`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we can execute the following code to get the predicted value using the
    fitted linear regression model on any other data, say `OutofSampleData`, by executing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Coefficient of determination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have fitted our model but now we need to test how good the model is fitting
    to the data. There are a few measures available for it but the main one is the
    coefficient of determination. This is given by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By definition, it is a proportion of the variance in the dependent variable
    that is explained by the independent variable and is also known as R2.
  prefs: []
  type: TYPE_NORMAL
- en: Significance test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we need to examine whether the relationship between the variables in the
    linear regression model is significant or not, at 0.05 significance level.
  prefs: []
  type: TYPE_NORMAL
- en: 'We execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It gives all the relevant statistics of the linear regression model as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Significance test](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Summary of linear regression model'
  prefs: []
  type: TYPE_NORMAL
- en: If the **Pvalue** associated with `Xprice` is less than **0.05** then the predictor
    is explaining the dependent variable significantly at **0.05** significance level.
  prefs: []
  type: TYPE_NORMAL
- en: Confidence interval for linear regression model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the important issues for the predicted value is to find the confidence
    interval around the predicted value. So let us try to find a 95% confidence interval
    around the predicted value of the fitted model. This can be achieved by executing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here we are estimating the predicted value for the given value of `Xprice =
    75` and then we try to find the confidence interval around the predicted value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output generated by executing the preceding code is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Confidence interval for linear regression model](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Prediction of confidence interval for linear regression model'
  prefs: []
  type: TYPE_NORMAL
- en: Residual plot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have fitted the model then we compare it with the observed value and
    find the difference, which is known as the residual. Then we plot the residual
    against the predictor variable to see the performance of the model visually. The
    following code can be executed to get the residual plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Residual plot](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Residual plot of linear regression model'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also plot the residual plot for the standardized residuals by just executing
    the following code in the previously mentioned code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Normality distribution of errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the assumptions of linear regression is that errors are normally distributed,
    and after fitting the model, we need to check that errors are normally distributed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be checked by executing the following code and can be compared with
    theoretical normal distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![Normality distribution of errors](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: QQ plot of standardized residuals'
  prefs: []
  type: TYPE_NORMAL
- en: 'Further details of the `summary` function for the linear regression model can
    be found in the R documentation. The following command will open a window which
    has complete information about the linear regression model, that is, `lm()`. It
    also has information about each and every input variable, including their data
    type, what all the variables this function returns are, and how output variables
    can be extracted, along with the examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Multivariate linear regression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In multiple linear regression, we try to explain the dependent variable in
    terms of more than one predictor variable. The multiple linear regression equation
    is given by the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multivariate linear regression](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here ![Multivariate linear regression](img/00040.jpeg)are multiple linear regression
    parameters and can be obtained by minimizing the sum of squares, which is also
    known as the OLS method of estimation.
  prefs: []
  type: TYPE_NORMAL
- en: Let us an take an example where we have the dependent variable `StockYPrice`
    and we are trying to predict it in terms of independent variables `StockX1Price`,
    `StockX2Price`, `StockX3Price`, and `StockX4Price`, which are present in the dataset
    `DataMR`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us fit the multiple regression model and get parameter estimates of
    multiple regression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the preceding code, it fits the multiple regression model on
    the data and gives the basic summary of statistics associated with multiple regression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multivariate linear regression](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Summary of multivariate linear regression'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the simple linear regression model, the `lm` function estimates the
    coefficients of the multiple regression model, as shown in the previous summary,
    and we can write our prediction equation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For any given set of independent variables, we can find the predicted dependent
    variable by using the previous equation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For any out of sample data, we can obtain the forecast by executing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This gives the output 80.63105 as the predicted value of the dependent variable
    for the given set of independent variables.
  prefs: []
  type: TYPE_NORMAL
- en: Coefficient of determination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For checking the adequacy of a model, the main statistics are the coefficient
    of determination and adjusted coefficient of determination, which have been displayed
    in the summary table as R-squared and adjusted R-squared matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also obtain them using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: From the summary table, we can see which variables are becoming significant.
    If the Pvalue associated with the variables in the summary table is <0.05 then
    the specific variable is significant, otherwise it is insignificant.
  prefs: []
  type: TYPE_NORMAL
- en: Confidence interval
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can find the prediction interval for the 95% confidence interval for the
    predicted value by the multiple regression model by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Confidence interval](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: Prediction of confidence interval for multiple regression model'
  prefs: []
  type: TYPE_NORMAL
- en: Multicollinearity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the predictor variables are correlated then we need to detect multicollinearity
    and treat it. Recognition of multicollinearity is crucial because two or more
    variables are correlated, which shows a strong dependence structure between those
    variables, and we are using correlated variables as independent variables, which
    end up having a double effect of these variables on the prediction because of
    the relation between them. If we treat the multicollinearity and consider only
    variables which are not correlated then we can avoid the problem of double impact.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find multicollinearity by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the multicollinearity table for the predictor variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multicollinearity](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: VIF table for multiple regression model'
  prefs: []
  type: TYPE_NORMAL
- en: Depending upon the values of VIF, we can drop the irrelevant variable.
  prefs: []
  type: TYPE_NORMAL
- en: ANOVA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ANOVA is used to determine whether there are any statistically significant
    differences between the means of three or more independent groups. In the case
    of only two samples, we can use the t-test to compare the means of the samples,
    but in the case of more than two samples, it may be very complicated. We are going
    to study the relationship between quantitative dependent variable returns and
    single qualitative independent variable stock. We have five levels of stock: stock1,
    stock2, .. stock5.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can study the five levels of stock by means of a box plot and we can compare
    by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This displays a few lines of the data used for analysis in tabular format:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | `Returns` | `Stock` |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1.64 | Stock1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 1.72 | Stock1 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1.68 | Stock1 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 1.77 | Stock1 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 1.56 | Stock1 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 1.95 | Stock1 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output and box plots it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ANOVA](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Box plot of different levels of stock'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding box plot shows that level stock has higher returns. If we repeat
    the procedure, we are most likely going to get different returns. It may be possible
    that all the levels of stock give similar numbers and we are just seeing random
    fluctuation in one set of returns. Let us assume that there is no difference at
    any level and it is our null hypothesis. Using ANOVA, let us test the significance
    of the hypothesis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the preceding code gives the following outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ANOVA](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Output of ANOVA for different levels of stock'
  prefs: []
  type: TYPE_NORMAL
- en: Since the **Pvalue** is less than **0.05**, the null hypothesis gets rejected.
    The returns at the different levels of stock are not similar.
  prefs: []
  type: TYPE_NORMAL
- en: Feature selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Feature selection is one of the toughest parts of financial model building.
    Feature selection can be done statistically or by having domain knowledge. Here
    we are going to discuss only a few of the statistical feature selection methods
    in the financial space.
  prefs: []
  type: TYPE_NORMAL
- en: Removing irrelevant features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data may contain highly correlated features and the model does better if we
    do not have highly correlated features in the model. The Caret R package gives
    the method for finding a correlation matrix between the features, which is shown
    by the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few lines of data used for correlation analysis and multiple regression analysis
    are displayed here by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|  | `StockYPrice` | `StockX1Price` | `StockX2Price` | `StockX3Price` | `StockX4Price`
    |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 80.13 | 72.86 | 93.1 | 63.7 | 83.1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 79.57 | 72.88 | 90.2 | 63.5 | 82 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 79.93 | 71.72 | 99 | 64.5 | 82.8 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 81.69 | 71.54 | 90.9 | 66.7 | 86.5 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 80.82 | 71 | 90.7 | 60.7 | 80.8 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 81.07 | 71.78 | 93.1 | 62.9 | 84.2 |'
  prefs: []
  type: TYPE_TB
- en: The preceding output shows five variables in `DataMR` named `StockYPrice`, `StockX1Price`,
    `StockX2Price`, `StockX3Price`, and `StockX4Price`. Here `StockYPrice` is dependent
    and all the other four variables are independent variables. Dependence structure
    is very important to study for going deep into the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command calculates the correlation matrix between the first four
    columns, which are `StockYPrice`, `StockX1Price`, `StockX2Price`¸ and `StockX3Price`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![Removing irrelevant features](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: Correlation matrix table'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding correlation matrix shows which variables are highly correlated
    and, accordingly, the feature will be selected in such a way that highly correlated
    features are not in the model.
  prefs: []
  type: TYPE_NORMAL
- en: Stepwise variable selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use stepwise variable selection (forward, backward, both) in predictive
    models using the `stepAIC()` function for feature selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the dataset used for multiple regression as the input dataset.
    One can also use all-subsets regression using the `leaps()` function from the
    leaps package.
  prefs: []
  type: TYPE_NORMAL
- en: Variable selection by classification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use classification techniques such as decision tree or random forest
    to get the most significant predictors. Here we are using random forest (code
    is given) to find the most relevant features. All the four attributes in the dataset
    `DataForMultipleRegression1` have been selected in the following example and the
    plot shows the accuracy of different subset sizes comparing across all the subsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It displays a few lines of the data used for analysis, as shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | `PortfolioYDirection` | `StockX1Price` | `StockX2Price` | `StockX3Price`
    | `StockX4Price` |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 72.86 | 93.1 | 63.7 | 83.1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 1 | 72.88 | 90.2 | 63.5 | 82 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 0 | 71.72 | 99 | 64.5 | 82.8 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 0 | 71.54 | 90.9 | 66.7 | 86.5 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 1 | 71 | 90.7 | 60.7 | 80.8 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 0 | 71.78 | 93.1 | 62.9 | 84.2 |'
  prefs: []
  type: TYPE_TB
- en: 'Execute the following code to do the required analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It generates the following plot, showing the accuracy of different subset sizes
    comparing across all the subsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Variable selection by classification](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.12: Plot showing model accuracy of different subset sizes'
  prefs: []
  type: TYPE_NORMAL
- en: We have given some of the examples of feature selection. Some of the other feature
    selection methods such as classification techniques and information value for
    predictive modeling are also available.
  prefs: []
  type: TYPE_NORMAL
- en: Ranking of variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After fitting a regression/predictive model, we need to understand what the
    relative ranking of significant attributes is on a comparative scale. This is
    explained by Beta parameter estimates. Beta, or standardized coefficients, are
    the slopes we get if all the variables are on the same scale, which is done by
    converting them to z-scores before doing the predictive modeling (regression).
    Beta coefficients allow a comparison of the approximate relative importance of
    the predictors and hence the variables can be ranked, which neither the unstandardized
    coefficients nor the Pvalues can. Scaling, or standardizing, the data vectors
    can be done using the `scale()` function. Once the scaled variables are created,
    the regression is redone using them. The resulting coefficients are the beta coefficients.
  prefs: []
  type: TYPE_NORMAL
- en: Wavelet analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Time series information is not always sufficient to get insight into the data.
    Sometimes the frequency content of the data also contains important information
    about the data. In the time domain, Fourier transformation (FT) captures the frequency-amplitude
    of the data but it does not show when in time this frequency has happened. In
    the case of stationary data, all frequency components exist at any point in time
    but this is not true for non-stationary data. So, FT does not fit for non-stationary
    data. **Wavelet transformation** (**WT**) has the capacity to provide time and
    frequency information simultaneously in the form of time-frequency. WT is important
    to analyze financial time series as most of the financial time series are non-stationary.
    In the remainder of this chapter, wavelet analysis (WT), I will help you understand
    how to solve non-stationary data in R using wavelets analysis. Stock price/index
    data requires certain techniques or transformations to obtain further information
    about the series which raw data does not show. The daily closing price for the
    **Dow Jones Industrial Average** (**DJIA**) and **S&P500** index from January
    1, 2010 to December 31, 2015 has been used for illustration purposes. I am going
    to use the wavelets package for this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting to work with wavelets transformation, you have to install the
    package named `Wavelets`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you install it or you already have this package in your machine then you
    just have to load it into the workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get a first impression of the data, we plot the `dji` and `snp` time series
    and their reture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first line is used to divide the plot into a two-by-one matrix, so the
    plot can have two plots in one figure, and the next two commands plot the Dow
    Jones price and its return series, which can be seen in *Figure 3.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wavelet analysis](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.13: Price and return series for Dow Jones Index (DJI)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dji` and `snp` time series are non-stationary. We use head and tail to
    look at the first and last part of the time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we apply **discrete wavelets transformation** (**DWT**) on the `dji` data
    and decompose it using various filters. It requires data in time series, matrix,
    or data frame format. We look at the `dji` variable format which is `xts` and
    `zoo` object. So we need to convert it into an acceptable format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is ready to be used in discrete wavelets transformation''s R function.
    We also need to provide other parameters, such as the type of filter you will
    be using and the number of levels you want your data to be decomposed into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It saves the output in the variable called model. You can write model on the
    command prompt and it will display the output in the command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It generates output which consists of various information matrices such as
    wavelet coefficients, scaling coefficients, type of filter used, and number of
    levels used. You can extract any individual information as well. To extract wavelet
    coefficients, you have to write the following command on the command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It generates output which consists of various information matrices such as
    wavelet coefficients, scaling coefficients, type of filter used, and number of
    levels used. You can extract any individual information as well. To extract wavelet
    coefficients, you have to write the following command on the command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands generate a relative list of wavelets and scaling coefficients.
    To get an individual component of wavelets, you have to mention the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the plot command to visualize data series, wavelets, and scaling
    coefficients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 3.14* will plot the price and its various level coefficients and help
    us to visualize and understand the data clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wavelet analysis](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.14: Plots for time series, wavelets, and scaling coefficients'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the discrete wavelet transformation function for the `haar`
    filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It will plot the data series, wavelets, and scaling coefficients using the `haar`
    filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute inverse discrete wavelet transformation, you have to use a wavelet
    object, as defined using discrete wavelet transformation. The variable model is
    a wavelet object using the `haar` filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes it is necessary to know the class of the R objects, for example, `model`
    and `imodel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the following commands for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The variable `imodel` is created using inverse wavelet transformation and it
    generates an original time series object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiresolution analysis** (**MRA**) is another widely useful wavelet method
    for time series analysis. Financial markets generate large quantities of data,
    which is analyzed to generate algorithmic trading signals. Wavelet multi-resolution
    analysis is increasingly being applied to these datasets because it enables traders
    to focus on a particular time scale where trading patterns are considered important.
    The la8 filter is used in the following example and the `haar` filter also can
    replaced for `la8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: For the analysis of market data, **maximal overlap discrete wavelet transform**
    (**MODWT**) is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, I considered the case of Dow Jones Index time series, `dji`,
    as input to the `modwt` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function decomposes the time series in detailed wavelets and
    scaled coefficients, which can be seen in *Figure 3.15*. The `plot.modwt()` function
    can be used to plot this `modwt` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '![Wavelet analysis](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.15: Plot of Maximal Overlap Discrete wavelets transform'
  prefs: []
  type: TYPE_NORMAL
- en: A few jumps in the time series can be seen as jumps in smaller coefficients
    such as **W1** and **W2**, and smooth coefficients such as **W6** show movement
    about some mean for the time period. Wavelets and scaled coefficients in *Figure
    3.15* clearly show price data at different time scales.
  prefs: []
  type: TYPE_NORMAL
- en: Wavelet analysis provides an important tool in quantitative finance, with applications
    ranging from short-term prediction and the calculation of variance in relation
    to specific time scales.
  prefs: []
  type: TYPE_NORMAL
- en: Fast Fourier transformation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Fast Fourier transformation** (**FFT**) is used for calculating the Fourier
    transform of discrete time series. You need to install the relevant package `fft`
    for FFT with the help of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you install the package, you have to load this into the workspace by using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Fast Fourier transform of time series can be calculated using `fft`, and it
    accepts real or complex numbers series.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `dji` is a real number time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable `model` is a transformed series which basically consists of complex
    numbers, and the real and imaginary parts can be extracted using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command calculates the absolute value of the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let me plot this and see what information the absolute value of `fft` has for
    me:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '![Fast Fourier transformation](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.16: Plot for absolute value of FFT modeled series'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3.16* shows spikes at both ends of the data. FFT can accept complex
    inputs, when the input is real (as with most real-world cases). The output for
    bins greater than *N/2* is redundant and does not provide additional spectral
    information. So, we can remove the values for bins > *N/2*. This arises from lack
    of normalization.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Results need to be normalized for the sample size. As the input data is real-valued,
    data greater than *N/2* is removed and we normalize the data by *N/2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The angle between the real and imaginary parts of the Fourier transformed series
    is calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes it is important to analyze the spectrum density of the time series
    and this can be calculated in R using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It accepts two methods: periodogram and autoregressive. You can choose either
    of these methods. This function returns the vector of frequencies at which spectral
    densities are estimated, as well as the vector of estimated spectral densities
    at frequency. It also returns some other parameters which are useful to multivariate
    analysis, such as coherence level and phase between multivariate series.'
  prefs: []
  type: TYPE_NORMAL
- en: Hilbert transformation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hilbert transformation is another technique to transform time series and R
    uses the `seewave` package for this. This package can be installed using `install.packages()`
    and loaded into the workspace using the `library()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is the time series object which you would like to transform,
    and the second parameter is the sampling frequency of the wave. In the preceding
    example, I used `dji` as time series and sampling frequency as 1 to calculate
    the Hilbert transformation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to know the output of the model then you should use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output mentions the length of input data series is `2555` and
    the type of output variable named `model` is complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the output is complex, we can extract real and imaginary values using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the real part is the original time series, which is `dji` in our case,
    and the imaginary part is the Hilbert transformed series of the original series.
    `ifreq()` returns the phase or instantaneous frequency, depending upon what output
    we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will generate instantaneous frequency:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hilbert transformation](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure:3.17\. Instantaneous frequency of time series using Hilbert transformation
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we would like to generate phases then we have to explicitly mention
    `PHASE=TRUE` in the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 3.18* shows the phases with respect to time variations. As time progresses,
    phases also increase with the increase in time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hilbert transformation](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.18: Phases of time series using Hilbert transformation'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the plot is true. If we say `PLOT=FALSE`, then it will not generate
    a plot and only generate variables in the workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The output variable is in the form of a list which contains both instantaneous
    frequency and phase and can be extracted using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes we analyze a pair of time series and then calculating phase difference
    is crucial rather than looking at the phase of univariate series. So, phase difference
    can be calculated by simply calculating phases of individual series and then subtracting
    the phase of one series from the other series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: There is another package, `waveslim`, which has all these transformations, such
    as discrete wavelet transformation, fast Fourier transformation, and Hilbert transformation,
    in one. In fact, there are many more packages which contain these transformations.
    You can use whichever you are comfortable with and find easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Define regression and how you can implement in R.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you find the coefficient of determination for linear regression / multiple
    regression in R?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you find the confidence interval for a prediction fitted with linear
    regression / multiple regression in R?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How will you detect multicollinearity in R in multiple regression?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the significance of ANOVA and how will you use it to compare the results
    of two linear regression models?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you perform feature selection in R for multiple linear regression?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you rank significance attributes in a multiple linear regression model
    in R?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you install the `waveslim` package and load it into the R workspace?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you plot a time series and extract the head and tail of the time series?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you know the class of a variable created by the `fft` function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you use the dwt function using any given filter and take inverse dwt?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you extract the real and imaginary parts of a series?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you use fast Fourier transformation and Hilbert transformation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regression is the backbone of any analysis and the reader cannot go ahead without
    touching on it. In this chapter, I have presented linear regression and multivariate
    regression and how they are used for prediction. The R function `lm()` is used
    to implement both simple and multivariate linear regression. I also presented
    significance testing along with residual calculations and the normality plot,
    which tests residuals for normality using a qq plot. **Analysis of variance**
    (**ANOVA**) is used to select the difference means of two or more samples. Multivariate
    linear regression involves many variables, and the coefficient of each variable
    is different, which varies the importance of each variable and is ranked accordingly.
    Stepwise regression is used to select variables which are important in the regression.
    Time series analysis does not represent the complete information sometimes. It
    becomes necessary to explore frequency analysis, which can be done with wavelet,
    fast Fourier and Hilbert transformation. All the methods are implemented in R
    for frequency analysis. I have also explained how results can be seen and plotted
    wherever it is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I will explain time series analysis and prediction techniques.
  prefs: []
  type: TYPE_NORMAL
