["```py\nimport scipy as sp\nx=sp.random.standard_normal(size=10)\nprint(x)\n[-0.98350472  0.93094376 -0.81167564 -1.83015626 -0.13873015  0.33408835\n  0.48867499 -0.17809823  2.1223147   0.06119195]\n```", "```py\n>>>import scipy as sp\n>>>x=sp.random.normal(size=10)\n```", "```py\n>>>import scipy as sp \n>>>x=sp.random.normal(0,1,10)\n```", "```py\n>>>help(sp.random.normal) \nHelp on built-in function normal:\nnormal(...) \nnormal(loc=0.0, scale=1.0, size=None)\n```", "```py\nimport scipy as sp\nimport scipy.stats as stats\nimport matplotlib.pyplot as plt\nx = sp.arange(-3,3,0.01)\ny=stats.norm.pdf(x)\nplt.plot(x,y)\nplt.title(\"A standard normal distribution\")\nplt.xlabel('x')\nplt.ylabel('y')\nplt.show()\n```", "```py\n>>>import scipy as sp \n>>>sp.random.seed(12345) \n>>>x=sp.random.normal(0,1,20) \n>>>print x[0:5] \n[-0.20470766 0.47894334 -0.51943872 -0.5557303 1.96578057] \n>>>\n```", "```py\n>>>impimport scipy as sp \n>>>sp.random.seed(12345) \n>>>mean=0.05\n>>>std=0.1\n>>>n=50\n>>>x=sp.random.normal(mean,std,n) \n>>>print(x[0:5])\n[ 0.02952923 0.09789433 -0.00194387 -0.00557303 0.24657806]\n>>>\n```", "```py\nimport scipy as sp \nimport matplotlib.pyplot as plt \nsp.random.seed(12345) \nmean=0.1\nstd=0.2\nn=1000\nx=sp.random.normal(mean,std,n) \nplt.hist(x, 15, normed=True) \nplt.title(\"Histogram for random numbers drawn from a normal distribution\")\nplt.annotate(\"mean=\"+str(mean),xy=(0.6,1.5))\nplt.annotate(\"std=\"+str(std),xy=(0.6,1.4))\nplt.show()\n```", "```py\nimport scipy as sp\nimport numpy as np\nimport matplotlib.pyplot as plt \nfrom scipy import sqrt,exp,log,pi\n#\nx=np.linspace(0.001,3,200)\nmu=0 \nsigma0=[0.25,0.5,1]\ncolor=['blue','red','green'] \ntarget=[(1.2,1.3),(1.7,0.4),(0.18,0.7)]\nstart=[(1.8,1.4),(1.9,0.6),(0.18,1.6)]\n#\nfor i in sp.arange(len(sigma0)):\n    sigma=sigma0[i]\n    y=1/(x*sigma*sqrt(2*pi))*exp(-(log(x)-mu)**2/(2*sigma*sigma))\n    plt.annotate('mu='+str(mu)+', sigma='+str(sigma),xy=target[i],xytext=start[i],arrowprops=dict(facecolor=color[i],shrink=0.01),) \n    plt.plot(x,y,color[i])\n    plt.title('Lognormal distribution') \n    plt.xlabel('x')\n    plt.ylabel('lognormal density distribution') \n#\nplt.show()\n```", "```py\n>>>import scipy as sp \n>>>sp.random.seed(123345) \n>>>x=sp.random.uniform(low=1,high=100,size=10) \n```", "```py\n>>>print(x[0:5])\n[ 30.32749021 20.58006409 2.43703988 76.15661293 75.06929084]\n>>>\n```", "```py\nimport random\ndef rollDice():\n    roll = random.randint(1,6)\n    return roll\ni =1\nn=10\nresult=[]\nrandom.seed(123)\nwhile i<n:\n    result.append(rollDice())\n    i+=1\nprint(result)\n[1, 1, 3, 1, 6, 1, 4, 2, 6]\n```", "```py\nimport scipy as sp \nn=100000\nx=sp.random.uniform(low=0,high=1,size=n) \ny=sp.random.uniform(low=0,high=1,size=n) \ndist=sp.sqrt(x**2+y**2) \nin_circle=dist[dist<=1] \nour_pi=len(in_circle)*4./n\nprint ('pi=',our_pi)\nprint('error (%)=', (our_pi-sp.pi)/sp.pi)\n```", "```py\n('pi=', 3.14168)\n('error (%)=', 2.7803225891524895e-05)\n```", "```py\nimport numpy as np\nimport scipy as sp \nimport matplotlib.pyplot as plt \nx=sp.random.poisson(lam=1, size=100) \n#plt.plot(x,'o') \na = 5\\. # shape \nn = 1000 \ns = np.random.power(a, n) \ncount, bins, ignored = plt.hist(s, bins=30) \nx = np.linspace(0, 1, 100) \ny = a*x**(a-1.) \nnormed_y = n*np.diff(bins)[0]*y \nplt.title(\"Poisson distribution\")\nplt.ylabel(\"y\")\nplt.xlabel(\"x\")\nplt.plot(x, normed_y) \nplt.show()\n```", "```py\nimport scipy as sp \nn_stocks_available=500 \nn_stocks=20 \nsp.random.seed(123345) \nx=sp.random.uniform(low=1,high=n_stocks_available,size=n_stocks)\ny=[] \nfor i in range(n_stocks): \n    y.append(int(x[i])) \n#print y \nfinal=sp.unique(y) \nprint(final) \nprint(len(final))\n[  8  31  61  99 124 148 155 172 185 205 226 275 301 334 356 360 374 379\n 401 449]\n20\n```", "```py\nimport scipy as sp\nimport numpy as np\nimport pandas as pd\n#\nn_stocks=10 \nx=pd.read_pickle('c:/temp/yanMonthly.pkl') \nx2=sp.unique(np.array(x.index)) \nx3=x2[x2<'ZZZZ']                        # remove all indices \nsp.random.seed(1234567) \nnonStocks=['GOLDPRICE','HML','SMB','Mkt_Rf','Rf','Russ3000E_D','US_DEBT','Russ3000E_X','US_GDP2009dollar','US_GDP2013dollar'] \nx4=list(x3) \n#\nfor i in range(len(nonStocks)): \n    x4.remove(nonStocks[i]) \n#\nk=sp.random.uniform(low=1,high=len(x4),size=n_stocks) \ny,s=[],[] \nfor i in range(n_stocks): \n    index=int(k[i]) \n    y.append(index) \n    s.append(x4[index]) \n#\nfinal=sp.unique(y) \nprint(final) \nprint(s)\n```", "```py\nimport numpy as np \nx=range(1,11) \nprint(x) \nfor i in range(5):\n    y=np.random.permutation(x) \n#\nprint(y)\n```", "```py\nimport numpy as np \ndef boots_f(data,n_obs,replacement=None):\n    n=len(data) \n    if (n<n_obs):\n        print \"n is less than n_obs\" \n    else: \n        if replacement==None:\n            y=np.random.permutation(data) \n            return y[0:n_obs] \n        else:\n            y=[] \n    #\n    for i in range(n_obs): \n        k=np.random.permutation(data) \n        y.append(k[0]) \n    return y\n```", "```py\nimport numpy as np \nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.finance import quotes_historical_yahoo_ochl as getData \n# Step 1: input area\nticker='MSFT'          # input value 1 \nbegdate=(1926,1,1)      # input value 2 \nenddate=(2013,12,31)    # input value 3 \nn_simulation=5000       # input value 4\n# Step 2: retrieve price data and estimate log returns\nx=getData(ticker,begdate,enddate,asobject=True)\nlogret = sp.log(x.aclose[1:]/x.aclose[:-1])\n# Step 3: estimate annual returns \ndate=[]\nd0=x.date\nfor i in range(0,sp.size(logret)): \n    date.append(d0[i].strftime(\"%Y\"))\ny=pd.DataFrame(logret,date,columns=['logret']) \nret_annual=sp.exp(y.groupby(y.index).sum())-1 \nret_annual.columns=['ret_annual']\nn_obs=len(ret_annual)\n# Step 4: estimate distribution with replacement \nsp.random.seed(123577) \nfinal=sp.zeros(n_obs,dtype=float)\nfor i in range(0,n_obs):\n    x=sp.random.uniform(low=0,high=n_obs,size=n_obs) \n    y=[]\n    for j in range(n_obs): \n        y.append(int(x[j]))\n        z=np.array(ret_annual)[y] \n    final[i]=sp.mean(z)\n# step 5: graph\nplt.title('Mean return distribution: number of simulations ='+str(n_simulation))\nplt.xlabel('Mean return')\nplt.ylabel('Frequency')\nmean_annual=round(np.mean(np.array(ret_annual)),4) \nplt.figtext(0.63,0.8,'mean annual='+str(mean_annual)) \nplt.hist(final, 50, normed=True)\nplt.show()\n```", "```py\nimport scipy as sp \nimport matplotlib.pyplot as plt\n# input area\nstock_price_today = 9.15 # stock price at time zero \nT =1\\.                    # maturity date (in years) \nn_steps=100\\.             # number of steps \nmu =0.15                 # expected annual return \nsigma = 0.2              # annualized volatility\nsp.random.seed(12345)    # fixed our seed \nn_simulation = 5         # number of simulations \ndt =T/n_steps \n#\nS = sp.zeros([n_steps], dtype=float) \nx = range(0, int(n_steps), 1) \nfor j in range(0, n_simulation): \n    S[0]= stock_price_today \n    for i in x[:-1]: \n        e=sp.random.normal() \n        S[i+1]=S[i]+S[i]*(mu-0.5*pow(sigma,2))*dt+sigma*S[i]*sp.sqrt(dt)*e; \n    plt.plot(x, S)\n#\nplt.figtext(0.2,0.8,'S0='+str(S[0])+',mu='+str(mu)+',sigma='+str(sigma)) \nplt.figtext(0.2,0.76,'T='+str(T)+', steps='+str(int(n_steps))) \nplt.title('Stock price (number of simulations = %d ' % n_simulation +')') \nplt.xlabel('Total number of steps ='+str(int(n_steps))) \nplt.ylabel('stock price') \nplt.show()\n```", "```py\nimport scipy as sp \nimport matplotlib.pyplot as plt\nfrom scipy import zeros, sqrt, shape \n#input area\nS0 = 9.15               # stock price at time zero \nT =1\\.                   # years\nn_steps=100\\.            # number of steps \nmu =0.15                # expected annual return \nsigma = 0.2             # volatility (annual) \nsp.random.seed(12345)   # fix those random numbers \nn_simulation = 1000     # number of simulation \ndt =T/n_steps \n#\nS = zeros([n_simulation], dtype=float) \nx = range(0, int(n_steps), 1) \nfor j in range(0, n_simulation): \n    tt=S0 \n    for i in x[:-1]: \n        e=sp.random.normal() \n        tt+=tt*(mu-0.5*pow(sigma,2))*dt+sigma*tt*sqrt(dt)*e; \n        S[j]=tt \n#\nplt.title('Histogram of terminal price') \nplt.ylabel('Number of frequencies') \nplt.xlabel('Terminal price') \nplt.figtext(0.5,0.8,'S0='+str(S0)+',mu='+str(mu)+',sigma='+str(sigma)) \nplt.figtext(0.5,0.76,'T='+str(T)+', steps='+str(int(n_steps))) \nplt.figtext(0.5,0.72,'Number of terminal prices='+str(int(n_simulation))) \nplt.hist(S) \nplt.show()\n```", "```py\nimport scipy as sp\nsp.random.seed(123)\nn=1000\nrho=0.3\nx1=sp.random.normal(size=n)\nx2=sp.random.normal(size=n)\ny1=x1\ny2=rho*x1+sp.sqrt(1-rho**2)*x2\nprint(sp.corrcoef(y1,y2))\n[[ 1\\.          0.28505213]\n [ 0.28505213  1\\.        ]]\n```", "```py\nimport scipy as sp \nfrom scipy import zeros, sqrt, shape \n#\nS0 = 40\\.              # stock price at time zero \nX= 40\\.                # exercise price \nT =0.5                # years \nr =0.05               # risk-free rate \nsigma = 0.2           # annualized volatility \nn_steps=100          # number of steps \n#\nsp.random.seed(12345) # fix those random numbers \nn_simulation = 5000   # number of simulation \ndt =T/n_steps \ncall = sp.zeros([n_simulation], dtype=float) \nx = range(0, int(n_steps), 1) \nfor j in range(0, n_simulation): \n    sT=S0 \n    for i in x[:-1]: \n        e=sp.random.normal() \n        sT*=sp.exp((r-0.5*sigma*sigma)*dt+sigma*e*sqrt(dt)) \n        call[j]=max(sT-X,0) \n#\ncall_price=sp.mean(call)*sp.exp(-r*T) \nprint('call price = ', round(call_price,3))\n```", "```py\nimport scipy as sp\ns0=40\\.                 # today stock price \nx=40\\.                  # exercise price \nT=0.5                  # maturity in years \nr=0.05                 # risk-free rate \nsigma=0.2              # volatility (annualized) \nsp.random.seed(123)    # fix a seed here \nn_simulation=100       # number of simulations \nn_steps=100\\.           # number of steps\n#\t\ndt=T/n_steps \ncall=sp.zeros([n_simulation], dtype=float) \nfor j in range(0, n_simulation): \n    sT=s0 \n    total=0 \n    for i in range(0,int(n_steps)): \n         e=sp.random.normal()\n         sT*=sp.exp((r-0.5*sigma*sigma)*dt+sigma*e*sp.sqrt(dt)) \n         total+=sT \n         price_average=total/n_steps \n    call[j]=max(price_average-x,0) \n#\ncall_price=sp.mean(call)*sp.exp(-r*T) \nprint('call price based on average price = ', round(call_price,3))\n('call price based on average price = ', 1.699)\n```", "```py\nimport scipy as sp \nfrom scipy import log,exp,sqrt,stats \n#\ndef bsCall(S,X,T,r,sigma):\n    d1=(log(S/X)+(r+sigma*sigma/2.)*T)/(sigma*sqrt(T)) \n    d2 = d1-sigma*sqrt(T)\n    return S*stats.norm.cdf(d1)-X*exp(-r*T)*stats.norm.cdf(d2)\n#\ndef up_and_out_call(s0,x,T,r,sigma,n_simulation,barrier):\n    n_steps=100\\. \n    dt=T/n_steps \n    total=0 \n    for j in sp.arange(0, n_simulation): \n        sT=s0 \n        out=False\n        for i in range(0,int(n_steps)): \n            e=sp.random.normal() \n            sT*=sp.exp((r-0.5*sigma*sigma)*dt+sigma*e*sp.sqrt(dt)) \n            if sT>barrier: \n               out=True \n        if out==False: \n            total+=bsCall(s0,x,T,r,sigma) \n    return total/n_simulation\n```", "```py\ns0=40\\.              # today stock price \nx=40\\.               # exercise price \nbarrier=42          # barrier level \nT=0.5               # maturity in years \nr=0.05              # risk-free rate \nsigma=0.2           # volatility (annualized) \nn_simulation=100    # number of simulations \nsp.random.seed(12)  # fix a seed\n#\nresult=up_and_out_call(s0,x,T,r,sigma,n_simulation,barrier) \nprint('up-and-out-call = ', round(result,3))\n('up-and-out-call = ', 0.937)\n```", "```py\nimport numpy as np\nimport numpy as np\nimport scipy as sp\nimport pandas as pd\nfrom scipy.stats import norm\n#\nposition=1e6              # portfolio value\nstd=0.2                   # volatility\nmean=0.08                 # mean return\nconfidence=0.99           # confidence level\nnSimulations=50000        # number of simulations\n# Method I\nz=norm.ppf(1-confidence)\nVaR=position*(mean+z*std)\nprint(\"Holding=\",position, \"VaR=\", round(VaR,2), \"tomorrow\")\n#\n# Method II: Monte Carlo simulaiton \nsp.random.seed(12345) \nret2=sp.random.normal(mean,std,nSimulations) \nret3=np.sort(ret2) \nm=int(nSimulations*(1-confidence))\nVaR2=position*(ret3[m])\nprint(\"Holding=\",position, \"VaR2=\", round(VaR2,2), \"tomorrow\")\n('Holding=', 1000000.0, 'VaR=', -385270.0, 'tomorrow')\n('Holding=', 1000000.0, 'VaR2=', -386113.0, 'tomorrow')\n```", "```py\nimport scipy as sp\nnYear=5                 # number of years\ncostEquipment=5e6       # 5 million \nn=nYear+1               # add year zero\nprice=28                # price of the product\nunits=100000            # estimate number of units sold \notherCost=100000        # other costs\nsellingCost=1500        # selling and administration cost \nR_and_D=200000          # Research and development\ncostRawMaterials=0.3    # percentage cost of raw materials\nR=0.15                  # discount rate\ntax=0.38                # corporate tax rate\n#\nsales=sp.ones(n)*price*units\nsales[0]=0              # sales for 1st year is zero\ncost1=costRawMaterials*sales\ncost2=sp.ones(n)*otherCost\ncost3=sp.ones(n)*sellingCost\ncost4=sp.zeros(n)\ncost4[0]=costEquipment\nRD=sp.zeros(n)\nRD[0]=R_and_D                     # assume R&D at time zero\nD=sp.ones(n)*costEquipment/nYear  # straight line depreciation \nD[0]=0                            # no depreciation at time 0\nEBIT=sales-cost1-cost2-cost3-cost4-RD-D\nNI=EBIT*(1-tax)\nFCF=NI+D                         # add back depreciation\nnpvProject=sp.npv(R,FCF)         # estimate NPV\nprint(\"NPV of project=\",round(npvProject,0))\n('NPV of project=', 1849477.0)\n```", "```py\nimport scipy as sp\nimport matplotlib.pyplot as plt\nnYear=5                 # number of years\ncostEquipment=5e6       # 5 million \nn=nYear+1               # add year zero\notherCost=100000        # other costs\nsellingCost=1500        # selling and administration cost \nR_and_D=200000          # Research and development\ncostRawMaterials=0.3    # percentage cost of raw materials\ntax=0.38                # corporate tax rate\nthousand=1e3            # unit of thousand \nmillion=1e6             # unit of million \n#\n# three uncertainties: price, unit and discount rate\nnSimulation=100         # number of simulation\nlowPrice=10             # low price\nhighPrice=30            # high price\nlowUnit=50*thousand     # low units expected to sell \nhighUnit=200*thousand   # high units expected to sell \nlowRate=0.15            # lower discount rate\nhighRate=0.25           # high discount rate \n#\nn2=nSimulation\nsp.random.seed(123)\nprice0=sp.random.uniform(low=lowPrice,high=highPrice,size=n2)\nunits0=sp.random.uniform(low=lowUnit,high=highUnit,size=n2)\nR0=sp.random.uniform(lowRate,highRate,size=n2)\n#\nnpv=[]\nfor i in sp.arange(nSimulation):\n    units=sp.ones(n)*units0[i]\n    price=price0[i]\n    R=R0[i]\n    sales=units*price\n    sales[0]=0              # sales for 1st year is zero\n    cost1=costRawMaterials*sales\n    cost2=sp.ones(n)*otherCost\n    cost3=sp.ones(n)*sellingCost\n    cost4=sp.zeros(n)\n    cost4[0]=costEquipment\n    RD=sp.zeros(n)\n    RD[0]=R_and_D                     # assume R&D at time zero\n    D=sp.ones(n)*costEquipment/nYear  # straight line depreciation \n    D[0]=0                            # no depreciation at time 0\n    EBIT=sales-cost1-cost2-cost3-cost4-RD-D\n    NI=EBIT*(1-tax)\n    FCF=NI+D                          # add back depreciation\n    npvProject=sp.npv(R,FCF)/million  # estimate NPV\n    npv.append(npvProject)\nprint(\"mean NPV of project=\",round(sp.mean(npv),0))\nprint(\"min  NPV of project=\",round(min(npv),0))\nprint(\"max  NPV of project=\",round(max(npv),0))\nplt.title(\"NPV of the project: 3 uncertainties\")\nplt.xlabel(\"NPV (in million)\")\nplt.hist(npv, 50, range=[-3, 6], facecolor='blue', align='mid')\nplt.show()\n```", "```py\nimport simpy\ndef clock(env, name, tick):\n     while True:\n         print(name, env.now)\n         yield env.timeout(tick)\n#\nenv = simpy.Environment()\nenv.process(clock(env, 'fast', 0.5))\nenv.process(clock(env, 'slow', 1))\nenv.run(until=2)\n('fast', 0)\n('slow', 0)\n('fast', 0.5)\n('slow', 1)\n('fast', 1.0)\n('fast', 1.5)\n```", "```py\nimport scipy as sp\nimport scipy.stats as stats\nsp.random.seed(123)\nu=stats.uniform(-1,1).rvs()\nn=stats.norm(500,150).rvs()\nb=stats.binom(10000,0.1).rvs()\nx='random number from a '\nprint(x+\"uniform distribution \",u)\nprint(x+\" normal distribution \",n)\nprint(x+\" binomial distribution \",b)\n('random number from a uniform distribution ', -0.30353081440213836)\n('random number from a  normal distribution ', 357.18541897080166)\n('random number from a  binomial distribution', 1003)\n```", "```py\nfrom pylab import *\nfrom scipy.stats import *\n#input area\nmillion=1e6                        # unit of million \nbillion=1e9                        # unit of billion \ntrillion=1e12                      # unit of trillion \ntiny=1e-7                          # a small number \nhourlyPay = 7.5                    # hourly wage\nworkingHoursPerWeek=40             # working hour per week                                \nworkingWeeksPerYear=50             # working weeks per year\nnAdult           = 227*million     # number of adult\nlaborForce       = 154*million     # labor force\ndisabledAdults   =  21*million     # disability \nnSimulations     = 1024*32         # number of simulations \n#\nbasicIncome = hourlyPay*workingHoursPerWeek*workingWeeksPerYear\n# define a few function\ndef geniusEffect(nNonWorkers):\n    nGenious = binom(nNonWorkers,tiny).rvs()\n    return nGenious* billion\n#\ndef costBasicIncome():\n    salaryCost= nAdult * basicIncome\n    unitAdmCost = norm(250,75)\n    nonWorkerMultiplier = uniform(-0.10, 0.15).rvs()\n    nonWorker0=nAdult-laborForce-disabledAdults\n    nNonWorker = nonWorker0*(1+nonWorkerMultiplier)\n    marginalWorkerHourlyProductivity = norm(10,1)\n    admCost = nAdult * unitAdmCost.rvs()\n    unitBenefitNonWorker=40*52*marginalWorkerHourlyProductivity.rvs()\n    benefitNonWorkers = 1 * (nNonWorker*unitBenefitNonWorker)\n    geniusBenefit=geniusEffect(nNonWorker)\n    totalCost=salaryCost + admCost - benefitNonWorkers-geniusBenefit\n    return totalCost\n#\ndef costBasicJob():\n    unitAdmCost4disabled= norm(500,150).rvs()\n    unitAdmCost4worker = norm(5000, 1500).rvs()\n    nonWorkerMultiplier = uniform(-0.20, 0.25).rvs()\n    hourlyProductivity = uniform(0.0, hourlyPay).rvs()\n    cost4disabled=disabledAdults * (basicIncome + unitAdmCost4disabled)\n    nBasicWorkers=((nAdult-disabledAdults-laborForce)*(1+nonWorkerMultiplier))\n    annualCost=workingHoursPerWeek*workingWeeksPerYear*hourlyProductivity\n    cost4workers=nBasicWorkers * (basicIncome+unitAdmCost4worker-annualCost)\n    return cost4disabled + cost4workers\n#\nN = nSimulations\ncostBI = zeros(shape=(N,),dtype=float)\ncostBJ = zeros(shape=(N,),dtype=float)\nfor k in range(N):\n    costBI[k] = costBasicIncome()\n    costBJ[k] = costBasicJob()\n#\ndef myPlot(data,myTitle,key):\n    subplot(key)\n    width = 4e12\n    height=50*N/1024\n    title(myTitle)\n    #xlabel(\"Cost (Trillion = 1e12)\")\n    hist(data, bins=50)\n    axis([0,width,0,height])\n#\nmyPlot(costBI,\"Basic Income\",211)\nmyPlot(costBJ,\"Basic Job\",212)\nshow()\n```", "```py\nimport numpy as np \nimport scipy as sp \nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom datetime import datetime as dt \nfrom scipy.optimize import minimize\n#\n# Step 1: input area\nmean_0=(0.15,0.25)   # mean returns for 2 stocks\nstd_0= (0.10,0.20)   # standard deviations for 2 stocks \ncorr_=0.2       # correlation between 2 stocks\nnSimulations=1000    # number of simulations \n#\n# Step 2: Generate two uncorrelated time series \nn_stock=len(mean_0)\nn=nSimulations\nsp.random.seed(12345) # to get the same random numbers \nx1=sp.random.normal(loc=mean_0[0],scale=std_0[0],size=n) \nx2=sp.random.normal(loc=mean_0[1],scale=std_0[1],size=n) \nif(any(x1)<=-1.0 or any(x2)<=-1.0):\n    print ('Error: return is <=-100%')\n#\n# Step 3: Generate two correlated time series \nindex_=pd.date_range(start=dt(2001,1,1),periods=n,freq='d') \ny1=pd.DataFrame(x1,index=index_) \ny2=pd.DataFrame(corr_*x1+sp.sqrt(1-corr_**2)*x2,index=index_)\n#\n# step 4: generate a return matrix called R \nR0=pd.merge(y1,y2,left_index=True,right_index=True) \nR=np.array(R0)\n#\n# Step 5: define a few functions \ndef objFunction(W, R, target_ret):\n    stock_mean=np.mean(R,axis=0) \n    port_mean=np.dot(W,stock_mean)            # portfolio mean\n    cov=np.cov(R.T)                           # var-covar matrix \n    port_var=np.dot(np.dot(W,cov),W.T)        # portfolio variance \n    penalty = 2000*abs(port_mean-target_ret)  # penalty 4 deviation\n    return np.sqrt(port_var) + penalty        # objective function\n#\n# Step 6: estimate optimal portfolio for a given return \nout_mean,out_std,out_weight=[],[],[] \nstockMean=np.mean(R,axis=0)\n#\nfor r in np.linspace(np.min(stockMean),np.max(stockMean),num=100): \n    W = sp.ones([n_stock])/n_stock             # start equal w\n    b_ = [(0,1) for i in range(n_stock)]       # bounds\n    c_ = ({'type':'eq', 'fun': lambda W: sum(W)-1\\. })# constraint \n    result=minimize(objFunction,W,(R,r),method='SLSQP',constraints=c_,bounds=b_)\n    if not result.success:                     # handle error \n        raise BaseException(result.message)\n    out_mean.append(round(r,4))                # decimal places\n    std_=round(np.std(np.sum(R*result.x,axis=1)),6) \n    out_std.append(std_) \n    out_weight.append(result.x)\n#\n# Step 7: plot the efficient frontier\nplt.title('Simulation for an Efficient Frontier from given 2 stocks') \nplt.xlabel('Standard Deviation of the 2-stock Portfolio (Risk)') \nplt.ylabel('Return of the 2-stock portfolio')\nplt.figtext(0.2,0.80,' mean = '+str(stockMean)) \nplt.figtext(0.2,0.75,' std  ='+str(std_0)) \nplt.figtext(0.2,0.70,' correlation ='+str(corr_))\nplt.plot(np.array(std_0),np.array(stockMean),'o',markersize=8) \nplt.plot(out_std,out_mean,'--',linewidth=3)\nplt.show()\n```", "```py\nimport numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom datetime import datetime as dt\nfrom scipy.optimize import minimize\n#\n# Step 1: input area\nnStocks=20\nsp.random.seed(1234)                        # produce the same random numbers \nn_corr=nStocks*(nStocks-1)/2                # number of correlation \ncorr_0=sp.random.uniform(0.05,0.25,n_corr)  # generate correlations \nmean_0=sp.random.uniform(-0.1,0.25,nStocks) # means\nstd_0=sp.random.uniform(0.05,0.35,nStocks)  # standard deviation \nnSimulations=1000                           # number of simulations \n#\n# Step 2: produce correlation matrix: Cholesky decomposition\ncorr_=sp.zeros((nStocks,nStocks))\nfor i in range(nStocks):\n    for j in range(nStocks):\n        if i==j:\n            corr_[i,j]=1\n        else:\n            corr_[i,j]=corr_0[i+j]\nU=np.linalg.cholesky(corr_)\n#\n# Step 3: Generate two uncorrelated time series \nR0=np.zeros((nSimulations,nStocks))\nfor i in range(nSimulations):\n    for j in range(nStocks):\n        R0[i,j]=sp.random.normal(loc=mean_0[j],scale=std_0[j],size=1)\nif(R0.any()<=-1.0):\n    print ('Error: return is <=-100%')\n#\n# Step 4: generate correlated return matrix: Cholesky     \nR=np.dot(R0,U)\nR=np.array(R)\n#\n# Step 5: define a few functions\ndef objFunction(W, R, target_ret): \n    stock_mean=np.mean(R,axis=0)  \n    port_mean=np.dot(W,stock_mean)           # portfolio mean\n    cov=np.cov(R.T)                          # var-covar matrix\n    port_var=np.dot(np.dot(W,cov),W.T)       # portfolio variance\n    penalty = 2000*abs(port_mean-target_ret) # penalty 4 deviation \n    return np.sqrt(port_var) + penalty       # objective function \n#\n# Step 6: estimate optimal portfolo for a given return \nout_mean,out_std,out_weight=[],[],[] \nstockMean=np.mean(R,axis=0)    \n#\nfor r in np.linspace(np.min(stockMean), np.max(stockMean), num=100):\n    W = sp.ones([nStocks])/nStocks             # starting:equal w \n    b_ = [(0,1) for i in range(nStocks)]       # bounds\n    c_ = ({'type':'eq', 'fun': lambda W: sum(W)-1\\. })# constraint\n    result=minimize(objFunction,W,(R,r),method='SLSQP',constraints=c_, bounds=b_)    \n    if not result.success:                    # handle error\n        raise BaseException(result.message) \n    out_mean.append(round(r,4))               # a few decimal places\n    std_=round(np.std(np.sum(R*result.x,axis=1)),6)\n    out_std.append(std_)\n    out_weight.append(result.x) \n#\n# Step 7: plot the efficient frontier\nplt.title('Simulation for an Efficient Frontier: '+str(nStocks)+' stocks')\nplt.xlabel('Standard Deviation of the Porfolio')\nplt.ylabel('Return of the2-stock portfolio')\nplt.plot(out_std,out_mean,'--',linewidth=3)\nplt.show()\n```", "```py\nimport numpy as np\nimport pandas as pd\nfrom matplotlib.finance import quotes_historical_yahoo_ochl as getData \n#\n# input area\nticker='IBM'           # input value 1 \nbegdate=(1926,1,1)     # input value 2 \nenddate=(2013,12,31)   # input value 3 \nn_forecast=25          # input value 4\n#\ndef geomean_ret(returns): \n    product = 1\n    for ret in returns: \n        product *= (1+ret)\n    return product ** (1.0/len(returns))-1\n#\nx=getData(ticker,begdate,enddate,asobject=True, adjusted=True)\nlogret = np.log(x.aclose[1:]/x.aclose[:-1]) \ndate=[]\nd0=x.date\nfor i in range(0,np.size(logret)):\n    date.append(d0[i].strftime(\"%Y\"))\n#\ny=pd.DataFrame(logret,date,columns=['logret'],dtype=float)\nret_annual=np.exp(y.groupby(y.index).sum())-1 \nret_annual.columns=['ret_annual']\nn_history=len(ret_annual) \na_mean=np.mean(np.array(ret_annual))\ng_mean=geomean_ret(np.array(ret_annual))\nw=n_forecast/n_history\nfuture_ret=w*g_mean+(1-w)*a_mean\nprint('Arithmetric mean=',round(a_mean,3), 'Geomean=',round(g_mean,3),'forecast=',future_ret)\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nnp.random.seed(12345)\nn=200\na = np.random.uniform(size=(n*2))\nplt.scatter(a[:n], a[n:])\nplt.show()\n```", "```py\nimport sobol_seq\nimport scipy as sp\nimport matplotlib.pyplot as plt\na=[]\nn=100\nfor i in sp.arange(2*n):\n     t=sobol_seq.i4_sobol(1,i)\n     a.append(t)\nprint(a[0:10])\nx=sp.random.permutation(a[:n])\ny=sp.random.permutation(a[n:])\nplt.scatter(x,y,edgecolors='r')\nplt.show()\n[[array([ 0.]), 1], [array([ 0.5]), 2], [array([ 0.75]), 3], [array([ 0.25]), 4], [array([ 0.375]), 5], [array([ 0.875]), 6], [array([ 0.625]), 7], [array([ 0.125]), 8], [array([ 0.1875]), 9], [array([ 0.6875]), 10]]\n>>>\n```"]