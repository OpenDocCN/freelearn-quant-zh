- en: Chapter 9.  Derivative Pricing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Algorithmic trading and financial engineering are the two most computationally
    intensive parts of finance. People in these areas are not only experts in finance,
    mathematics, and statistics, but they are also well versed in computationally
    intensive software. In the earlier chapters, we have learnt about algorithmic
    trading. In this chapter, we will study the different types of derivative pricing
    techniques in R, as pricing of derivatives is the most crucial part of financial
    engineering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Derivative price depends upon the value of its underlying. We will start with
    a few basic option pricing models and move to other asset classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Option pricing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implied volatility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bond pricing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credit spread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credit default swaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interest rate derivatives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exotic options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Option pricing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The binomial model works with the continuous process, while the Cox-Ross-Rubinstein
    model works with the discrete process. Option price depends upon stock price,
    strike price, interest rates, volatility, and time to expiry. We will use the
    package `fOption` for the Black-Scholes model. The following commands install
    and load this into the workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Black-Scholes model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us consider an example of `call` and `put` options using hypothetical data
    in June 2015 with a maturity of September 2015, that is, 3 months to time to maturity.
    Assume that the current price of the underlying stock is USD 900, the strike price
    is USD 950, the volatility is 22%, and the risk-free rate is 2%. We also have
    to set the cost of carry (`b`); in the original Black-Scholes model (with underlying
    paying no dividends), it equals the risk-free rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command `GBSOption()` calculates the `call` option price using
    all other parameters. The first parameter is type of option, that is, `call` or
    `put`, the second is current stock price, the third is strike price, the fourth,
    fifth, sixth, and seventh are time to expiry, risk-free rate of interest, volatility,
    and cost of carry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the model can be seen by typing `model` on the R console and
    it consists of the title, which is Black-Scholes option, methodology, function
    syntax, parameters used and, toward the end, it has option price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would like to find the option price, you can do so using the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can change the first parameter to `p` if you would like to calculate the
    `put` option price.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will calculate the `put` option price and extract only
    price. It does not show other items in output as we used `@price`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Cox-Ross-Rubinstein model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Cox-Ross-Rubinstein model assumes that the underlying asset price follows
    a discrete binomial process. The price either goes up or down in each period.
    The important feature of the CRR model is that the magnitude of the up movement
    is inversely proportional to the down movement, that is, *u=1/d*. The price after
    two periods will be the same if it first goes up and then goes down or vice versa,
    as shown in *Figure 9.1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two commands compute the `call` and `put` option prices using
    the binomial model and keeps all other parameters the same as in the continuous
    case except the last parameter. The last parameter is the number of steps time
    is to be divided to model the option. I used `n=3`, which means only three steps
    are used to price option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: However, all the values supplied to the Black-Scholes and binominal models are
    the same but the output is not exactly the same, it is a little bit different
    for both `call` and `put` options. If we are interested in the path or trajectory
    of the price movement then we should use the following command, which calculates
    the binomial tree of the `call` option price, and save the result in variable
    named `model`.
  prefs: []
  type: TYPE_NORMAL
- en: The second command uses the variable model to plot the binomial tree, which
    is done using `BonimialTreePlot()`; it also helps in placing the option value
    in tree. Third and fourth are x-axis and y-axis labels, and the fifth is x-axis
    limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third command is used to place the title of the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you are interested in calculating the `put` option value then you should
    use the first parameter, that is, `TypeFlag="pe"`, in `BinomialTreeOption()`.
    As the number of steps increases, the binomial tree results converge to continuous
    case. This can be verified using a `for` loop with 100 iterations. For this, we
    can define the `func` function with one parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the definition of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following figure, you can see the option price, which shows the price
    at each node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cox-Ross-Rubinstein model](img/00131.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Call option value at each node'
  prefs: []
  type: TYPE_NORMAL
- en: The rightmost layer has four nodes and the prices are **0**, **0**, **9.01**,
    and **138.9** from down. The third layer has three nodes and the prices are **0**,
    **4.47** and **73.47**, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.1* is for three time steps. However, we can increase the number of
    steps and the option price starts converging to fair price as the number of steps
    increases. We have to put the `func` function into the loop from 1 to 100\. Next,
    we can plug this into `sapply()` along with iterations 1 to 100 and `func`, which
    results in a sequence of 100 option prices with an increasing number of steps.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the use of `sapply()`, and *Figure 9.2* shows the
    binomial prices and CRR prices with 100 step sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As the number of steps increases, we can see in the following figure that CRR
    price converges to Black-Scholes price:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cox-Ross-Rubinstein model](img/00132.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Black-Scholes and CRR prices'
  prefs: []
  type: TYPE_NORMAL
- en: Greeks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Greeks are also very important in option pricing. It helps to understand the
    movement of option price against different factors such as underlying price, time
    to expiry, risk-free rate of return, and volatility. The `GBSGreeks()` function
    calculates Greeks, where the first parameter is for what Greek we are interested
    in, the second is for option type, the third is for underlying price, the fourth
    for exercise price, the fifth for time to maturity, the sixth for risk-free rate
    of interest, and the seventh and eighth for annualized cost of carry and annualized
    volatility. Using the following code, we can calculate `delta` of the `call` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can change the second parameter to `p`, which will give you
    `delta` for the `put` options. Understanding of Greeks is important as this shows
    how Greeks change with other market parameters. This helps to diversify portfolios
    and control risk. Gamma can be calculated using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can calculate Vega, Rho, and Theta for `call` and `put` options
    controlling the first and second parameters. Now, suppose you want to calculate
    `delta` of a straddle portfolio, that is, a portfolio of `call` and `put` options
    for the same underlying, striking price, and expiration date, you should calculate
    `delta` separately for `call` and `put` options and add them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code calculates the `delta` for `call` and `put` options for
    prices ranging from `500` to `1500` with increment of 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This command shows the first few values of the `call` and `put` option delta
    separately. The first column is for `call` and the second column is for `put`
    option delta:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We plot the straddle portfolio''s `delta` using `plot()` using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is the *x* axis, which is underlying price; in our case,
    it is ranging from `500` to `1500`. The second parameter is the *y* axis, which
    is the sum of `call` and `put delta`, keeping all other parameters constant. The
    following figure shows the `delta` for the straddle portfolio which lies between
    -1 to 1 and is S-shaped:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Greeks](img/00133.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Delta of straddle portfolio'
  prefs: []
  type: TYPE_NORMAL
- en: Implied volatility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In option trading, we calculated volatility as historical volatility and implied
    volatility. Historical volatility is the price deviation in the past one year
    while implied volatility, on the other hand, is calculated using option price
    and implies stock volatility in the future. Implied volatility is crucial in option
    trading as it gives the future estimate of stock volatility. European `call` option
    implied volatility can be calculated using `EuropeanOptionImpliedVolatility()`,
    as shown in the following code. The first parameter is type of option, the second
    is `call` or `put` price, the third and fourth are current price of underlying
    and strike price of option, the fifth is dividend yield, and the sixth, seventh,
    and eighth parameters are risk-free rate of return, time to maturity in years,
    and initial guess for volatility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, implied volatility for the American option can be calculated using
    `AmericanOptionImpliedVolatility()`.
  prefs: []
  type: TYPE_NORMAL
- en: Bond pricing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bonds are very important financial instruments as they provide cash flow at
    a certain time at the predetermined rate or current market rate. Bonds help investors
    to create well-diversified portfolios. One must calculate bond price, yield, and
    maturity precisely to get a better idea of the instrument. We are going to use
    package `termstrc` for this. We have to install and load it into the R workspace
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the data `govtbonds` in the package, which can be loaded and viewed
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable `govbonds` has bond data for three countries - Germany, Austria,
    and France. We will be using the Germany data to calculate bond prices, which
    can be accessed using `govbonds[[1]]`. The following two lines of code generate
    `cashflow` and `maturity` matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will look at the usage of `bond_prices()`, which calculates the bond
    prices. `beta` is another parameter to be supplied to the function `bond_prices()`.
    Next we can create the `beta` variable and defined `bond_prices()`. The first
    parameter in this function is `method`, which supports three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ns` for Nelson/Siegel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dl` for Diebold/Li'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sv` for the Svensson approach'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will choose the `ns` method for the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable `bp` has spot rates, discount factors, and bond prices. Any information
    can be accessed using `$`. For example, you can bond prices using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Bond yield is investor return which is realized on bond investment, and it
    can be calculated using `bond_yields()`. The following two lines of code generate
    `cashflow` and `maturity` matrices, which include dirty prices as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code calculates the bond yield and maturities in matrix form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code can be seen by typing the following command
    `head()` and the output has two columns, where the first column of the output
    matrix is maturity in years and the second column is the corresponding bond yield
    for the corresponding bonds. Bond names are given as an index of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows yield curve or term structure against various maturities.
    Yields fluctuate initially for a very small maturity period and continuously increase
    as the maturity increases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bond pricing](img/00134.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Yield curve, that is, term structure with different maturities'
  prefs: []
  type: TYPE_NORMAL
- en: 'Duration measures the length of time it takes for the price of the bond to
    be repaid by its internal `cashflow`. It is a very important factor for investors
    to consider, as bonds with higher duration carry more risk and higher price volatility
    than bonds with lower duration. Duration can be measured using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns duration in years, modified duration, and weights for all bonds
    in the portfolio. If you want to look at the portfolio composition, you can see
    the third column of the output matrix. The third column is weights for your investment
    and you would see that the sum of the weights is equal to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Credit spread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Credit risk is one of the major problems for financial institutions. The major
    cause for this is credit quality, and credit spread values help to understand
    credit risk depending upon the credit quality. Credit spread is an important concept
    in institutional trading as credit spread depends upon the quality or rating of
    bonds. It is the difference in bond yield of two bonds with similar maturity but
    with different bond ratings. We are going to use the `CreditMetrics` package for
    this, which can be installed and imported to the R workspace using the following
    two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Credit spread is calculated using `cm.cs()`, which has just two parameters.
    The first parameter is the one-year migration matrix for some institution or government
    which issues credit and the second parameter is **loss given default** (**LGD**),
    which means maximum loss if the obligor of credit defaults. Normally, credit with
    rating `AAA` is on the top and considered as safe, and rating `D` is on the bottom
    and considered as default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a vector of all credit ratings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows we have eight ratings. The transition matrix is the
    probability of going from one credit rating to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code generates a matrix of such probabilities in an eight-by-eight matrix,
    with rating as index and column names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can have a look at this matrix by typing the variable name, that is, `M,`
    on the command prompt, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see in the preceding table that the last column has probabilities of
    default for bonds of all ratings; that means it is very unlikely bonds with `AAA`,
    `AA`, and `A` rating will default. However, the default probability increases
    as the bond rating deteriorates towards `CCC`. The last row has all zeros except
    for the last one, which means bonds which are default have zero probability of
    improving the rating. We can set the loss given default (`lgd`) parameter as `0.2`
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As we have designed a transition matrix and set the `lgd` parameter, we can
    now use the `cm.cs()` function to generate credit spread.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code does this and calculates credit spread for all ratings respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding results illustrate that credit spread is less for good credit
    rating bonds and it increases as we move toward the left or as the probability
    of default increases. The rightmost rating `CCC` has the highest spread of 4%
    because, as per above matrix `M`, the probability of default for `CCC` rating
    bonds is 19.79 % .Value at risk for this credit can be calculated using `cm.CVaR()`,
    which has nine parameters. The first two parameters are the same as for `cm.cs()`,
    that is, migration matrix and loss given default (`lgd`), and the remaining are
    exposure at default, number of companies, number of simulated random numbers,
    risk-free interest, correlation matrix, confidence level, and rating of companies.
  prefs: []
  type: TYPE_NORMAL
- en: 'All parameters are set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Credit value at risk can be used in the following line of code, where the parameters
    are as defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This credit VaR number is annualized, which means there is a 1% chance that
    this portfolio of three companies might lose this value in the next year. This
    output is based on simulated prices. Simulated prices change in every run so `cm.CVaR()`
    output might also change every time you execute the preceding code. `ca.gain()`,
    which requires all the parameters as `cm.CVaR()` except alpha, is used to calculate
    simulated profit and loss and can be used like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Credit default swaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In brief, a **credit default swap** (**CDS**) is used to transfer the credit
    risk of a reference entity (corporate or sovereign) from one party to another.
    In a standard CDS contract, one party purchases credit protection from another
    party, to cover the loss of the face value of an asset following a credit event.
    A credit event is a legally defined event that typically includes bankruptcy,
    failure-to-pay, and restructuring. The protection lasts until some specified maturity
    date. To pay for this protection, the protection buyer makes a regular stream
    of payments, known as the premium leg, to the protection seller. This size of
    these premium payments is calculated from a quoted default swap spread, which
    is paid on the face value of the protection. These payments are made until a credit
    event occurs or until maturity, whichever occurs first. The issuer of the CDS
    derivative has to price it before selling. We will be using the `credule` package
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two codes are used for installing this package and loading it into the
    R workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`priceCDS()` calculates the spread of several CDSs of different maturities
    from a yield curve and credit curve. Here, we are going to define parameters which
    will be used for pricing CDSs. The yield curve vector is defined below and is
    the tenor of each yield curve in years:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the vector is defined as yield curve discounted rate, which is going
    to be the second parameter in the pricing CDS function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two lines of code define the tenor of the credit curve in years
    and survival probability for a tenor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the maturity of the CDS in years, which we are going to price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Another parameter is defined here, which is recovery rate in case of default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We have successfully defined mandatory parameters. The next line does the job
    of pricing the CDS of multiple tenors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function returns a DataFrame where the first column is tenors
    and the second column is spreads for **credit default swaps** (**CDS**) for a
    given tenor. If you would like to use the bootstrap technique to understand the
    probability distribution of credit default swaps then you can use `bootstrapCDS()`,
    which has yield curve tenor, yield curve rates, CDS tenor, CDS spread, and recovery
    rates. We are going to define the `cdsSpread` parameter, as all other parameters
    have already been defined above, which we will use in `bootstrapCDS()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command gives the bootstrap credit curve for credit default swap
    spreads for different maturities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The output of the preceding command generates three columns. The first is the
    tenor, the second column is survival probability for each tenor, and the last
    column is hazard rate, that is, the intensity of Poisson distribution, for each
    tenor.
  prefs: []
  type: TYPE_NORMAL
- en: Interest rate derivatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the `GUIDE` package to calculate the price for interest rate derivatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will open a pop-up window which requires all the parameters.
    Once you supply the required parameters in the pop-up window, it generates the
    interest rate derivative price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters to be supplied in the pop-up window are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Notional:** To be entered in decimals'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fixed rate**: Entered in decimals, for example, 0.05 for 5%'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Last spot rate**: Entered in decimals, for example, 0.05 for 5 per cent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Months for first payment**: Enter 3 for 3 months'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spot rates**: Enter with comma separation, for example, 0.054, 0.056, 0.058'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frequency of spot rates**: Chosen from continuous/quarterly/semi-annual/annual'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Settlement frequency**: Chosen from quarterly/semi-annual/annual'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exotic options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Asian, barrier, binary, and lookback options are a few exotic options. Exotic
    options are quite different than normal American or European options, or vanilla
    options, and have a few new features which make it quite complex to price. An
    American or European `call` or `put` option is considered as a non-exotic or vanilla
    option. Exotic options are complex because of a few features:'
  prefs: []
  type: TYPE_NORMAL
- en: The way it gets settled varies depending on the moneyless of the option at the
    time of maturity. It can be settled in cash as well as stock options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It could also involve foreign exchange rates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payoff at the time of maturity depends not just on the underlying stock price
    but on its value at several times during the contract life.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will be using the `fExoticOptions` package to price various types of exotic
    options. For this, the following two lines of code are used to install and load
    this package into the R workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Asian options can be priced in different ways. Here are a few functions to price
    Asian options. `GeometricAverageRateOption()` prices Asian options based on geometric
    average rate options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code with the Asian `call` option pricing function using geometric
    average rate option. The first parameter is the `call` (`"c"`) option and other
    parameters are stock price (`110`), exercise price (`120`), time to maturity (`0.5`,
    that is, 6 months), risk-free interest rate (3%), cost of carry (5%), and volatility
    (10%):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You can calculate the price for Asian `put` options as well by replacing `c`
    with `p`. `TurnbullWakemanAsianApproxOption()` also calculates the Asian option
    price and is based on Turnbull and Wakeman''s approximation. It uses two new parameters
    (`SA`), time and `tau` in addition to parameters used in previous functions. `SA`
    and time are used. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there is another technique to calculate the Asian option price by
    using `LevyAsianApproxOption()`, which uses Levy''s approximation to price Asian
    options and use all parameters used in `TurnbullWakemanAsianApproxOption()` except
    `tau`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: There are many functions to calculate the price for barrier options as well.
    Standard barrier option, double barrier option, and lookback barrier option are
    a few of them. There are four types of single barrier options.
  prefs: []
  type: TYPE_NORMAL
- en: The type flag `cdi` denotes a down-and-in call, `cui` denotes an up-and-in call,
    `cdo` denotes a down-and-out call, and `cuo` denotes an up-and-out call.
  prefs: []
  type: TYPE_NORMAL
- en: The following command calculates the standard barrier option price using `StandardBarrierOption()`,
    which requires two additional parameters in `GeometricAverageRateOption()` and
    these additional parameters are barrier value and rebate value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first parameter is option type, which is a down-and-out call in the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, `H = 95` is barrier value and `K=3` is rebate. Double
    barrier option requires lower (`L`) and upper (`U`) bounds along with curvature
    of lower and upper bounds, that is, `delta1` and `delta2`. It also has four types
    of options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type flag `co` denotes an up-and-out-down-and-out call, `ci` denotes an
    up-and-in-down-and-in `call`, `po` denotes an up-and-out-down-and-out `put`, and
    `pi` denotes an up-and-in-down-and-in call. We will use `co` type option in the
    following command along with other parameters to calculate the double barrier
    option price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The option comes into existence if it is a knock-in barrier or becomes worthless
    if it is a knocked-out barrier. Lookback barrier is another type of barrier option
    and it also has four types, `cuo` denotes an up-and-out call, `cui` denotes an
    up-and-in call, `pdo` denotes a down-and-out put, `pdi` denotes a down-and-in
    put.The option's barrier monitoring period starts at time zero and ends at an
    arbitrary date before expiration. If the barrier is not triggered during this
    period, the fixed strike lookback option will be kicked off at the end of the
    barrier tenor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line of code calculates the lookback barrier, that is, `cuo`,
    option price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Barrier options are another kind of exotic option, which are also called digital
    options. Unlike standard European-style options, the payout for binary options
    does not depend on how much it is in the money but rather whether or not it is
    on the money. The option''s payoff is fixed at the option''s inception and is
    based on the price of the underlying asset on the expiration date. Gap option,
    cash or nothing, and two asset cash or nothing are a few of the binary options.
    The payoff on a gap option depends on the usual factors of a plain option, but
    is also affected by a `gap` amount of exercise prices, which may be positive or
    negative. The following commands calculate gap option, which is one of the binary
    options, price using `GapOption()` and the `X1` and `X2` parameters in this function
    are two exercise price which create gap option, and all other parameters are as
    usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`CashOrNothingOption()` calculates the price for the cash or nothing option
    and for this option, a predetermined amount is paid at expiration if the asset
    is above for a call or below for a put at strike level. The amount independent
    of the path is taken. These options require no payment of an exercise price. The
    exercise price determines whether or not the option returns a payoff. The value
    of a cash-or-nothing `call` (`put`) option is the present value of the fixed cash
    payoff multiplied by the probability that the terminal price will be greater than
    (less than) the exercise price. The following line has `S` as stock price, `X`
    as exercise price, and `K` as cash amount to be paid at expiry if the option expires
    in the money:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Two Asset Cash or Nothing options are building blocks for constructing more
    complex exotic options and there are four types of two asset cash or nothing options.
    The first two situations are: a Two Asset Cash or Nothing call which pays out
    a fixed cash amount if the price of the first asset is above (below) the strike
    price of the first asset and the price of the second asset is also above (below)
    the strike price of the second asset at expiration. The other two situations arise
    under the following conditions: a Two Asset Cash or Nothing down-up pays out a
    fixed cash amount if the price of the first asset is below (above) the strike
    price of the first asset and the price of the second asset is above (below) the
    strike price of the second asset at expiration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function does the job of calculating the two asset cash or nothing
    option price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TypeFlag` : Option type `"c"` for call `"p"` for put'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`S1`, `S2`: Stock price for two assets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X1`, `X2`: Two exercise prices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`K`: Cash amount to be paid at expiry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Time`: Time to expiry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r`: Risk-free interest rate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b1`, `b2`: Cost of carry for two assets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sigma1`, `sigma2`: Two asset volatility'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rho`: Correlation between two assets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is much more detail available about all other type of exotic options and
    for more details about exotic options, you should look at the PDF file with the
    name `fExoticOptions` which you can download from the Web.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the packages to be used for option, bond, and exotic options pricing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which functions will you use to calculate the option price using the Black-Scholes
    and Cox-Ross-Rubinstein methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the CRR price converge to the binomial price and which command would
    you use to calculate Greeks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a command to calculate implied volatility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you prepare a `cashflow` and `maturity` matrix to the form which would
    be used in bond pricing function, and which function would be used for bond pricing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the functions to be used for credit spread and credit default swaps?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the Asian option types, barrier option types, and digital option types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the functions you would use for the options in question 7?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter used derivative pricing only in terms of implementation in R, and
    various packages such as `foptions`, `termstrc`, `CreditMetrics`, `credule`, `GUIDE`,
    and `fExoticOptions` to price options, bonds, credit spreads, credit default swaps,
    and interest rate derivatives, and different types of exotic options were used.
    Derivative pricing is crucial in derivative trading and it is very important to
    learn it.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also covered the Black-Scholes and Cox-Ross-Rubinstein methods,
    along with Greeks and implied volatility for options. It also explained bond price
    and yield curves. It also used functions which explain how credit spread, credit
    default swaps, and interest rate derivatives are priced. Toward the end, it covered
    various types of exotic options. It used data given in relevant packages and implemented
    functions.
  prefs: []
  type: TYPE_NORMAL
