- en: Chapter 8. Setting Up the Trading System Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we'll set up the trading system, which we'll develop throughout
    the rest of this book. The trading system will summarize the things we've learned
    so far. It's also a good way of illustrating the power of F# in combination with
    existing tools and libraries. We'll start out by setting up the project in Visual
    Studio, then adding the references needed for testing and connecting to Microsoft
    SQL Server. Type providers and **Language-INtegrated-Query** **(LINQ**) will be
    briefly introduced here, and more details will be covered in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: More about automated trading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-driven development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements for the trading system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type providers in F#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining automated trading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated trading is becoming increasingly popular these days. Most trading
    strategies can be implemented to be traded by a computer. There are many benefits
    to automating a trading strategy. The trading strategy can be backtested using
    historical data. This means the strategy is run on historical data and the performance
    of the strategy can be studied. We'll not cover backtesting in this book, but
    the trading system developed here can be modified to support backtesting.
  prefs: []
  type: TYPE_NORMAL
- en: Automated trading systems are, as the name suggests, automated systems for trading
    that are run on a computer. They often consist of several parts such as feed handlers,
    order management systems, and trading strategies. Typically, automated trading
    systems will represent a pipeline from market data to orders to be executed, and
    keep track of state and history. Rules are written to be executed in near real
    time for the market data entering the system. It's much like a regular control
    system, with an input and an output. In the following chapters we'll look at how
    to implement a rather simple, yet powerful, trading system in F#, wrapping up
    what we have learnt in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the parts of an automated trading system:'
  prefs: []
  type: TYPE_NORMAL
- en: Feed handlers and market data adapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trading strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order execution and order management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistence layer (DBs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GUI for monitoring and human interaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the block diagram showing the parts of an automated trading system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Explaining automated trading](img/4623OS_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: Typical block diagram of a trading system'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding software testing and test-driven development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing software, it's crucial to be able to test the functionality of
    the system being written. In software development, there is a popular and effective
    way of writing code in a more agile fashion, namely test-driven development. This
    method is driven by tests, and the tests written before the main logic are implemented.
    In other words, when you are about to write a test case for a system, you will
    certainly have a couple of requirements already at hand, or an idea about the
    software. In test-driven development, the tests will reflect the requirements.
    This is a way of writing the requirements in code that will test the piece of
    software for a given set of functionality. The tests are implemented as test cases,
    and test cases are collected into test suites. The tests will preferably be automated
    with a tool. Having automated tests will enable the developers to rerun the tests
    every time a change is made to the code.
  prefs: []
  type: TYPE_NORMAL
- en: We'll focus on unit testing in this chapter using **NUnit**.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding NUnit and FsUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NUnit is an open source unit testing framework for all .NET languages, same
    as JUnit is for Java. NUnit enables the programmer to write unit tests, and execute
    the test to be able to see which tests are successful and which failed. In our
    project we''ll use NUnit and its external tool for running tests. A typical line
    for testing in F# using FsUnit can look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Requirements for the system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section we'll discuss some of the main requirements for the trading
    system. We'll not specify all the details, because some of them are needed to
    be divided into parts. The trading system will make use of some libraries and
    tools, specified in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Table some of the most important requirements of the trading system we'll develop.
    It will be a simple system with trading options for volatility arbitrage opportunities
    using S&P 500 index options and the CBOE Volatility Index (VIX). The S&P 500 index
    consists of the largest 500 companies listed on NYSE or NASDAQ. It's considered
    to be a general indicator of the U.S. stock market. The VIX is an index of the
    implied volatility of S&P 500 index options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system should be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Store log entries in a Microsoft SQL Server database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store trade history in a Microsoft SQL Server database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download quotes from Yahoo! Finance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send an order using FIX 4.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect using FIX 4.2 to a FIX simulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute a trading strategy written in F#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be controlled from a basic GUI with start/stop buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the current position(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the current profit and loss
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the latest quote(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the MVC pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the libraries and tools used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'QuickFIX/N: The FIX protocol for .NET'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'QuantLib: This is a library for quantitative finance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft SQL Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FSharpChart: This is an F# friendly wrapper of Microsoft Chart Controls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section we'll set up the solution in Visual Studio. It will consist
    of two projects; one project for the trading system and one project for the tests.
    Separating the two has some advantages and will produce two binaries. The tests
    will be run from the NUnit program, which is a standalone program for running
    unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will create two projects in the same solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new F# application, name it **TradingSystem** as shown in the following
    screenshot:![Setting up the project](img/4623OS_08_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2: Adding a new project to a solution'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a new project to the existing **TradingSystem** solution. Right-click on
    the solution as shown in *Figure 2*, and navigate to **Add** | **New Project...**.
    Create another F# application and name it **TradingSystem.Tests**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we have to add the testing frameworks to the **TradingSystem.Tests** project
    as shown in the following screenshot:![Setting up the project](img/4623OS_08_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3: The solution with the two projects'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now we have the solution set up with two projects. You can see the references
    in each of the projects in *Figure 3*. We'll add some more references to both
    projects in this chapter. Next we'll install the testing frameworks, first NUnit,
    then FsCheck.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing the NUnit and FsUnit frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section we'll look at how to install NUnit and FsUnit and how to use
    it with F# Interactive to verify that everything works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install NUnit and FsUnit, follow these steps in Visual Studio 2012:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Package Manager console by navigating to **VIEW** | **Other Windows**
    | **Package Manager Console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **TradingSystem.Tests** as the default project in the drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `Install-Package NUnit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `Install-Package FsUnit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `Add-BindingRedirect TradingSystem.Tests`. The following screenshot
    shows the result from the preceding steps:![Installing the NUnit and FsUnit frameworks](img/4623OS_08_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last command is to ensure that `Fsharp.Core` is up-to-date, and it will
    also update `App.config` if necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s play around with the NUnit framework in F# Interactive to get a feeling
    of what it is and to see if everything is set up correctly. Add the following
    code to an F# script file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that you have to find the path of the two DLLs, because it will differ
    from machine to machine. Simply go to **References** in your project (**TradingSystem.Tests**),
    click on the particular framework in **Solution Explorer**, and **Full Path**
    will be updated in the **Properties** window. Use this **Full Path** in the preceding
    code, do it for both the DLLs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally you can test the preceding code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This means our first testing framework is set up successfully. Next we'll look
    at adding some tests in the code and run them from NUnit.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to Microsoft SQL Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will assume you have a running instance of Microsoft SQL Server
    either on your local machine, as part of Visual Studio 2012, or on a remote machine
    with access permissions as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting to Microsoft SQL Server](img/4623OS_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The steps for connecting to Microsoft SQL Server are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **VIEW** | **Server Explorer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on **Data Connections**, and choose **Add connection**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Microsoft SQL Server (SqlClient)** as the **Data Source**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the local machine if you have Microsoft SQL Server installed locally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Use Windows Authentication**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the name of the database. From now on, we'll refer to our database as
    **TradingSystem**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To test whether the setup is successful, press **Test Connection** in the lower-left
    corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then you will encounter a dialog asking if you want to create it, press **Yes**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we have the database for our project, and next we'll add the tables needed
    for the project. To do this, open **VIEW** | **SQL Server Object Explorer**. It
    will look like the following screenshot:![Connecting to Microsoft SQL Server](img/4623OS_08_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add our tables, we'll use the SQL snippets provided in the next step. Right-click
    on the **TradingSystem** database, and click on **New Query…**. Paste the following
    code to create the table `Log`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the SQL code to create the `Log` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will output the following in the SQL terminal below the editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll use this table in the next section about type providers and LINQ.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing type providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type providers are powerful ways of dealing with structured data from XML documents,
    SQL databases, and CSV files. They combine the type system of F# with structured
    data, which can be a tedious task in statically typed languages in many cases.
    Using type providers, the type of the data source is automatically converted to
    native types; this means the data is parsed and stored using the same field names
    as used in the data source. This enables Visual Studio and IntelliSense to support
    you in your coding without looking in the data source for the field names all
    the time.
  prefs: []
  type: TYPE_NORMAL
- en: Using LINQ and F#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'LINQ is a feature in the .NET framework and has been supported in F# since
    Version 3.0\. It''s used to provide powerful query syntax and can be used together
    with databases, XML documents, .NET collections, and so on. In this section we''ll
    briefly introduce LINQ and see how we can use it together with a SQL database.
    But first we''ll look at LINQ together with collections:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need a list of values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we can construct our first LINQ query, which will select all the values
    in the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is not that useful, so let''s add a condition. We''ll now select all values
    greater than `5`, this is done using a `where` clause:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can add another condition, selecting values greater than `5` and less than
    `8`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is quite powerful, and it's more useful when dealing with data from, for
    example, SQL databases. In the next section we'll look at a sample application
    using both type providers and LINQ to insert and query a database.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining sample code using type providers and LINQ
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section we''ll look at a sample application using type providers and
    LINQ. We''ll use the `Log` table that we created earlier. This is a good way to
    test if everything works with the SQL database and the permissions to read and
    write to and from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The connection string has to be changed in some cases; if so, simply check
    the `Connection` string value in the properties for the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use LINQ to query our table. The code will be modified and used in the
    final application. Here we have one query to list all entries from the `Log` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use F# Interactive to see if the code works by adding a log entry and
    then trying to obtain it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This seems to work fine, and we can consider the SQL Server setup done. We'll
    add tables and functionality in the next two chapters. But this is fine for now,
    the setup is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also convenient to browse the data in Visual Studio for a table in the
    database. To do this, right-click on the `Log` table in the **SQL Server Object
    Explorer** and **View Data**. You will see a view similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Explaining sample code using type providers and LINQ](img/4623OS_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the remaining table for our project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SQL database will be used to store the state and history of our system.
    It's mainly for illustrative purposes. We'll store log information and trade history.
    For this, we have to add a new table, and this will be done in the same way as
    before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you execute the preceding SQL code, you will now see the table added to
    the **Tables view** in the **SQL Server Object Explorer** as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the remaining table for our project](img/4623OS_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Following in our previous footsteps, we will examine sample code to query and
    insert a trade history entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use F# Interactive to see if the code works by adding a trade entry
    and then trying to obtain it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It seems to work fine!
  prefs: []
  type: TYPE_NORMAL
- en: Writing test cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section we''ll look at some of the test cases that can be written for
    the trading system. We''ll use NUnit together with the graphical user interface
    provided by NUnit to accomplish this. The following screenshot displays the main
    GUI from NUnit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing test cases](img/4623OS_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: The NUnit user interface'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start to write real tests for our system, we''ll write a simple test
    to verify that our setup is correct. NUnit will automatically rerun the executable
    every time it''s built. We start by writing a simple test inside the `TestOrderValidation`
    file, before we write the real ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is quite silly, but we''ll be able to see if NUnit detects changes and
    if NUnit will detect the test cases inside the `.exe` file. The steps for writing
    a simple test case are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up **NUnit** and navigate to **File** | **Open Project...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `.exe` file corresponding to the .exe? file in **TradingSystem.Tests**,
    located in `..\visual studio 2012\Projects\TradingSystem\TradingSystem.Tests\bin\Debug`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the **Run** button and it should look like the following figure:![Writing
    test cases](img/4623OS_08_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 5: NUnit when the sample unit test is run successfully'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we know the setup is correct, let''s start to write some real unit
    tests for our order validation code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to build the project and then NUnit should be able to detect the
    changes. If everything works correctly, the NUnit GUI should look like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing test cases](img/4623OS_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: NUnit when the ValidateBuyOrder test is run'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some more tests for the order validation code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the name of the module is renamed to `ValidateOrderTests`. We''ll
    add more tests for validating instruments and using pre-trade risks in the same
    file. The following screenshot shows the four tests for validating orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing test cases](img/4623OS_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: NUnit when the four tests are run
  prefs: []
  type: TYPE_NORMAL
- en: Details about the setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a listing of the references used in the project until now.
    Use this to check if your project is up-to-date:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TradingSystemFSharp.Core`'
  prefs: []
  type: TYPE_NORMAL
- en: '`FSharp.Data.TypeProviders`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mscorlib`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Core`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Data`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Data.Linq`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Numerics`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TradingSystem.Tests`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Fsharp.Core`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FsUnit.NUnit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TradingSystem.Core`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FSharp.Data.TypeProviders`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mscorlib`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nunit.framework`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Core`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Numerics`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we set up the project, consisting of the trading system itself
    and the tests. We looked at how to use Visual Studio to handle our solution and
    integrate it with NUnit and FsUnit. We also looked at how to connect to Microsoft
    SQL Server and how to write queries in LINQ and retrieve data throughout the type
    providers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two chapters, we'll continue to develop the trading system from
    the base built in this chapter.
  prefs: []
  type: TYPE_NORMAL
