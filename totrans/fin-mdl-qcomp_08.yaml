- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: NISQ Quantum Hardware Roadmap
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NISQ量子硬件路线图
- en: When using our implemented circuits for the different options we have explored,
    one key factor is the relevance of noise to obtain meaningful results. Along these
    lines, we would like to take you through the work you might need to consider while
    adapting to each specific hardware vendor, the specifics of those devices, and
    the bets some of them have taken for their scaling roadmap so that you can choose
    your companionship for this journey wisely.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用我们实现的电路进行我们探索的不同选项时，一个关键因素是噪声对获得有意义结果的相关性。在这方面，我们希望带您了解您可能需要考虑的工作，包括如何适应每个特定硬件供应商、这些设备的具体细节，以及他们在规模化路线图中所做的一些尝试，这样您可以明智地选择在这条旅程中的合作伙伴。
- en: Previously, we have seen how simulators can be used with classical devices,
    with those simulators being free of any kind of noise, as we explained in [*Chapter
    8*](B19146_08.xhtml#_idTextAnchor157). We could also include the limitations and
    noise models of different types of quantum devices so that emulation can occur.
    So, even though classical resources will be used to perform our computations,
    the system will introduce errors and specific characteristics related to the qubit
    coupling of real devices so that the outcome will resemble the effect of running
    on the actual hardware.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们已经看到如何使用经典设备来运行模拟器，这些模拟器不受任何噪声的影响，正如我们在[*第8章*](B19146_08.xhtml#_idTextAnchor157)中所解释的那样。我们也可以包括不同类型量子设备的限制和噪声模型，以便进行仿真。因此，即使经典资源将用于执行我们的计算，系统也会引入错误和与实际设备的量子比特耦合相关的特定特性，从而使结果类似于在实际硬件上运行的效果。
- en: In any case, both simulators and emulators are limited by classical hardware
    and its ability to imitate the dynamics of a quantum circuit. And even though
    performant means are available today, as we saw in the previous chapter, this
    limitation will lead us to the actual hardware at some point. In particular, when
    focusing on realistic applications, we may need several qubits to encode the problems
    at hand.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，模拟器和仿真器都受到经典硬件的限制，以及它模仿量子电路动态的能力。即使今天已经有高效的手段，正如我们在前一章中所看到的，这一限制最终还是会将我们引向实际硬件。特别是当我们关注实际应用时，可能需要多个量子比特来编码手头的问题。
- en: Currently, companies such as IBM and D-Wave provide quantum hardware services
    that are in the order of 433 qubits, as in the case of IBM’s superconducting chips,
    and 5,000 qubits, as in the case of D-Wave’s annealing machines. It is complicated
    to get close to emulating something in that order. Recently, researchers of the
    AWS Quantum Computing Center learned they could perform a 44-qubit simulation
    ([https://aws.amazon.com/blogs/hpc/simulating-44-qubit-quantum-circuits-using-aws-parallelcluster/](https://aws.amazon.com/blogs/hpc/simulating-44-qubit-quantum-circuits-using-aws-parallelcluster/))
    while leveraging their distributed computing cloud resources. You can see the
    problems we might face classically while simulating circuits at these scales.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，像IBM和D-Wave这样的公司提供的量子硬件服务约为433个量子比特（例如IBM的超导芯片）和5,000个量子比特（例如D-Wave的退火机器）。要模拟如此规模的设备是非常复杂的。最近，AWS量子计算中心的研究人员发现，他们可以通过利用分布式计算云资源，进行一个44量子比特的仿真（[https://aws.amazon.com/blogs/hpc/simulating-44-qubit-quantum-circuits-using-aws-parallelcluster/](https://aws.amazon.com/blogs/hpc/simulating-44-qubit-quantum-circuits-using-aws-parallelcluster/)）。您可以看到，在这种规模下进行电路仿真时，我们可能面临的经典计算问题。
- en: Therefore, to leverage the potential of current quantum devices, we will need
    to deal with noise and potential errors while executing a quantum circuit.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了充分利用当前量子设备的潜力，我们需要在执行量子电路时处理噪声和潜在的错误。
- en: Each vendor has proposed a roadmap for their device evolution, which allows
    for lower-level analog encoding, scaling by classically communicating quantum
    devices, or even going from specific functionality to broader - scope digitized
    devices, as in the case of D-Wave. But why? What is the basis for those decisions
    and how does it affect our roadmap for quantum computing adoption?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每个供应商都提出了其设备演变的路线图，这些路线图包括通过经典通信量子设备实现低级别的模拟编码、通过量子设备进行扩展，甚至像D-Wave一样从特定功能转向更广泛的数字化设备。那么，为什么会有这样的决策？这些决策的基础是什么？它们如何影响我们采用量子计算的路线图？
- en: 'To better understand those decisions and help us design a strategy accordingly,
    this chapter will dig deeper into the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些决策并帮助我们相应地设计战略，本章将深入探讨以下主题：
- en: The difference between physical and logical qubits
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理量子比特与逻辑量子比特的区别
- en: Fault-tolerance versus the NISQ era
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容错与NISQ时代的对比
- en: Mitigation and scaling
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓解和扩展
- en: Annealing processes and other types of computations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退火过程和其他类型的计算
- en: This topic is a highly technical one, so the main idea is to enable you to understand
    and be aware of the challenges and limitations you could face when betting for
    specific devices and providers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个话题是一个高度技术性的内容，因此主要目的是让你理解并意识到在选择特定设备和提供者时可能面临的挑战和局限性。
- en: Logical versus physical qubits
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑量子比特与物理量子比特
- en: Classical computing resources deal with faulty physical means or errors generated
    by all kinds of sources. Error-correcting codes have been extensively studied
    ([https://en.wikipedia.org/wiki/Error_correction_code](https://en.wikipedia.org/wiki/Error_correction_code))
    concerning those needs. Richard Hamming (1950) was the first to propose error-correcting
    codes in early 1950\. Classical error correction codes use the concept of redundancy
    or information replication to spot inconsistencies in the outcome of a given channel
    or computation result. This way, the error can be detected and even corrected
    to recover the mitigated outcome.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 经典计算资源处理的是由各种来源产生的物理故障或错误。关于这些需求，错误更正码已经得到了广泛研究（[https://en.wikipedia.org/wiki/Error_correction_code](https://en.wikipedia.org/wiki/Error_correction_code)）。理查德·哈明（1950）是第一个在1950年代初提出错误更正码的人。经典错误更正码使用冗余或信息复制的概念来发现给定通道或计算结果中的不一致性。通过这种方式，可以检测到错误，甚至进行更正，以恢复缓解后的结果。
- en: Taking this to the quantum regime faces two main challenges. The no-cloning
    theorem (*Lindblad 1999*) states that there is no way we can copy a quantum state
    if this state is unknown. Knowing this state would mean measuring it, and this
    event will force the state to collapse and lose all its quantum information. These
    two challenges require inventive solutions to deal with errors within the quantum
    regime, given that classical protocol will not be possible given these conditions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将此问题带入量子领域面临两个主要挑战。不可克隆定理（*Lindblad 1999*）指出，如果量子状态未知，就无法复制该量子状态。了解该状态意味着对其进行测量，而这一事件将迫使状态坍缩并丧失所有量子信息。这两个挑战要求提出创新的解决方案来应对量子领域内的错误，因为在这种情况下，经典协议将无法执行。
- en: 'If we look at, for example, IBM’s 127-qubit superconducting device (`ibm_washington`),
    we will notice that information is provided, other than the coupling map between
    different qubits, as shown in *Figure 9**.1*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看例如IBM的127量子比特超导设备（`ibm_washington`），我们会注意到除了不同量子比特之间的耦合图外，还提供了其他信息，如*图9.1*所示：
- en: '![Figure 9.1 – Error map of IBM’s Washington device equipped with 127 superconducting
    qubits (Eagle r1)](img/B19146_09_001.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – IBM华盛顿设备的错误图，配备127个超导量子比特（Eagle r1）](img/B19146_09_001.jpg)'
- en: Figure 9.1 – Error map of IBM’s Washington device equipped with 127 superconducting
    qubits (Eagle r1)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – IBM华盛顿设备的错误图，配备127个超导量子比特（Eagle r1）
- en: On the left-hand side of *Figure 9**.1*, we can see the error rate of Pauli-X
    gates. It indicates how many times the effect of this operation does not affect
    the qubit it gets applied to. We can retrieve this information for each of the
    qubits in the device at a given time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.1*的左侧，我们可以看到Pauli-X门的误差率。这表示该操作对所应用的量子比特的影响失效的次数。我们可以在给定时间内为设备中的每个量子比特检索此信息。
- en: The other relevant piece of information in the preceding figure is the CNOT
    two-qubit operation, which is required for qubit-qubit interactions and generating
    entanglement. We can see that single qubit operations are at a reasonable median
    of a 10 −4 error rate. Still, for the two-qubit entangling gates (CNOT), even
    though the median is low (10 −2), we can see it can raise to 100% probability
    in some couplings (look at qubits 96, 109, and 114), which means almost all entangling
    operations involving these three qubits will face failure by all means.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前图中的另一个相关信息是CNOT两比特操作，它是量子比特间相互作用和生成纠缠所必需的。我们可以看到，单比特操作的误差率处于合理的中值（10 −4）。然而，对于两比特纠缠门（CNOT），尽管中值较低（10 −2），我们仍然可以看到在某些耦合中它会升高到100%的概率（查看量子比特96、109和114），这意味着几乎所有涉及这三个量子比特的纠缠操作都将面临完全失败。
- en: More importantly, we should consider how many of these instructions are involved
    in previously designed circuits. If we take the portfolio optimization use case
    we covered in [*Chapter 5*](B19146_05.xhtml#_idTextAnchor100) as an example, each
    asset significantly increases the number of operations as we would need to cover
    its relationship with every other asset. More instructions will be needed to implement
    the circuit effectively. Circuit depth refers to the longest sequence of quantum
    gates (operations) that must be performed in sequence, from input to output. More
    formally, in a quantum circuit model, the depth of the circuit is the maximum
    number of time steps required to execute the circuit, assuming that gates acting
    on different qubits can be performed simultaneously. The deeper our circuits become,
    the more of these gates will be involved in the circuit. This fact creates a cumulative
    probability of noise being introduced into our system, due to which higher error
    rates will be faced. This is why the community focuses on creating shallower circuits
    to solve the same problems (*Bravyi et* *al. 2018*).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们应该考虑这些指令在之前设计的电路中涉及的数量。如果我们以[**第5章**](B19146_05.xhtml#_idTextAnchor100)中覆盖的投资组合优化用例为例，每个资产都会显著增加操作的数量，因为我们需要覆盖其与每个其他资产的关系。为了有效实现电路，将需要更多的指令。电路深度指的是必须按顺序执行的量子门（操作）的最长序列，从输入到输出。更正式地说，在量子电路模型中，电路的深度是执行电路所需的最大时间步数，假设作用于不同量子比特的门可以同时执行。随着电路深度的增加，更多的量子门将参与到电路中。这个事实造成了噪声被引入系统的累积概率，因此我们将面临更高的错误率。这就是为什么社区专注于创建更浅的电路来解决同样的问题（*Bravyi等人
    2018*）。
- en: There are techniques to improve the effectiveness of our circuits that specifically
    deal with these sources of error. Ideally, we would like to abstract our circuits
    from the specific nature of the underlying hardware. From experience in the classical
    domain, error-detecting schemes and correcting codes have been proposed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些技术可以提高我们电路的有效性，专门处理这些错误源。理想情况下，我们希望将电路从底层硬件的具体性质中抽象出来。从经典领域的经验来看，已经提出了错误检测方案和纠正码。
- en: Let’s consider the basic example of a bit-flip error or the Pauli-X error we
    mentioned previously. Consider the situation when a single qubit in the |ψ⟩ state
    needs to be transmitted over a noisy channel, ϵ, which can also be pictured as
    the time taken for our circuit to run. The noise in this mean takes the effect
    of an X gate with probability p. Therefore, if we take that single qubit state
    over that mean, the final state we would obtain has a probability of (1 − p) to
    be read as the expected outcome state, |ψ⟩, and p for the flipped version, (X|ψ⟩).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的例子，即之前提到的位翻转错误或泡利-X错误。假设一个位于|ψ⟩状态的单个量子比特需要通过一个嘈杂通道ϵ进行传输，这个通道也可以被看作是电路运行所需的时间。在这种情况下，噪声表现为以概率p发生的X门。因此，如果我们将这个单个量子比特状态传递通过该噪声通道，最终的状态有(1
    - p)的概率将被读取为预期的结果状态|ψ⟩，有p的概率为翻转版本(X|ψ⟩)。
- en: Instead of using a single qubit to encode our state, we could replace the physical
    qubits (the actual hardware-based qubits) with a higher-level abstraction or logical
    version that utilizes three physical qubits instead.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用三个位物理量子比特代替物理量子比特（实际硬件基础的量子比特），从而替换编码状态的单个量子比特，形成一个更高级的抽象或逻辑版本。
- en: 'The logical representation of our potential |ψ⟩ state can be described with
    the following equations:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们潜在的|ψ⟩状态的逻辑表示可以通过以下方程描述：
- en: '|0 L⟩ ≡ |000⟩'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '|0 L⟩ ≡ |000⟩'
- en: '|1 L⟩ ≡ |111⟩'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '|1 L⟩ ≡ |111⟩'
- en: 'We can identify any bit flip by using an entangled state to describe our logical
    qubit. If we measured, for example, the |010⟩ state at a given point in our channel,
    we would be able to detect the inconsistency of the state. It could only be one
    of those described previously, so something happened in the system. Given that
    we know the current status, we could recover the original state by using the redundant
    information in those extra physical qubits, known as the *syndrome qubits*:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用纠缠态来描述逻辑量子比特，从而识别任何位翻转。如果我们在某个时刻测量，例如在我们的通道中测量|010⟩态，我们将能够检测到该态的不一致性。它只能是之前描述的那些状态之一，所以系统中发生了某些事情。鉴于我们知道当前的状态，我们可以通过利用这些额外物理量子比特中的冗余信息来恢复原始状态，这些冗余量子比特被称为*综合量子比特*：
- en: '![Figure 9.2 – Implementation of a 3-qubit physical code for bit flip detection
    and correction](img/B19146_09_002.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 用于位翻转检测和纠正的3量子比特物理码实现](img/B19146_09_002.jpg)'
- en: Figure 9.2 – Implementation of a 3-qubit physical code for bit flip detection
    and correction
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 用于比特翻转检测和纠正的3量子比特物理编码实现
- en: This scheme performs that detection and correction over the initial |ψ⟩ state
    as part of the qubit containing the information within the logical form. Error
    operations, which are represented by the  bit block, can therefore be identified
    and even corrected if they can be mapped to operations, as we will see later.
    This was one of the first error-resilient codes proposed by Asher Peres (*Peres
    1985,* *Peres 1996*).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该方案对初始的|ψ⟩状态进行检测和纠正，这是量子比特内含有逻辑形式信息的一部分。错误操作（由比特块表示）因此可以被识别，并且如果它们可以映射到某些操作，甚至可以被纠正，正如我们后面将看到的那样。这是Asher
    Peres（*Peres 1985,* *Peres 1996*）提出的第一个错误恢复编码之一。
- en: 'These errors occur because qubits are not completely isolated from the environment.
    A quantum circuit, like the one shown previously, is hardly completely isolated
    from the environment, which is also a quantum mechanical system, so the interaction
    between the two can cause some unexpected action leading to a different set of
    operations affecting the initial state. This leads to four main actions that can
    occur inside our error block that could affect our perfect initial state:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误发生的原因是量子比特并未完全与环境隔离。像之前展示的量子电路一样，几乎不可能完全与环境隔离，而环境本身也是一个量子力学系统，因此两者之间的相互作用可能导致一些意外的行为，进而导致影响初始状态的一组不同操作。这会导致在我们的错误块中发生四种主要的操作，这些操作可能影响我们完美的初始状态：
- en: 'Nothing: |ψ⟩'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '无状态: |ψ⟩'
- en: 'Bit flip: X|ψ⟩'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '比特翻转: X|ψ⟩'
- en: 'Phase flip: Z|ψ⟩'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '相位翻转: Z|ψ⟩'
- en: 'Both: Y|ψ⟩'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '两者: Y|ψ⟩'
- en: 'In 1995, Peter Shor (*Shor 1995*) suggested using 9 physical qubits so that
    any arbitrary change would be detected and corrected, extending previous works
    on single qubit bit flip and sign changes. *Figure 9**.3* shows the underlying
    circuit for one of those logical qubits following Shor’s scheme. The *E* block
    points to where the error might take place:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 1995年，Peter Shor（*Shor 1995*）建议使用9个物理量子比特，以便检测和纠正任何任意的变化，扩展了先前在单量子比特比特翻转和符号变化方面的研究。*图9.3*展示了遵循Shor方案的其中一个逻辑量子比特的基础电路。*E*块指示错误可能发生的地方：
- en: '![Figure 9.3 – Implementation of 9-qubit physical code for bit flip detection
    and correction (Shor)](img/B19146_09_003.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 用于比特翻转检测和纠正的9量子比特物理编码实现（Shor）](img/B19146_09_003.jpg)'
- en: Figure 9.3 – Implementation of 9-qubit physical code for bit flip detection
    and correction (Shor)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 用于比特翻转检测和纠正的9量子比特物理编码实现（Shor）
- en: This field of study has been extended to the current status, where some really
    interesting techniques have appeared. Surface codes (*Fowler 2012*), from the
    original work on toric codes (*Bravyi and Kitaev 1998*), have recently emerged,
    trying to create a more generic approach to these techniques on a 2D lattice setup.
    Indubitably a research field will be enabling agnostic algorithmic setups once
    it is fully developed and quantum hardware can deliver the required number of
    physical qubits.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这一研究领域已经扩展到目前的状态，并且出现了一些非常有趣的技术。从最初的环面编码（*Bravyi 和 Kitaev 1998*）的研究工作中，*Fowler
    2012*提出了表面编码，并且近年来尝试在二维晶格结构上为这些技术提供一种更通用的方法。毫无疑问，这一研究领域将在完全发展后使得算法设置与硬件无关，一旦量子硬件能够提供所需的物理量子比特数量。
- en: Of course, this takes us to the limit on how many physical qubits we would require
    to implement a logical qubit that relies upon all the interferences and error
    sources a realistic system might face. Error-resilient quantum computation might
    require quite a few physical resources. It is suggested that the order of physical
    qubits is placed around 1,000 qubits per logical qubit, although this figure may
    vary for specific implementations.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这使我们不得不考虑实现依赖于所有干扰和错误源的逻辑量子比特所需的物理量子比特数量的极限。在实际系统中，具有错误恢复能力的量子计算可能需要相当多的物理资源。据建议，物理量子比特的数量大约为每个逻辑量子比特1,000个，尽管这个数字可能因特定实现而有所不同。
- en: Once again quoting Peter Shor and his famous algorithm for prime factorization,
    to effectively decode an RSA 2,048-bit integer in 8 hours (*Gidney & Ekerå 2021*),
    we would need to provide a quantum machine in the order of 20 million physical
    qubits due to the usage of logical qubits to overcome hardware-generated errors.
    From this, it is evident that we are far from a realistic realization of said
    approaches under the current noise regime and physical constraints.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 再次引用彼得·肖尔和他著名的质因数分解算法，要有效地解码一个 2,048 位的 RSA 整数，在 8 小时内（*Gidney & Ekerå 2021*），我们需要提供一个大约
    2000 万个物理量子比特的量子机器，原因是需要使用逻辑量子比特来克服硬件生成的错误。从这一点可以看出，在当前的噪声环境和物理约束下，我们离实现这些方法还有很长的路要走。
- en: The use of logical qubits for circuit implementation also poses a challenge
    in terms of the scalability of resources. Blindly trying to apply them will force
    hardware providers to scale up to the million-qubit regime, which seems a long-term
    bet, even if it’s feasible for some of the currently available hardware (*Fellous-Asiani
    2021*).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑量子比特进行电路实现也在资源的可扩展性方面提出了挑战。盲目地尝试应用它们将迫使硬件供应商扩展到百万量子比特的规模，这似乎是一个长期的赌注，即使对于一些当前可用的硬件来说是可行的（*Fellous-Asiani
    2021*）。
- en: Some providers believe this is the approach to follow, which is why their product
    roadmaps aim to deliver millions of qubits, despite the decrease in the fidelity
    of operations it might create when working at larger scales. Google is one of
    those providers that is aiming to build six-figure qubit devices, as evidenced
    by their roadmap ([https://quantumai.google/learn/map](https://quantumai.google/learn/map)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一些供应商认为这是应该遵循的方法，这也是为什么他们的产品路线图旨在提供数百万个量子比特，尽管在更大规模上操作的保真度可能会下降。谷歌是这些供应商之一，目标是构建百万量级的量子比特设备，正如他们的路线图所显示的那样（[https://quantumai.google/learn/map](https://quantumai.google/learn/map)）。
- en: Fault-tolerant approaches
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容错方法
- en: Extending the notion of quantum error detection and correction, fault-tolerant
    quantum computation broadens the scope of some of the techniques known in classical
    computation. A fully fault-tolerant system (*Paler and Devitt, 2015*) should look
    for errors at the physical qubit level and system level so that our circuits can
    run, even though they would need to switch hardware instances at a given point
    in time. This general overview is a key factor when we want to leap from theory
    to actual field usage for the techniques and examples shown in previous chapters.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展量子错误检测和修正的概念，容错量子计算扩展了经典计算中已知的一些技术的应用范围。一个完全容错的系统（*Paler 和 Devitt, 2015*）应在物理量子比特级别和系统级别上寻找错误，以便我们的电路能够运行，即使它们在某个时刻需要切换硬件实例。当我们希望将前几章中展示的技术和示例从理论应用到实际领域时，这个概述是一个关键因素。
- en: As we already discussed, some errors in the quantum regime can be detected and
    corrected. Other errors may come from systematic defects, as is the case of readout
    errors, which we will discuss later. But some errors will come from the fact that
    these machines may fail at a service level. Most of the quantum devices that are
    used are at a laboratory status, so they may have lower availability than we are
    used to in other classical services.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论过的那样，量子领域中的一些错误可以被检测和修正。其他错误可能来源于系统性缺陷，例如读取错误，我们将在后面讨论。但是，一些错误可能来源于这些机器在服务级别的故障。大多数使用的量子设备处于实验室状态，因此它们的可用性可能低于我们在其他经典服务中习惯的水平。
- en: We will experience queuing times and non-operational periods during which these
    quantum devices will not be that useful from an operational perspective
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在排队时间和非操作周期中遇到这些量子设备，它们在操作上可能不会那么有用
- en: ':'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ：
- en: '![Figure 9.4 – Availability and queuing time on Azure and IBM cloud services](img/B19146_09_004.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – Azure 和 IBM 云服务的可用性和排队时间](img/B19146_09_004.jpg)'
- en: Figure 9.4 – Availability and queuing time on Azure and IBM cloud services
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – Azure 和 IBM 云服务的可用性和排队时间
- en: Productive environments need to be aware of the problems the whole chain of
    actions may entail, from data collection to results to preprocessing. Specific
    problems may also exploit the need for bigger systems that are often scarcer and,
    therefore, harder to get computing time available.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境需要意识到整个操作链可能带来的问题，从数据收集到结果处理再到预处理。特定问题也可能会利用对更大系统的需求，而这些系统通常更为稀缺，因此，获取可用计算时间会更加困难。
- en: In some cases, we might be able to fit our problems into different devices to
    parallelize the workload. Still, those different devices will come with different
    error mitigation and correction techniques, leading to small discrepancies. This
    makes distributed quantum computation (*Häner et al. 2021*) a field needed but
    still in its infancy.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能能够将问题适配到不同的设备中以并行化工作负载。然而，这些不同的设备将配备不同的错误缓解和修正技术，导致一些小的差异。这使得分布式量子计算（*Häner
    等 2021*）成为一个必要但仍处于起步阶段的领域。
- en: One key requirement to get all the advantages would be a technology capable
    of interconnecting those devices without losing the quantum advantage. This could
    be achieved by using fiber optics and Bell states as communicating states, entering
    the promising land of quantum communications and the quantum internet (*Kimble
    2018*).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 获得所有优势的一个关键要求是能够互连这些设备而不失去量子优势的技术。这可以通过使用光纤和贝尔态作为通信状态来实现，进入量子通信和量子互联网的有前景领域（*Kimble
    2018*）。
- en: On a more practical note, providers such as IBM have proposed using the existing
    communication networks and knowledge from classical distributed systems to not
    achieve the theoretical gain a quantum networking system could provide but surpass
    the barrier of single-chip computations that nowadays limit the capacity of our
    exercises.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 更实际地说，像 IBM 这样的供应商已经提出使用现有的通信网络和经典分布式系统的知识，不是为了实现量子网络系统可能提供的理论增益，而是突破单芯片计算的障碍，单芯片计算如今限制了我们练习的能力。
- en: Circuit knitting
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电路编织
- en: Circuit knitting was proposed recently (*Piveteau and Sutter 2022*), given the
    complexity of providing larger chips without introducing large amounts of errors.
    Instead of aiming for larger, fully quantum chips, you could think of distributed
    resource systems where these instances are classically connected.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 电路编织在最近被提出（*Piveteau 和 Sutter 2022*），考虑到在不引入大量错误的情况下提供更大芯片的复杂性。与其追求更大、更完全的量子芯片，不如考虑分布式资源系统，在这些系统中，这些实例是经典连接的。
- en: This type of architecture has been exploited in the field of distributed GPU
    computing (*Gu et al. 2019*), distributed computing for big data (*Zaharia et
    al. 2012*), and even edge computation (*Shi 2016*). However, it does not entail
    a paradigm shift from classical to quantum as all these resources work, let’s
    say, at the same physical level.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构已在分布式 GPU 计算领域（*Gu 等 2019*）、大数据的分布式计算领域（*Zaharia 等 2012*）甚至边缘计算领域（*Shi 2016*）得到应用。然而，它并不意味着从经典到量子的范式转变，因为所有这些资源都在相同的物理层面上工作。
- en: 'The main difference between those approaches and circuit knitting is the need
    to split a quantum circuit that would classically communicate with other parts
    of the circuit. Assuming there is a group of gates that could minimize the cut
    between two groups of more densely connected operations, you could split the circuit
    into two groups, replacing those quantum interactions connecting the two groups
    by classical means, as shown in *Figure 9**.5*, where two CNOTs can be reshaped
    into two splittable circuits (classically connected):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法与电路编织的主要区别在于，需要拆分一个量子电路，该电路在经典情况下会与电路的其他部分通信。假设有一组门能够最小化两个更密集连接的操作组之间的切割，你可以将电路分成两组，用经典方式替代连接两组之间的量子交互，如*图
    9.5*所示，其中两个 CNOT 门可以被重塑为两个可分割的电路（经典连接）：
- en: '![Figure 9.5 – Two CNOT gates split into blocks of classically connected circuits](img/B19146_09_005.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 两个 CNOT 门被拆分为经典连接电路的块](img/B19146_09_005.jpg)'
- en: Figure 9.5 – Two CNOT gates split into blocks of classically connected circuits
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 两个 CNOT 门被拆分为经典连接电路的块
- en: You need to reflect on how the quantum advantage is compromised when taking
    the complexity of quantum states to classical bits and bytes and back again. You
    must also reflect on the ability to split the initial design into blocks of densely
    and weakly connected circuits.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要反思，当将量子状态转化为经典比特和字节再转回来时，量子优势如何被妥协。你还必须思考将初始设计拆分为密集连接和弱连接电路块的能力。
- en: For sparsely connected examples, it could be that these schemes provide a significant
    advantage. Still, some of the examples we have seen require all-to-all connectivity
    between qubits, making it more complicated to split and not lose the actual computational
    gain quantum hardware aims for.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于稀疏连接的示例，这些方案可能提供显著的优势。然而，我们看到的一些示例需要量子比特之间的全对全连接，这使得拆分更加复杂，并且无法丧失量子硬件所追求的实际计算增益。
- en: Error mitigation
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误缓解
- en: Some common sources of error can be more systematically tackled since measuring
    the classical outcome of quantum hardware is not free of errors. Luckily, this
    type of error can be tackled by observing the common errors that are made upon
    readout and compensating for post-processing the outcome.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的误差来源可以通过更系统的方法来解决，因为测量量子硬件的经典结果并非没有误差。幸运的是，这种类型的误差可以通过观察读取时常见的错误并对结果进行后处理补偿来解决。
- en: 'If we look into our IBM Quantum Experience service once more, we could request
    the readout error for a given device. In *Figure 9**.6*, we can observe how any
    operation that’s done on qubits 10 and 15, upon measurement, could be misinterpreted:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看我们的 IBM Quantum Experience 服务，我们可以请求某个设备的读取误差。在*图 9.6*中，我们可以观察到，在对量子比特10和15进行操作时，测量结果可能会被误解：
- en: '![Figure 9.6 – Readout error on IBM’s Toronto device (27 superconducting qubits
    Falcon r4)](img/B19146_09_006.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – IBM Toronto 设备的读取误差（27个超导量子比特 Falcon r4）](img/B19146_09_006.jpg)'
- en: Figure 9.6 – Readout error on IBM’s Toronto device (27 superconducting qubits
    Falcon r4)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – IBM Toronto 设备的读取误差（27个超导量子比特 Falcon r4）
- en: These statistics can be derived by the simple act of placing an operation whose
    outcome is known (for example, X|ψ⟩) and recording the discrepancies upon measuring
    it for a significant number of tryouts. If those statistics are known, you can
    compensate for the measurements that are obtained for an experiment by knowing
    this systematic error.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些统计数据可以通过简单地放置一个已知结果的操作（例如，X|ψ⟩），并记录在进行大量实验时测量的差异来得出。如果这些统计数据是已知的，你可以通过了解这个系统误差来补偿实验中的测量结果。
- en: 'Let’s consider a simple scenario. Imagine we encode all possible combinations
    on a two-qubit case separately. These states are prepared using an X gate on the
    corresponding qubit, and we measure the following outcome for 10,000 shots in
    each case:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的情境。假设我们分别对两量子比特的所有可能组合进行编码。这些状态是通过在相应的量子比特上施加X门来准备的，并且我们对每种情况在10000次实验中得到了以下结果：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can see that the output is almost always right, measuring close to 9,800
    times out of the 10,000 circuit runs in the state we were aiming to prepare by
    applying X gates. But it is not a perfect statistic as, more or less, 1-2% of
    the time, we get an unexpected bitstring upon measurement (that is, measuring
    11 when we prepared the |00⟩ state). What would you think if, for the device we
    used in the previous experiment, we got the following output on 100 shots?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，输出几乎总是正确的，在我们通过应用 X 门准备的状态中，10000次电路运行中有9800次接近正确。但这并不是一个完美的统计，因为在1-2%的情况下，测量结果会出现意外的比特串（例如，当我们准备了|00⟩状态时，测量得到11）。如果对于我们在之前实验中使用的设备，在100次尝试中得到了以下输出，你会怎么想？
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Half of the time, we obtained 11 bit strings and 00 for the other half in some
    minor cases, where we measured 01 and 10\. We already know that the device has
    a 1-2% error rate of flipping qubit states from our previous exercise. So, could
    we assume a superposition between the |00⟩ and |11⟩ states? Maybe a Bell state?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一半的时间，我们得到了11比特串，另一半时间得到了00，偶尔会测量到01和10。我们已经知道该设备有1-2%的误差率，会使量子比特状态发生翻转。因此，我们能否假设在|00⟩和|11⟩状态之间有叠加？也许是一个贝尔态？
- en: By understanding the systematic error a given device introduces compared to
    the ideal representation of operations when preparing the state, we could characterize
    its error and mitigate it by the inverse effect. By setting a matrix conversion
    that would do this operation mapping prepared states with measured states, we
    could error correct upon measurement of every experiment done on a device.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解给定设备相较于理想操作表示所引入的系统误差，我们可以表征其误差并通过逆效应进行缓解。通过设置一个矩阵转换来执行操作映射，将准备的状态与测量的状态进行比对，我们可以在每次实验的测量中进行误差修正。
- en: 'Qiskit already provides some of these functionalities within its experimental
    package:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Qiskit 已经在其实验包中提供了一些这些功能：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code will plot the circuits that have been created to calibrate
    the readout error as shown in *Figure 9**.7*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将绘制出用于校准读取误差的电路，如*图 9.7*所示。
- en: '![Figure 9.7 – Calibration circuits for a two-qubit device](img/B19146_09_007.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 两量子比特设备的校准电路](img/B19146_09_007.jpg)'
- en: Figure 9.7 – Calibration circuits for a two-qubit device
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 两量子比特设备的校准电路
- en: In this manner, by just invoking the calibration upon a noisy backend, we would
    get the matrix that’s needed to mitigate the readout error.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，仅通过调用一个嘈杂的后端进行校准，我们将获得缓解读取误差所需的矩阵。
- en: 'As an example, if we took the case of a |00⟩ state on the `ibmq_lima` device,
    which would be like the first circuit shown in the preceding plots, we would expect
    only a 00 bitstring to be read. However, we would see that its plot would differ
    from the expected outcome, plotting some unwanted or unexpected bitstrings:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，如果我们以`ibmq_lima`设备上的 |00⟩ 状态为例，就像前面图表中显示的第一个电路一样，我们预计只会读取到 00 比特串。然而，我们会看到它的图表与预期结果不同，绘制出一些不想要的或意外的比特串：
- en: '![Figure 9.8 – Estimation of the ​​|00⟩​​ state after 1,024 shots](img/B19146_09_008.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 在 1,024 次实验后对 |00⟩ 状态的估计](img/B19146_09_008.jpg)'
- en: Figure 9.8 – Estimation of the |00⟩ state after 1,024 shots
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 在 1,024 次实验后对 |00⟩ 状态的估计
- en: 'Here, we can calibrate the systematic error on the device by using the previous
    circuits shown in *Figure 9**.7*:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以使用之前的电路来校准设备上的系统误差，如*图 9.7*所示：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'By doing this, we would obtain a matrix similar to the following that applies
    to previous counts of measured bitstrings. By doing this, it would be able to
    correct this device’s systematic error upon measurement. By plotting this matrix,
    we would see that apart from obvious maps between prepared and measured states
    shown in black, gray areas appear as well, representing the transition some states
    make from the prepared state to the measured one. This is what is called a mitigation
    matrix as it allows us to map the systematic transitions that occur between states.
    It can reverse or at least compensate for the effects caused by errors occurring
    within the device once applied after the measurement:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们将获得一个类似于以下的矩阵，该矩阵适用于先前测量的比特串的计数。通过这种方式，它将能够在测量时纠正设备的系统误差。通过绘制这个矩阵，我们会看到，除了明显的黑色映射外，还会出现灰色区域，表示某些状态从准备状态过渡到测量状态的过渡。这就是所谓的缓解矩阵，因为它允许我们映射在状态之间发生的系统性过渡。一旦应用于测量后，它可以逆转或至少补偿设备内发生的错误造成的影响：
- en: '![Figure 9.9 – Mitigation matrix for the ​​|00⟩​​ state](img/B19146_09_009.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – |00⟩ 状态的缓解矩阵](img/B19146_09_009.jpg)'
- en: Figure 9.9 – Mitigation matrix for the |00⟩ state
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – |00⟩ 状态的缓解矩阵
- en: 'This way, we could compare the plots showing the mitigated and unmitigated
    results. This matrix is going to be able to extract a probability distribution
    with negative probability values so that, once it’s applied to the outcome probabilities
    of bitstring upon measurement, the compensation of it will plot the quasi-probabilities
    of measurements. Here, quasi-probability refers to the relaxation over conventional
    probability distributions as negative values may be reflected in the outcome:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以比较缓解和未缓解结果的图表。这个矩阵能够提取一个具有负概率值的概率分布，因此，一旦它应用于比特串测量后的结果概率，其补偿效果将绘制测量的准概率。在这里，准概率是指相较于常规概率分布的放松，因为负值可能会反映在结果中：
- en: '![Figure 9.10 – Probability to obtain the state |00⟩ with and without error
    mitigation](img/B19146_09_010.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – 获得状态 |00⟩ 的概率，带有和不带有误差缓解](img/B19146_09_010.jpg)'
- en: Figure 9.10 – Probability to obtain the state |00⟩ with and without error mitigation
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 获得状态 |00⟩ 的概率，带有和不带有误差缓解
- en: 'Note that this technique will not play well when scaling to bigger devices
    (more qubits) as we would need to characterize all possible combinations for the
    number of qubits available in the system to obtain such statistics. That is why
    different methods for error mitigation on large-scale devices (devices with many
    qubits) have been suggested that will perform much better at those scales. Let’s
    look at some of those early-stage research areas digging deeper into error mitigation:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当扩展到更大的设备（更多的量子比特）时，这种技术可能效果不佳，因为我们需要对系统中可用的量子比特数量的所有可能组合进行表征，以获得这些统计数据。这就是为什么针对大规模设备（具有多个量子比特的设备）提出了不同的误差缓解方法，这些方法在大规模设备上能够表现得更好。让我们来看一下这些早期研究领域，深入探讨误差缓解：
- en: '**Probabilistic error cancellation** (*Pashayan et al. 2015*) is one technique
    that tries to characterize the outcome probability of ideal gate sets, so this
    can be considered an error cancellation technique for a more general case. The
    concept holds the same description as the error mitigation described above, where
    an outcome probability wants to be set and corrected for a specific device, but
    in this case Monte Carlo averaged probabilities are used.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概率误差消除**（*Pashayan 等，2015*）是一种试图描述理想门集输出概率的技术，因此可以将其视为一种更通用的误差消除技术。这个概念与上面描述的误差缓解相同，都是希望为特定设备设置并修正输出概率，但在这种情况下，使用的是蒙特卡洛平均概率。'
- en: '**Zero noise extrapolation** (*Giurgica-Tiron et al. 2020*) is more suited
    to when the expectation value is used. The error is modeled by running the hardware
    and increasing its noise factor (λ) so that a curve can be fitted. If hardware
    noise is set to λ = 1, then the model can be used to estimate the expectation
    value at λ = 0, since this is our error-mitigated expectation value.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零噪声外推**（*Giurgica-Tiron 等，2020*）更适用于使用期望值的情况。通过运行硬件并增加其噪声因子（λ）来建模误差，从而拟合曲线。如果硬件噪声设置为
    λ = 1，那么该模型可以用于估算 λ = 0 时的期望值，因为这就是我们的误差缓解期望值。'
- en: '**Dynamical decoupling** (*Viola et al. 1999*) is a technique that takes place
    almost at the lowest level of the hardware. Each gate we have talked about takes
    a different physical meaning. In the case of IBM, for example, these are pulses
    that, depending on the gate, could have a longer or shorter duration (depending
    on the operation being performed). Given these disparities between the length
    of the instructions, when certain qubits idle for a while, other qubits are acted
    on. These idle qubits are prone to errors due to interactions with the environment.
    By introducing sequences of operations that would not affect the outcome of the
    problem, we can keep those qubits active, diminishing the idling error that’s
    generated.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态解耦**（*Viola 等，1999*）是一种几乎在硬件的最低层级上进行的技术。我们之前提到的每个门操作都有不同的物理含义。例如，在 IBM
    的情况下，这些操作是脉冲，脉冲的持续时间会根据所执行的操作有所不同（可能更长或更短）。由于指令长度之间存在差异，当某些量子比特空闲一段时间时，其他量子比特会受到操作。这些空闲的量子比特容易由于与环境的相互作用而发生错误。通过引入一系列不会影响问题结果的操作，我们可以保持这些量子比特处于活跃状态，从而减少因空闲而产生的错误。'
- en: If you do not want to go that far in terms of the electronics of the hardware
    being used, the Mitiq framework has enabled a digital dynamical decoupling package
    so that we can abstract from the complexities of those DD schemes ([https://mitiq.readthedocs.io/en/stable/guide/ddd-5-theory.html#common-examples-of-ddd-sequences](https://mitiq.readthedocs.io/en/stable/guide/ddd-5-theory.html#common-examples-of-ddd-sequences)
    and ([https://mitiq.readthedocs.io/en/stable/guide/ddd-3-options.html](https://mitiq.readthedocs.io/en/stable/guide/ddd-3-options.html)).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想深入到所使用硬件的电子学层面，Mitiq 框架已经启用了一个数字动态解耦包，这样我们就可以从那些 DD 方案的复杂性中抽象出来（[https://mitiq.readthedocs.io/en/stable/guide/ddd-5-theory.html#common-examples-of-ddd-sequences](https://mitiq.readthedocs.io/en/stable/guide/ddd-5-theory.html#common-examples-of-ddd-sequences)
    和 [https://mitiq.readthedocs.io/en/stable/guide/ddd-3-options.html](https://mitiq.readthedocs.io/en/stable/guide/ddd-3-options.html)）。
- en: Given the complexity and specific knowledge required to apply most of the previously
    described techniques, many companies have included a hardware/software middle
    layer in their roadmap that takes care of these techniques. Companies such as
    IBM have included these techniques within their recently released Qiskit Runtime
    or partnered with technology providers such as Riverlane, who aim to build the
    perfect abstraction layer between algorithm developers and hardware providers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于应用之前描述的大多数技术所需的复杂性和特定知识，许多公司在其路线图中增加了一个硬件/软件中间层，负责处理这些技术。像 IBM 这样的公司已经将这些技术纳入其最近发布的
    Qiskit Runtime，或者与技术提供商如 Riverlane 合作，后者旨在构建一个完美的抽象层，连接算法开发者和硬件提供商。
- en: Some important changes will need to be made in the medium term regarding how
    these errors are handled and how users abstract from them. However, at the time
    of writing, some attention is needed from early adopters to select the set of
    techniques that will allow them to squeeze the most out of hardware providers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在中期，需要对这些错误的处理方式以及用户如何从中抽象出来做出一些重要的改变。然而，在撰写本文时，需要早期采用者特别关注，选择一组技术以便充分利用硬件提供商的能力。
- en: Annealers and other devices
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 退火器和其他设备
- en: We have mostly talked about digital quantum computers, which are computers that
    use the abstraction of gates to operate on qubits. But quantum annealers such
    as those used in *Chapters 5* to *7* (D-Wave’s quantum annealers) are also subject
    to errors and problems when dealing with larger-scale problems, mainly when increasing
    the number of assets involved in our operations.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要谈论的是数字量子计算机，这些计算机使用门的抽象来操作量子比特。但是，像*第5章*到*第7章*（D-Wave的量子退火机）中使用的量子退火机在处理更大规模的问题时也会出现错误和问题，主要是在增加我们操作中涉及的资产数量时。
- en: If we take the example of portfolio optimization, D-Wave provides up to 5,000
    qubit chips, which could potentially mean up to 5,000 asset portfolios having
    to be optimized.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以资产组合优化为例，D-Wave提供了最多5000个量子比特的芯片，这可能意味着需要优化最多5000个资产组合。
- en: 'Annealers require problems to be encoded or mapped onto their hardware, which
    involves representing the assets using the QUBO or Ising models and assigning
    them to specific qubits on their chips. Then, relationships between those variables
    are mapped to the couplings between qubits. Those links will carry the parameters
    associated with a given pair, which is often represented by J ij in the canonical
    form of an Ising type of problem, as shown here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 退火机要求问题被编码或映射到其硬件上，这涉及使用QUBO或Ising模型表示资产，并将它们分配到芯片上的特定量子比特。然后，这些变量之间的关系被映射到量子比特之间的耦合。那些链接将承载与给定对相关的参数，这通常在Ising类型问题的标准形式中表示为J
    ij，如下所示：
- en: H(σ) = − ∑ 〈ij〉   J ij σ i σ j − μ∑ j   h j σ j,
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: H(σ) = − ∑ 〈ij〉 J ij σ i σ j − μ∑ j h j σ j，
- en: Here, σ j will be the variable that’s mapped to a qubit in the device. This
    linking cannot always be present as the device itself may lack some of those connections
    in an all-to-all connected problem.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，σ j 将是映射到设备中的量子比特的变量。这种连接并不总是存在，因为设备本身可能缺乏在全连接问题中所需的一些连接。
- en: 'In fact, in 2019, Venturelli and Kondratyev were able to embed up to 60 asset
    portfolios in a DW 2000Q system thanks to them leveraging minor-embedding compilation
    techniques. This allowed them to place a 1D string in all assets so that they
    could be placed on a Chimera chip. Due to the embedding technique’s overhead,
    this was the maximum they could achieve, even for a 2,000-qubit system. This limitation
    is visible if you look at the chip architecture in *Figure 9**.11*:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在2019年，Venturelli和Kondratyev通过利用次级嵌入编译技术，成功地将最多60个资产组合嵌入到DW 2000Q系统中。这使他们能够将所有资产放置在一个一维串中，从而可以将它们放置在Chimera芯片上。由于嵌入技术的开销，这是他们能够实现的最大规模，即使是对于一个2000量子比特的系统。这个限制在查看*图9.11*的芯片架构时是显而易见的：
- en: '![Figure 9.11 – D-Wave’s Chimera chip’s qubit architecture and coupling map
    (32 qubits square)](img/B19146_09_011.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – D-Wave的Chimera芯片量子比特架构和耦合图（32量子比特方阵）](img/B19146_09_011.jpg)'
- en: Figure 9.11 – D-Wave’s Chimera chip’s qubit architecture and coupling map (32
    qubits square)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – D-Wave的Chimera芯片量子比特架构和耦合图（32量子比特方阵）
- en: In the preceding Chimera graph, we can see how each qubit is directly connected
    to another 5 or 6 qubits in general. This means that if a qubit representing a
    variable requires more connections than the ones it has, you would need to chain
    more than one qubit instance as they would represent the same variable of the
    problem – hence the name chain, which means two qubits behave as a single unit.
    That way, by losing a single coupler, a qubit could almost double its connection
    capacity.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述的Chimera图中，我们可以看到每个量子比特通常直接连接到另外5个或6个量子比特。这意味着，如果一个表示变量的量子比特需要更多的连接，而它所拥有的连接数不足，你就需要将多个量子比特实例连接成链，因为它们将代表问题的同一个变量——因此叫做链，意味着两个量子比特作为一个单元工作。通过这种方式，通过失去一个耦合器，量子比特几乎可以将其连接能力翻倍。
- en: This is what D-Wave refers to as a chain. This is established by setting a strong
    coupling between those two units so that they will return the same value (remember,
    they refer to the same qubit). In this case, those two physical qubits represent
    (or should represent) the same logical unit or qubit.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是D-Wave所称的链。这是通过在这两个单元之间设置强耦合来建立的，使得它们将返回相同的值（记住，它们指的是相同的量子比特）。在这种情况下，这两个物理量子比特代表（或应代表）相同的逻辑单元或量子比特。
- en: However, this chain can be broken. Generally, the strength of those couplings
    is higher than those referenced by the specific problem being embedded. However,
    they could return different values upon readout, meaning the chain was broken,
    and the obtained solution may not be valid according to our problem definition.
    To dig deeper into this concept of chains, D-Wave’s documentation offers plenty
    of information on it ([https://docs.ocean.dwavesys.com/en/stable/concepts/embedding.html](https://docs.ocean.dwavesys.com/en/stable/concepts/embedding.html)).
    In the end, many of the limitations we find in the general cases for quantum devices
    can also be found in specific machines, as in the case of quantum annealers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个链条可以被打破。通常，这些耦合的强度高于被嵌入的特定问题的参考值。然而，它们可能在读取时返回不同的值，意味着链条被打破，所获得的解可能不符合我们问题定义中的有效解。要深入了解这个链条的概念，D-Wave的文档提供了大量相关信息（[https://docs.ocean.dwavesys.com/en/stable/concepts/embedding.html](https://docs.ocean.dwavesys.com/en/stable/concepts/embedding.html)）。最终，我们在量子设备的通用案例中发现的许多限制，也可以在特定机器中找到，例如量子退火器。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the challenges that working on real hardware may
    pose. Depending on the specific nature of the hardware, regardless of whether
    it is purpose-specific, as in the case of quantum annealers, or one of the many
    implementations of digital quantum computers, these concepts are still hard to
    omit.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用真实硬件可能带来的挑战。根据硬件的具体性质，无论它是特定用途的（如量子退火器）还是数字量子计算机的众多实现之一，这些概念仍然难以忽视。
- en: Being aware that the mapping for a given problem is being done at a hardware
    level, paying attention to which qubits are used, their associated error, and
    how this will be reflected in the outcome, you can implement countermeasures so
    that the results still offer enough resolution. That way, the advantage that’s
    expected from quantum computation can still be significant.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 意识到给定问题的映射是在硬件层面进行的，关注哪些量子比特被使用，它们的相关误差，以及这如何反映在结果中，你可以实施对策，以确保结果仍然具有足够的分辨率。这样，量子计算所期望的优势仍然可以是显著的。
- en: By understanding the different challenges and how they may affect a given problem
    setup, you can choose the appropriate hardware that can better accommodate the
    problem.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解不同的挑战以及它们如何影响给定的问题设置，你可以选择更适合问题的硬件。
- en: Annealers can be used for large problems but not as large as you might think
    in terms of embedding restrictions and the type of problems this may solve. D-Wave
    is still in the order of thousands of qubits compared to other providers, and
    it is likely to provide close to 8,000 qubits by 2023/2024\. But still, this might
    not be sufficient to encode some of the problems at the scale that the industry
    requires.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 退火器可以用于解决大规模问题，但在嵌入限制和能够解决的问题类型方面，它们并不像你想象的那样能处理如此庞大的问题。与其他提供商相比，D-Wave的量子比特数量仍然在数千量级，并预计在2023/2024年达到接近8000个量子比特。然而，这仍可能不足以编码某些规模上行业所需的问题。
- en: Digital quantum hardware comes with different types of physical implementations
    to choose from, from superconducting chips such as the ones offered by IBM to
    Cold Atoms by QuEra or Topological Qubits, Microsoft’s bet.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 数字量子硬件提供了不同类型的物理实现供选择，从IBM提供的超导芯片，到QuEra的冷原子技术，再到微软的拓扑量子比特。
- en: Undoubtedly, each technology will offer different coupling architectures or
    error levels for operation fidelity or readout accuracy. Having a minimal understanding
    of how this can be leveraged will be critical in the short term, so it might be
    necessary for the adventurous to educate themselves on those hardware specifications.
    Luckily, the active effort done by IBM on both Qiskit Runtime and circuit knitting
    techniques may soon abstract you from needing to understand how to optimally embed
    a problem into your device. However, it is still in its infancy, looking to provide
    significant advances while trying to come close to the numbers available at D-Wave
    ([https://www.ibm.com/quantum/roadmap](https://www.ibm.com/quantum/roadmap)).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，每种技术都会提供不同的耦合架构或误差水平，以确保操作的保真度或读取准确性。对这一点有最基本的理解，将在短期内至关重要，因此，勇于探索的人可能需要自己了解这些硬件规格。幸运的是，IBM在Qiskit
    Runtime和电路编织技术方面的积极努力，可能很快就会让你不再需要理解如何将问题最优地嵌入到你的设备中。然而，这项技术仍处于起步阶段，旨在提供重大的进展，同时努力接近D-Wave提供的数量（[https://www.ibm.com/quantum/roadmap](https://www.ibm.com/quantum/roadmap)）。
- en: Google is also continuing at a steady pace, focusing on enlarging their devices
    to the range of millions of qubits, surpassing competitors, and trying to achieve
    the scale required for error-corrected qubits. So far, they have progressed at
    a steady pace but to work with their existing devices, you need to make it onto
    the list of privileged collaborators ([https://quantumai.google/hardware](https://quantumai.google/hardware)).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌也在稳步推进，专注于将其设备扩展到数百万量子比特的范围，超越竞争对手，力图实现误差修正量子比特所需的规模。到目前为止，他们已经稳步进展，但要使用现有的设备，你需要进入特权合作伙伴名单（[https://quantumai.google/hardware](https://quantumai.google/hardware)）。
- en: Lastly, ion-trap providers such as IonQ and Quantinuum are focusing on providing
    the best hardware available. Their quality is a major milestone for them providing
    consistent improvements in the number of operations they can put together while
    providing meaningful results ([https://www.quantinuum.com/news/quantum-volume-reaches-5-digits-for-the-first-time-5-perspectives-on-what-it-means-for-quantum-computing](https://www.quantinuum.com/news/quantum-volume-reaches-5-digits-for-the-first-time-5-perspectives-on-what-it-means-for-quantum-computing)).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，像 IonQ 和 Quantinuum 这样的离子阱提供商，专注于提供最好的硬件。它们的质量是一个重要的里程碑，标志着它们在整合操作数时提供一致性改进，同时提供有意义的结果（[https://www.quantinuum.com/news/quantum-volume-reaches-5-digits-for-the-first-time-5-perspectives-on-what-it-means-for-quantum-computing](https://www.quantinuum.com/news/quantum-volume-reaches-5-digits-for-the-first-time-5-perspectives-on-what-it-means-for-quantum-computing)）。
- en: You should never forget that this is an actively researched field where scientific
    breakthroughs are expected. It could very well happen that some limitations on
    scalability-specific technologies may be solved in the next decade, so do not
    hesitate to experiment with all those different options so that you’re prepared.
    Thanks to cloud service providers, this is easier than ever. One important key
    to partnering or betting on an appropriate provider is to balance the size of
    your problems, connectivity, and accuracy to provide meaningful results. This
    will most likely drive your decisions in the near future.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远不能忘记，这是一个积极研究的领域，科学突破在其中是指日可待的。某些针对可扩展性特定技术的限制可能会在下一个十年内得到解决，因此不要犹豫，去尝试所有不同的选项，以便做好准备。得益于云服务提供商，现在这一切比以往更加容易。与合适的服务商合作或选择合适的提供商的一个重要关键是平衡问题的规模、连接性和准确性，以提供有意义的结果。这很可能会影响你在不久的将来的决策。
- en: Further reading
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'It is worth highlighting that the techniques we discussed in this chapter require
    less technical detail to grasp their advantage fully. Interestingly, the work
    by Huang et al. 2022 cites the whole path from algorithm definition to lower-level
    action on devices, with some detailed information on how previously discussed
    error mitigation techniques can be used:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的是，我们在本章讨论的技术，理解其优势时需要较少的技术细节。有趣的是，黄等人（2022年）的研究引用了从算法定义到在设备上执行低级操作的完整路径，并提供了一些详细信息，说明之前讨论的误差缓解技术如何被应用：
- en: '![Figure 9.12 – Landscape of quantum error mitigation techniques](img/B19146_09_012.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – 量子误差缓解技术的全景](img/B19146_09_012.jpg)'
- en: Figure 9.12 – Landscape of quantum error mitigation techniques
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 量子误差缓解技术的全景
- en: You can also benefit from the implementations available in the open source community
    so that you can apply them without requiring deep technical knowledge to code
    what can be found in the literature. It is pretty common nowadays that an implemented
    version of the published results is made available to the public.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从开源社区中找到现有的实现，这样你就可以应用它们，而无需具备深入的技术知识来编写文献中已有的代码。如今，发布结果的实现版本公开发布已变得非常普遍。
- en: Qiskit, one of the most mature frameworks for quantum computing, has extensive
    documentation and practical tutorials that will make understanding those concepts
    much easier.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Qiskit 是量子计算领域最成熟的框架之一，具有丰富的文档和实用教程，这将使理解这些概念变得更加容易。
- en: 'Hardware-related tutorials and lower-level experiments, such as the ones we
    have tackled in this chapter, can be found in their experimental library documentation:
    [https://qiskit.org/documentation/experiments/tutorials/index.html](https://qiskit.org/documentation/experiments/tutorials/index.html).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与硬件相关的教程和低级实验，例如我们在本章中涉及的内容，可以在他们的实验库文档中找到：[https://qiskit.org/documentation/experiments/tutorials/index.html](https://qiskit.org/documentation/experiments/tutorials/index.html)。
- en: 'Another interesting resource is the Mitiq package, which is supported by the
    non-profit organization Unitary Fund. This resource not only implements some of
    the already discussed techniques in different hardware and cloud service providers
    but also offers extensive documentation and a vibrant community that you can join
    to discuss any topic related to efficient quantum computing: [https://mitiq.readthedocs.io/en/stable/index.html](https://mitiq.readthedocs.io/en/stable/index.html).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的资源是Mitiq包，它由非营利组织Unitary Fund支持。这个资源不仅在不同的硬件和云服务提供商上实现了已经讨论过的一些技术，还提供了详尽的文档和一个充满活力的社区，您可以加入该社区讨论任何与高效量子计算相关的话题：[https://mitiq.readthedocs.io/en/stable/index.html](https://mitiq.readthedocs.io/en/stable/index.html)。
- en: References
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: '*Bravyi, S. B., & Kitaev, A. Y. (1998). Quantum codes on a lattice with boundary.
    arXiv* *preprint quant-ph/9811052.*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*Bravyi, S. B., & Kitaev, A. Y. (1998). 带边界的格上的量子编码。arXiv* *预印本 quant-ph/9811052。*'
- en: '*Bravyi, S., Gosset, D., & König, R. (2018). Quantum advantage with shallow
    circuits. Science,* *362(6412), 308-311.*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*Bravyi, S., Gosset, D., & König, R. (2018). 浅电路下的量子优势。科学，* *362(6412), 308-311。*'
- en: '*Fellous-Asiani, M., Chai, J. H., Whitney, R. S., Auffèves, A., & Ng, H. K.
    (2021). Limitations in quantum computing from resource constraints. PRX Quantum,*
    *2(4), 040335.*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*Fellous-Asiani, M., Chai, J. H., Whitney, R. S., Auffèves, A., & Ng, H. K.
    (2021). 量子计算中的资源约束限制。PRX Quantum，* *2(4), 040335。*'
- en: '*Fowler, A. G., Mariantoni, M., Martinis, J. M., & Cleland, A. N. (2012). Surface
    codes: Towards practical large-scale quantum computation. Physical Review A,*
    *86(3), 032324.*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*Fowler, A. G., Mariantoni, M., Martinis, J. M., & Cleland, A. N. (2012). 表面码：迈向实用的大规模量子计算。物理评论
    A，* *86(3), 032324。*'
- en: '*Gidney, C., & Ekerå, M. (2021). How to factor 2,048-bit RSA integers in 8
    hours using 20 million noisy qubits. Quantum,* *5, 433.*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*Gidney, C., & Ekerå, M. (2021). 如何使用2000万个嘈杂的量子比特在8小时内分解2048位RSA整数。Quantum，*
    *5, 433。*'
- en: '*Giurgica-Tiron, T., Hindy, Y., LaRose, R., Mari, A., & Zeng, W. J. (2020,
    October). Digital zero noise extrapolation for quantum error mitigation. In 2020
    IEEE International Conference on Quantum Computing and Engineering (QCE) (pp.*
    *306-316). IEEE.*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*Giurgica-Tiron, T., Hindy, Y., LaRose, R., Mari, A., & Zeng, W. J. (2020年10月).
    量子误差缓解的数字零噪声外推。在2020年IEEE国际量子计算与工程会议(QCE)中（第* *306-316页）。IEEE。*'
- en: '*Gu, J., Chowdhury, M., Shin, K. G., Zhu, Y., Jeon, M., Qian, J., ... & Guo,
    C. (2019). Tiresias: A {GPU} cluster manager for distributed deep learning. In
    16th USENIX Symposium on Networked Systems Design and Implementation (NSDI 19)
    (**pp. 485-500).*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*Gu, J., Chowdhury, M., Shin, K. G., Zhu, Y., Jeon, M., Qian, J., ... & Guo,
    C. (2019). Tiresias：一个用于分布式深度学习的{GPU}集群管理器。在第16届USENIX网络系统设计与实现研讨会(NSDI 19)中（**第485-500页）。*'
- en: '*Hamming, R. W. (1950). Error detecting and error correcting codes. The Bell
    system technical journal,* *29(2), 147-160.*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*Hamming, R. W. (1950). 错误检测与错误纠正码。贝尔系统技术期刊，* *29(2), 147-160。*'
- en: '*Häner, T., Steiger, D. S., Hoefler, T., & Troyer, M. (2021, November). Distributed
    quantum computing with qmpi. In Proceedings of the International Conference for
    High Performance Computing, Networking, Storage and Analysis (**pp. 1-13).*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*Häner, T., Steiger, D. S., Hoefler, T., & Troyer, M. (2021年11月). 使用qmpi进行分布式量子计算。在国际高性能计算、网络、存储与分析会议论文集中（**第1-13页）。*'
- en: '*Huang, H. L., Xu, X. Y., Guo, C., Tian, G., Wei, S. J., Sun, X., ... & Long,
    G. L. (2022). Near-Term Quantum Computing Techniques: Variational Quantum Algorithms,
    Error Mitigation, Circuit Compilation, Benchmarking, and Classical Simulation.
    arXiv* *preprint arXiv:2211.08737.*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*Huang, H. L., Xu, X. Y., Guo, C., Tian, G., Wei, S. J., Sun, X., ... & Long,
    G. L. (2022). 近期量子计算技术：变分量子算法、误差缓解、电路编译、基准测试和经典模拟。arXiv* *预印本 arXiv:2211.08737。*'
- en: '*Kimble, H. J. (2008). The quantum internet. Nature,* *453(7198), 1023-1030.*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*Kimble, H. J. (2008). 量子互联网。自然，* *453(7198), 1023-1030。*'
- en: '*Lindblad, G. (1999). A general no-cloning theorem. Letters in Mathematical
    Physics,* *47(2), 189-196.*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lindblad, G. (1999). 一般的不可克隆定理。数学物理学通讯，* *47(2), 189-196。*'
- en: '*Paler, A., & Devitt, S. J. (2015). An introduction to fault-tolerant quantum
    computing. arXiv* *preprint arXiv:1508.03695.*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*Paler, A., & Devitt, S. J. (2015). 容错量子计算简介。arXiv* *预印本 arXiv:1508.03695。*'
- en: '*Pashayan, H., Wallman, J. J., & Bartlett, S. D. (2015). Estimating outcome
    probabilities of quantum circuits using quasiprobabilities. Physical review letters,*
    *115(7), 070501.*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pashayan, H., Wallman, J. J., & Bartlett, S. D. (2015). 使用准概率估算量子电路的结果概率。物理评论快报，*
    *115(7), 070501。*'
- en: '*Peres, A. (1985). Reversible logic and quantum computers. Physical review
    A,* *32(6), 3266.*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*Peres, A. (1985). 可逆逻辑与量子计算机。物理评论 A，* *32(6), 3266。*'
- en: '*Peres, A. (1996). Error correction and symmetrization in quantum computers.
    arXiv* *preprint quant-ph/9611046.*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*Peres, A. (1996). 量子计算机中的错误修正与对称化。arXiv* *预印本 quant-ph/9611046.*'
- en: '*Piveteau, C., & Sutter, D. (2022). Circuit knitting with classical communication.
    arXiv* *preprint arXiv:2205.00016.*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*Piveteau, C., & Sutter, D. (2022). 使用经典通信的电路编织。arXiv* *预印本 arXiv:2205.00016.*'
- en: '*Shi, W., & Dustdar, S. (2016). The promise of edge computing. Computer,* *49(5),
    78-81.*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shi, W., & Dustdar, S. (2016). 边缘计算的前景。Computer,* *49(5), 78-81.*'
- en: '*Shor, P. W. (1995). Scheme for reducing decoherence in quantum computer memory.
    Physical review A,* *52(4), R2493.*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shor, P. W. (1995). 量子计算机内存中去相干的减少方案。Physical review A,* *52(4), R2493.*'
- en: '*Venturelli, D., & Kondratyev, A. (2019). Reverse quantum annealing approach
    to portfolio optimization problems. Quantum Machine Intelligence,* *1(1), 17-30.*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*Venturelli, D., & Kondratyev, A. (2019). 反向量子退火方法在投资组合优化问题中的应用。Quantum Machine
    Intelligence,* *1(1), 17-30.*'
- en: '*Viola, L., Knill, E., & Lloyd, S. (1999). Dynamical decoupling of open quantum
    systems. Physical Review Letters,* *82(12), 2417.*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*Viola, L., Knill, E., & Lloyd, S. (1999). 开放量子系统的动态解耦。Physical Review Letters,*
    *82(12), 2417.*'
- en: '*Zaharia, M., Chowdhury, M., Das, T., Dave, A., Ma, J., Mccauley, M., ... &
    Stoica, I. (2012). Fast and interactive analytics over Hadoop data with Spark.
    Usenix Login,* *37(4), 45-51.*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*Zaharia, M., Chowdhury, M., Das, T., Dave, A., Ma, J., Mccauley, M., ... &
    Stoica, I. (2012). 基于Spark的Hadoop数据快速交互式分析。Usenix Login,* *37(4), 45-51.*'
