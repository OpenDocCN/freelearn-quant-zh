- en: Chapter 1. Introducing F# Using Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the history of F# and its roots in other
    programming languages. We will also be introducing Visual Studio and the fundamental
    language constructs of F#. You will be comfortable using the interactive mode
    for prototyping the code step-by-step. You will get a better understanding of
    how to build programs in F# by putting pieces together. Also, the basics of the
    language are covered by using and evaluating the code in the **Read Eval Print
    Loop** (**REPL**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use F# with Visual Studio 2012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use F# Interactive to write the code in a new exploratory way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of F# and how to write your first non-toy application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How functional programming will make you more productive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive in to the language itself, we should discuss why we need it in
    the first place. F# is a powerful language, which may sound like a cliché, but
    it combines multiple paradigms into real-life productivity and supports the .NET
    components and libraries natively as well as the **Common Language Infrastructure**
    (**CLI**). Functional programming has long been associated with academics and
    experts. F# is one of the few languages offering a complete environment that is
    mature enough to comfortably be integrated into an organization.
  prefs: []
  type: TYPE_NORMAL
- en: Also, F# has extensive support for parallel programming, where advanced features
    such as asynchronous and multi-threaded concepts are implemented as language constructs.
    It hides a lot of implementation details from the programmer. In F#, the functional
    programming paradigm is the main philosophy used to solve problems. The other
    paradigms, object-oriented and imperative programming, are prioritized to be used
    as subsidiaries and complements for this main paradigm. Reasons for them to coexist,
    involves compatibility and pragmatic, real-world productivity concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start by introducing Visual Studio as the main tool of choice for this
    book. Although it's possible to use the standalone F# compiler and your favorite
    editor, you will most likely be more productive using Visual Studio 2012, as we
    will do throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: F# has been a part of Visual Studio since 2010\. We will use the latest version
    of Visual Studio and F# throughout this book. This will enable us to use the latest
    functionality and enhancements available in Visual Studio 2012 and F# 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: F# is open source, which means you can use it on any supported platform; it's
    not bound to Microsoft or Visual Studio. There is good support in other IDEs,
    such as MonoDevelop, which will run on Linux and Mac OS X.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about F# and the F# Software Foundation, visit [http://fsharp.org](http://fsharp.org).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new F# project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in Visual Studio for F#, which is to be used in this guide
    to explore the basics, as shown in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project in Visual Studio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the following steps, we can create a new project in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: To create your first F# project, open Visual Studio 12 and navigate to **File**
    | **New** | **Project,** then, from the menu select **New Project**.![Creating
    a new project in Visual Studio](img/4623OS_01_1.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you will see the **New Project** window appear. Select **F#** in the left
    panel and then select **F# Application**. You can name it anything you like. Finally,
    click on **OK**.![Creating a new project in Visual Studio](img/4623OS_01_2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you have created your first F# application, which will just print the arguments
    passed to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding the program template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's have a brief look at the program template generated by Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the program template](img/4623OS_01_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you run this program, which will just print out the arguments passed to it,
    you will see a terminal window appear.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the program template](img/4623OS_01_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `[<EntryPoint>]` function in the preceding screenshot is the main function,
    which tells Visual Studio to use that particular function as the entry point for
    the program executable. We will not dig any deeper into this program template
    for now, but we will come back to this in the last three chapters when we'll build
    the trading system.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an F# script file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will use an F# script file after having looked at the standard program template
    instead of exploring the basics of the language in a more interactive fashion.
    You can think of F# script files as notebooks, where you have executable code
    that you can explore in pieces in an incremental style:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the F# script file by right-clicking on the **Solution Explorer** to the
    right of the code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then navigate to **Add** | **New Item…,** as shown in the following screenshot:![Adding
    an F# script file](img/4623OS_01_5.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can name the script file anything you like, such as `GettingStarted.fsx`.![Adding
    an F# script file](img/4623OS_01_6.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have set up the basic project structure in Visual Studio, let's
    continue and explore F# Interactive.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding F# Interactive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: F# Interactive is a way of executing parts of a program interactively. Doing
    this enables you as a programmer to explore parts of the code and how it behaves.
    You will have a more dynamic feel for writing code. It's also more fun. F# Interactive
    is a REPL for F#. This means, it will read the code, evaluate it, and then print
    out the result. It will then do this over and over again. It's much like a command
    line, where the code is executed and the result is displayed to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute a code in F# Interactive, have a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the source code you are interested in and press *Alt* + *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can write a simple line of code that will just print a string to the REPL''s
    output window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It's also possible to right-click on the selected code and choose **Execute
    In Interactive**.![Understanding F# Interactive](img/4623OS_01_7.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When executing the code using the Interactive mode, the result is shown in the
    **F# Interactive Evaluation** window below the code editor. It is also possible,
    and sometimes preferable to enter snippets into the **Interactive** window like
    the following example illustrates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enter the following line in the **F# Interactive** window and press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will be evaluated to the following in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using double semicolons (;;) after the line will terminate the input and enable
    you to just hit the *Enter* key, they are required if you type directly into the
    terminal window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you want to cancel the evaluation, it's possible to right-click on and then
    select **Cancel Interactive Evaluation**, or simply press *Ctrl* + *Break*.![Understanding
    F# Interactive](img/4623OS_01_8.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Language overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now start our journey into functional programming using F#, and explore
    its capabilities in quantitative finance applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at how values are declared, that is, how to bind values
    to names, mutability, and immutability.
  prefs: []
  type: TYPE_NORMAL
- en: To initialize and create a value, use the `let` keyword. `let` will bind the
    value on the right-hand side to the variable name on the left-hand side of the
    equals sign. This is a bind operator, a lot like math.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `let` binding is also used in the same way for binding functions to a name,
    as we will see in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining mutability and immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once a variable is defined to have a particular value, it keeps that value indefinitely.
    There are exceptions to this, and shadowing can be used to override a previous
    assignment made within the same scope. Thus, variables in mathematics are immutable.
    Similarly, variables in F# are immutable with some exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable variables are default in F#. They are useful because they are thread-safe
    and easier to reason about. This is one of the reasons you may have heard a lot
    about immutability recently. The concept is to solve the biggest issues and design
    flaws of concurrent programming, including shared mutable state. If the values
    do not change, there is no need to protect them either, which is one of the reasons
    for promoting immutability in concurrent programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to alter the value of an immutable variable, you will encounter
    a message similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, however, it's desirable to have variables that are mutable. Often
    the need arises in real-life applications when some global state is shared like
    a counter. Also, object-oriented programming and interoperability with other .NET
    languages makes the use of mutability unavoidable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a mutable variable, you simply put the keyword `mutable` in front
    of the name as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the variable, after it is created, use the arrow operator (`←`) as
    shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is a little bit different from other languages. But once you have wrapped
    your head around the concept, it makes more sense. In fact, it will most likely
    be one of the main ways to reason about variables in the future as well.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may look like F# is a dynamic typed language like JavaScript, Ruby, or Python.
    In fact, F# is statically typed like C#, C++, and Java. It uses type inference
    to figure out the correct types. Type inference is a technique which is used to
    automatically deduce the type used by analyzing the code. This approach works
    remarkably well in nearly all situations. However, there are circumstances in
    which you as a programmer need to make clarifications to the compiler. This is
    done using type annotations, a concept we will look into in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore some of the built-in types in F# using the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This means that F# figured out the type of `anInt` to be of type `int`. It simply
    inferred the type on the left-hand side to be of the same type as the right-hand
    side of the assignment. Logically, the type must be the same on both sides of
    the assignment operator, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extend our analysis into floating point numbers as shown in the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of the decimal sign, the type is determined to be of type `float`.
    The same holds true for `double` as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For other types, it works in the same way as expected as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: All the primitive built-in types, except for `unit`, have a corresponding type
    in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the most common primitive types in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | .NET type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| bool | Boolean | true or false |'
  prefs: []
  type: TYPE_TB
- en: '| byte | Byte | 0 to 255 |'
  prefs: []
  type: TYPE_TB
- en: '| int | Int32 | -128 to 127 |'
  prefs: []
  type: TYPE_TB
- en: '| int64 | Int64 | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 |'
  prefs: []
  type: TYPE_TB
- en: '| char | Char | 0 to 18,446,744,073,709,551,615 |'
  prefs: []
  type: TYPE_TB
- en: '| string | String | Unicode text |'
  prefs: []
  type: TYPE_TB
- en: '| decimal | Decimal | Floating data type |'
  prefs: []
  type: TYPE_TB
- en: '| unit | - | Absence of an actual value |'
  prefs: []
  type: TYPE_TB
- en: '| void | Void | No type or value |'
  prefs: []
  type: TYPE_TB
- en: '| float | Single | 64-bit floating point value |'
  prefs: []
  type: TYPE_TB
- en: '| double | Double | Same as above |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information and all type you can visit [http://msdn.microsoft.com/en-us/library/dd233210.aspx.](http://msdn.microsoft.com/en-us/library/dd233210.aspx.)
  prefs: []
  type: TYPE_NORMAL
- en: There are also other types that are built into the language which will be covered
    in more detail in the next chapter, such as lists, arrays, sequences, records,
    and discriminated unions.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type inference means that the compiler will automatically deduce the type of
    an expression used in the code, based on the information provided from the programmer
    about the context of the expression. Type inference analyses the code, as you
    have seen in the preceding section, to determine types that are often obvious
    to the programmer. This spares the programmer from having to explicitly define
    the types of every single variable. It's not always needed to have the types defined
    to be able to understand the code, as seen in the preceding section for simple
    assignments of integers and floats. Type inference will make the code easier to
    write, and as a consequence, easier to read, leaving a lot of ceremony where it
    belongs.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s now time to look at functions, the most basic and powerful building block
    in F#, and any other functional programming language for that matter. Functional
    programming languages use functions as first class constructs, in contrast to
    object-oriented programming, where objects and data are first class constructs.
    This means that in functional programming, functions will produce data based on
    the input and not based on state. In object-oriented programming, the state is
    encapsulated into objects and passed around. Functions are declared in the same
    way as variables were declared previously in the preceding snippets, with `let`
    bindings. Have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to evaluate the first `sum` function using *Alt* + *Enter*, F# Interactive
    will respond with a function like the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This means that `sum` is a function that takes two values of type `int` and
    returns a value of type `int`. The compiler simply knows that it's just the last
    type that is the return type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the following case where parameters of wrong types are passed
    to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As seen in the modified version of the `sum` function, the types are explicitly
    declared as float. This is a way of telling the compiler beforehand that float
    is the value to be used in the function. The first version of sum used type inference
    to calculate the types for `x` and `y` respectively and found it to be of type
    `int`.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about anonymous functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since it is common to create small helper functions in F# programming, F# also
    provides a special syntax for creating anonymous functions. These functions are
    sometimes called lambdas, or lambda functions. To define an anonymous function,
    the keyword `fun` is used. Have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Explaining higher-order functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now the square function can be used by itself or as an argument to other functions
    or higher-order functions. Have a look at the following square function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, the square function is passed as an argument to the function `squareByFour`.
    The function `squareByFour` is a higher-order function; it takes another function
    as an argument. Higher-order functions can take a function as an argument or return
    a function, or do both. This is an often used technique in functional programming
    to be able to construct new functions from existing functions and reuse them.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though, currying is sometimes considered to be an advanced feature of programming
    languages, it makes the most sense on connection to functions and higher-order
    functions. The idea is not complicated at all, and once you have seen a couple
    of examples, the concept should be clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following `sum` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assume we want to reuse the function, but we may often call it for some
    fixed value of `x`. That means we have a fixed `x`, let''s say `2`, and we vary
    the `y` parameter. Have a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of having to write out the `x` parameter every time, we can make use
    of the concept of currying. That means we create a new function with the first
    parameter fixed in this case. Take a look at the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have now saved ourselves from rewriting some arguments, but this is not the
    main reason. It's the ability to control the parameters and reuse functionality.
    More about currying will be covered in later chapters, but the basics were covered
    here in connection to higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists in F# are very useful, they are some of the most frequently used building
    blocks. They are the basic building blocks in functional languages and often replace
    the need of other types or classes. This is because the support for manipulating
    and creating lists and also being able to nest lists can be enough to replace
    custom types. You can think of lists as a sequence of values of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists in F# are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A powerful way to store data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable linked lists of values of any type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often used as building blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the best ways to store data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Investigating lists](img/4623OS_01_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This illustrates a list in F#, with a head and a tail, where each element is
    linked to the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following simple list of price information which are represented
    as floating points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want a list with values between 0 and 100, instead of writing them
    yourself, F# can do it for you. Take a look at the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is fine if we just want a simple range with fixed size increments. Sometimes
    however, you may want to have a smaller increment, let''s say 0.1, which is between
    1.0 and 10.0\. The following code shows how it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Lists can be of any type, and type inference works here as well. Have a look
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you mix the types in a list, the compiler will get confused about
    the actual type used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Concatenating lists is useful when you want to add lists together. This is
    done using the `@` operator. Have a look at the following code where the `@` operator
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at some of the most commonly used functions in the List
    Module: `Length`, `Head`, `Tail`, `map`, and `filter` respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `Length` will simply return the length of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want the first element of a list, use `Head`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the list, meaning all other elements except the `Head`, is defined
    as the `Tail`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also do some more interesting things with lists, such as calculating
    the square of all the elements one by one. Note that it''s an entirely new list
    returned from the `map` function, since lists are immutable. This is done using
    higher-order functions, where `List.map` takes a lambda function defined to return
    the value of `x*x` as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Another interesting function is the `filter` function of lists, which will
    return a new list matching the filter criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tuples are a group of unnamed but ordered values. The values can be of different
    types, if needed. You can think of them as more flexible versions of the Tuple
    class in C#.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze the type information from the tuples in the REPL. The first
    tuple has the type information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `*` symbol is used to separate the type elements for a tuple. It''s simply
    a tuple of two floats. The next one is a bit more complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'But the type inference figured it out without any doubts. The last one consists
    of expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the expressions are evaluated before the type data is analyzed.
    It may be useful to extract the values from a tuple, this can be done using simple
    patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you are not interested in the first value, use the wildcard character (the
    underscore) to simply ignore it. The wildcard is used throughout F#, for example,
    in pattern matching, which will be introduced in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The pipe operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The pipe operator is used a lot and it's defined as a function which takes the
    values on the left-hand side of the operator and applies them to the function
    on the right-hand side. There is another version of the pipe operator with various
    numbers of arguments, and more about them will be covered later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pipe-forward operator (|>) is the most common pipe operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet first creates a list from 0 to 100, as illustrated in the section
    about lists previously. Then, the list is piped to the filter function with a
    conditional lambda function. Every even value in the list gets passed on to the
    next function. The map function will execute the lambda function to square every
    number. Finally, all numbers are summed, with the result of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Documenting your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documenting your code is a good practice to get used to. Do you remember details
    about code you worked on some weeks ago? Then imagine yourself looking at the
    code you worked on several years ago. This is where documentation comes in. Just
    some hints about the logic will be sufficient for you and your colleges to grasp
    the main concepts behind the logic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Your first application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first application for doing something useful will be this Hello World of
    finance, which will illustrate some powerful yet simple concepts and strengths
    of F# and functional languages in general.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start our journey into quantitative finance by looking at a simple yet
    illustrative example using Yahoo finance data. First, we will just put the data
    into the code to get used to the basic concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we put some data in. In F# you can declare a list of strings on multiple
    lines like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We introduce a function for splitting strings on commas; this will create an
    array of strings. Don't forget to evaluate the parts of the program in F# Interactive
    using *Alt* + *Enter*. Doing this as a practice will make the number of errors
    less, and you will also be getting more comfortable and understand the types involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of the `stockData` value is not explicitly declared, but if you evaluate
    it, you should see it is of type `string list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Evaluating the expression `lowestVolume` will parse the strings in `stockData`
    and extract the row with the lowest trading volume, column six. Hopefully, the
    result will be the row with date 2013-05-29, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The whole program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the code listing for the program we developed in the previous
    section, the Hello World program of finance. Try it out for yourself and make
    changes to it if you like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The pipe operator makes the logic of the program very straightforward. The program
    takes the list `stockData`, splits for commas, then selects specific columns and
    applies a mathematical operator. Then, it selects the maximum value of these calculations
    and finally returns the first column of the row fulfilling the `minBy` criteria.
    You can think of it as building blocks, where each piece is a standalone function
    on its own. Combining many functions into powerful programs is the philosophy
    behind functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the example program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's extend the preceding program to read data from a file instead. Since having
    it explicitly declared in the code is not that useful in the long run, as data
    tends to change. During this extension, we will also introduce exceptions and
    how they are used in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: We start by writing a simple function to read all the contents from a file,
    where its path is passed as an argument. The argument is of type string, as you
    can see in the function header using the type annotation. Annotations are used
    either when the compiler can't figure out the type on its own, or when you as
    a programmer want to clarify the type used or enforce a certain type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The function will catch `FileNotFoundException` if the file is not found. There
    is also a new operator (`:?`) before the exception type. This is a type test operator,
    which returns true if the value matches the specified type, otherwise, returns
    false.
  prefs: []
  type: TYPE_NORMAL
- en: Let's change the preceding code to use the content loaded from the file instead
    of the pre-coded stock prices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: There are some minor changes needed to the code to make it able to handle the
    input from the **Comma-Separated Values** (**CSV**) file. As with the input to
    the pipes, we use the result from the call to the `openFile` function. Then, we
    split for commas as before. It was necessary to have a way to skip the first line;
    this is easy to do in F#, and you just insert a `Seq.skip n`, where n is the number
    of elements in the sequence to skip.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply use `printfn` formatted with `%A`, which will just take anything
    and format for output (very convenient).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at one more example of this useful string formatter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The entire program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at the code for the entire program, which we looked at in the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The power of prototyping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the interactive mode in Visual Studio and being able to write the program
    in smaller building blocks using prototyping is a great way of writing software.
    You have already used this exploratory way of writing programs with the first
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The workflow is to build up programs incrementally instead of running all code
    at once. The REPL is a perfect place to try out snippets and experiment with different
    aspects of F#.
  prefs: []
  type: TYPE_NORMAL
- en: Functional languages in quantitative finance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding example code, we saw that parsing data from a file and extracting
    various information is straightforward, and results in code that is both easy
    to read and understand. That's one of the highlights of F#, not less important
    in quantitative finance where code can be complex and hard to follow and comprehend
    in many languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s illustrate the preceding statements with another example. The data in
    the CSV file in the previous sample application was sorted with the most recent
    date first. If we want the data to be ordered in a more natural way, lowest date
    first and so on, we can simply reverse the entire list in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the imperative code and interoperability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose we are interested in parsing the date column in the example with the
    stock prices. The entire row looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We are interested in the first column, with index 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make use of the .NET classes for date and time in the `System.DateTime`
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a `System.DateTime` object, which is compatible with C# and the
    other .NET languages, to work with!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a look into the basics of programming in F# using Visual
    Studio. We covered a wide variety of the language and scratched the surface of
    functional programming, where immutability plays a key role. Throughout the chapter
    we started out illustrating some of F#'s language features and how to make use
    of the .NET framework. At the end of the chapter, we put together a simple application
    which shows the power and elegant syntax of F#. Functions are the main building
    block in any functional programming language. Building new functions from existing
    ones is a way of abstracting away the complexity and allows for reuse.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll dive into more details about the F# language. You'll
    learn more about data structures, such as Lists, Sequences, and Arrays. You'll
    also learn how to structure your program using modules and namespaces, things
    that will become useful in larger programs. The next chapter will also introduce
    you to threads, thread pools, asynchronous programming using .NET, and language-specific
    constructs for the F# language.
  prefs: []
  type: TYPE_NORMAL
