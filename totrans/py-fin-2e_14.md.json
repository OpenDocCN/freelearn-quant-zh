["```py\ndef binomialCallAmerican(s,x,T,r,sigma,n=100):\n    from math import exp,sqrt\n    import numpy as np\n    deltaT = T /n\n    u = exp(sigma * sqrt(deltaT)) \n    d = 1.0 / u\n    a = exp(r * deltaT)\n    p = (a - d) / (u - d)\n    v = [[0.0 for j in np.arange(i + 1)] for i in np.arange(n + 1)] \n    for j in np.arange(n+1):\n        v[n][j] = max(s * u**j * d**(n - j) - x, 0.0) \n    for i in np.arange(n-1, -1, -1):\n        for j in np.arange(i + 1):\n            v1=exp(-r*deltaT)*(p*v[i+1][j+1]+(1.0-p)*v[i+1][j]) \n            v2=max(v[i][j]-x,0)         # early exercise \n            v[i][j]=max(v1,v2)\n    return v[0][0]\n#\ns=40\\.        # stock price today \nx=40\\.        # exercise price\nT=6./12      # maturity date ii years\ntao=1/12     # when to choose\nr=0.05       # risk-free rate\nsigma=0.2    # volatility \nn=1000       # number of steps\n#\nprice=binomialCallAmerican(s,x,T,r,sigma,n)\nprint(\"American call =\", price)\n('American call =', 2.7549263174936502)\n```", "```py\n            v2=max(v[i][j]-x,0)         # early exercise \n            v[i][j]=max(v1,v2)\n```", "```py\ndef callBermudan(s,x,T,r,sigma,T2,n=100):\n    from math import exp,sqrt\n    import numpy as np\n    n2=len(T2)\n    deltaT = T /n\n    u = exp(sigma * sqrt(deltaT)) \n    d = 1.0 / u\n    a = exp(r * deltaT)\n    p = (a - d) / (u - d)\n    v =[[0.0 for j in np.arange(i + 1)] for i in np.arange(n + 1)] \n    for j in np.arange(n+1):\n        v[n][j] = max(s * u**j * d**(n - j) - x, 0.0) \n    for i in np.arange(n-1, -1, -1):\n        for j in np.arange(i + 1):\n            v1=exp(-r*deltaT)*(p*v[i+1][j+1]+(1.0-p)*v[i+1][j])\n            for k in np.arange(n2):\n                if abs(j*deltaT-T2[k])<0.01:\n                    v2=max(v[i][j]-x,0)  # potential early exercise \n                else: \n                    v2=0\n            v[i][j]=max(v1,v2)\n    return v[0][0]\n#\ns=40\\.                 # stock price today \nx=40\\.                 # exercise price\nT=6./12               # maturity date ii years\nr=0.05                # risk-free rate\nsigma=0.2             # volatility \nn=1000                # number of steps\nT2=(3./12.,4./12.)    # dates for possible early exercise \n#\nprice=callBermudan(s,x,T,r,sigma,T2,n)\nprint(\"Bermudan call =\", price)\n('Bermudan call =', 2.7549263174936502)\n```", "```py\nfrom scipy import log,exp,sqrt,stats \ndef callAndPut(S,X,T,r,sigma,tao,type='C'):\n    d1=(log(S/X)+r*T+0.5*sigma*sigma*tao)/(sigma*sqrt(tao)) \n    d2 = d1-sigma*sqrt(tao)\n    if type.upper()=='C':\n        c=S*stats.norm.cdf(d1)-X*exp(-r*T)*stats.norm.cdf(d2)\n        return c\n    else:\n        p=X*exp(-r*T)*stats.norm.cdf(-d2)-S*stats.norm.cdf(-d1)\n        return p\n#\ndef chooserOption(S,X,T,r,sigma,tao):\n    call_T=callAndPut(S,X,T,r,sigma,T)\n    put_tao=callAndPut(S,X,T,r,sigma,tao,type='P')\n    return call_T- put_tao\n#\ns=40\\.        # stock price today \nx=40\\.        # exercise price\nT=6./12      # maturity date ii years\ntao=1./12\\.   # when to choose\nr=0.05       # risk-free rate\nsigma=0.2    # volatility \n#\nprice=chooserOption(s,x,T,r,sigma,tao)\nprint(\"price of a chooser option=\",price)\n('price of a chooser option=', 2.2555170735574421)\n```", "```py\ndef shoutCall(s,x,T,r,sigma,shout,n=100):\n    from math import exp,sqrt\n    import numpy as np\n    deltaT = T /n\n    u = exp(sigma * sqrt(deltaT)) \n    d = 1.0 / u\n    a = exp(r * deltaT)\n    p = (a - d) / (u - d)\n    v =[[0.0 for j in np.arange(i + 1)] for i in np.arange(n + 1)] \n    for j in np.arange(n+1):\n        v[n][j] = max(s * u**j * d**(n - j) - x, 0.0) \n    for i in np.arange(n-1, -1, -1):\n        for j in np.arange(i + 1):\n            v1=exp(-r*deltaT)*(p*v[i+1][j+1]+(1.0-p)*v[i+1][j]) \n            v2=max(v[i][j]-shout,0)   # shout  \n            v[i][j]=max(v1,v2)\n    return v[0][0]\n#\ns=40\\.              # stock price today \nx=40\\.              # exercise price\nT=6./12            # maturity date ii years\ntao=1/12           # when to choose\nr=0.05             # risk-free rate\nsigma=0.2          # volatility \nn=1000             # number of steps\nshout=(1+0.03)*s   # shout out level \n#\nprice=shoutCall(s,x,T,r,sigma,shout,n)\nprint(\"Shout call =\", price)\n```", "```py\nimport random\nimport scipy as sp\n#\ndef terminalStockPrice(S, T,r,sigma):\n    tao=random.gauss(0,1.0)\n    terminalPrice=S * sp.exp((r - 0.5 * sigma**2)*T+sigma*sp.sqrt(T)*tao)\n    return terminalPrice\n#\ndef binaryCallPayoff(x, sT,payoff):\n    if sT >= x:\n        return payoff\n    else:\n        return 0.0\n# input area \nS = 40.0            # asset price\nx = 40.0            # exercise price \nT = 0.5             # maturity in years \nr = 0.01            # risk-free rate \nsigma = 0.2         # vol of 20%\nfixedPayoff = 10.0  # payoff \nnSimulations =10000 # number of simulations \n#\npayoffs=0.0\nfor i in xrange(nSimulations):\n    sT = terminalStockPrice(S, T,r,sigma) \n    payoffs += binaryCallPayoff(x, sT,fixedPayoff)\n#\nprice = sp.exp(-r * T) * (payoffs / float(nSimulations))\nprint('Binary options call= %.8f' % price)\n```", "```py\nimport numpy as np\nfrom matplotlib import cm\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n#\n# input area\nn   = 60                      # number of intervals\nx   = np.linspace(-3, 3, n)   # x dimension\ny   = np.linspace(-3, 4, n)   # y dimension \nx,y = np.meshgrid(x, y)       # grid \n#\n# Mean vector and covariance matrix\nmu = np.array([0., 1.])\ncov= np.array([[ 1\\. , -0.5], [-0.5,  1.5]])\n#\n# combine x and y into a single 3-dimensional array\npos = np.empty(x.shape + (2,))\npos[:, :, 0] = x\npos[:, :, 1] = y\n#\ndef multiNormal(pos, mu, cov):\n    n = mu.shape[0]\n    Sigma_det = np.linalg.det(cov)\n    Sigma_inv = np.linalg.inv(cov)\n    n2 = np.sqrt((2*np.pi)**n * Sigma_det)\n    fac=np.einsum('...k,kl,...l->...', pos-mu, Sigma_inv, pos-mu)\n    return np.exp(-fac/2)/n2\n#\nz    = multiNormal(pos, mu, cov)\nfig  = plt.figure()\nax   = fig.gca(projection='3d')\nax.plot_surface(x, y, z, rstride=3, cstride=3,linewidth=1, antialiased=True,cmap=cm.viridis)\ncset = ax.contourf(x, y, z, zdir='z', offset=-0.15, cmap=cm.viridis)\nax.set_zlim(-0.15,0.2)\nax.set_zticks(np.linspace(0,0.2,5))\nax.view_init(27, -21)\nplt.title(\"Bivariate normal distribtuion\")\nplt.ylabel(\"y values \")\nplt.xlabel(\"x values\")\nplt.show()\n```", "```py\ndef N2_f(d1,d2,rho):\n    \"\"\"cumulative bivariate standard normal distribution \n       d1: the first value\n       d2: the second value\n       rho: correlation\n\n       Example1:\n               print(N2_f(0,0,1.)) => 0.5\n       Example2:\n               print(N2_f(0,0,0)  => 0.25\n     \"\"\"\n    import statsmodels.sandbox.distributions.extras as extras\n    muStandardNormal=0.0    # mean of a standard normal distribution \n    varStandardNormal=1.0   # variance of standard normal distribution \n    upper=([d1,d2])         # upper bound for two values\n    v=varStandardNormal     # simplify our notations\n    mu=muStandardNormal     # simplify our notations\n    covM=([v,rho],[rho,v])\n    return extras.mvnormcdf(upper,mu,covM)\n#\n```", "```py\nfrom math import exp,sqrt,log\nimport statsmodels.sandbox.distributions.extras as extras\n#\ndef dOne(s,k,r,sigma,T):\n    #print(s,k,r,sigma,T)\n    a=log(s/k)+(r-0.5*sigma**2)*T\n    b=(sigma*sqrt(T))\n    return a/b\n#\ndef sigmaA_f(sigma1,sigma2,rho):\n    return sqrt(sigma1**2-2*rho*sigma1*sigma2+sigma2**2)\n#\ndef dTwo(d1,sigma,T):\n    return d1+sigma*sqrt(T)\n#\ndef rhoTwo(sigma1,sigma2,sigmaA,rho):\n    return (rho*sigma2-sigma1)/sigmaA\n#\ndef N2_f(d1,d2,rho):\n    import statsmodels.sandbox.distributions.extras as extras\n    muStandardNormal=0.0    # mean of a standard normal distribution \n    varStandardNormal=1.0   # variance of standard normal distribution \n    upper=([d1,d2])         # upper bound for two values\n    v=varStandardNormal     # simplify our notations\n    mu=muStandardNormal     # simplify our notations\n    covM=([v,rho],[rho,v])\n    return extras.mvnormcdf(upper,mu,covM)\n#\ndef dOneTwo(s1,s2,sigmaA,T):\n    a=log(s2/s1)-0.5*sigmaA**2*T\n    b=sigmaA*sqrt(T)\n    return a/b\n#\ndef rainbowCallOnMinimum(s1,s2,k,T,r,sigma1,sigma2,rho):\n    d1=dOne(s1,k,r,sigma1,T)\n    d2=dOne(s2,k,r,sigma2,T)\n    d11=dTwo(d1,sigma1,T)\n    d22=dTwo(d2,sigma2,T)\n    sigmaA=sigmaA_f(sigma1,sigma2,rho)\n    rho1=rhoTwo(sigma1,sigma2,sigmaA,rho)\n    rho2=rhoTwo(sigma2,sigma1,sigmaA,rho)\n    d12=dOneTwo(s1,s2,sigmaA,T)\n    d21=dOneTwo(s2,s1,sigmaA,T)\n    #\n    part1=s1*N2_f(d11,d12,rho1)\n    part2=s2*N2_f(d21,d22,rho2)\n    part3=k*exp(-r*T)*N2_f(d1,d2,rho)\n    return part1 + part2 - part3\n#\ns1=100.\ns2=95.\nk=102.0\nT=8./12.\nr=0.08\nrho=0.75\nsigma1=0.15\nsigma2=0.20\nprice=rainbowCallOnMinimum(s1,s2,k,T,r,sigma1,sigma2,rho)\nprint(\"price of call based on the minimum of 2 assets=\",price)\n('price of call based on the minimum of 2 assets=', 3.747423936156629)\n```", "```py\nimport scipy as sp\nsp.random.seed(123)\nn=1000\nrho=0.3\nx1=sp.random.normal(size=n)\nx2=sp.random.normal(size=n)\ny1=x1\ny2=rho*x1+sp.sqrt(1-rho**2)*x2\nprint(sp.corrcoef(y1,y2))\n[[ 1\\.          0.28505213]\n [ 0.28505213  1\\.        ]]\n```", "```py\nimport scipy as sp \nfrom scipy import zeros, sqrt, shape \n#\nsp.random.seed(123)  # fix our random numbers\ns1=100\\.              # stock price 1 \ns2=95\\.               # stock price 2\nk=102.0              # exercise price\nT=8./12\\.             # maturity in years\nr=0.08               # risk-free rate\nrho=0.75             # correlation between 2\nsigma1=0.15          # volatility for stock 1\nsigma2=0.20          # volatility for stock 1\nnSteps=100\\.          # number of steps \nnSimulation=1000     # number of simulations \n#\n# step 1: generate correlated random number\ndt =T/nSteps \ncall = sp.zeros([nSimulation], dtype=float) \nx = range(0, int(nSteps), 1) \n#\n# step 2: call call prices \nfor j in range(0, nSimulation): \n    x1=sp.random.normal(size=nSimulation)\n    x2=sp.random.normal(size=nSimulation)\n    y1=x1\n    y2=rho*x1+sp.sqrt(1-rho**2)*x2\n    sT1=s1\n    sT2=s2 \n    for i in x[:-1]: \n        e1=y1[i]\n        e2=y2[i]\n        sT1*=sp.exp((r-0.5*sigma1**2)*dt+sigma1*e1*sqrt(dt)) \n        sT2*=sp.exp((r-0.5*sigma2**2)*dt+sigma2*e2*sqrt(dt)) \n        minOf2=min(sT1,sT2)\n        call[j]=max(minOf2-k,0) \n#\n# Step 3: summation and discount back \ncall=sp.mean(call)*sp.exp(-r*T) \nprint('Rainbow call on minimum of 2 assets = ', round(call,3))\n('Rainbow call on minimum of 2 assets = ', 4.127)\n```", "```py\nimport numpy as np\n# input area\nnSimulation=5000              # number of simulations\nc=np.array([[1.0, 0.5, 0.3],  # correlation matrix\n            [0.5, 1.0, 0.4],\n            [0.3, 0.4, 1.0]])\nnp.random.seed(123)           # fix random numbers \n#\n# generate uncorrelated random numbers\nx=np.random.normal(size=3*nSimulation)\nU=np.reshape(x,(nSimulation,3))\n#\n# Cholesky decomposition \nL=np.linalg.cholesky(c)\n# generate correlated random numbers\nr=np.dot(U,L)\n#check the correlation matrix\nprint(np.corrcoef(r.T))\n[[ 1\\.          0.51826188  0.2760649 ]\n [ 0.51826188  1\\.          0.35452286]\n [ 0.2760649   0.35452286  1\\.        ]]\n```", "```py\nimport scipy as sp \ns0=30\\.                 # today stock price \nx=32\\.                  # exercise price \nT=3.0/12\\.              # maturity in years \nr=0.025                # risk-free rate \nsigma=0.18             # volatility (annualized) \nsp.random.seed(123)    # fix a seed here \nn_simulation=1000      # number of simulations \nn_steps=500\\.           # number of steps\n#\ndt=T/n_steps \ncall=sp.zeros([n_simulation], dtype=float) \nfor j in range(0, n_simulation): \n    sT=s0 \n    total=0 \n    for i in range(0,int(n_steps)): \n         e=sp.random.normal()\n         sT*=sp.exp((r-0.5*sigma*sigma)*dt+sigma*e*sp.sqrt(dt)) \n         total+=sT \n         price_average=total/n_steps \n    call[j]=max(price_average-x,0) \n#\ncall_price=sp.mean(call)*sp.exp(-r*T) \nprint('call price based on average price = ', round(call_price,3))\n('call price based on average price = ', 0.12)\n```", "```py\nimport scipy as sp \nfrom scipy import log,exp,sqrt,stats \n#\ndef bsCall(S,X,T,r,sigma):\n    d1=(log(S/X)+(r+sigma*sigma/2.)*T)/(sigma*sqrt(T)) \n    d2 = d1-sigma*sqrt(T)\n    return S*stats.norm.cdf(d1)-X*exp(-r*T)*stats.norm.cdf(d2)\n#\ndef up_and_out_call(s0,x,T,r,sigma,n_simulation,barrier):\n    n_steps=100\\. \n    dt=T/n_steps \n    total=0 \n    for j in sp.arange(0, n_simulation): \n        sT=s0 \n        out=False\n        for i in range(0,int(n_steps)): \n            e=sp.random.normal() \n            sT*=sp.exp((r-0.5*sigma*sigma)*dt+sigma*e*sp.sqrt(dt)) \n            if sT>barrier: \n               out=True \n        if out==False: \n            total+=bsCall(s0,x,T,r,sigma) \n    return total/n_simulation \n#\n```", "```py\ns0=30\\.              # today stock price \nx=30\\.               # exercise price \nbarrier=32          # barrier level \nT=6./12\\.            # maturity in years \nr=0.05              # risk-free rate \nsigma=0.2           # volatility (annualized) \nn_simulation=100    # number of simulations \nsp.random.seed(12)  # fix a seed\n#\nresult=up_and_out_call(s0,x,T,r,sigma,n_simulation,barrier) \nprint('up-and-out-call = ', round(result,3))\n('up-and-out-call = ', 0.93)\n```", "```py\ndef down_and_in_put(s0,x,T,r,sigma,n_simulation,barrier): \n    n_steps=100.\n    dt=T/n_steps \n    total=0\n    for j in range(0, n_simulation): \n        sT=s0\n        in_=False\n        for i in range(0,int(n_steps)): \n            e=sp.random.normal()\n            sT*=sp.exp((r-0.5*sigma*sigma)*dt+sigma*e*sp.sqrt(dt)) \n            if sT<barrier:\n                in_=True\n            #print 'sT=',sT\n            #print 'j=',j ,'out=',out if in_==True:\n            total+=p4f.bs_put(s0,x,T,r,sigma) \n    return total/n_simulation\n#\n```", "```py\ndef upCall(s,x,T,r,sigma,nSimulation,barrier):\n    import scipy as sp\n    import p4f \n    n_steps=100\n    dt=T/n_steps \n    inTotal=0 \n    outTotal=0\n    for j in range(0, nSimulation): \n        sT=s\n        inStatus=False \n        outStatus=True\n        for i in range(0,int(n_steps)):\n            e=sp.random.normal()\n            sT*=sp.exp((r-0.5*sigma*sigma)*dt+sigma*e*sp.sqrt(dt)) \n            if sT>barrier:\n                outStatus=False \n                inStatus=True\n        if outStatus==True:\n            outTotal+=p4f.bs_call(s,x,T,r,sigma) \n        else:\n            inTotal+=p4f.bs_call(s,x,T,r,sigma) \n    return outTotal/nSimulation, inTotal/nSimulation\n#\n```", "```py\nimport p4f\ns=40\\.                 # today stock price \nx=40\\.                 # exercise price \nbarrier=42.0          # barrier level \nT=0.5                 # maturity in years \nr=0.05                # risk-free rate \nsigma=0.2             # volatility (annualized) \nnSimulation=500       # number of simulations \n#\nupOutCall,upInCall=upCall(s,x,T,r,sigma,nSimulation,barrier) \nprint 'upOutCall=', round(upOutCall,2),'upInCall=',round(upInCall,2) \nprint 'Black-Scholes call', round(p4f.bs_call(s,x,T,r,sigma),2)\n```", "```py\nupOutCall= 0.75 upInCall= 2.01\nBlack-Scholes call 2.76\n```", "```py\nimport p4f\nimport scipy as sp\nimport matplotlib.pyplot as plt\n#\ns =9.25              # stock price at time zero\nx =9.10              # exercise price\nbarrier=10.5         # barrier\nT =0.5               # maturity date (in years)\nn_steps=30           # number of steps\nr =0.05              # expected annual return\nsigma = 0.2          # volatility (annualized) \nsp.random.seed(125)  # seed()\nn_simulation = 5     # number of simulations \n#\ndt =T/n_steps\nS = sp.zeros([n_steps], dtype=float) \ntime_= range(0, int(n_steps), 1) \nc=p4f.bs_call(s,x,T,r,sigma) \nsp.random.seed(124)\noutTotal, inTotal= 0.,0\\. \nn_out,n_in=0,0\n\nfor j in range(0, n_simulation):\n    S[0]= s\n    inStatus=False\n    outStatus=True\n    for i in time_[:-1]:\n        e=sp.random.normal()\n        S[i+1]=S[i]*sp.exp((r-0.5*pow(sigma,2))*dt+sigma*sp.sqrt(dt)*e) \n        if S[i+1]>barrier:\n            outStatus=False \n            inStatus=True\n    plt.plot(time_, S) \n    if outStatus==True:\n        outTotal+=c;n_out+=1 \n    else:\n        inTotal+=c;n_in+=1 \n        S=sp.zeros(int(n_steps))+barrier \n        plt.plot(time_,S,'.-') \n        upOutCall=round(outTotal/n_simulation,3) \n        upInCall=round(inTotal/n_simulation,3) \n        plt.figtext(0.15,0.8,'S='+str(s)+',X='+str(x))\n        plt.figtext(0.15,0.76,'T='+str(T)+',r='+str(r)+',sigma=='+str(sigma)) \n        plt.figtext(0.15,0.6,'barrier='+str(barrier))\n        plt.figtext(0.40,0.86, 'call price  ='+str(round(c,3)))\n        plt.figtext(0.40,0.83,'up_and_out_call ='+str(upOutCall)+' (='+str(n_out)+'/'+str(n_simulation)+'*'+str(round(c,3))+')') \n        plt.figtext(0.40,0.80,'up_and_in_call ='+str(upInCall)+' (='+str(n_in)+'/'+ str(n_simulation)+'*'+str(round(c,3))+')')\n#\nplt.title('Up-and-out and up-and-in parity (# of simulations = %d ' % n_simulation +')')\nplt.xlabel('Total number of steps ='+str(int(n_steps))) \nplt.ylabel('stock price')\nplt.show()\n```", "```py\nplt.show()\ndef lookback_min_price_as_strike(s,T,r,sigma,n_simulation): \n    n_steps=100\n    dt=T/n_steps\n    total=0\n    for j in range(n_simulation): \n        min_price=100000\\.  # a very big number \n        sT=s\n        for i in range(int(n_steps)): \n            e=sp.random.normal()\n            sT*=sp.exp((r-0.5*sigma*sigma)*dt+sigma*e*sp.sqrt(dt)) \n            if sT<min_price:\n                min_price=sT\n                #print 'j=',j,'i=',i,'total=',total \n                total+=p4f.bs_call(s,min_price,T,r,sigma)\n    return total/n_simulation\n```", "```py\nimport scipy as sp\nimport p4f\ns=40\\.             # today stock price\nT=0.5               # maturity in years\nr=0.05              # risk-free rate\nsigma=0.2           # volatility (annualized)\nn_simulation=1000   # number of simulations\nresult=lookback_min_price_as_strike(s,T,r,sigma,n_simulation)\nprint('lookback min price as strike = ', round(result,3))\n```", "```py\n('lookback min price as strike = ', 53.31)t(\n```", "```py\n    import scipy as sp\n    import pandas as pd\n    x=pd.read_pickle(\"c:/temp/cruideOilPriceDaily.pkl\")\n    print(x.head())\n    print(x.tail())\n                PRICE\n    1986-01-02  25.56\n    1986-01-03  26.00\n    1986-01-06  26.53\n    1986-01-07  25.85\n    1986-01-08  25.87\n                PRICE\n    2017-02-28  54.00\n    2017-03-01  53.82\n    2017-03-02  52.63\n    2017-03-03  53.33\n    2017-03-06  53.19\n    ```", "```py\n    def N_f(x):\n        from scipy import stats\n        return stats.norm.cdf(x)\n    #\n    def N2_f(x,y,rho):\n        import statsmodels.sandbox.distributions.extras as extras\n        muStandardNormal=0.0    # mean of a standard normal distribution \n        varStandardNormal=1.0   # variance of standard normal distribution \n        upper=([x,y])           # upper bound for two values\n        v=varStandardNormal     # simplify our notations\n        mu=muStandardNormal     # simplify our notations\n        covM=([v,rho],[rho,v])\n    return extras.mvnormcdf(upper,mu,covM) \n    ```"]