- en: Chapter 4. Getting Started with Data Visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to get started with data visualization and
    build graphical user interfaces (GUIs) in F#. In quantitative finance, it is essential
    to be able to plot and visualize time series. F# is a great tool for this and
    we'll learn how to use F# as an advanced graphical calculator using F# Interactive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content in this chapter will be used throughout the book whenever user
    interfaces are needed. In this chapter you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: Programming of basic GUI in F# and .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting data using Microsoft Charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting financial data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an interactive GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making your first GUI in F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: F# leverages the .NET platform and GUI programming is no exception. All classes
    from the .NET platform are available in this section. We will concentrate on the
    one from the `System.Windows.Forms` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to use the same code from F# Interactive and modify the GUI on
    the fly. We will look at this in more detail in the *Displaying data* section.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example where we make use of a .NET form and a button. The
    button will be connected to an event handler called for every click on the button.
    As you can see when you read the code, event handlers are higher-order functions
    that result in a clean and compact code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The screenshot for the output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making your first GUI in F#](img/4623OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first GUI application in F# consisting of a form and a button
  prefs: []
  type: TYPE_NORMAL
- en: Composing interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we have looked at the first code to generate a form and composed a very
    simple interface consisting of a button. As you may have noticed, F# has no visual
    designer as present in the other .NET languages. There are several ways of composing
    interfaces in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing interface code manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the C# visual designer and converting the code into F#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a library using other .NET language and using it from F#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your own visual designer to output F# code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we will mainly use the first alternative—writing interface code
    manually. This may seem tedious, but the upside is total control over the layout.
    We'll now look at a larger example using an agent to keep track of the highest
    number and a user interface with a button. When a user clicks on that button,
    a random number is sent to the agent (see the following screenshot). The agent
    then outputs the highest number every second. Also, the example illustrates the
    use of namespaces and modules in a realistic fashion. This gives the reader an
    idea of when to use namespaces and modules, and how to structure the programs
    when they become larger.
  prefs: []
  type: TYPE_NORMAL
- en: '![Composing interfaces](img/4623OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The form of the agent application, with a button to send values to the agent.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The order of the files in the project is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Agent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Otherwise, you will see some errors due to references. See the following figure
    showing **Solution Explorer** and notice the order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Composing interfaces](img/4623OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: More about agents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we start with the agent. The agent is much the same as the agent in the
    section about agents in [Chapter 2](ch02.html "Chapter 2. Learning More About
    F#"), *Learning More About F#*, except for some modifications and the namespace
    `Agents`. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The screenshot for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![More about agents](img/4623OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The console window with the output from the agent
  prefs: []
  type: TYPE_NORMAL
- en: The user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The user interface is placed in the GUI namespace. `SampleForm` inherits from
    the `Form` .NET class. If you are familiar with other .NET languages, you will
    see some of the common steps involved. All the layout code is also a part of the
    code. There is no visual designer in F#, as mentioned earlier. To use `System.Windows.Forms`,
    you have to add a reference to the assembly with the same name. The code is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The main application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the main application entry point. It is annotated to tell the runtime
    environment (.NET platform) from where to start out. This is done by using the
    `[<STAThread>]` annotation. Here, we simply kick off the application and its GUI.
    The code for `SampleForm` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Learning about event handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Event driven programming and events from user are common ways of building GUIs.
    Event handlers are easy in F#, and lambda functions are easy to read and understand.
    Compact code is always preferable and makes things such as maintenance and understanding
    of the code easier for everyone involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look more closely at the code previously used for event handling, you
    can see that we first use a lambda function and inside the lambda we call a member
    function of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is just a way of making the code more readable and easier to understand.
    It's of course possible to include all the logic in the lambda function directly;
    but this approach is leaner, especially for larger projects.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Displaying and visualizing data is essential to get a better understanding of
    its characteristics. Also, data is at its core in quantitative finance. F# is
    a sharp tool for data analysis and visualization. A majority of the functionalities
    of visualization and user interfaces comes from the .NET platform. Together with
    the exploratory characteristics of F#, especially through F# Interactive, the
    combination becomes very efficient and powerful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start out by using F# Interactive to create a form that will display
    data feed to it. This means we will have a form that can change the content at
    runtime, without the need for recompiling. The controls in the form are also interchangeable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this code, you will see a form with the title **Displaying data
    in F#** as the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying data](img/4623OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The window with a RichTextBox control to display data
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a function to send data to the textbox in the window and display it.
    Here is the one to do the job for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the function and it will send the formatted data to our textbox
    (`textBox`). Here are some examples that show you how to use the function; it''s
    useful to utilize the pipe function as illustrated in the later snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to clear the contents of the textbox, you can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying data](img/4623OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is how the form looks with the content generated from the previous snippet
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try this out for yourself and see which work flow is best suited for you.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the form to use a table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have looked at how to use F# Interactive and feed data to a form
    on the fly, we can extend the concept and use a table as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will add `DataGridView` to the form, with some styling added
    to it. The last lines of code will populate `DataGridView` with some sample data.
    It will finally look something like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extending the form to use a table](img/4623OS_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: DataGridView added to the form with sample data
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend the example and use code to set the column headers together with
    code to use a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will look something like the window in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extending the form to use a table](img/4623OS_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A formatted DataGridView using a collection as data source
  prefs: []
  type: TYPE_NORMAL
- en: Displaying financial data from Yahoo! Finance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will look at a bigger example application, where we will use the concepts
    introduced this far and extend the functionality to cover visualization of financial
    data. Here, we will download data from Yahoo! Finance and display the closing
    prices together with a calculated moving average in the same chart window. The
    application will finally look something like the one in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying financial data from Yahoo! Finance](img/4623OS_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An example application to visualize data form Yahoo! Finance
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the application code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application will use some code introduced in previous sections, as well
    as in previous chapters. If you don''t recognize any of the content, please go
    back and refresh on that particular topic. The main building block here is `Systems.Windows.Forms`
    and `System.Windows.Forms.DataVisualization.Charting`. A lot more information
    is available online at MSDN: [http://msdn.microsoft.com/en-us/library/system.windows.forms.datavisualization.charting.aspx](http://msdn.microsoft.com/en-us/library/system.windows.forms.datavisualization.charting.aspx).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the code needed to provide the preceding functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll first create a chart and initialize it by setting `style` and `ChartAreas`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the form is created and displayed. After that, the title of the program
    is set and the chart control is added to the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, there is some code to create the two charting series needed and some
    style is set to the two charting series to distinguish them from each other. The
    stock price series will be red, and the moving average will be blue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, the code for the fetching of data is the same as we used in the previous
    chapter, [Chapter 3](ch03.html "Chapter 3. Financial Mathematics and Numerical
    Analysis"), *Financial Mathematics and Numerical Analysis*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The interesting part here is how data is added to the chart. This is done by
    iterating the time series and using the `series.Points.Add` method. It's an elegant
    and concise way of doing it. The `ignore` operator is used to simply skip the
    resulting value from the `Points.Add` method, ignoring it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Extending the application to use Bollinger bands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll now extend the application we used in the previous section to use Bollinger
    bands. Bollinger bands is an extension of moving average, where two bands are
    added—one upper band and one lower band. The bands are typically K (where K=2.0)
    times a moving standard deviation above and below the moving average. We need
    to add a function to calculate the moving standard deviation. We can use the standard
    deviation from the previous chapter and use it with the `Seq.windowed` function,
    as shown in the following code. In this example, we also add legends to specify
    which data series corresponds to which color. The screenshot is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extending the application to use Bollinger bands](img/4623OS_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Example application extended to use Bollinger Bands
  prefs: []
  type: TYPE_NORMAL
- en: 'The code looks pretty much like the code used in the preceding example; except
    for the calculation of the upper and lower band, and the moving standard deviation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Legends are easily added to a chart using `chart.Legends.Add`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll need two new data series for our upper and lower bands respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The code to calculate the moving standard deviation is a modification of the
    code used in the previous chapter, to work with the `Seq.windowed` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This section is pretty interesting. Here, we add and subtract the result from
    the moving standard deviation to the moving average, which is multiplied with
    the K-value to form the upper and lower band:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can extend this application and implement other technical indicators if
    you like. The nice thing about using F# Interactive is that the application itself
    doesn't have to be restarted to show new data. In other words, you can use `movingAvg.Points.Add`
    and the point will be added to the chart.
  prefs: []
  type: TYPE_NORMAL
- en: Using FSharp.Charting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**FsChart** is a commonly used F# chart library implemented as a functional
    wrapper over the Microsoft Chart Control. This control can save you some work
    because there is no need for boilerplate code as in the preceding examples for
    Microsoft Chart Control. FsChart is also designed to work with F# and integrate
    better with F# Interactive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The library can be installed using the Package Manager Console by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Creating a candlestick chart from stock prices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the code for displaying a candlestick chart of the same stock
    as used before (Oracle) with data from Yahoo! Finance. This time there is less
    boilerplate code needed to set up the charting. The main part of the program consists
    of downloading, parsing, and converting the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To use `FSharpCharting`, first we need to set up the chart as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We need to reorder the data from open, high, low close to high, low, and open
    close. This is done when we parse the strings to floating point numbers. Also,
    we include the date as the first value. The date will be used by `FSharpCharts`
    to order the candles.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The data will be downloaded, parsed, and displayed in the chart and the final
    result will look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a candlestick chart from stock prices](img/4623OS_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using FSharpCharts to display a candlestick chart
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bar chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll learn how to plot a histogram of a distribution generated
    by Math.NET. Histograms are useful to visualize statistical data and get a grip
    of their properties. We'll use a simple normal distribution with a zero mean and
    a standard deviation of one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we''ll create the normal distribution that will be used in the histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, Math.NET and FSharpCharting is not compatible out of the box.
    We need to convert the histogram from Math.NET to use it with the `Chart.Column`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the following screenshot, the distribution looks a lot like
    the normal distribution. You can experiment with the number of buckets yourself
    to see how this behavior will change with the number of buckets. Also, you can
    increase the number of samples used.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a bar chart](img/4623OS_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using FSharpCharts to display a histogram
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at data visualization in F# and learned to build
    user interfaces. We have looked at how to use F# to create user interfaces without
    a visual designer. There are pros and cons of using this approach of course. The
    main benefit is total control and there is no hidden magic. On the other side,
    it can be time consuming when we talk about larger GUI applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll use the data visualization tools introduced in this
    chapter to study some interesting properties of options. We'll talk about the
    basics of the options and how they are priced using the Black Scholes formula.
    Also, the Black Scholes formula will be implemented in F# and discussed in detail.
  prefs: []
  type: TYPE_NORMAL
