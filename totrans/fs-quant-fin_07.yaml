- en: Chapter 7. Getting Started with Order Types and Market Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：开始使用订单类型和市场数据
- en: In this chapter you will learn how to model order types and market data and
    various types of feeds in F#.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在F#中建模订单类型、市场数据以及各种类型的市场数据源。
- en: 'In this chapter you will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: Modeling Order Types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单类型建模
- en: Modeling Market data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 市场数据建模
- en: Implementing simple pretrade risk analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现简单的交易前风险分析
- en: Using function composition and currying
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数组合和柯里化
- en: Introducing orders
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍订单
- en: Typically, orders are instructions from the buyer's side to the seller's side
    regarding how to buy and sell financial instruments. These orders are standardized
    to some extent. In most situations, the orders and order types are determined
    by the broker used and the exchange.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，订单是买方给卖方关于如何买卖金融工具的指令。这些订单在一定程度上是标准化的。在大多数情况下，订单和订单类型由所使用的经纪商和交易所决定。
- en: Order types
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订单类型
- en: Order types are the types of orders that are found in trading systems and on
    exchanges in general. Often you look at market orders, limit orders, and conditional
    orders. In the conditional orders category, we have stop-orders and other orders
    with special conditions for execution.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 订单类型是交易系统和交易所中常见的订单种类。通常你会遇到市场订单、限价单和条件单。在条件单类别中，我们有止损单和其他具有特定执行条件的订单。
- en: 'Other types exist as well, but they are considered to be synthetic orders because
    they are combinations of the types previously described. Order types can be one
    of the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类型的订单，但它们被认为是合成订单，因为它们是前面所述订单类型的组合。订单类型可以是以下几种之一：
- en: Market order
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 市场订单
- en: Limit order
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限价单
- en: Conditional and stop-orders
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件单和止损单
- en: Market orders
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 市场订单
- en: Market orders are orders to be executed at the current market price on an exchange.
    These orders will accept the current bid/ask (top of book) price for the particular
    instrument. Furthermore, market orders are the simplest of the order types presented
    here. Due to the uncertainty in the price for which the order will be executed,
    market orders are not used where a more sophisticated risk profile is maintained.
    This means that their uses are quite limited in reality.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 市场订单是以当前市场价格在交易所执行的订单。这些订单将接受特定金融工具的当前买卖价格（即订单簿顶端价格）。此外，市场订单是此处展示的最简单的订单类型。由于执行价格的不确定性，市场订单不适用于需要更复杂风险管理的情况。这意味着它们在现实中的应用是相对有限的。
- en: Limit orders
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限价单
- en: Limit orders are the most commonly used order type. They are, as the name suggests,
    limited to a fixed price. This means that the order has a limit price for which
    they will be executed. For buy orders, this means that there is a limit, and they
    are bounded above the limit price. All prices below this limit will be accepted
    for buy orders. For sell orders, the opposite holds; there is a lower limit and
    the prices are bounded below. All prices above this limit will be accepted for
    sell orders.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 限价单是最常用的订单类型。顾名思义，它们是限定在一个固定价格范围内的订单。这意味着订单有一个限制价格，只有在该价格下，订单才会被执行。对于买单而言，这意味着存在一个上限，所有低于该限价的价格都会被接受。对于卖单，情况则相反，存在一个下限，所有高于该限价的价格都会被接受。
- en: Conditional and stop-orders
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件单和止损单
- en: Conditional orders, especially stop-orders, are orders that will be activated
    on the exchange on certain conditions. Stop-orders are activated when a certain
    price is touched by the order book (top of book). When this condition is met,
    the order will be converted into a market order. Certain stop-orders that will
    be converted into limit orders also exist.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 条件单，尤其是止损单，是在特定条件下会在交易所被激活的订单。止损单会在订单簿（即顶端订单）触及某一价格时被激活。当该条件满足时，订单将转换为市场订单。也存在一些在触发条件后会转为限价单的止损单。
- en: Order properties
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订单属性
- en: Order properties refer to the properties of an order describing what to do and
    under which conditions. The following table presents the most basic properties
    with descriptions and examples for each one.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 订单属性指的是描述订单应执行的操作及其条件的属性。下表展示了最基本的订单属性，并附有每个属性的描述和示例。
- en: '| Property | Description | Examples |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Order side | Whether the order is a buy or sell order with short sell orders
    included | Buy, Sell |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 订单方向 | 订单是买单还是卖单，包括卖空订单 | 买、卖 |'
- en: '| Order type | Type of the order | Market, Limit, and Stop |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 订单类型 | 订单种类 | 市场、限价和止损 |'
- en: '| Order status | The status for the order in the execution flow | Created,
    New, Filled, Canceled, and so on |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 订单状态 | 订单在执行流程中的状态 | Created, New, Filled, Canceled 等 |'
- en: '| Tif | Time in force; how long an order will remain active | GoodForDay, FillOrKill
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 有效时间 | 订单的有效时长 | GoodForDay, FillOrKill |'
- en: '| Quantity | Number of units to buy or sell of the specific instrument | 10,
    25, and 200 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 数量 | 要购买或出售的特定工具的数量 | 10, 25 和 200 |'
- en: '| Price | The limit price for the order | 26.50, 55.10 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 价格 | 订单的限价 | 26.50, 55.10 |'
- en: '| Instrument | The instrument to be used in the order | MSFT, GOOG, AAPL |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 工具 | 订单中使用的工具 | MSFT, GOOG, AAPL |'
- en: '| Stop price | The stop price used in the order | 26.50, 55.10 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 止损价格 | 订单中使用的止损价格 | 26.50, 55.10 |'
- en: '| Timestamp | The date and time when the order was created | 2013-09-14 11:30:44
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 时间戳 | 订单创建的日期和时间 | 2013-09-14 11:30:44 |'
- en: 'Next, we''ll continue the work we started out in [Chapter 2](ch02.html "Chapter 2. Learning
    More About F#"), *Learning More About F#,* and extend the order class and describe
    some properties as discriminated unions. First off, we will revisit the order
    side:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续在[第2章](ch02.html "第2章. 进一步了解 F#")中开始的工作，*进一步了解 F#*，并扩展订单类，描述一些作为区分联合的属性。首先，我们将重新审视订单的一方：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this context, the order side will have three alternatives; buy, sell, and
    sell short. Then we have the order type, which will either be buy, sell, stop,
    or stop limit. The stop limit is a stop order that will be converted into a limit
    order.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，订单方向将有三种选择：买入、卖出和卖空。然后是订单类型，可以是买入、卖出、止损或止损限价。止损限价是止损订单，随后会转为限价订单。
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Discriminated unions are elegant ways of describing data with different values.
    The values can be many, without losing the readability. Next, we have the order
    status:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 区分联合是描述具有不同值的数据的优雅方式。值可以有很多个，但不会失去可读性。接下来，我们来看订单状态：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are many values for the order status; they are from the FIX 4.2 specification
    and will be familiar to most of you who are familiar to FIX. They are here for
    illustrative purposes and will be used in the trading system. **Time in force**
    (**Tif**) has the most common alternatives used in trading:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 订单状态有很多值；它们来自 FIX 4.2 规范，熟悉 FIX 的大多数人都很了解这些值。它们在这里作为示例，将用于交易系统中。**有效时间** (**Tif**)
    是交易中最常用的选项：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We''ll introduce a new type here to be used along with the functionality introduced
    in this section. First, we will look at the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里引入一个新类型，与本节中介绍的功能一起使用。首先，我们将查看以下代码：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note the use of the `Result` in the preceding snippet; this is used so that
    we identify the outcome of the validation function(s), which we'll introduce later
    on. For now, you can think of them as a way of representing alternative return
    types.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前面代码片段中使用的`Result`；它用于标识验证函数的结果，我们将在后面介绍。现在，你可以把它们看作表示不同返回类型的方式。
- en: 'The following order class is an extension on the work we did in [Chapter 2](ch02.html
    "Chapter 2. Learning More About F#"), *Learning More About F#*. It''s implemented
    using some mutability, which is allowed in F# because it''s not a pure functional
    language in that sense. Mutability provides more flexibility and compromises for
    more pragmatic solutions. Here, we use private member fields and some new fields:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下订单类是对我们在[第2章](ch02.html "第2章. 进一步了解 F#")中工作内容的扩展。它使用了一些可变性，这在 F# 中是允许的，因为它不是纯粹的函数式语言。可变性提供了更多的灵活性，并为更务实的解决方案做出了妥协。这里，我们使用私有成员字段和一些新字段：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding method will toggle the side of the order, which is useful if we,for
    example, want to change the side of the order without creating a new one.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的方法将切换订单的一方，这在我们想要改变订单方向而不创建新订单时非常有用。
- en: 'The preceding class can be used in the same way as other classes in F#:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类可以像 F# 中的其他类一样使用：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The fields will be as follows, where the private fields are hidden and the
    property getter functions are the names of the fields:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 字段如下，其中私有字段是隐藏的，属性的 getter 函数对应字段的名称：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Suppose you want to validate an order for correctness and avoid simple mistakes.
    For example, if the order is a limit order, we can check whether the order has
    a price above zero. Furthermore, if the order is a stop order, the stop price
    has to be greater than zero, and so on. Let''s write a function to execute this
    order:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想验证一个订单的正确性并避免简单的错误。例如，如果订单是限价单，我们可以检查该订单的价格是否大于零。此外，如果订单是止损单，则止损价格必须大于零，依此类推。让我们编写一个函数来执行这个订单：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The function will take an order object wrapped in the order monad. This will
    become clear when we look at how to use it in the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将接受一个封装在订单单子（order monad）中的订单对象。当我们查看如何在以下代码中使用它时，这一点将变得更加明确：
- en: We can create some orders of various types and see if our validation function
    works.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以创建一些不同类型的订单，看看我们的验证函数是否有效。
- en: '[PRE9]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we will test our validation function for the preceding orders just created:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将测试我们为前面创建的订单编写的验证函数：
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s suppose we also want a validator to check whether the instrument is
    set for an order. We can then run these tests one by one. First, we need a function
    to do the validation:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们还想要一个验证器来检查订单是否设置了交易品种。然后我们可以逐个运行这些测试。首先，我们需要一个函数来进行验证：
- en: '[PRE11]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running this in F# Interactive will result in the following:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 F# Interactive 中运行此代码将得到以下结果：
- en: '[PRE12]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now we want to combine the two validators into one validator. This can be done
    in F# using function composition. Function composition, with the `>>` operator,
    lets you take two or more functions and combine them into one new function. You
    can look at function composition as a way of chaining functions together. This
    is useful when smaller building blocks are used and reused and supports modularity.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们希望将两个验证器合并为一个验证器。这可以通过 F# 的函数组合来实现。函数组合使用 `>>` 操作符，可以将两个或更多的函数组合成一个新的函数。你可以把函数组合看作是将函数链式连接的一种方式。这在使用和重用较小的构建块时非常有用，支持模块化。
- en: '[PRE13]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This function can now be used in the same way as the one we used previously:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以像我们之前使用的那个函数一样使用此函数：
- en: '[PRE14]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is a rather powerful way of combining functionality and can be useful in
    many situations. We'll come back to function composition later on when we look
    at pretrade risks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结合功能的一种非常强大的方式，在许多情况下都很有用。当我们稍后在处理交易前风险时，我们会再次讨论函数组合。
- en: Understanding order execution
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解订单执行
- en: Let's look at order execution and order flow for a moment. Order execution is
    where the orders are executed, typically at an exchange. For algorithmic trading,
    the buy side (trader) will often have their own order management system or order
    execution engine at the exchange, close to the exchange's trading servers. The
    orders at the exchange are typically limit orders; there are other types too.
    All other order types are considered to be synthetic orders or non-native orders.
    If you use a broker, you will never see this. But for high frequency trading,
    limit orders are considered to be the only native type. Market orders are simply
    limit orders with the current market price (from the top of book).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微看一下订单执行和订单流。订单执行是订单被执行的地方，通常是在交易所。对于算法交易，买方（交易员）通常会在交易所有自己的订单管理系统或订单执行引擎，靠近交易所的交易服务器。交易所的订单通常是限价单；当然也有其他类型。所有其他类型的订单都被视为合成订单或非原生订单。如果使用经纪商，你是看不到这些的。但对于高频交易而言，限价单被认为是唯一的原生订单类型。市价单实际上是以当前市场价格（来自订单簿顶部）设置的限价单。
- en: The following illustration shows a simple order flow between an order execution
    engine and the exchange. The order execution engine resides on the buy side and
    keeps track of the orders that are currently in and their status.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了订单执行引擎与交易所之间的简单订单流。订单执行引擎位于买方一侧，并跟踪当前存在的订单及其状态。
- en: '![Understanding order execution](img/4623OS_07_01.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![理解订单执行](img/4623OS_07_01.jpg)'
- en: Order execution flow and status updates for an order
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 订单执行流程和订单状态更新
- en: 'The order status of an order is represented by the discriminated union we have
    seen before:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 订单的状态由我们之前看到的区分联合体（discriminated union）表示：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The property will be updated for the order management system when an execution
    report is received for that particular order. First the order has the order status
    `Created` and then if it is accepted, it will have the order status `New`. Then,
    it will have any of the order statuses from the preceding `OrderStatus` object;
    for example `Filled`, `Expired`, `Rejected`, and so on.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到特定订单的执行报告时，订单管理系统中的属性将会更新。首先，订单的状态是`Created`，然后如果被接受，它将具有订单状态`New`。接下来，它将具有来自前一个`OrderStatus`对象中的任何订单状态；例如`Filled`、`Expired`、`Rejected`等。
- en: Introducing market data
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入市场数据
- en: Market data is the data representing the current bid/ask for a financial instrument
    at an exchange. The market data can either be the top of book, best bid/ask for
    the particular instrument, or an aggregated book with several levels of depth.
    Normally, we just look at the best bid/ask prices, top of book called quotes.
    Market data can also be sent as OHLC bars or candles. Such bars are only useful
    for visualizing price information in charts or for trading at a longer horizon.
    It is a simple way of filtering the price information. The midpoint is defined
    as the average between the bid and ask.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 市场数据是表示某个金融工具在交易所当前买卖报价的数据。市场数据可以是该工具的顶级报价、最优买/卖报价，或是包含多个深度层级的汇总书。通常，我们只查看最佳买卖报价，称为“报价”。市场数据也可以作为OHLC条形图或蜡烛图发送。这些条形图仅用于在图表中可视化价格信息或在较长时间跨度的交易中使用。这是一种简单的价格信息筛选方式。中点定义为买价和卖价的平均值。
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s see how to use this type:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这个类型：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can calculate the midpoint as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式计算中点：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can extend the `Quote` type to have a built-in function to calculate the
    spread for that quote:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展`Quote`类型，添加一个内置函数来计算该报价的价差：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Sometimes, in real systems, the bid and ask are not sent in the same object
    because updates to them will not occur simultaneously. Then, it''s preferable
    to separate them:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在实际系统中，买价和卖价不会在同一个对象中发送，因为它们的更新不会同时发生。此时，最好将它们分开：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Implementing simple pretrade risk analysis
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现简单的交易前风险分析
- en: In this section, we'll briefly cover pretrade risks for a simple trading system.
    Pretrade risks are everything that are considered to be risks and analyzed before
    the order is sent to the exchange. Typically, this is done in the trading engine
    or order execution engine or order management system. Here we'll consider basic
    pretrade risk measurements, such as order size and maximum distance for limit
    prices (that is values that tend to be high/low from the current market price).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍一个简单交易系统的交易前风险。交易前风险是指在订单发送到交易所之前，所有被认为是风险的内容并进行分析的部分。通常，这些操作在交易引擎、订单执行引擎或订单管理系统中完成。在这里，我们将考虑一些基本的交易前风险衡量标准，例如订单大小和限价的最大距离（即相对于当前市场价格可能出现的高/低值）。
- en: 'The following are the examples of pretrade risk rules:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交易前风险规则的示例：
- en: Limit the order price distance from the current market price
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制订单价格与当前市场价格的距离
- en: The maximum order value
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大订单价值
- en: Total exposure
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总风险敞口
- en: Number of orders sent per time unit
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每单位时间发送的订单数量
- en: Validating orders
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证订单
- en: Let's dive into some code and look at how pretrade risk can be implemented using
    functional programming and function composition. We'll look at two simple pretrade
    risk rules. The first one is for the total order value and the other one is for
    checking if the limit price is set on the favorable side of the current market
    price. This can be useful for manual trading, for example.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入一些代码，看看如何使用函数式编程和函数组合来实现交易前风险控制。我们将查看两个简单的交易前风险规则。第一个规则是针对总订单价值的，另一个规则是检查限价是否设定在当前市场价格的有利一侧。例如，这对于手动交易可能非常有用。
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The next rule we will use is `currying`, which is a concept we talked about
    in [Chapter 2](ch02.html "Chapter 2. Learning More About F#"), *Learning More
    About F#*. Currying is a way of calling a function where parts of the functions
    arguments are saved to be specified later. The following is the second rule for
    our pretrade risk analysis:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的下一个规则是`currying`，这是我们在[第2章](ch02.html "第2章. 深入学习 F#")，*深入学习 F#*中讨论过的一个概念。Currying是一种调用函数的方式，它将函数的部分参数保存起来，稍后再指定。以下是我们用于交易前风险分析的第二个规则：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will now use function composition, as before, and create new rules from
    existing ones:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将像以前一样使用函数组合，从现有的规则中创建新规则：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This pattern can quickly become quite impractical. However, there is an elegant
    technique to be used where we first specify the functions in a list and then use
    `List.reduce` and the composite operator to create a new composition:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式可能会迅速变得不太实用。然而，有一个优雅的技巧可以使用，我们首先在一个列表中指定函数，然后使用`List.reduce`和组合运算符来创建一个新的组合：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Introducing FIX and QuickFIX/N
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍FIX和QuickFIX/N
- en: In this section we'll learn about the FIX 4.2 standard and the QuickFIX/N library
    for .NET. FIX is the standard protocol of communicating with brokers and exchanges
    and stands for **Financial Information eXchange**. It has been around since the
    early 90s and uses an ASCII-based representation of messages. Other alternatives
    exist, such as proprietary APIs and protocols.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将了解FIX 4.2标准以及用于.NET的QuickFIX/N库。FIX是与经纪商和交易所通信的标准协议，代表**金融信息交换**（Financial
    Information eXchange）。它自90年代初以来就存在，使用基于ASCII的消息表示方式。还有其他替代方案，例如专有的API和协议。
- en: Using FIX 4.2
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FIX 4.2
- en: In this section we'll refactor the existing trading system in order to use FIX
    4.2 messages.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将重构现有的交易系统，以便使用FIX 4.2消息。
- en: Download FIXimulator from the following URL:[http://fiximulator.org/](http://fiximulator.org/)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下网址下载FIXimulator：[http://fiximulator.org/](http://fiximulator.org/)
- en: 'Download QuckFIX/n from the following URL: [http://www.quickfixn.org/download](http://www.quickfixn.org/download).'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下网址下载QuickFIX/n：[http://www.quickfixn.org/download](http://www.quickfixn.org/download)。
- en: Extract the files from the archives into folders.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从压缩包中提取文件到文件夹中。
- en: Start FIXimulator by running `fiximulator.bat`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`fiximulator.bat`启动FIXimulator。
- en: When you have started FIXimulator, it will look like the following figure. At
    the bottom of the application, there is a status bar with indicators. The leftmost
    indicator is for the client connection status. The first step is to make a successful
    connection to the simulator.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动FIXimulator时，应用程序将显示如下图所示。在应用程序底部有一个状态栏，显示指示器。最左侧的指示器是客户端连接状态。第一步是成功连接到模拟器。
- en: Configuring QuickFIX to use the simulator
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置QuickFIX以使用模拟器
- en: 'To be able to connect to the FIXimulator, you need a proper configuration file,
    `config.cfg`, in the classpath of the project as well as the correct path in the
    `SessionSettings` constructor in the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够连接到FIXimulator，你需要一个合适的配置文件`config.cfg`，它应放在项目的类路径中，并且在以下代码中的`SessionSettings`构造函数里有正确的路径：
- en: 'The contents of `config.cfg` are:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`config.cfg`的内容如下：'
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You have to change the value of the `SocketConnectHost` field to suit your setup,
    and this will be your local IP address if you run the simulator on the same machine.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须更改`SocketConnectHost`字段的值以适应你的设置，如果你在同一台机器上运行模拟器，那么这将是你的本地IP地址。
- en: There is also a configuration file for the simulator, namely `FIXimulator.cfg`,
    where the value of `TargetCompID` has to be changed to `TRADINGSYSTEM`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器还有一个配置文件，即`FIXimulator.cfg`，其中`TargetCompID`的值必须更改为`TRADINGSYSTEM`。
- en: '![Configuring QuickFIX to use the simulator](img/4623OS_07_02.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![配置QuickFIX以使用模拟器](img/4623OS_07_02.jpg)'
- en: No client is connected
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 没有客户端连接
- en: On the client side, in our program, we'll use the QuickFIX library and implement
    the methods needed in order to connect to the simulator. Add the following code
    to a new file `FIX.fs`. We'll use this in the final project, so it's recommended
    to work from the TradingSystem project while doing this project, which will start
    in the next chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们将在程序中使用QuickFIX库并实现所需的方法，以便连接到模拟器。将以下代码添加到新文件`FIX.fs`中。我们将在最终项目中使用这个代码，因此建议在完成这个项目时，从TradingSystem项目开始，这个项目将在下一章开始。
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To use QuickFIX, a number of interfaces have to be implemented. The `ClientInitiator
    function` is where the messages will be handled:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用QuickFIX，必须实现多个接口。`ClientInitiator`函数是消息处理的地方：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `ConsoleLog` function is another interface needed to support logging.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConsoleLog`函数是另一个需要支持日志记录的接口。'
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Finally, we have `FIXEngine` itself. This is the interface provided to the other
    parts of the system. It provides methods to start, stop, and send orders.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`FIXEngine`本身。这是提供给系统其他部分的接口。它提供了启动、停止和发送订单的方法。
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now we can try the preceding code using F# Interactive, and we will be connected
    to the simulator. The client connection status in the **FIXimulator** window will
    now be green if everything worked out successfully.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用F# Interactive尝试前面的代码，并且我们将成功连接到模拟器。如果一切顺利，**FIXimulator**窗口中的客户端连接状态将变为绿色。
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![Configuring QuickFIX to use the simulator](img/4623OS_07_03.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![配置 QuickFIX 使用模拟器](img/4623OS_07_03.jpg)'
- en: The client connection status is green when the client is connected
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端连接时，客户端连接状态为绿色
- en: 'Let''s make things more interesting and try out some code to send an order
    to the simulator. As previously mentioned, orders have various properties. The
    fields in our `Order` object are supposed to mimic the FIX 4.2 fields as closely
    as possible. We''ll first try out the QuickFIX representation or orders, and send
    a limit order to the simulator to see if everything works as expected. To do this,
    we''ll add a method to `FIXEngine`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们增加些趣味，尝试一些代码将订单发送到模拟器。如前所述，订单有各种属性。我们`Order`对象中的字段应该尽可能贴近 FIX 4.2 字段。我们首先尝试使用
    QuickFIX 来表示订单，并向模拟器发送一个限价订单，看看一切是否按预期工作。为此，我们将向 `FIXEngine` 添加一个方法：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This method will just be used for testing purposes and it is useful to have
    a working reference when we later add support to translate our internal Order
    object into the representation used by QuickFIX. You have to restart the F# Interactive
    session to see the changes in `FIXEngine` that we did earlier. Run the following
    code, and you''ll hopefully have sent your first order to the simulator:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将仅用于测试目的，在我们稍后添加支持将内部 `Order` 对象转换为 QuickFIX 使用的表示时，它会作为一个有效的参考。你需要重新启动
    F# Interactive 会话，以便看到我们之前对 `FIXEngine` 所做的更改。运行以下代码，希望你能将第一个订单发送到模拟器：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![Configuring QuickFIX to use the simulator](img/4623OS_07_04.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![配置 QuickFIX 使用模拟器](img/4623OS_07_04.jpg)'
- en: The client connection status is green when the client is connected
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端连接时，客户端连接状态为绿色
- en: Let's stay in **FIXimulator** for a moment and see what useful functionality
    we got.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在**FIXimulator**中再待一会儿，看看我们得到了哪些有用的功能。
- en: 'You can select the **Orders** tab in the simulator and you will have a new
    view, as shown in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在模拟器中选择**订单**标签页，接着你会看到一个新的视图，如下图所示：
- en: '![Configuring QuickFIX to use the simulator](img/4623OS_07_05.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![配置 QuickFIX 使用模拟器](img/4623OS_07_05.jpg)'
- en: Investigating the order properties from incoming orders
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 调查来自进单的订单属性
- en: 'The `SenderCompID` field corresponds to the actual sender of the order, which
    is the `TradingSystem`. We can also see the other properties of the order. Inside
    the simulator, you have several alternatives for each order, for example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`SenderCompID` 字段对应的是订单的实际发送者，即`TradingSystem`。我们还可以看到订单的其他属性。在模拟器中，每个订单都有多个选择，例如：'
- en: Acknowledged
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已确认
- en: Canceled
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已取消
- en: Rejected
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被拒绝
- en: Executed
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已执行
- en: We need some support for keeping track of the orders in our system and to change
    their state depending on the messages received from the counterpart (simulator);
    this is done by using the `ClientInitiator` function. Here we have the method
    called `FromApp`, which is a method to handle incoming messages; for example,
    modify the state of the orders in the system. The message to listen to, in the
    case of order execution management, is `ExecutionReport`. It is exactly what the
    name suggests, a report of execution. First we'll implement the code to just print
    out the status from the last order execution in the simulator. Then we'll use
    the simulator to test it out.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些支持来跟踪系统中的订单，并根据从对方（模拟器）接收到的消息改变它们的状态；这通过使用 `ClientInitiator` 函数来实现。这里有一个名为
    `FromApp` 的方法，用来处理传入的消息；例如，修改系统中订单的状态。在订单执行管理的情况下，监听的消息是 `ExecutionReport`。顾名思义，它是执行报告。首先，我们将实现代码，仅打印出模拟器中最后一次订单执行的状态。然后我们将使用模拟器进行测试。
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, we try to cast `msg` to an `ExecutionReport` instance
    and if that succeeds, we pattern match on the order status. Let's try this together
    with the simulator.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们尝试将 `msg` 强制转换为 `ExecutionReport` 实例，如果成功，我们会对订单状态进行模式匹配。让我们一起在模拟器中试试这个。
- en: Send a test order to the simulator using `fixEngine.sendTestLimitOrder()`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `fixEngine.sendTestLimitOrder()` 向模拟器发送测试订单。
- en: In **FIXimulator**, under **Orders**, select the received order.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**FIXimulator**中，选择**订单**下接收到的订单。
- en: Press the **Acknowledge** button.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**确认**按钮。
- en: 'F# Interactive will output the execution report, which will look something
    like:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: F# Interactive 将输出执行报告，内容大致如下：
- en: '[PRE34]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This means we have received an execution report, and the order status is now
    `New`.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着我们已收到执行报告，订单状态现在是`New`。
- en: Select the same order in the simulator and click on **Cancel**.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器中选择相同的订单并点击**取消**。
- en: '[PRE35]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We'll repeat the procedure, but this time we'll acknowledge and then execute
    the order in two steps, resulting in a `New`, `Partial fill`, and `Filled` execution
    report.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重复该过程，但这次我们将先确认订单，然后分两步执行，结果将产生 `New`、`Partial fill` 和 `Filled` 执行报告。
- en: Send a test order again.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次发送测试订单。
- en: Acknowledge the order.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认订单。
- en: Execute the order with LastShares=50 and LastPx=25.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行订单，LastShares=50 和 LastPx=25。
- en: Execute again with LastShares=50 and LastPx=24.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次执行，LastShares=50 和 LastPx=24。
- en: Watch the output in F# Interactive.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察 F# Interactive 中的输出。
- en: Note the order in which the execution reports arrive. First, we execute half
    the order resulting in a partial fill. Then, we execute the remaining 50, which
    will fill the order.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意执行报告到达的顺序。首先，我们执行了订单的一半，导致部分成交。然后，我们执行剩余的50份，完成整个订单。
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the simulator, we can see the value in the `AvgPx` column is 24.5\. This
    corresponds to the average price for the whole order. Next, we'll implement a
    lightweight order manager to keep track of all this for us.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器中，我们可以看到 `AvgPx` 列中的值为 24.5。这对应于整个订单的平均价格。接下来，我们将实现一个轻量级的订单管理器，帮助我们跟踪所有这些信息。
- en: 'Let''s look at the modified code for the `FromApp` callback function where
    we just altered the status of the order matching the order ID:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看修改后的 `FromApp` 回调函数代码，我们仅仅修改了与订单 ID 匹配的订单状态：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `orders` list is a `BindingList`, which is just a declaration we use for
    experimentation outside of the MVC model where it will be located in the final
    system.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`orders` 列表是一个 `BindingList`，这是我们在 MVC 模型之外用于实验的声明，最终系统中将会定位在该模型中。'
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `sendOrder` method is also modified slightly so that it can handle our
    Order objects and convert them to the QuickFIX representation:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendOrder` 方法也稍作修改，以便处理我们的订单对象并将其转换为 QuickFIX 表示形式：'
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We can now use the code elaborated so far to test out the simple order manager
    using the simulator. When the three orders are sent to the simulator, the output
    will look like the following screenshot. Select the first one and click on **Acknowledge**.
    We can now compare the contents of the orders list to see if the execution report
    is handled and if the order manager has done its job.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用迄今为止编写的代码，通过模拟器测试简单的订单管理器。当三笔订单发送到模拟器时，输出将如下截图所示。选择第一笔订单并点击 **确认**。现在我们可以比较订单列表的内容，查看执行报告是否已处理，以及订单管理器是否完成了任务。
- en: 'Here is the first `Order` in the `orders` list:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `orders` 列表中的第一笔 `Order`：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will be changed to the following if everything works out:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，这将更改为如下所示：
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![Configuring QuickFIX to use the simulator](img/4623OS_07_06.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![配置 QuickFIX 使用模拟器](img/4623OS_07_06.jpg)'
- en: Testing out the first version of our order manager
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 测试我们订单管理器的第一版
- en: The remaining part is to include support for partial fills, where we have open
    and executed quantities and the average price. This is the final part of the order
    manager to be elaborated. We'll also enhance the outputs from the `ClientInitiator`
    function to include these fields from the execution reports.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的部分是包括对部分成交的支持，其中我们有未完成和已执行的数量以及平均价格。这是订单管理器要完善的最后部分。我们还将增强 `ClientInitiator`
    函数的输出，以包含来自执行报告的这些字段。
- en: 'The following are the modifications done to the code to handle the order management
    part:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码进行的修改，用于处理订单管理部分：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To handle the status of `Filled`, we set the average price, the open quantity,
    and the executed quantity:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理 `Filled` 状态，我们设置了平均价格、未完成数量和已执行数量：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To handle the status of `PartiallyFilled`, we set the average price, the open
    quantity, and the executed quantity:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理 `PartiallyFilled` 状态，我们设置了平均价格、未完成数量和已执行数量：
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The remaining status updates are straightforward updates:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的状态更新是直接的更新：
- en: '[PRE45]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can test this out using the simulator, and a test run with partial fills,
    as before, results in the following content in the `orders` list:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过模拟器进行测试，像之前一样进行部分成交的测试运行，结果将导致 `orders` 列表中出现以下内容：
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![Configuring QuickFIX to use the simulator](img/4623OS_07_07.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![配置 QuickFIX 使用模拟器](img/4623OS_07_07.jpg)'
- en: The final iteration and testing of the order manager
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 订单管理器的最终迭代和测试
- en: The values will be presented in a data grid in the GUI for the trading system,
    which we'll start preparing in the next chapter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值将在交易系统的 GUI 数据网格中展示，我们将在下一章开始准备该部分。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we introduced several concepts regarding orders and market data.
    We also looked at how to model orders and market data in F# using some of the
    information available from the FIX 4.2 standard to guide us. It's good to have
    an overview of these facts while working with quantitative finance, especially
    when dealing with algorithmic trading.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了关于订单和市场数据的几个概念。我们还探讨了如何在 F# 中利用 FIX 4.2 标准中提供的一些信息来建模订单和市场数据。这些事实在从事量化金融工作时非常有用，特别是在处理算法交易时。
- en: The results from this chapter will be used when we start to set up the trading
    system, which we'll start doing in the next chapter. We'll also look at how to
    implement test cases for the validation code provided in this chapter.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的结果将在我们开始搭建交易系统时使用，搭建工作将在下一章开始。我们还将探讨如何为本章中提供的验证代码实现测试用例。
