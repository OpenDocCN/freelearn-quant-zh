- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technical Analysis and Building Interactive Dashboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover the basics of **technical analysis** (**TA**)
    in Python. In short, TA is a methodology for determining (forecasting) the future
    direction of asset prices and identifying investment opportunities based on studying
    past market data (especially the prices themselves and the traded volume).
  prefs: []
  type: TYPE_NORMAL
- en: We begin by showing how to calculate some of the most popular TA indicators
    (with hints on how to calculate others using selected Python libraries). Additionally,
    we show how to download precalculated technical indicators from reliable financial
    data vendors. We also touch upon a subfield of TA—candlestick pattern recognition.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we demonstrate how to create a web app, which enables
    us to visualize and inspect the predefined TA indicators in an interactive fashion.
    Then, we deploy this app to the cloud, to make it accessible for anyone from anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we present the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the most popular technical indicators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading the technical indicators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognizing candlestick patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an interactive web app for technical analysis using Streamlit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the technical analysis app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the most popular technical indicators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are hundreds of different technical indicators that traders use for making
    decisions on whether to enter or exit a position. In this recipe, we will learn
    how to easily calculate a few of those indicators using the `TA-Lib` library,
    which is the most popular library for such a task. We start with a brief introduction
    of a few of the selected indicators.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bollinger bands** are a statistical method, used for deriving information
    about the prices and volatility of a certain asset over time. To obtain the Bollinger
    bands, we need to calculate the moving average and standard deviation of the time
    series (prices), using a specified window (typically, 20 days). Then, we set the
    upper/lower bands at *K* times (typically, 2) the moving standard deviation above/below
    the moving average. The interpretation of the bands is quite simple: the bands
    widen with an increase in volatility and contract with a decrease in volatility.'
  prefs: []
  type: TYPE_NORMAL
- en: The default setting of using 2 standard deviations for the bands is connected
    to the (empirically incorrect) assumption about the normality of returns. Under
    the Gaussian distribution, we would assume that when using 2 standard deviations,
    95% of returns would fall within the bands.
  prefs: []
  type: TYPE_NORMAL
- en: The **relative strength index** (**RSI**) is an indicator that uses the closing
    prices of an asset to identify oversold/overbought conditions. Most commonly,
    the RSI is calculated using a 14-day period and is measured on a scale from 0
    to 100 (it is an oscillator). Traders usually buy an asset when it is oversold
    (if the RSI is below 30) and sell when it is overbought (if the RSI is above 70).
    More extreme high/low levels, such as 80–20, are used less frequently and, at
    the same time, imply stronger momentum.
  prefs: []
  type: TYPE_NORMAL
- en: The last considered indicator is the **moving average convergence divergence**
    (**MACD**). It is a momentum indicator showing the relationship between two exponential
    moving averages (EMA) of a given asset’s price, most commonly 26- and 12-day ones.
    The MACD line is the difference between the fast (short period) and slow (long
    period) EMAs. Lastly, we calculate the MACD signal line as a 9-day EMA of the
    MACD line. Traders can use the crossover of the lines as a trading signal. For
    example, it can be considered a buy signal when the MACD line crosses the signal
    line from below.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, most of the indicators are not used in isolation and traders look
    at multiple signals before making a decision. Also, all of the indicators can
    be tuned further (by changing their parameters) depending on the specific goal.
    We will cover backtesting trading strategies based on technical indicators in
    another chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following steps to calculate some of the most popular technical
    indicators using IBM’s stock prices from 2020:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`TA-Lib` is not like most Python libraries and it has a bit of a different
    installation process. For more information on how to do it, please refer to the
    GitHub repository provided in the *See also* section.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Download IBM’s stock prices from 2020:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate and plot the Simple Moving Average (SMA):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the snippet generates the following plot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../Images/B18112_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: IBM’s close price and the 20-day SMA'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate and plot the Bollinger bands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the snippet generates the following plot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../Images/B18112_05_02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.2: IBM’s close price and the Bollinger bands'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Calculate and plot the RSI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the snippet generates the following plot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../Images/B18112_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: The RSI calculated using IBM’s close prices'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate and plot the MACD:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the snippet generates the following plot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../Images/B18112_05_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: The MACD calculated using IBM’s close prices'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have calculated the technical indicators and plotted them. In the
    next chapters, we will spend more time on their implications and building trading
    strategies on their basis.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After importing the libraries, we downloaded IBM’s stock prices from 2020.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 3*, we calculated the 20-day simple moving average using the `SMA`
    function. Naturally, we could have calculated the same indicator using the `rolling`
    method of a `pandas` DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 4*, we calculated the Bollinger bands. The `BBANDS` function returns
    three objects (the upper and lower thresholds and the moving average), which we
    assigned to different columns of our DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we calculated the RSI using the default settings. We plotted
    the indicator, together with two horizontal lines (created using `ax.hlines`)
    indicating the popular decision-making thresholds.
  prefs: []
  type: TYPE_NORMAL
- en: In the last step, we calculated the MACD, also using the default number of periods
    for the EMAs. The `MACD` function also returned three objects, the MACD, the signal
    line, and the MACD histogram, which is effectively the difference between the
    first two elements. We plotted them on separate plots, as is most commonly done
    on trading platforms.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TA-Lib` is a great library and the gold standard when it comes to calculating
    technical indicators. However, there are also alternative libraries out there,
    which are gaining traction. One of them is called `ta`. Compared to `TA-Lib`,
    which is a wrapper around a C++ library, `ta` is written using `pandas`, which
    makes exploring the code base much easier.'
  prefs: []
  type: TYPE_NORMAL
- en: While it does not offer as extensive functionalities as `TA-Lib`, one of its
    unique features is that it can calculate all of the available 30+ indicators in
    a single line of code. That can definitely be useful in situations in which we
    want to calculate a lot of potential features for a machine learning model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following steps to calculate 30+ technical indicators with a single
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Discard the previously calculated indicators and keep only the required columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate all the technical indicators available in the `ta` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The resulting DataFrame contains 88 columns, out of which 83 were added by the
    single function call.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Please find below links to repositories of `TA-Lib`, `ta`, and other interesting
    libraries useful for technical analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/mrjbq7/ta-lib](https://github.com/mrjbq7/ta-lib)—The GitHub
    repository of `TA-lib`. Please refer to this source for more details on installing
    the library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://ta-lib.org/](https://ta-lib.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/bukosabino/ta](https://github.com/bukosabino/ta)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/twopirllc/pandas-ta](https://github.com/twopirllc/pandas-ta)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/peerchemist/finta](https://github.com/peerchemist/finta)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading the technical indicators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already mentioned in *Chapter 1*, *Acquiring Financial Data*, that some
    data vendors not only provide historical stock prices but also offer a selection
    of the most popular technical indicators. In this recipe, we will show how to
    download the RSI indicator for IBM’s stock, which can be directly compared to
    the one we calculated in the previous recipe using the `TA-Lib` library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following steps to download the RSI calculated for IBM from Alpha
    Vantage:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instantiate the `TechIndicators` class and authenticate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Download the RSI for IBM’s stock:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Plot the downloaded RSI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the snippet generates the following plot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../Images/B18112_05_05.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.5: The RSI downloaded for IBM’s stock prices'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The downloaded DataFrame contains RSI values from November 1999 until the most
    recent date.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Explore the metadata object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By displaying the metadata object, we can see the following details of our
    request:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After importing the libraries, we instantiated the `TechIndicators` class, which
    can be used for downloading any of the available technical indicators (via the
    class’s methods). While doing so, we provided our API key and indicated that we
    would like to receive the output in the form of a `pandas` DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 3*, we downloaded the RSI for IBM’s stock using the `get_rsi` method.
    At this point, we specified we wanted to use the last 14 days for calculating
    the indicator.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind while downloading calculated indicators is the data
    vendors’ pricing policy. At the time of writing, the RSI endpoint of Alpha Vantage
    is a free one, while the MACD is a premium endpoint and requires purchasing a
    paid plan.
  prefs: []
  type: TYPE_NORMAL
- en: What can be a bit surprising is that we cannot specify the range of dates that
    we are interested in. We can clearly see this in *Step 4*, in which we can see
    data points going as far back as November 1999\. We also plotted the RSI line,
    just as we have done in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: In the last step, we explored the metadata of the request, which contains the
    RSI’s parameters, the stock symbol we requested, the latest refresh date, and
    which price series was used for calculating the indicator (in this case, the close
    price).
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alpha Vantage is not the only data vendor that is providing access to technical
    indicators. Another one is Intrinio. We demonstrate below how to download the
    MACD using its API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Authenticate using the personal API key and select the API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Request the MACD for IBM’s stock from 2020:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While using Intrinio, we can actually specify the period for which we would
    like to download the indicator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Convert the request’s output into a `pandas` DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Plot the MACD:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the snippet generates the following plot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../Images/B18112_05_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: The MACD downloaded for IBM’s stock prices'
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing candlestick patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have already covered some of the most popular technical
    indicators. Another field of technical analysis that can be used for making trading
    decisions is **candlestick pattern recognition**. Overall, there are hundreds
    of candlestick patterns that can be used for determining the price direction and
    momentum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to all approaches to technical analysis, we should have a few things
    in mind while using pattern recognition. First, the patterns are only informative
    within the limitations of the given chart (in a specified frequency: intraday,
    daily, weekly, and so on). Second, the patterns’ predictive potency decreases
    very quickly after a few (3–5) bars once the pattern has been completed. Third,
    in the modern electronic environment, many signals identified by analyzing candlestick
    patterns might not work reliably anymore. Some big players are also able to set
    up traps by creating fake candlestick patterns to be picked up by other market
    participants.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bulkowski (2021) divides the patterns into two categories, based on the expected
    outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: Reversal patterns—such patterns predict a change in the price’s direction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuation patterns—such patterns predict an extension in the current trend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we try to identify the **three line strike** pattern in hourly
    Bitcoin prices. That pattern belongs to the continuation group. Its bearish variant
    (identified in an overall bearish trend) is characterized by three bars, each
    one having a lower low than the previous one. The fourth bar of the pattern opens
    at the third candle’s low or even lower, but then reverses heavily and closes
    above the high of the first candle of the series.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following steps to identify the three line strike pattern in Bitcoin’s
    hourly candlesticks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Download Bitcoin’s hourly prices from the last 9 months:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Identify the three line strike pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Locate and plot the bearish pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![](../Images/B18112_05_07.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.7: The first five observations of the bearish three line strike pattern'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Executing the snippet returns the following plot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../Images/B18112_05_08.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.8: The identified bearish three line strike pattern'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Locate and plot the bullish pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![](../Images/B18112_05_09.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.9: The first five observations of the bullish three line strike pattern'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Executing the snippet returns the following plot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../Images/B18112_05_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.10: The identified bullish three line strike pattern'
  prefs: []
  type: TYPE_NORMAL
- en: We could use the identified patterns to create trading strategies. For example,
    a bearish three line strike usually signals a small pullback that will be followed
    by a continuation of the bearish trend.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After importing the libraries, we downloaded hourly Bitcoin prices from the
    last 3 months using the `yfinance` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Step 3*, we used the `TA-Lib` library to identify the three line strike
    pattern (with the `CDL3LINESTRIKE` function). We had to separately provide the
    OHLC prices as inputs for the function. We store the outputs of the function in
    a new column. For this function, there are three possible outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`100`—Indicates the bullish variant of the pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`—No pattern detected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-100`—Indicates the bearish variant of the pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The authors of the library warn that the user should consider the three line
    strike pattern to be significant when it appears in a trend in the same direction
    (this is not verified by the library).
  prefs: []
  type: TYPE_NORMAL
- en: Certain functions can have additional possible outputs. Some of them also have
    values of -200/200 (for example, for the Hikkake pattern), whenever there is some
    additional confirmation in the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 4*, we filtered the DataFrame for a bearish pattern. It has been identified
    six times and we chose the one from `2021-07-16 12:00:00`. Then, we plotted the
    pattern together with some neighboring candles.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 5*, we have repeated the same procedure, this time for a bullish pattern.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we wanted to use the identified patterns as features for a model/strategy,
    it might be worthwhile to try to identify all the possible patterns at once. We
    can do so by executing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get all available pattern names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Iterate over the list of patterns and try identifying them all:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inspect the summary statistics of the patterns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For brevity, we only present the top 10 rows of the returned DataFrame:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../Images/B18112_05_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.11: Summary statistics of the identified candlestick patterns'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that some patterns were never identified (the minimum and maximum
    of zero), while others had either one or two of the variants (bullish or bearish).
    In the notebook (available on GitHub), we have also looked into identifying the
    **evening star** pattern based on the outputs of this table.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://sourceforge.net/p/ta-lib/code/HEAD/tree/trunk/ta-lib/c/src/ta_func/](https://sourceforge.net/p/ta-lib/code/HEAD/tree/trunk/ta-lib/c/src/ta_func/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bulkowski, T. N. 2021 *Encyclopedia of Chart Patterns*. John Wiley & Sons, 2021.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an interactive web app for technical analysis using Streamlit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have already covered the basics of technical analysis, which
    can help traders make their decision. However, until now everything was quite
    static—we downloaded the data, calculated an indicator, plotted it, and if we
    wanted to change the asset or the range of dates, we had to repeat all the steps.
    What if there was a better and more interactive way to approach this challenge?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is exactly where Streamlit comes into play. Streamlit is an open source
    framework (and a company under the same name, similarly to Plotly) that allows
    us to build interactive web apps using only Python, all within minutes. Below
    you can find the highlights of Streamlit:'
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to learn and can generate results very quickly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is Python only; no frontend experience is required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows us to focus purely on the data/ML sides of the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use Streamlit’s hosting services for our apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will build an interactive app used for technical analysis.
    You will be able to select any of the constituents of the S&P 500 and carry out
    a simple analysis quickly and in an interactive way. What is more, you can easily
    expand the app to add more features such as different indicators and assets, or
    even embed backtesting of trading strategies within the app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is slightly different than the rest. The code of our app “lives”
    in a single Python script (`technical_analysis_app.py`), which has around a hundred
    lines of code. A very basic app can be much more concise, but we wanted to go
    over some of the most interesting features of Streamlit, even if they are not
    strictly necessary to make a basic app for technical analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In general, Streamlit executes code from top to bottom, which makes the explanation
    easier to fit into the structure used in this book. Thus, the steps in this recipe
    are not steps *per se*—they cannot/should not be executed on their own. Instead,
    they are a step-by-step walkthrough of all the components of the app. While building
    your own apps or expanding this one, you can freely change the order of the steps
    as you see fit (as long as they are aligned with Streamlit’s framework).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps are all located in the `technical_analysis_app.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function for downloading a list of S&P 500 constituents from Wikipedia:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function for downloading historical stock prices using `yfinance`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function for storing downloaded data as a CSV file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the part of the sidebar used for selecting the ticker and the dates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the part of the sidebar used for tuning the details of the technical
    analysis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the expander with parameters of the SMA:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the expander with parameters of the Bollinger bands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the expander with parameters of the RSI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Specify the title and additional text in the app’s main body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load the historical stock prices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the expander with a preview of the downloaded data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the candlestick chart with the selected TA indicators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the app, open the terminal, navigate to the directory in which the `technical_analysis_app.py`
    script is located, and run the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the code opens the Streamlit app in your default browser. The app’s
    default screen looks as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../Images/B18112_05_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: Our technical analysis app in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: The app is fully responsive to the inputs—anytime you change the inputs in the
    sidebar or the app’s main body, the displayed contents will adjust accordingly.
    Potentially, we could even take it a step further and connect our app to a broker
    via the broker’s API. This way, we could analyze the patterns in the app and create
    orders based on the outcome of our analyses.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned in the *Getting ready* section, this recipe is structured differently.
    The steps are in fact a sequence of elements that all define the app we built.
    Before diving into the details, the general structure of the app’s codebase is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Imports and setup (*step 1*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data loading functions (*steps 2–4*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sidebar (*steps 5–9*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App’s main body (*steps 10–13*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first step, we imported the required libraries. For the technical analysis
    part, we decided to use a library that can visualize a selection of technical
    indicators in as few lines of code as possible. That is why we decided to go with
    `cufflinks`, which was introduced in *Chapter 3*, *Visualizing Financial Time
    Series*. However, in case you need to calculate a wider range of indicators, you
    can use any other library and create the plots yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Step 2*, we defined a function for loading a list of S&P 500 constituents
    from Wikipedia. We used the `pd.read_html` to download the information from the
    table straight into a DataFrame. The function returns two elements: a list of
    valid tickers and a dictionary containing pairs of tickers and their corresponding
    companies’ names.'
  prefs: []
  type: TYPE_NORMAL
- en: You surely have noticed that we used a `@st.cache` decorator while defining
    the function. We will not go over a lot of details of decorators in general, but
    we will cover what this one does as it is very handy while building an app using
    Streamlit. The decorator indicates that the app should cache the previously fetched
    data for later use. So in case we refresh the page or the function is called again,
    the data will not be downloaded/processed again (unless some conditions occur).
    This way, we can greatly increase the web app’s responsiveness and lower the end
    user’s waiting time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind the scenes, Streamlit keeps track of the following information to determine
    if the data should be fetched again:'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameters that we provided while calling the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values of any external variables used in the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body of the called function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body of any function called inside of the cached function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, if this is the first time Streamlit sees a certain combination of
    those four elements, it will execute the function and store its output in a local
    cache. If it encounters the very same set of items the next time the function
    is called, it will skip executing it and return the cached output from the previous
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: '*Steps 3* and *4* contain very small functions. The first one is used to fetch
    the historical stock prices from Yahoo Finance using the `yfinance` library. The
    following step saves the output of a DataFrame into a CSV file, which is then
    encoded in UTF-8.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Step 5*, we started working on the app’s sidebar, which we use for storing
    the parameter configurations for the app. The first thing to notice is that all
    the elements that are meant to be located in the sidebar are called with `st.sidebar`
    (as opposed to just `st`, which we use when defining the main body’s elements
    and other functions). In this step, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We specified the header.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We downloaded the list of available tickers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created a drop-down selection box of the available tickers. We also provided
    additional formatting by passing the dictionary containing symbol-name pairs to
    the `format_func` argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We allowed the users to select the start and end dates for the analysis. Using
    `date_input` displays an interactive calendar from which the users can select
    a date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We accounted for invalid combinations of dates (start later than the end) by
    using an `if` statement together with `st.sidebar.error`. This will halt the app
    execution until the error is resolved, that is, until a proper input is provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The outcome of this step looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/B18112_05_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: Part of the sidebar where we can choose the ticket and start/end
    dates'
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 6*, we added another header to our sidebar and created a checkbox using
    `st.checkbox`. If checked, the assigned variable will hold a `True` value, `False`
    if unchecked.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Step 7*, we started with configuring the technical indicators. To keep
    the app clean, we used expanders (`st.expander`). Expanders are collapsible boxes,
    which we trigger to expand by pressing the plus icon. Inside, we stored two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A checkbox indicating whether we want to display the SMA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A numeric field in which we can specify the number of periods for the moving
    average. For that element, we used Streamlit’s `number_input` object. We provided
    the label, minimum/maximum values, the default value, and the step size (we can
    incrementally increase/decrease the value of the field by that number when we
    press the corresponding buttons).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When using expanders, we first instantiated one in the sidebar using `exp_sma
    = st.sidebar.expander("SMA")`. Then, when we wanted to add elements to the expander,
    for example, the checkbox, we used the following syntax: `sma_flag = exp_sma.checkbox(label="Add
    SMA")`. This way, it was added straight into the expander, not just the sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Steps 8* and *9* are very similar. We created two expanders for other technical
    indicators we wanted to include in the app – Bollinger bands and the RSI.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code from *Steps 7–9* generates the following part of the app’s sidebar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/B18112_05_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.14: Part of the sidebar where we can modify the parameters of the
    selected indicators'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we proceeded to define the app’s main body. In *Step 10*, we added the
    app’s title using `st.title` and added a user manual using `st.write`. When using
    the latter function, we can provide text input in a Markdown-formatted string.
    For this part, we used a subheader (indicated by `###`) and created a list of
    bullets indicated by `*`. For brevity, we did not include all the text in the
    book, but you can find it in the book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 11*, we downloaded the historical stock prices based on the inputs
    from the sidebar. What we could also have done here is download a full range of
    dates available for a given stock and only then use the sidebar’s start/end dates
    to filter out the periods of interest. By doing so, we would not have to redownload
    the data anytime we changed the start/end dates.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 12*, we defined another expander, this time in the app’s main body.
    First, we added a multiple selection field (`st.multiselect`) from which we can
    select any of the available columns from the downloaded historical prices. Then,
    we displayed the selected columns of the DataFrame for further inspection using
    `st.dataframe`. Lastly, we added the functionality to download the selected data
    (including the column selection) as a CSV file. For that, we used our `convert_df_to_csv`
    function, together with `st.download_button`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 12* is responsible for generating the following part of the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/B18112_05_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.15: Part of the app where we can inspect the DataFrame containing
    prices and download it as a CSV'
  prefs: []
  type: TYPE_NORMAL
- en: In the app’s last step, we defined the figure we wanted to display. Without
    any of the technical analysis inputs, the app will display a candlestick chart
    using `cufflinks`. We instantiated the `QuantFig` object and then added elements
    to it depending on the inputs from the sidebar. Each of the Boolean flags triggers
    a separate command that adds an element to the plot. To display the interactive
    figure, we used `st.plotly_chart`, which works with `plotly` figures (`cufflinks`
    is a wrapper on top of `plotly`).
  prefs: []
  type: TYPE_NORMAL
- en: For other visualization libraries, there are different commands to embed visualizations.
    For example, for `matplotlib`, we would use `st.pyplot`. We could also display
    plots created in Altair using `st.altair_chart`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first edition of the book, we covered a bit of a different approach to
    creating an interactive dashboard for technical analysis. Instead of Streamlit,
    we used `ipywidgets` to build the dashboard inside of a Jupyter notebook.
  prefs: []
  type: TYPE_NORMAL
- en: In general, Streamlit might be the better tool for this particular job, especially
    if we want to deploy the app (covered in the next recipe) and share it with others.
    However, `ipywidgets` can still be useful for other projects, which can live locally
    inside of a notebook. That is why you can find the code used for creating a very
    similar dashboard (within a notebook) in the accompanying GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://streamlit.io/](https://streamlit.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.streamlit.io/](https://docs.streamlit.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the technical analysis app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we created a full-fledged web app for technical analysis,
    which we can easily run and use locally. However, that is not always the goal,
    as we might want to access the app from anywhere or share it with our friends
    or colleagues. That is why the next step would be to deploy the app to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we show how to deploy the app using Streamlit’s (the company)
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To deploy the app to Streamlit Cloud, we need to create an account there ([https://forms.streamlit.io/community-sign-up](https://forms.streamlit.io/community-sign-up)).
    You will also need a GitHub account to host the code of the app.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following steps to deploy the Streamlit app to the cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: Host the code base of the app in a public repository on GitHub:![](../Images/B18112_05_16.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 5.16: The code base of the app hosted in a public GitHub repository'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this step, remember to host the entire code base of the app, which can naturally
    be spread out over multiple files. Also, please include some kind of a dependencies
    list. In our case, it is the `requirements.txt` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Go to [https://share.streamlit.io/](https://share.streamlit.io/) and log in.
    You might need to connect your GitHub account to your Streamlit account and authorize
    it to have certain types of access to your GitHub account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the *New app* button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provide the required details: the name of the repository in your profile, the
    branch, and the file containing the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/B18112_05_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.17: The information we have to provide to create the app'
  prefs: []
  type: TYPE_NORMAL
- en: Click *Deploy!*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you can go to the provided link to use the app.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first step, we hosted the app’s code in a public GitHub repository. If
    you are new to Git or GitHub, please refer to the link in the *See also* section
    for more information. At the time of writing, it is not possible to use other
    version control providers such as GitLab or BitBucket for hosting code of Streamlit
    apps. The bare minimum in terms of the files is the app’s script (in our case,
    `technical_analysis_app.py`) and some form of a list with requirements. The easiest
    one would be a simple `requirements.txt` text file containing all the libraries
    you would like to use in the app. If you are using a different dependency manager
    (`conda`, `pipenv`, or `poetry`), you need to provide their respective files.
  prefs: []
  type: TYPE_NORMAL
- en: If there are multiple libraries you would like to use in the app, the easiest
    way to create the requirements file containing them would be to run `pip freeze
    > requirements.txt` while having your virtual environment activated.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the next steps are quite intuitive, as Streamlit’s platform is very easy
    to navigate. What might be useful to mention is that in *Step 4*, we can also
    provide some more advanced settings. They include:'
  prefs: []
  type: TYPE_NORMAL
- en: The Python version that you would like the app to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Secrets field, in which you can store some environment variables and secrets,
    such as API keys. In general, it is against best practices to store usernames,
    API keys, and other secrets in public GitHub repositories. If your app is fetching
    data from some provider or your internal database, that is the field in which
    you can safely store the credentials, which will be then encrypted and served
    securely to your app at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we showed how to deploy our web app to the Streamlit Cloud.
    While being the simplest, it is not the only option. Another one would be to deploy
    the app to Heroku, which is a **Platform as a Service** (**PaaS**) type of platform
    that enables you to build, run, and operate applications entirely in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://www.heroku.com/](https://www.heroku.com/)—for more information about
    Heroku’s services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.streamlit.io/streamlit-cloud](https://docs.streamlit.io/streamlit-cloud)—for
    more details on how to deploy the app and what are the best practices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.github.com/en/get-started/quickstart/hello-world](https://docs.github.com/en/get-started/quickstart/hello-world)—a
    tutorial on how to use GitHub'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have learned about technical analysis. We started by calculating
    some of the most popular technical indicators (and downloading precalculated ones):
    the SMA, the RSI, and the MACD. We have also explored identifying patterns in
    candlesticks. Lastly, we learned how to create and deploy an interactive app for
    technical analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: In further chapters, we will put this knowledge into practice by creating and
    backtesting trading strategies based on the technical indicators we have already
    covered.
  prefs: []
  type: TYPE_NORMAL
