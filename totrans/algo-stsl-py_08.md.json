["```py\n# Import Libraries\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\n%matplotlib inline\nimport matplotlib.pyplot as plt \n```", "```py\ndef kelly(win_rate,avg_win,avg_loss):  \n    # Kelly = win% / abs(avg_loss%) - loss% / avg_win% \n    return win_rate / np.abs(avg_loss) - (1-win_rate) / avg_win \n```", "```py\ndef concave(ddr, floor):\n    '''\n    For demo purpose only\n    '''\n    if floor == 0:\n        concave = ddr\n    else:\n        concave = ddr ** (floor)\n    return concave\n\n# obtuse \ndef convex(ddr, floor):\n    '''\n    obtuse = 1 - acute\n    '''\n    if floor == 0:\n        convex = ddr\n    else:\n        convex = ddr ** (1/floor)\n    return convex\n\n# instantiate minimum Kapital \nfloor = np.arange(0,1,0.125)\n# print('floor', floor)\n\nx = -np.linspace(0, 1, 100)\n\nfig, ax = plt.subplots()\nfor i,f in enumerate(floor):\n    y = concave(ddr=-x, floor=f)\n    current_label = f' concave f = {f:.3}'\n    ax.plot(x, y, linewidth=2, alpha=0.6, label=current_label)\n\nax.legend()\nplt.ylabel('Concave Oscillator')\nplt.xlabel('Equity Curve From Trailing Trough To Peak')\nax.set_ylim(ax.get_ylim()[::-1])\nplt.show()\n\nfig, ax = plt.subplots()\nfor i,f in enumerate(floor):\n    y = convex(ddr=-x, floor=f)\n    current_label = f' convex f = {f*10:.3}'\n    ax.plot(x, y, linewidth=2, alpha=0.6, label=current_label)\nax.legend()\n\nplt.ylabel('Convex Oscillator')\nplt.xlabel('Equity Curve From Trailing Trough To Peak')\nax.set_ylim(ax.get_ylim()[::-1])\nplt.figure(figsize=(20,8))\nplt.show() \n```", "```py\nticker = '^GDAXI'\ndd_tolerance = -0.1\n\nequity = pd.DataFrame()\nstart = '2017-12-31'\nend = None\nequity['equity'] =  yf.download(tickers= ticker,start= start, end = end,\n                        interval = \"1d\",group_by = 'column',\n                        auto_adjust = True, prepost = True,\n                        treads = True, proxy = None)['Close']\n\nequity['peak_equity'] = equity['equity'].cummax()\nequity['tolerance'] = equity['peak_equity'] * (1 + dd_tolerance )\nequity['drawdown'] = equity['equity'] /equity['equity'].cummax() -1\n\nequity.plot(style = ['k','g-.','r-.','m:'] ,\n            secondary_y=['drawdown'], figsize=(20,8),grid=True)\nequity.columns \n```", "```py\ndef risk_appetite(eqty, tolerance, mn, mx, span, shape):\n    '''\n    eqty: equity curve series\n    tolerance: tolerance for drawdown (<0)\n    mn: min risk\n    mx: max risk\n    span: exponential moving average to smoothe the risk_appetite\n    shape: convex (>45 deg diagonal) = 1, concave (<diagonal) = -1, else: simple risk_appetite\n    '''\n    # drawdown rebased\n    eqty = pd.Series(eqty)\n    watermark = eqty.expanding().max() \n    # all-time-high peak equity\n    drawdown = eqty / watermark - 1 \n    # drawdown from peak\n    ddr = 1 - np.minimum(drawdown / tolerance,1) \n    # drawdown rebased to tolerance from 0 to 1\n    avg_ddr = ddr.ewm(span = span).mean() \n    # span rebased drawdown\n\n    # Shape of the curve\n    if shape == 1: # \n        _power = mx/mn # convex \n    elif shape == -1 :\n        _power = mn/mx # concave\n    else:\n        _power = 1 # raw, straight line\n    ddr_power = avg_ddr ** _power # ddr \n\n    # mn + adjusted delta\n    risk_appetite = mn + (mx - mn) * ddr_power \n\n    return risk_appetite \n```", "```py\neqty= equity['equity']\ntolerance= dd_tolerance\nmn= -0.0025 \nmx= -0.0075 \navg = (mn + mx)/2\nspan= 5 \nshape = 1\nequity['constant_risk'] = -equity['equity'] * avg\nequity['convex_risk'] = -risk_appetite(eqty, tolerance, mn, mx, span, shape=1) * equity['peak_equity'] \nequity['concave_risk'] = -risk_appetite(eqty, tolerance, mn, mx, span, shape=-1) * equity['peak_equity'] \n\nequity[['equity', 'peak_equity', 'tolerance',\n        'constant_risk','convex_risk','concave_risk']].plot(figsize= (20,8),grid=True,\n    secondary_y=['constant_risk','convex_risk','concave_risk'],\n    style= ['k','g-.','r-.','b:','y-.', 'orange'])\n\nequity[['drawdown','constant_risk','convex_risk','concave_risk']].plot(grid=True,\n    secondary_y=['drawdown'],style= ['m--','b:','y-.', 'orange'], figsize= (20,8) ) \n```", "```py\ndef regime_breakout(df,_h,_l,window):\n    hl =  np.where(df[_h] == df[_h].rolling(window).max(),1,\n                                np.where(df[_l] == df[_l].rolling(window).min(), -1,np.nan))\n    roll_hl = pd.Series(index= df.index, data= hl).fillna(method= 'ffill')\n    return roll_hl\n\ndef turtle_trader(df, _h, _l, slow, fast):\n#### removed for brevity: check GitHub repo for full code ####\n    return turtle\n# CHAPTER 8\n\nticker = '9984.T' # Softbank\nstart = '2017-12-31'\nend = None\ndf =  round(yf.download(tickers= ticker,start= start, end = end, \n                        interval = \"1d\",group_by = 'column',auto_adjust = True, \n                              prepost = True, treads = True, proxy = None),0)\n\nccy_ticker = 'USDJPY=X'\nccy_name = 'JPY'\nccy_df = np.nan\n\ndf[ccy_name] =  round(yf.download(tickers= ccy_ticker,start= start, end = end, \n                        interval = \"1d\",group_by = 'column',auto_adjust = True, \n                              prepost = True, treads = True, proxy = None)['Close'],2)\ndf[ccy_name] = df[ccy_name].fillna(method='ffill')\nslow = 50\nfast = 20 \ndf['tt'] = turtle_trader(df, _h= 'High', _l= 'Low', slow= slow,fast= fast)\ndf['tt_chg1D'] = df['Close'].diff() * df['tt'].shift()\ndf['tt_chg1D_fx'] = df['Close'].diff() * df['tt'].shift() / df[ccy_name]\n\ndf['tt_log_returns'] = np.log(df['Close'] / df['Close'].shift()) * df['tt'].shift()\ndf['tt_cumul_returns'] = df['tt_log_returns'].cumsum().apply(np.exp) - 1 \n\ndf['stop_loss'] = np.where(df['tt'] == 1, df['Low'].rolling(fast).min(),\n                    np.where(df['tt'] == -1, df['High'].rolling(fast).max(),np.nan))# / df[ccy_name]\ndf['tt_PL_cum'] = df['tt_chg1D'].cumsum()\ndf['tt_PL_cum_fx'] = df['tt_chg1D_fx'].cumsum()\n\ndf[['Close','stop_loss','tt','tt_cumul_returns']].plot(secondary_y=['tt','tt_cumul_returns'],\n                                  figsize=(20,10),style= ['k','r--','b:','b'],\n                       title= str(ticker)+' Close Price, Turtle L/S entries')\n\ndf[['tt_chg1D','tt_chg1D_fx']].plot(secondary_y=['tt_chg1D_fx'],\n                                  figsize=(20,10),style= ['b','c'],\n                                 title= str(ticker) +' Daily P&L Local & USD')\n\ndf[['tt_PL_cum','tt_PL_cum_fx']].plot(secondary_y=['tt_PL_cum_fx'],\n                                  figsize=(20,10),style= ['b','c'],\n                                 title= str(ticker) +' Cumulative P&L Local & USD') \n```", "```py\ndef eqty_risk_shares(px,sl,eqty,risk,fx,lot):\n    r = sl - px\n    if fx > 0:\n        budget = eqty * risk * fx\n    else:\n        budget = eqty * risk\n    shares = round(budget // (r *lot) * lot,0)\n#     print(r,budget,round(budget/r,0))\n    return shares\n\npx = 2000\nsl = 2222\n\neqty = 100000\nrisk = -0.005\nfx = 110\nlot = 100\n\neqty_risk_shares(px,sl,eqty,risk,fx,lot) \n```", "```py\n-300.0 \n```", "```py\nstarting_capital = 1000000\nlot = 100\nmn = -0.0025\nmx = -0.0075\navg = (mn + mx) / 2\ntolerance= -0.1\nequal_weight = 0.05\nshs_fxd = shs_ccv = shs_cvx = shs_eql = 0\ndf.loc[df.index[0],'constant'] = df.loc[df.index[0],'concave'] = starting_capital\ndf.loc[df.index[0],'convex'] = df.loc[df.index[0],'equal_weight'] = starting_capital\n\nfor i in range(1,len(df)):\n    df['equal_weight'].iat[i] = df['equal_weight'].iat[i-1] + df['tt_chg1D_fx'][i] * shs_eql\n    df['constant'].iat[i] = df['constant'].iat[i-1] + df['tt_chg1D_fx'][i] * shs_fxd\n    df['concave'].iat[i] = df['concave'].iat[i-1] + df['tt_chg1D_fx'][i] * shs_ccv\n    df['convex'].iat[i] = df['convex'].iat[i-1] + df['tt_chg1D_fx'][i] * shs_cvx\n\n    ccv = risk_appetite(eqty= df['concave'][:i], tolerance=tolerance, \n                        mn= mn, mx=mx, span=5, shape=-1)\n    cvx = risk_appetite(eqty= df['convex'][:i], tolerance=tolerance, \n                        mn= mn, mx=mx, span=5, shape=1)\n\n    if (df['tt'][i-1] ==0) & (df['tt'][i] !=0):\n        px = df['Close'][i]\n        sl = df['stop_loss'][i]\n        fx  = df[ccy_name][i]\n        shs_eql = (df['equal_weight'].iat[i]  * equal_weight  *fx//(px * lot)) * lot\n        if px != sl:\n            shs_fxd = eqty_risk_shares(px,sl,eqty= df['constant'].iat[i],\n                                        risk= avg,fx=fx,lot=100)\n            shs_ccv = eqty_risk_shares(px,sl,eqty= df['concave'].iat[i],\n                                            risk= ccv[-1],fx=fx,lot=100)\n            shs_cvx = eqty_risk_shares(px,sl,eqty= df['convex'].iat[i],\n                                            risk= cvx[-1],fx=fx,lot=100)\n\ndf[['constant','concave','convex','equal_weight', 'tt_PL_cum_fx']].plot(figsize = (20,10), grid=True,\n    style=['y.-','m--','g-.','b:', 'b'],secondary_y='tt_PL_cum_fx',\ntitle= 'cumulative P&L, concave, convex, constant equity at risk, equal weight ') \n```", "```py\ndef pyramid(position, root=2):\n    '''\n    position is the number of positions\n    power is root n. \n    Conservative = 1, aggressive = position, default = 2\n    '''\n    return 1 / (1+position) ** (1/root)\ndef amortized_weight(raw_weight, amortization):\n    '''\n    raw_weight is the initial position size\n    amortization is pyramid(position,root=2)\n    '''\n    return raw_weight * amortization\nweight = 0.05\nposition = np.arange(1,4)\nprint('position', position)\nprint('linear',pyramid(position, root=1)* weight)\nprint('square root',pyramid(position, root=2)* weight)\nprint('position n',pyramid(position, root=position)* weight) \n```", "```py\nposition [1 2 3]\nlinear [0.025      0.01666667 0.0125    ]\nsquare root [0.03535534 0.02886751 0.025     ]\nposition n [0.025      0.02886751 0.03149803] \n```"]