- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Portfolio Optimization and Performance Evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alpha factors generate signals that an algorithmic strategy translates into
    trades, which, in turn, produce long and short positions. The returns and risk
    of the resulting portfolio determine the success of the strategy.
  prefs: []
  type: TYPE_NORMAL
- en: To test a strategy prior to implementation under market conditions, we need
    to simulate the trades that the algorithm would make and verify their performance.
    Strategy evaluation includes backtesting against historical data to optimize the
    strategy's parameters and forward-testing to validate the in-sample performance
    against new, out-of-sample data. The goal is to avoid false discoveries from tailoring
    a strategy to specific past circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: In a portfolio context, positive asset returns can offset negative price movements.
    Positive price changes for one asset are more likely to offset losses on another,
    the lower the correlation between the two positions is. Based on how portfolio
    risk depends on the positions' covariance, Harry Markowitz developed the theory
    behind modern portfolio management based on diversification in 1952\. The result
    is mean-variance optimization, which selects weights for a given set of assets
    to minimize risk, measured as the standard deviation of returns for a given expected
    return.
  prefs: []
  type: TYPE_NORMAL
- en: The **capital asset pricing model** (**CAPM**) introduces a risk premium, measured
    as the expected return in excess of a risk-free investment, as an equilibrium
    reward for holding an asset. This reward compensates for the exposure to a single
    risk factor—the market—that is systematic as opposed to idiosyncratic to the asset
    and thus cannot be diversified away.
  prefs: []
  type: TYPE_NORMAL
- en: Risk management has evolved to become more sophisticated as additional risk
    factors and more granular choices for exposure have emerged. The Kelly criterion
    is a popular approach to dynamic portfolio optimization, which is the choice of
    a sequence of positions over time; it was famously adapted from its original application
    in gambling to the stock market by Edward Thorp in 1968.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, there are several approaches to optimize portfolios, including
    the application of **machine learning** (**ML**) to learn hierarchical relationships
    among assets, and to treat their holdings as complements or substitutes with respect
    to the portfolio risk profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to measure portfolio risk and return
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing portfolio weights using mean-variance optimization and alternatives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using machine learning to optimize asset allocation in a portfolio context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating trades and create a portfolio based on alpha factors using Zipline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to evaluate portfolio performance using pyfolio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code samples for this chapter and links to additional resources
    in the corresponding directory of the GitHub repository. The notebooks include
    color versions of the images..
  prefs: []
  type: TYPE_NORMAL
- en: How to measure portfolio performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To evaluate and compare different strategies or to improve an existing strategy,
    we need metrics that reflect their performance with respect to our objectives.
    In investment and trading, the most common objectives are the return and the risk
    of the investment portfolio.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, these metrics are compared to a benchmark that represents alternative
    investment opportunities, such as a summary of the investment universe like the
    S&P 500 for US equities or the risk-free interest rate for fixed income assets.
  prefs: []
  type: TYPE_NORMAL
- en: There are several metrics to evaluate these objectives. In this section, we
    will review the most common measures for comparing portfolio results. These measures
    will be useful when we look at different approaches to optimize portfolio performance,
    simulate the interaction of a strategy with the market using Zipline, and compute
    relevant performance metrics using the pyfolio library in later sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use some simple notation: let *R* be the time series of one-period simple
    portfolio returns, *R*=(*r*[1], ..., *r*[T]), from dates 1 to *T*, and *R*^f =(*r*^f[1],
    ..., *r*^f[T]) be the matching time series of risk-free rates, so that *R*[e]=*R*-*R*[f]
    =(*r*[1]-*r*^f[1],..., *r*[T]-*r*^f[T]) is the excess return.'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing risk-return trade-offs in a single number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The return and risk objectives imply a trade-off: taking more risk may yield
    higher returns in some circumstances, but also implies greater downside. To compare
    how different strategies navigate this trade-off, ratios that compute a measure
    of return per unit of risk are very popular. We''ll discuss the Sharpe ratio and
    the information ratio in turn.'
  prefs: []
  type: TYPE_NORMAL
- en: The Sharpe ratio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ex ante **Sharpe ratio** (**SR**) compares the portfolio''s expected excess
    return to the volatility of this excess return, measured by its standard deviation.
    It measures the compensation as the average excess return per unit of risk taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15439_05_001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Expected returns and volatilities are not observable, but can be estimated
    as follows from historical data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15439_05_002.png)'
  prefs: []
  type: TYPE_IMG
- en: Unless the risk-free rate is volatile (as in emerging markets), the standard
    deviation of excess and raw returns will be similar.
  prefs: []
  type: TYPE_NORMAL
- en: For **independently and identically distributed** (**IID**) returns, the distribution
    of the SR estimator for tests of statistical significance follows from the application
    of the **central limit theorem** (**CLT**), according to large-sample statistical
    theory, to ![](img/B15439_05_003.png) and ![](img/B15439_05_004.png). The CLT
    implies that sums of IID random variables like ![](img/B15439_05_003.png) and
    ![](img/B15439_05_006.png) converge to the normal distribution.
  prefs: []
  type: TYPE_NORMAL
- en: When you need to compare SR for different frequencies, say for monthly and annual
    data, you can multiply the higher frequency SR by the square root of the number
    of the corresponding period contained in the lower frequency. To convert a monthly
    SR into an annual SR, multiply by ![](img/B15439_05_007.png), and from daily to
    monthly multiply by ![](img/B15439_05_007.png).
  prefs: []
  type: TYPE_NORMAL
- en: However, financial returns often violate the IID assumption. Andrew Lo has derived
    the necessary adjustments to the distribution and the time aggregation for returns
    that are stationary but autocorrelated. This is important because the time-series
    properties of investment strategies (for example, mean reversion, momentum, and
    other forms of serial correlation) can have a non-trivial impact on the SR estimator
    itself, especially when annualizing the SR from higher-frequency data (Lo, 2002).
  prefs: []
  type: TYPE_NORMAL
- en: The information ratio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **information ratio** (**IR**) is similar to the Sharpe ratio but uses a
    benchmark rather than the risk-free rate. The benchmark is usually chosen to represent
    the available investment universe such as the S&P 500 for a portfolio on large-cap
    US equities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, the IR measures the excess return of the portfolio, also called alpha,
    relative to the tracking error, which is the deviation of the portfolio returns
    from the benchmark returns, that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15439_05_009.png)'
  prefs: []
  type: TYPE_IMG
- en: The IR has also been used to explain how excess returns depend on a manager's
    skill and the nature of her strategy, as we will see next.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental law of active management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '"Diversification is protection against ignorance. It makes little sense if
    you know what you are doing."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Warren Buffet
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It's a curious fact that **Renaissance Technologies** (**RenTec**), the top-performing
    quant fund founded by Jim Simons, which we mentioned in *Chapter 1*, *Machine
    Learning for Trading – From Idea to Execution*, has produced similar returns as
    Warren Buffet, despite extremely different approaches. Warren Buffet's investment
    firm Berkshire Hathaway holds some 100-150 stocks for fairly long periods, whereas
    RenTec may execute 100,000 trades per day. How can we compare these distinct strategies?
  prefs: []
  type: TYPE_NORMAL
- en: 'A high IR reflects an attractive out-performance of the benchmark relative
    to the additional risk taken. The **Fundamental Law of Active Management** explains
    how such a result can be achieved: it approximates the IR as the product of the
    **information coefficient** (**IC**) and the breadth of the strategy.'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the previous chapter, the IC measures the rank correlation between
    return forecasts, like those implied by an alpha factor, and the actual forward
    returns. Hence, it is a measure of the forecasting skill of the manager. The breadth
    of the strategy is measured by the independent number of bets (that is, trades)
    an investor makes in a given time period, and thus represents the ability to apply
    the forecasting skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Fundamental Law states that the IR, also known as the **appraisal risk**
    (Treynor and Black), is the product of both values. In other words, it summarizes
    the importance to play both often (high breadth) and to play well (high IC):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15439_05_010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This framework has been extended to include the **transfer coefficient** (**TC**)
    to reflect portfolio constraints as an additional factor (for example, on short-selling)
    that may limit the information ratio below a level otherwise achievable given
    IC or strategy breadth. The TC proxies the efficiency with which the manager translates
    insights into portfolio bets: if there are no constraints, the TC would simply
    equal one; but if the manager does not short stocks even though forecasts suggests
    they should, the TC will be less than one and reduce the IC (Clarke et al., 2002).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Fundamental Law is important because it highlights the key drivers of outperformance:
    both accurate predictions and the ability to make independent forecasts and act
    on these forecasts matter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, managers with a broad set of investment decisions can achieve
    significant risk-adjusted excess returns with information coefficients between
    0.05 and 0.15, as illustrated by the following simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15439_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Information ratios for different values of breadth and information
    coefficient'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, estimating the breadth of a strategy is difficult, given the cross-sectional
    and time-series correlation among forecasts. You should view the Fundamental Law
    and its extensions as a useful analytical framework for thinking about how to
    improve your risk-adjusted portfolio performance. We'll look at techniques for
    doing so in practice next.
  prefs: []
  type: TYPE_NORMAL
- en: How to manage portfolio risk and return
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Portfolio management aims to pick and size positions in financial instruments
    that achieve the desired risk-return trade-off regarding a benchmark. As a portfolio
    manager, in each period, you select positions that optimize diversification to
    reduce risks while achieving a target return. Across periods, these positions
    may require rebalancing to account for changes in weights resulting from price
    movements to achieve or maintain a target risk profile.
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of modern portfolio management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Diversification permits us to reduce risks for a given expected return by exploiting
    how imperfect correlation allows for one asset's gains to make up for another
    asset's losses. Harry Markowitz invented **modern portfolio theory** (**MPT**)
    in 1952 and provided the mathematical tools to optimize diversification by choosing
    appropriate portfolio weights.
  prefs: []
  type: TYPE_NORMAL
- en: Markowitz showed how portfolio risk, measured as the standard deviation of portfolio
    returns, depends on the covariance among the returns of all assets and their relative
    weights. This relationship implies the existence of an **efficient frontier**
    of portfolios that maximizes portfolio returns given a maximal level of portfolio
    risk.
  prefs: []
  type: TYPE_NORMAL
- en: However, mean-variance frontiers are highly sensitive to the estimates of the
    inputs required for their calculation, namely expected returns, volatilities,
    and correlations. In practice, mean-variance portfolios that constrain these inputs
    to reduce sampling errors have performed much better. These constrained special
    cases include equal-weighted, minimum-variance, and risk-parity portfolios.
  prefs: []
  type: TYPE_NORMAL
- en: The **capital asset pricing model** (**CAPM**) is an asset valuation model that
    builds on the MPT risk-return relationship. It introduces the concept of a risk
    premium that an investor can expect in market equilibrium for holding a risky
    asset; the premium compensates for the time value of money and the exposure to
    overall market risk that cannot be eliminated through diversification (as opposed
    to the idiosyncratic risk of specific assets).
  prefs: []
  type: TYPE_NORMAL
- en: 'The economic rationale for **non-diversifiable risk** includes, for example,
    macro drivers of the business risks affecting all equity returns or bond defaults.
    Hence, an asset''s expected return, *E*[*r*[i]], is the sum of the risk-free interest
    rate, *r*[f], and a risk premium proportional to the asset''s exposure to the
    expected excess return of the market portfolio, *r*[m], over the risk-free rate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15439_05_011.png)'
  prefs: []
  type: TYPE_IMG
- en: In theory, the **market portfolio** contains all investable assets and, in equilibrium,
    will be held by all rational investors. In practice, a broad value-weighted index
    approximates the market, for example, the S&P 500 for US equity investments.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15439_05_012.png) measures the exposure of asset, *i*, to the excess
    returns of the market portfolio. If the CAPM is valid, the intercept component,
    ![](img/B15439_05_013.png), should be zero. In reality, the CAPM assumptions are
    often not met, and alpha captures the returns left unexplained by exposure to
    the broad market.'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the previous chapter, over time, research uncovered **non-traditional
    sources of risk premiums**, such as the momentum or the equity value effects that
    explained some of the original alpha. Economic rationales, such as behavioral
    biases of under- or overreaction by investors to new information, justify risk
    premiums for exposure to these alternative risk factors.
  prefs: []
  type: TYPE_NORMAL
- en: These factors evolved into investment styles designed to capture these **alternative
    betas** that became tradable in the form of specialized index funds. Similarly,
    risk management now aims to control the exposure of numerous sources of risk beyond
    the market portfolio.
  prefs: []
  type: TYPE_NORMAL
- en: After isolating contributions from these alternative risk premiums, true alpha
    becomes limited to idiosyncratic asset returns and the manager's ability to time
    risk exposures.
  prefs: []
  type: TYPE_NORMAL
- en: The **efficient market hypothesis** (**EMH**) has been refined over the past
    several decades to rectify many of the original shortcomings of the CAPM, including
    imperfect information and the costs associated with transactions, financing, and
    agency. Many behavioral biases have the same effect, and some frictions are modeled
    as behavioral biases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern portfolio theory and practice have evolved significantly over the last
    several decades. We will introduce several approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Mean-variance optimization, and its shortcomings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatives such as minimum-risk and 1/*n* allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Risk parity approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Risk factor approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mean-variance optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modern portfolio theory solves for the optimal portfolio weights to minimize
    volatility for a given expected return or maximize returns for a given level of
    volatility. The key requisite inputs are expected asset returns, standard deviations,
    and the covariance matrix.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Diversification works because the variance of portfolio returns depends on the
    covariance of the assets. It can be reduced below the weighted average of the
    asset variances by including assets with less than perfect correlation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, given a vector, ![](img/B15439_05_014.png), of portfolio weights
    and the covariance matrix, ![](img/B15439_04_009.png), the portfolio variance,
    ![](img/B15439_05_016.png), is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15439_05_017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Markowitz showed that the problem of maximizing the expected portfolio return
    subject to a target risk has an equivalent dual representation of minimizing portfolio
    risk, subject to a target expected return level, ![](img/B15439_05_018.png). Hence,
    the optimization problem becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15439_05_019.png)'
  prefs: []
  type: TYPE_IMG
- en: Finding the efficient frontier in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can calculate an efficient frontier using `scipy.optimize.minimize` and
    the historical estimates for asset returns, standard deviations, and the covariance
    matrix. SciPy ''s `minimize` function implements a range of constrained and unconstrained
    optimization algorithms for scalar functions that output a single number from
    one or more input variables (see the SciPy documentation for more details). The
    code can be found in the `strategy_evaluation` subfolder of the repository for
    this chapter and implements the following sequence of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the simulation generates random weights using the Dirichlet distribution
    and computes the mean, standard deviation, and SR for each sample portfolio using
    the historical return data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up the quadratic optimization problem to solve for the minimum
    standard deviation for a given return or the maximum SR. To this end, we define
    the functions that measure the key performance metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a target function that represents the negative SR for scipy''s
    `minimize` function to optimize, given the constraints that the weights are bounded
    by, [0, 1], and sum to one in absolute terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we compute the efficient frontier by iterating over a range of target
    returns and solving for the corresponding minimum variance portfolios. To this
    end, we formulate the optimization problem using the constraints on portfolio
    risk and return as a function of the weights, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution requires iterating over ranges of acceptable values to identify
    optimal risk-return combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The simulation yields a subset of the feasible portfolios, and the efficient
    frontier identifies the optimal in-sample return-risk combinations that were achievable
    given historic data.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.2* shows the result, including the minimum variance portfolio, the
    portfolio that maximizes the SR, and several portfolios produced by alternative
    optimization strategies that we''ll discuss in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15439_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: The efficient frontier and different optimized portfolios'
  prefs: []
  type: TYPE_NORMAL
- en: The portfolio optimization can be run at every evaluation step of the trading
    strategy to optimize the positions.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges and shortcomings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding mean-variance frontier estimation illustrates **in-sample**, that
    is, **backward-looking** optimization. In practice, portfolio optimization requires
    forward-looking inputs and outputs. However, expected returns are notoriously
    difficult to estimate accurately. It is best viewed as a starting point and benchmark
    for numerous improvements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The covariance matrix can be estimated somewhat more reliably, which has given
    rise to several alternative approaches. However, covariance matrices with correlated
    assets pose computational challenges since the optimization problem requires inverting
    the matrix. The high condition number induces numerical instability, which in
    turn gives rise to the **Markovitz curse**: the more diversification is required
    (by correlated investment opportunities), the more unreliable the weights produced
    by the algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: Many investors prefer to use portfolio-optimization techniques with less onerous
    input requirements. We will now introduce several alternatives that aim to address
    these shortcomings, including a more recent approach based on machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to mean-variance optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The challenges with accurate inputs for the mean-variance optimization problem
    have led to the adoption of several practical alternatives that constrain the
    mean, the variance, or both, or omit return estimates that are more challenging,
    such as the risk parity approach, which we'll discuss later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The 1/N portfolio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Simple portfolios provide useful benchmarks to gauge the added value of complex
    models that generate the risk of overfitting. The simplest strategy—an **equally-weighted
    portfolio**—has been shown to be one of the best performers.
  prefs: []
  type: TYPE_NORMAL
- en: Famously, de Miguel, Garlappi, and Uppal (2009) compared the out-of-sample performance
    of portfolios produced by various mean-variance optimizers, including robust Bayesian
    estimators, portfolio constraints, and optimal combinations of portfolios, to
    the simple 1/N rule. They found that the 1/N portfolio produced a higher Sharpe
    ratio than the alternatives on various datasets, explained by the high cost of
    estimation errors that often outweighs the benefits of sophisticated optimization
    out of sample.
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, they found that the estimation window required for the sample-based
    mean-variance strategy and its extensions to outperform the 1/N benchmark is around
    3,000 months for a portfolio with 25 assets and about 6,000 months for a portfolio
    with 50 assets.
  prefs: []
  type: TYPE_NORMAL
- en: The 1/N portfolio is also included in *Figure 5.2* in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: The minimum-variance portfolio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another alternative is the **global minimum-variance** (**GMV**) portfolio,
    which prioritizes the minimization of risk. It is shown in *Figure 5.2* and can
    be calculated, as follows, by minimizing the portfolio standard deviation using
    the mean-variance framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The corresponding minimum volatility portfolio lies on the efficient frontier,
    as shown previously in *Figure 5.2*.
  prefs: []
  type: TYPE_NORMAL
- en: Global Portfolio Optimization – the Black-Litterman approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Global Portfolio Optimization** approach of Black and Litterman (1992)
    combines economic models with statistical learning. It is popular because it generates
    estimates of expected returns that are plausible in many situations.
  prefs: []
  type: TYPE_NORMAL
- en: The technique assumes that the market is a mean-variance portfolio, as implied
    by the CAPM equilibrium model. It builds on the fact that the observed market
    capitalization can be considered as optimal weights assigned to each security
    by the market. Market weights reflect market prices that, in turn, embody the
    market's expectations of future returns.
  prefs: []
  type: TYPE_NORMAL
- en: The approach can thus reverse-engineer the unobservable future expected returns
    from the assumption that the market is close enough to equilibrium, as defined
    by the CAPM. Investors can adjust these estimates to their own beliefs using a
    shrinkage estimator. The model can be interpreted as a Bayesian approach to portfolio
    optimization. We will introduce Bayesian methods in *Chapter 10*, *Bayesian ML
    – Dynamic Sharpe Ratios and Pairs Trading Strategies*.
  prefs: []
  type: TYPE_NORMAL
- en: How to size your bets – the Kelly criterion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Kelly criterion** has a long history in gambling because it provides guidance
    on how much to stake on each bet in an (infinite) sequence of bets with varying
    (but favorable) odds to maximize terminal wealth. It was published in a 1956 paper,
    *A New Interpretation of the Information Rate*, by John Kelly, who was a colleague
    of Claude Shannon's at Bell Labs. He was intrigued by bets placed on candidates
    at the new quiz show "The $64,000 Question," where a viewer on the west coast
    used the three-hour delay to obtain insider information about the winners.
  prefs: []
  type: TYPE_NORMAL
- en: Kelly drew a connection to Shannon's information theory to solve for the bet
    that is optimal for long-term capital growth when the odds are favorable, but
    uncertainty remains. His rule maximizes logarithmic wealth as a function of the
    odds of success of each game and includes implicit bankruptcy protection since
    *log(0)* is negative infinity so that a Kelly gambler would naturally avoid losing
    everything.
  prefs: []
  type: TYPE_NORMAL
- en: The optimal size of a bet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Kelly began by analyzing games with a binary win-lose outcome. The key variables
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '*b*: The odds defining the amount won for a $1 bet. Odds = 5/1 implies a $5
    gain if the bet wins, plus recovery of the $1 capital.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*p*: The probability defining the likelihood of a favorable outcome.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*f*: The share of the current capital to bet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*V*: The value of the capital as a result of betting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Kelly criterion aims to maximize the value''s growth rate, *G*, of infinitely
    repeated bets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15439_05_020.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When *W* and *L* are the numbers of wins and losses, then:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15439_05_021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can maximize the rate of growth *G* by maximizing *G* with respect to *f*,
    as illustrated using SymPy, as follows (you can find this in the `kelly_rule`
    notebook):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We arrive at the optimal share of capital to bet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15439_05_022.png)'
  prefs: []
  type: TYPE_IMG
- en: Optimal investment – single asset
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a financial market context, both outcomes and alternatives are more complex,
    but the Kelly criterion logic does still apply. It was made popular by Ed Thorp,
    who first applied it profitably to gambling (described in the book *Beat the Dealer*)
    and later started the successful hedge fund Princeton/Newport Partners.
  prefs: []
  type: TYPE_NORMAL
- en: 'With continuous outcomes, the growth rate of capital is defined by an integrate
    over the probability distribution of the different returns that can be optimized
    numerically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15439_05_023.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can solve this expression for the optimal *f** using the `scipy.optimize`
    module. The `quad` function computes the value of a definite integral between
    two values *a* and *b* using FORTRAN''s QUADPACK library (hence its name). It
    returns the value of the integral and an error estimate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Optimal investment – multiple assets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will use an example with various equities. E. Chan (2008) illustrates how
    to arrive at a multi-asset application of the Kelly criterion, and that the result
    is equivalent to the (potentially levered) maximum Sharpe ratio portfolio from
    the mean-variance optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The computation involves the dot product of the precision matrix, which is
    the inverse of the covariance matrix, and the return matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The Kelly portfolio is also shown in the previous efficient frontier diagram
    (after normalization so that the sum of the absolute weights equals one). Many
    investors prefer to reduce the Kelly weights to reduce the strategy's volatility,
    and Half-Kelly has become particularly popular.
  prefs: []
  type: TYPE_NORMAL
- en: Risk parity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fact that the previous 15 years have been characterized by two major crises
    in the global equity markets, a consistently upwardly sloping yield curve, and
    a general decline in interest rates, made risk parity look like a particularly
    compelling option. Many institutions carved out strategic allocations to risk
    parity to further diversify their portfolios.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple implementation of risk parity allocates assets according to the inverse
    of their variances, ignoring correlations and, in particular, return forecasts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The risk parity portfolio is also shown in the efficient frontier diagram at
    the beginning of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Risk factor investment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative framework for estimating input is to work down to the underlying
    determinants, or factors, that drive the risk and returns of assets. If we understand
    how the factors influence returns, and we understand the factors, we will be able
    to construct more robust portfolios.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of factor investing looks beyond asset class labels. It looks to
    the underlying factor risks that we discussed in the previous chapter on alpha
    factors to maximize the benefits of diversification. Rather than distinguishing
    investment vehicles by labels such as hedge funds or private equity, factor investing
    aims to identify distinct risk-return profiles based on differences in exposure
    to fundamental risk factors (Ang 2014).
  prefs: []
  type: TYPE_NORMAL
- en: The naive approach to mean-variance investing plugs (artificial) groupings as
    distinct asset classes into a mean-variance optimizer. Factor investing recognizes
    that such groupings share many of the same factor risks as traditional asset classes.
    Diversification benefits can be overstated, as investors discovered during the
    2008 crisis when correlations among risky asset classes increased due to exposure
    to the same underlying factor risks.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 7*, *Linear Models – From Risk Factors to Return Forecasts*, we
    will show how to measure the exposure of a portfolio to various risk factors so
    that you can either adjust the positions to tune your factor exposure, or hedge
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical risk parity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mean-variance optimization is very sensitive to the estimates of expected returns
    and the covariance of these returns. The covariance matrix inversion also becomes
    more challenging and less accurate when returns are highly correlated, as is often
    the case in practice. The result has been called the Markowitz curse: when diversification
    is more important because investments are correlated, conventional portfolio optimizers
    will likely produce an unstable solution. The benefits of diversification can
    be more than offset by mistaken estimates. As discussed, even naive, equally weighted
    portfolios can beat mean-variance and risk-based optimization out of sample.'
  prefs: []
  type: TYPE_NORMAL
- en: More robust approaches have incorporated additional constraints (Clarke et al.,
    2002) or Bayesian priors (Black and Litterman, 1992), or used shrinkage estimators
    to make the precision matrix more numerically stable (Ledoit and Wolf, 2003),
    available in scikit-learn ([http://scikit-learn.org/stable/modules/generated/sklearn.covariance.LedoitWolf.html](http://scikit-learn.org/stable/modules/generated/sklearn.covariance.LedoitWolf.html)).
  prefs: []
  type: TYPE_NORMAL
- en: '**Hierarchical risk parity** (**HRP**), in contrast, leverages unsupervised
    machine learning to achieve superior out-of-sample portfolio allocations. A recent
    innovation in portfolio optimization leverages graph theory and hierarchical clustering
    to construct a portfolio in three steps (Lopez de Prado, 2015):'
  prefs: []
  type: TYPE_NORMAL
- en: Define a distance metric so that correlated assets are close to each other,
    and apply single-linkage clustering to identify hierarchical relationships.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the hierarchical correlation structure to quasi-diagonalize the covariance
    matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply top-down inverse-variance weighting using a recursive bisectional search
    to treat clustered assets as complements, rather than substitutes, in portfolio
    construction and to reduce the number of degrees of freedom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A related method to construct **hierarchical clustering portfolios** (**HCP**)
    was presented by Raffinot (2016). Conceptually, complex systems such as financial
    markets tend to have a structure and are often organized in a hierarchical way,
    while the interaction among elements in the hierarchy shapes the dynamics of the
    system. Correlation matrices also lack the notion of hierarchy, which allows weights
    to vary freely and in potentially unintended ways.
  prefs: []
  type: TYPE_NORMAL
- en: Both HRP and HCP have been tested by JP Morgan (2012) on various equity universes.
    The HRP, in particular, produced equal or superior risk-adjusted returns and Sharpe
    ratios compared to naive diversification, the maximum-diversified portfolios,
    or GMV portfolios.
  prefs: []
  type: TYPE_NORMAL
- en: We will present the Python implementation in *Chapter 13*, *Data-Driven Risk
    Factors and Asset Allocation with Unsupervised Learning*.
  prefs: []
  type: TYPE_NORMAL
- en: Trading and managing portfolios with Zipline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced Zipline to simulate the computation of
    alpha factors from trailing market, fundamental, and alternative data for a cross-section
    of stocks. In this section, we will start acting on the signals emitted by alpha
    factors. We'll do this by submitting buy and sell orders so we can enter long
    and short positions or rebalance the portfolio to adjust our holdings to the most
    recent trade signals.
  prefs: []
  type: TYPE_NORMAL
- en: We will postpone optimizing the portfolio weights until later in this chapter
    and, for now, just assign positions of equal value to each holding. As mentioned
    in the previous chapter, an in-depth introduction to the testing and evaluation
    of strategies that include ML models will follow in *Chapter 6*, *The Machine
    Learning Process*.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling signal generation and trade execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the custom `MeanReversion` factor developed in the previous chapter
    (see the implementation in `01_backtest_with_trades.ipynb`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Pipeline` created by the `compute_factors()` method returns a table with
    columns containing the 50 longs and shorts. It selects the equities according
    to the largest negative and positive deviations, respectively, of their last monthly
    return from the annual average, normalized by the standard deviation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It also limited the universe to the 1,000 stocks with the highest average trading
    volume over the last 30 trading days. `before_trading_start()` ensures the daily
    execution of the `Pipeline` and the recording of the results, including the current
    prices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `rebalance()` method submits trade orders to the `exec_trades()` method
    for the assets flagged for long and short positions by the `Pipeline` with equal
    positive and negative weights. It also divests any current holdings that are no
    longer included in the factor signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `rebalance()` method runs according to `date_rules` and `time_rules` set
    by the `schedule_function()` utility at the beginning of the week, right after
    `market_open`, as stipulated by the built-in `US_EQUITIES` calendar (see the Zipline
    documentation for details on rules).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also specify a trade commission both in relative terms and as a minimum
    amount. There is also an option to define slippage, which is the cost of an adverse
    change in price between trade decision and execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The algorithm continues to execute after calling the `run_algorithm()` function
    and returns the same backtest performance `DataFrame` that we saw in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing mean-variance portfolio optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We demonstrated in the previous section how to find the efficient frontier using
    `scipy.optimize`. In this section, we will leverage the PyPortfolioOpt library,
    which offers portfolio optimization (using SciPy under the hood), including efficient
    frontier techniques and more recent shrinkage approaches that regularize the covariance
    matrix (see *Chapter 7*, *Linear Models – From Risk Factors to Return Forecasts*,
    on shrinkage for linear regression). The code example lives in `02_backtest_with_pf_optimization.ipynb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the same setup with 50 long and short positions derived from the
    `MeanReversion` factor ranking. The `rebalance()` function receives the suggested
    long and short positions and passes each subset on to a new `optimize_weights()`
    function to obtain dictionaries with `asset: target_percent` pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `optimize_weights()` function uses the `EfficientFrontier` object, provided
    by PyPortfolioOpt, to find the weights that maximize the Sharpe ratio based on
    the last year of returns and the covariance matrix, both of which the library
    also computes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It returns normalized weights that sum to 1, set to negative values for the
    short positions.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.3* shows that, for this particular set of strategies and time frame,
    the mean-variance optimized portfolio performs significantly better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15439_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Mean-variance vs equal-weighted portfolio performance'
  prefs: []
  type: TYPE_NORMAL
- en: PyPortfolioOpt also finds the minimum volatility portfolio. More generally speaking,
    this example illustrates how you can add logic to tweak portfolio weights using
    the methods presented in the previous section, or any other of your choosing.
  prefs: []
  type: TYPE_NORMAL
- en: We will now turn to common measures of portfolio return and risk, and how to
    compute them using the pyfolio library.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring backtest performance with pyfolio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pyfolio facilitates the analysis of portfolio performance, both in and out of
    sample using a rich set of metrics and visualizations. It produces tear sheets
    that cover the analysis of returns, positions, and transactions, as well as event
    risk during periods of market stress using several built-in scenarios. It also
    includes Bayesian out-of-sample performance analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Pyfolio relies on portfolio returns and position data and can also take into
    account the transaction costs and slippage losses of trading activity. It uses
    the empyrical library, which can also be used on a standalone basis to compute
    performance metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the returns and benchmark inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The library is part of the Quantopian ecosystem and is compatible with Zipline
    and Alphalens. We will first demonstrate how to generate the requisite inputs
    from Alphalens and then show how to extract them from a Zipline backtest performance
    `DataFrame`. The code samples for this section are in the notebook `03_pyfolio_demo.ipynb`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting pyfolio input from Alphalens
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pyfolio also integrates with Alphalens directly and permits the creation of
    pyfolio input data using `create_pyfolio_input`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two options to specify how portfolio weights will be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`long_short`: If `False`, weights will correspond to factor values divided
    by their absolute value so that negative factor values generate short positions.
    If `True`, factor values are first demeaned so that long and short positions cancel
    each other out, and the portfolio is market neutral.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`equal_weight`: If `True` and `long_short` is `True`, assets will be split
    into two equal-sized groups, with the top/bottom half making up long/short positions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long-short portfolios can also be created for groups if `factor_data` includes,
    for example, sector information for each asset.
  prefs: []
  type: TYPE_NORMAL
- en: Getting pyfolio input from a Zipline backtest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The result of a Zipline backtest can also be converted into the required pyfolio
    input using `extract_rets_pos_txn_from_zipline`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Walk-forward testing – out-of-sample returns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing a trading strategy involves back- and forward testing. The former involves
    historical data and often refers to the sample period used to fine-tune alpha
    factor parameters. Forward-testing simulates the strategy on new market data to
    validate that it performs well out of sample and is not too closely tailored to
    specific historical circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: Pyfolio allows for the designation of an out-of-sample period to simulate walk-forward
    testing. There are numerous aspects to take into account when testing a strategy
    to obtain statistically reliable results. We will address this in more detail
    in *Chapter 8*, *The ML4T Workflow – From Model to Strategy Backtesting*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `plot_rolling_returns` function displays cumulative in- and out-of-sample
    returns against a user-defined benchmark (we are using the S&P 500). Pyfolio computes
    cumulative returns as the product of simple returns after adding 1 to each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot in *Figure 5.4* includes a cone that shows expanding confidence intervals
    to indicate when out-of-sample returns appear unlikely, given random-walk assumptions.
    Here, our toy strategy did not perform particularly well against the S&P 500 benchmark
    during the simulated 2016 out-of-sample period:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15439_05_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Pyfolio cumulative performance plot'
  prefs: []
  type: TYPE_NORMAL
- en: Summary performance statistics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pyfolio offers several analytic functions and plots. The `perf_stats` summary
    displays the annual and cumulative returns, volatility, skew, and kurtosis of
    returns and the SR.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following additional metrics (which can also be calculated individually)
    are most important:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Max drawdown**: Highest percentage loss from the previous peak'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Calmar ratio**: Annual portfolio return relative to maximal drawdown'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Omega ratio**: Probability-weighted ratio of gains versus losses for a return
    target, zero per default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sortino ratio**: Excess return relative to downside standard deviation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tail ratio**: Size of the right tail (gains, the absolute value of the 95th
    percentile) relative to the size of the left tail (losses, absolute value of the
    5th percentile)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Daily value at risk (VaR)**: Loss corresponding to a return two standard
    deviations below the daily mean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alpha**: Portfolio return unexplained by the benchmark return'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Beta**: Exposure to the benchmark'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `plot_perf_stats` function bootstraps estimates of parameter variability
    and displays the result as a box plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15439_05_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: Pyfolio performance statistic plot'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `show_perf_stats` function computes numerous metrics for the entire period,
    as well as separately, for in- and out-of-sample periods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For the simulated long-short portfolio derived from the `MeanReversion` factor,
    we obtain the following performance statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Metric | All | In-sample | Out-of-sample |'
  prefs: []
  type: TYPE_TB
- en: '| Annual return | 2.80% | 2.10% | 4.70% |'
  prefs: []
  type: TYPE_TB
- en: '| Cumulative returns | 11.60% | 6.60% | 4.70% |'
  prefs: []
  type: TYPE_TB
- en: '| Annual volatility | 8.50% | 8.80% | 7.60% |'
  prefs: []
  type: TYPE_TB
- en: '| Sharpe ratio | 0.37 | 0.29 | 0.64 |'
  prefs: []
  type: TYPE_TB
- en: '| Calmar ratio | 0.21 | 0.16 | 0.57 |'
  prefs: []
  type: TYPE_TB
- en: '| Stability | 0.26 | 0.01 | 0.67 |'
  prefs: []
  type: TYPE_TB
- en: '| Max drawdown | -13.10% | -13.10% | -8.30% |'
  prefs: []
  type: TYPE_TB
- en: '| Omega ratio | 1.07 | 1.06 | 1.11 |'
  prefs: []
  type: TYPE_TB
- en: '| Sortino ratio | 0.54 | 0.42 | 0.96 |'
  prefs: []
  type: TYPE_TB
- en: '| Skew | 0.33 | 0.35 | 0.25 |'
  prefs: []
  type: TYPE_TB
- en: '| Kurtosis | 7.2 | 8.04 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Tail ratio | 1.04 | 1.06 | 1.01 |'
  prefs: []
  type: TYPE_TB
- en: '| Daily value at risk | -1.10% | -1.10% | -0.90% |'
  prefs: []
  type: TYPE_TB
- en: '| Gross leverage | 0.69 | 0.68 | 0.72 |'
  prefs: []
  type: TYPE_TB
- en: '| Daily turnover | 8.10% | 8.00% | 8.40% |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha | 0 | -0.01 | 0.03 |'
  prefs: []
  type: TYPE_TB
- en: '| Beta | 0.25 | 0.27 | 0.17 |'
  prefs: []
  type: TYPE_TB
- en: See the appendix for details on the calculation and interpretation of portfolio
    risk and return metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Drawdown periods and factor exposure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `plot_drawdown_periods(returns)` function plots the principal drawdown
    periods for the portfolio, and several other plotting functions show the rolling
    SR and rolling factor exposures to the market beta or the Fama-French size, growth,
    and momentum factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The plots in *Figure 5.6*, which highlights a subset of the visualization contained
    in the various tear sheets, illustrate how pyfolio allows us to drill down into
    the performance characteristics and gives us exposure to fundamental drivers of
    risk and returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15439_05_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Various pyfolio plots of performance over time'
  prefs: []
  type: TYPE_NORMAL
- en: Modeling event risk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pyfolio also includes timelines for various events that you can use to compare
    the performance of a portfolio to a benchmark during this period. Pyfolio uses
    the S&P 500 by default, but you can also provide benchmark returns of your choice.
    The following example compares the performance to the S&P 500 during the fall
    2015 selloff, following the Brexit vote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 5.7* shows the resulting plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15439_05_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: Pyfolio event risk analysis'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the important topic of portfolio management, which
    involves the combination of investment positions with the objective of managing
    risk-return trade-offs. We introduced pyfolio to compute and visualize key risk
    and return metrics, as well as to compare the performance of various algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how important accurate predictions are for optimizing portfolio weights
    and maximizing diversification benefits. We also explored how machine learning
    can facilitate more effective portfolio construction by learning hierarchical
    relationships from the asset-returns covariance matrix.
  prefs: []
  type: TYPE_NORMAL
- en: We will now move on to the second part of this book, which focuses on the use
    of machine learning models. These models will produce more accurate predictions
    by making more effective use of more diverse information. They do this to capture
    more complex patterns than the simpler alpha factors that were most prominent
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by training, testing, and tuning linear models for regression
    and classification using cross-validation to achieve robust out-of-sample performance.
    We will also embed these models within the framework for defining and backtesting
    algorithmic trading strategies, which we covered in the previous two chapters.
  prefs: []
  type: TYPE_NORMAL
