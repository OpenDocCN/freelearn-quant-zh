- en: '3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quadratic Unconstrained Binary Optimisation
  prefs: []
  type: TYPE_NORMAL
- en: 'Undoubtedly, Quadratic Unconstrained Binary Optimisation (QUBO) is a flagship
    use case of quantum annealing. We only need to have a closer look at the name
    of this class of optimisation problems to see why:'
  prefs: []
  type: TYPE_NORMAL
- en: Quantum annealers operate on binary spin variables. It is straightforward to
    perform mapping between binary decision variables (represented by the logical
    qubits) and spin variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The objective functions of quadratic optimisation problems have only linear
    and quadratic terms. This significantly simplifies the models and allows their
    embedding on existing quantum annealing hardware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unconstrained optimisation means that although QUBO allows us to specify conditions
    that must be satisfied, they are not hard constraints. The violation of constraints
    is penalised through the additional terms in the QUBO objective function, but
    it is still possible to find solutions that violate specified constraints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these features make QUBO problems solvable on quantum annealers. At the
    same time, the QUBO formulation exists for many important NP-hard combinatorial
    optimisation problems, such as graph partitioning, job-shop scheduling, binary
    integer linear programming, and many others. This class also includes the discrete
    portfolio optimisation problem, which we consider in this chapter. We should also
    mention here some of the recent attempts to address the problem of discrete portfolio
    optimisation using classical methods, such as the knapsack problem formulation
    by Vaezi *et* *al.*  [[289](Biblography.xhtml#XVaezi2019)] and the application
    of evolutionary search methods such as genetic algorithms by Anagnostopoulos and
    Mamanis  [[12](Biblography.xhtml#XAnagnostopoulos2010)]. Both the knapsack problem
    with integer weights and genetic algorithms are discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Principles of Quadratic Unconstrained Binary Optimisation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: QUBO represents optimisation problems in which a quadratic function of *N* binary
    variables, *q*[1]*,…,q*[N], has to be minimised over all possible 2^N assignments
    of its variables. The function to be minimised is referred to as the *cost function*,
    and it can be written as
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ N N N ∑ ∑ ∑ LQUBO (q ) = aiqi + bijqiqj, i=1 i=1 j=i+1 ](img/file329.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: where q := (*q*[1]*,…,q*[N]) ∈{0*,*1}^N represents the assignment of *N* binary
    decision variables.
  prefs: []
  type: TYPE_NORMAL
- en: A broad class of optimisation problems with many practical applications admits
    a QUBO formulation  [[197](Biblography.xhtml#XLucas)]. To solve hard QUBO instances
    in an exact way, known classical algorithms require exponential time (in the problem
    size defined as the number of binary decision variables, *N*)  [[120](Biblography.xhtml#XGuerreschi2021)].
    Several approximate classical methods have been devised to reduce the computational
    cost; however, it is the fast maturing quantum annealing that aspires to demonstrate
    material speedup on the hardest QUBO instances, such as NP-hard discrete portfolio
    optimisation problems  [[175](Biblography.xhtml#XKondratyev2019), [296](Biblography.xhtml#XVenturelli2019)].
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.1 QUBO to Ising transformation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A QUBO problem can be easily translated into a corresponding Ising problem solvable
    on a quantum annealer. The Ising cost function of *N* spin variables s := (*s*[1]*,…,s*[N])
    ∈{−1*,*+1}^N is given by
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ N N N ∑ ∑ ∑ LIsing(s) = gisi + Jijsisj. i=1 i=1 j=i+1 ](img/file330.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: The Ising and QUBO models are related through the transformation *s*[i] = 2*q*[i]
    − 1, hence the relationship with ([3.1](#x1-640001)) is
  prefs: []
  type: TYPE_NORMAL
- en: '![ (i∑−1 ∑N ) Jij = 1bij and gi = 1ai + 1- bki + bil 4 2 4 k=1 l=i+1 ](img/file331.jpg)'
  prefs: []
  type: TYPE_IMG
- en: disregarding an unimportant constant offset for the optimisation.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.2 QUBO problem examples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are many examples of important QUBO problems that can be directly applied
    to practical use cases arising in finance. Here, following Lucas  [[197](Biblography.xhtml#XLucas)],
    we mention a few of them in their traditional formulation.
  prefs: []
  type: TYPE_NORMAL
- en: Number Partitioning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Given a set of *N* positive numbers {*n*[1]*,…,n*[N]}, is there a partition
    of this set of numbers into two disjoint subsets such that the sum of the elements
    in both sets is the same? For example, we can think about the set {*n*[1]*,…,n*[N]}
    as a collection of assets that must be divided equally between two parties. The
    Ising formulation of this problem is
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ( )2 ∑N L(s) = sini , i=1 ](img/file332.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: where spin variables (*s*[i])[i=1,…,N] ∈{−1*,*+1} are the decision variables.
    If there is a solution to the Ising model with *L* = 0, then there is a configuration
    of spins where the sum of the *n*[i] for the +1 spins is the same for the sum
    of the *n*[i] for the −1 spins. The number partitioning problem finds numerous
    applications in economics and finance, from routing and scheduling problems  [[71](Biblography.xhtml#XCoslovich2006)]
    to signal detection and time series analysis  [[148](Biblography.xhtml#XJackson2005)].
  prefs: []
  type: TYPE_NORMAL
- en: Graph Partitioning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider an undirected graph
  prefs: []
  type: TYPE_NORMAL
- en: '![G = (V,E ), ](img/file333.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'where *V* stands for the set of vertices and *E* stands for the set of edges,
    with an even number *N* of vertices. The task is to partition the set *V* into
    two subsets of equal size *N∕*2, such that the number of edges connecting the
    two subsets is minimised. This problem has many applications: finding these partitions
    can allow us to run some graph algorithms in parallel on the two partitions, and
    then make some modifications due to the few connecting edges at the end  [[36](Biblography.xhtml#XBillionnet1989)].
    The spin variables represent the graph vertices, with values +1 and −1 denoting
    the vertex being in either the {+} set or the {−} set. The problem is solved with
    the cost function consisting of two components:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![L(s) = LA(s)+ LB (s), ](img/file334.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ N∑ LA(s) = A si i=1 ](img/file335.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: provides a penalty if the number of elements in the {+} set is not equal to
    the number in the {−} set, and
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ∑ LB (s) = B 1-−-susv (u,v)∈E 2 ](img/file336.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: is a term that provides a penalty for each time that an edge connects vertices
    from different subsets. If *B >* 0, then we wish to minimise the number of edges
    between the two subsets; if *B <* 0, we will choose to maximise this number. Should
    we choose *B <* 0, we must ensure that *B* is small enough so that it is never
    favorable to violate the *L*[A] constraint. The graph partitioning problem can
    be applied to studying clustering in financial markets  [[271](Biblography.xhtml#XSorensen2014)].
  prefs: []
  type: TYPE_NORMAL
- en: Both problems, number and graph partitioning, are NP-hard problems  [[155](Biblography.xhtml#XKarp)].
  prefs: []
  type: TYPE_NORMAL
- en: Binary Integer Linear Programming
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let q := (*q*[1]*,…,q*[N]) be a vector of *N* binary variables. The task is
    to maximise c ⋅ q, for some vector c, given the constraint
  prefs: []
  type: TYPE_NORMAL
- en: '| ![Sq = b ](img/file337.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: with S ∈ℳ[m,N](ℝ) and b ∈ℝ^m. Many problems can be posed as binary integer linear
    programming, for example, a maximisation of profit subject to regulatory constraints  [[255](Biblography.xhtml#XSchrijver1998)].
  prefs: []
  type: TYPE_NORMAL
- en: The cost function *L*(q) corresponding to this problem can be constructed as
    a sum of two terms, *L*(q) = *L*[A](q) + *L*[B](q), where the first term is
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ m ( N )2 ∑ ∑ LA (q) = A bj − Sijqi , j=1 i=1 ](img/file338.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: for some constant *A >* 0\. Note that *L*[A] = 0 enforces the constraint Sq
    = b. The second term is
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ N∑ LB(q) = − B ciqi, i=1 ](img/file339.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: with another positive constant *B < A*.
  prefs: []
  type: TYPE_NORMAL
- en: Knapsack with Integer Weights
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We have a list of *N* objects, labelled by indices *i* = 1*,…,N*, with the weight
    of each object given by *w*[i] ∈ℕ, and its value given by *c*[i], and we have
    a knapsack that can only carry some weight up to *W*[max] ∈ℕ. If *q*[i] is a binary
    variable denoting whether (*q*[i] = 1) or not (*q*[i] = 0) object *i* is contained
    in the knapsack, the total weight in the knapsack is
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ∑N W = wiqi, i=1 ](img/file340.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: and the total value is
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ N C = ∑ c q. i=1 i i ](img/file341.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: The task is to maximise *C* subject to the constraint that *W* ≤ *W*[max]. The
    knapsack problem finds multiple applications in economics and finance  [[159](Biblography.xhtml#XKellerer2004), [289](Biblography.xhtml#XVaezi2019)].
  prefs: []
  type: TYPE_NORMAL
- en: We introduce a binary variable, *y*[n], for each *n* = 1*,…,W*[max], which is
    1 if the final weight of the knapsack is *n*, and 0 otherwise. As before, the
    cost function consists of two terms, *L*(q) = *L*[A](q) + *L*[B](q), with
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ( )2 ( )2 W∑max Wm∑ax ∑N LA (q) = A 1 − yn + A nyn − wiqi , n=1 n=1 i=1
    ](img/file342.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: which enforces that the weight can only take on one value and that the weight
    of the objects in the knapsack equals the value we claimed it did, and
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ N∑ LB(q) = − B ciqi. i=1 ](img/file343.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: As we require that it should not be possible to find a solution where *L*[A]
    is weakly violated at the expense of *L*[B] becoming more negative, we require
    0 *< B* max[i=1,…,N]*c*[i] *< A* (adding an item to the knapsack, which makes
    it too heavy, is not allowed).
  prefs: []
  type: TYPE_NORMAL
- en: Many other famous NP-hard optimisation problems can be solved on quantum annealers.
    Here, we can mention the Map Colouring Problem  [[76](Biblography.xhtml#XDahl2013)]
    and the Job-Shop Scheduling Problem  [[295](Biblography.xhtml#XVenturelli2015)],
    which were successfully solved on the D-Wave quantum annealers. In this chapter,
    we provide detailed description and analysis of an important finance-related QUBO
    problem – a discrete portfolio optimisation problem investigated by Venturelli
    and Kondratyev  [[175](Biblography.xhtml#XKondratyev2019), [296](Biblography.xhtml#XVenturelli2019)].
    This is a hard, fully connected graph problem that can be best addressed using
    a newly developed technique of reverse quantum annealing.
  prefs: []
  type: TYPE_NORMAL
- en: Many famous NP-hard problems can be solved with practical efficiency on quantum
    annealers in their QUBO formulation, up to a non-trivial number of variables.
    This makes quantum annealing a useful tool in dealing with classically hard optimisation
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Forward and Reverse Quantum Annealing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having defined the QUBO problem, we now review how quantum annealing can act
    as an efficient solver.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.1 Forward quantum annealing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The quantum annealing protocol, inspired by the adiabatic principle of quantum
    mechanics detailed in Chapter [2](Chapter_2.xhtml#x1-480002), dictates driving
    the system from an easy-to-prepare ground state of an initial Hamiltonian ℋ[0]
    to the unknown low-energy subspace of states of the problem Hamiltonian ℋ[F] ,
    ideally to the lowest energy state corresponding to the global minimum of the
    objective function. This *forward* quantum annealing procedure can be ideally
    described as attempting to drive the evolution of the time-dependent Hamiltonian
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ℋ (t) = A (t)ℋ0 + B (t)ℋF , ](img/file344.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: starting from
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ∑N ( ∑Nc ) ℋ0 = σic , i=1 c=1 x ](img/file345.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: where ℋ[0] is a Hamiltonian describing an independent collection of local transverse
    fields for each spin of the system (*σ*[x] is the Pauli X spin operator, or the
    quantum NOT gate, detailed in Section [6.3.3](Chapter_6.xhtml#x1-1300003)).
  prefs: []
  type: TYPE_NORMAL
- en: In expression ([3.2.1](#x1-720001)), the first sum runs over all *logical qubits*
    representing binary decision variables in the QUBO formulation of the optimisation
    problem, and the second sum runs over all *physical qubits* in the chain that
    represents a logical qubit. The construction of a logical qubit from a chain of
    physical qubits is explained in Chapter [2](Chapter_2.xhtml#x1-480002) and a sample
    embedding of the qubit chain on the quantum chip is shown in Figure [2.3](Chapter_2.xhtml#2.3)
    for the *Chimera* graph. No physical qubit can be an element of more than one
    qubit chain. Assuming the most dense embedding scheme, we have *N* × *N*[c] =
    *K*, where *K* is the total number of physical qubits in the quantum chip. However,
    in practice we have *N* × *N*[c] *< K* for most problems of realistic size that
    require full connectivity between the logical qubits. For example, in the case
    of a D-Wave 2000Q *Chimera* graph consisting of *K* = 2,048 physical qubits, the
    maximum number of fully connected logical qubits is 64 and the maximum number
    of physical qubits in a chain is 17, meaning that *N* × *N*[c] = 1,088.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [3.1](#3.1) shows how *A*(*t*) and *B*(*t*) vary over the scale of total
    *annealing time* *τ*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-72002r1: Schematic forward annealing schedule. A(t) indicates the
    strength of the transverse magnetic field and B(t) indicates the strength of the
    longitudinal magnetic field. ](img/file346.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Schematic forward annealing schedule. A(t) indicates the strength
    of the transverse magnetic field and B(t) indicates the strength of the longitudinal
    magnetic field.'
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the annealing run, *A*(*τ*) = 0 and the system is projected on
    the computational basis by a measurement of each qubit magnetisation. The duration
    of the anneal, *τ*, is a free parameter, hence it is often useful to define the
    fractional completion of the annealing schedule *s* = *t∕τ*.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.2 Reverse quantum annealing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Figure [3.2](#3.2) illustrates the quantum annealing protocol when the quantum
    annealer is set to operate as a reverse annealer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-73002r2: Schematic reverse annealing schedule. A(t) indicates the
    strength of the transverse magnetic field and B(t) indicates the strength of the
    longitudinal magnetic field. ](img/file347.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Schematic reverse annealing schedule. A(t) indicates the strength
    of the transverse magnetic field and B(t) indicates the strength of the longitudinal
    magnetic field.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The system is initialised with *B*(0) = max{*B*} and *A*(0) = 0, with spins
    set to a classical bitstring. The evolution then undergoes an inverse schedule
    up to a point where the Hamiltonian time-dependence is temporarily paused. With
    reference to the Hamiltonian evolution in ([3.2.1](#x1-720001)), the transverse
    field evolution that we program for this protocol is the following three-phase
    function (analogous equations for *B*(*t*)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![ AR (t) := A(τ + (sp − 1)t) Reverse Annealing: t ∈ [0,τ ], AP (t) := A (spτ)
    Annealing Pause: t ∈ [τ,τ + ρ], F A (t) := A ((1− sp)(t− ρ)− (1 − 2sp)τ) Forward
    Annealing: t ∈ [τ + ρ,2τ + ρ], ](img/file348.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *ρ* is the duration of the pause and *s*[p] ∈ [0*,*1] indicates the location
    of the forward schedule where the pause is implemented. The total duration of
    the selected reverse anneal protocol is 2*τ* + *ρ* as opposed to *τ* for the forward
    anneal. While the theory of reverse annealing is just starting to be investigated,
    the physics rationale of reverse annealing is to be found in the oversimplified
    idea that, if the system is initialised in a state 𝒮 corresponding to a local
    minimum of the objective function, the interplay of quantum and thermal fluctuations
    might help the state *tunnel* out of the energy trap during the reverse annealing,
    while the annealing pause (and to some extent the final forward annealing) allows
    the system to thermalise and relax in the neighborhood of the newfound minimum.
    The quality of the initial state 𝒮 is likely to influence dramatically the reverse
    annealing process. For the portfolio optimisation use case presented in this chapter,
    a classical greedy algorithm to set 𝒮 can be used as described in  [[296](Biblography.xhtml#XVenturelli2019)].
  prefs: []
  type: TYPE_NORMAL
- en: The combination of reverse quantum annealing with a classical greedy search
    algorithm has the potential to massively speed up a QUBO solver, thus realising
    a promising hybrid quantum-classical algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Discrete Portfolio Optimisation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The optimal portfolio construction problem is one of the most extensively studied
    problems in quantitative finance. The Modern Portfolio Theory (MPT)  [[202](Biblography.xhtml#XMarkowitz1952)]
    has laid the foundation for highly influential mean-variance portfolio optimisation
    approach. According to the MPT, a typical portfolio optimisation problem can be
    formulated as follows. Let *N* be the number of assets, *μ*[i] be the expected
    return of asset *i*, Σ[ij] be the covariance between the returns for assets *i*
    and *j*, and *R* be the target portfolio return. Then the decision variables are
    the weights *w*[i], i.e., the investment associated with the asset *i* (*w*[i]
    ∈ℝ). The standard Markowitz mean-variance approach consists in the constrained,
    quadratic optimisation problem
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ∑N ∑N N∑ N∑ min wiwjΣij, subject to wi = 1 and wiμi = R. i=1j=1 i=1 i=1
    ](img/file349.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: Quadratic problems of this form are efficiently solvable by standard computational
    means (e.g., quadratic programming with linear constraints) if the covariance
    matrix is positive definite. However, related discrete portfolio optimisation
    problems (with discrete weights *w*[i]) are much harder to solve. In fact, they
    are known to be NP-complete  [[158](Biblography.xhtml#XKellerer2000selecting)].
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the problem can also be cast into an unconstrained quadratic
    optimisation problem, which is a suitable formulation for quantum annealers  [[116](Biblography.xhtml#XGrant2020), [205](Biblography.xhtml#XMarzec2016), [234](Biblography.xhtml#XPhillipson2021), [251](Biblography.xhtml#XRosenberg2016)].
    The problem we are trying to solve here is a construction of the optimal portfolio
    from the universe of assets with known characteristics, such as asset returns,
    volatilities, and pairwise correlations. A stylised portfolio optimisation problem
    consists of selecting *M* assets from the universe of *N* investable assets. These
    *M* assets should ideally be the best possible choice according to some criteria.
  prefs: []
  type: TYPE_NORMAL
- en: The scenario we target is a Fund of Funds portfolio manager who is facing a
    task of selecting the best funds that follow particular trading strategies in
    order to maximise the risk-adjusted returns according to some model  [[175](Biblography.xhtml#XKondratyev2019)]
    with a constraint that the assets are selected with equal preference weights  [[82](Biblography.xhtml#XDeMiguel2009)].
    Should we want to generalise the portfolio with larger allocation to a given asset,
    we could allow for multiples of the reference weight by cloning an asset and treating
    it as a new one.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.1 QUBO encoding
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The task of encoding the relationship among the choices of *M* funds (*without*
    *replacement*) from the universe of *N* funds can then be formulated as a quadratic
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ N∑ ∑N ∑N L(q) = aiqi + bijqiqj, i=1 i=1j=i+1 ](img/file350.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'where *q*[i] = 1 means that asset *i* is selected and *q*[i] = 0 means that
    asset *i* is not selected. The task is then to find a configuration of q := (*q*[1]*,…,q*[N])
    that minimises *L*(q) subject to satisfying the cardinality constraint (i.e.,
    selection of exactly *M* assets). A common way to deal with the cardinality constraint
    would be to add a term *L*[penalty](q) to the cost function given by ([3.3.1](#x1-750001))
    such that the unsatisfying selections would be penalised by a large value *P*
    ≫ 1, which would force the global minimum to be such that ∑ [i=1]^N*q*[i] = *M*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ( N )2 L (q) = P M − ∑ q . penalty i i=1 ](img/file351.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: The coefficients (*a*[i])[1≤i≤N] reflect asset attractiveness on a standalone
    basis and can be derived from the individual assets’ expected risk-adjusted returns.
    Assets with large expected risk-adjusted returns should be rewarded with negative
    values of *a*[i], while assets with small expected risk-adjusted returns should
    be penalised with positive values of *a*[i]. The coefficients (*b*[ij])[1≤i<j≤N]
    reflect pairwise diversification penalties (positive values) and rewards (negative
    values). These coefficients can be derived from the pairwise correlations.
  prefs: []
  type: TYPE_NORMAL
- en: The minimisation of the QUBO cost function given by ([3.3.1](#x1-750001)) and ([3.3.1](#x1-750001))
    should optimise the risk-adjusted returns by the use of the metrics of the Sharpe
    ratio. The Sharpe ratio (excess asset return measured in the asset volatility
    units) is calculated as (*r* − *r*[0])*∕σ*, where *r* is the expected annualised
    asset return, *r*[0] is the applicable risk-free interest rate, and *σ* is asset
    volatility (annualised standard deviation of the asset returns). The higher the
    fund’s Sharpe ratio, the better the fund’s returns have been relative to the risk
    it has taken on. Volatility can be estimated as the historical annualised standard
    deviation of the net asset value returns (per share). Expected return can be either
    estimated as the historical return on fund investment or derived independently
    by the analyst/portfolio manager taking into account different considerations
    about the future fund performance.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.2 The coarse-grained encoding scheme
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Instead of using the raw real numbers obtained from the financial data for the
    QUBO coefficients, we opt to coarse-grain the individual funds Sharpe ratios and
    their mutual correlations down to integer values by grouping intervals in buckets
    (the sample mapping schemes are shown in Table [3.1](#x1-76001r1)). By using bucketed
    values, we define a scorecard, which is loosely based on the past fund performances
    but can be easily adjusted by portfolio managers according to their personal views
    and any new information not yet reflected in the funds reports.
  prefs: []
  type: TYPE_NORMAL
- en: '| Sharpe ratio bucket | Coefficient a[i] |'
  prefs: []
  type: TYPE_TB
- en: '| Equally spaced buckets, | Mapping scheme: |'
  prefs: []
  type: TYPE_TB
- en: '| from worst to best | A | B | C |'
  prefs: []
  type: TYPE_TB
- en: '| 1st | 15 | 25 | 30 |'
  prefs: []
  type: TYPE_TB
- en: '| 2nd | 12 | 16 | 24 |'
  prefs: []
  type: TYPE_TB
- en: '| 3rd | 9 | 9 | 18 |'
  prefs: []
  type: TYPE_TB
- en: '| 4th | 6 | 4 | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| 5th | 3 | 1 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 6th | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 7th | −3 | −1 | −6 |'
  prefs: []
  type: TYPE_TB
- en: '| 8th | −6 | −4 | −12 |'
  prefs: []
  type: TYPE_TB
- en: '| 9th | −9 | −9 | −18 |'
  prefs: []
  type: TYPE_TB
- en: '| 10th | −12 | −16 | −24 |'
  prefs: []
  type: TYPE_TB
- en: '| 11th | −15 | −25 | −30 |'
  prefs: []
  type: TYPE_TB
- en: '| Correlation bucket | Coefficient b[ij] |'
  prefs: []
  type: TYPE_TB
- en: '|  | Mapping scheme: |'
  prefs: []
  type: TYPE_TB
- en: '|  | D | E | F |'
  prefs: []
  type: TYPE_TB
- en: '| −1.00 ≤ρ[ij] < −0.25 | −5 | −9 | −10 |'
  prefs: []
  type: TYPE_TB
- en: '| −0.25 ≤ρ[ij] < −0.15 | −3 | −4 | −6 |'
  prefs: []
  type: TYPE_TB
- en: '| −0.15 ≤ρ[ij] < −0.05 | −1 | −1 | −2 |'
  prefs: []
  type: TYPE_TB
- en: '| −0.05 ≤ρ[ij] < 0.05 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0.05 ≤ρ[ij] < 0.15 | 1 | 1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 0.15 ≤ρ[ij] < 0.25 | 3 | 4 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 0.25 ≤ρ[ij] ≤1.00 | 5 | 9 | 10 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.1: Specification of the sample QUBO coefficients from NAV time series
    market data.'
  prefs: []
  type: TYPE_NORMAL
- en: The choice of QUBO coefficients as small integer numbers is dictated by the
    technical realisation of the existing quantum annealer architecture (precision
    of the superconducting chip circuitry). Within this restriction, the portfolio
    manager may choose any linear or non-linear scale for QUBO coefficients. For example,
    the quadratic mapping scheme B strongly penalises low Sharpe ratio funds and strongly
    rewards high Sharpe ratio funds. The linear mapping schemes A and C distinguish
    better between funds with average performances. Similarly, the mapping scheme E
    penalises large positive correlations and rewards large negative correlations
    stronger than the mapping scheme D.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.3 Construction of the instance set for numerical experiments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The instance set used for our case study is obtained by simulating asset values
    with the help of correlated geometric Brownian motion processes with a constant
    correlation *ρ*, drift *μ*, and log-normal volatility *σ*. The specific values
    of these parameters were derived from a wide range of fund industry researches
    (see  [[79](Biblography.xhtml#XDarolles2010conditionally)] for the Sharpe ratio
    distributions) and, therefore, can be viewed as representative of the industry.
    The simulation time horizon was chosen to be one year and the time step was set
    at one month.
  prefs: []
  type: TYPE_NORMAL
- en: Every simulated (or "realised") portfolio scenario consists of 12 monthly returns
    for each asset. From these returns, we calculated the total realised return and
    realised volatility for each asset (which, obviously, differ from their expected
    values *μ* and *σ*) and for the portfolio as a whole. We also calculated realised
    pairwise correlations between all assets according to the input uniform correlation
    *ρ*. Finally, we calculated individual assets and portfolio Sharpe ratios. For
    reference, with *ρ* = 0*.*1, *μ* = 0*.*075, *σ* = 0*.*15, and the constant risk-free
    interest rate set at *r*[0] = 0*.*015, the expected Sharpe ratio for each asset
    in the portfolio is 0.4\. The expected Sharpe ratio for the portfolio of *N* assets
    is significantly larger due to the diversification and low correlation between
    the assets, e.g., for a 48-asset portfolio we would expect Sharpe ratio values
    from 0.5 (25th percentile) to 2.1 (75th percentile) with a mean around 1.4\.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.4 Classical benchmark – Genetic Algorithm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We selected Genetic Algorithm (GA) as a classical benchmark heuristic, which
    is a popular choice for solving hard combinatorial optimisation problems. GAs
    are adaptive methods of searching a solution space by applying operators modelled
    after natural genetic inheritance and simulating the Darwinian struggle for survival.
    There is a rich history of GA applications to portfolio optimisation problems,
    including  [[172](Biblography.xhtml#XKondratyev2017), [179](Biblography.xhtml#XKshatriya2018)]
    recently.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of portfolio optimisation, the solution (chromosome) is a vector
    q := (*q*[1]*,…,q*[N]) consisting of *N* elements (genes) that can take binary
    values in {0*,*1}. The task is to find a combination of genes that minimises the
    cost (fitness) function *L*(q). Due to the solution being represented by a relatively
    short bit string, we do not use the crossover recombination mechanism as it provides
    very little value in improving the algorithm convergence. Algorithm [1](#x1-78010r1)
    provides a detailed description of the GA procedure.
  prefs: []
  type: TYPE_NORMAL
- en: '![--------------------------------------------------------------------- Algorithm
    1: GA − portfolio optimisation with cardinality con- -straint--------------------------------------------------------------
    Result: Optimal portfolio. 1: Generate L initial solutions by populating solutions
    with random draws from a pool of possible element values {0, 1}, with the restriction
    that "1" is assigned to the values of exactly M elements and "0" is assigned to
    the values of remaining N − M elements. 2: Evaluate the cost (fitness) function
    for each solution. 3: Rank the solutions from "best" to "worst" according to the
    cost function evaluation results. for i from 0 to number of iterations − 1 do
    | | | a) Select K best solutions from the previous generation and produce L |
    new | | solutions by randomly swapping the values of two elements with | opposite
    | | values. With L = mK, every one of the "best" solutions will be used to | produce
    m new solutions. | | | b) Evaluate the cost (fitness) function for each solution.
    | | c) Rank the solutions from "best" to "worst" according to the cost | function
    | | evaluation results. end ---------------------------------------------------------------------
    ](img/file352.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The optimal values of the parameters *L* and *K* depend on the problem size
    and the specific QUBO coefficient mapping scheme, and can be found through trial
    and error. The objective here is to achieve the target convergence with the smallest
    number of objective function calls.
  prefs: []
  type: TYPE_NORMAL
- en: Our first task is to verify that the proposed mapping schemes are sensible in
    the sense that the minimisation of the objective functions ([3.3.1](#x1-750001))
    and ([3.3.1](#x1-750001)) indeed leads to the construction of optimal portfolios.
    One possible approach to the problem of selecting *M* best assets from the universe
    of *N* investable assets is to select *M* individually best assets according to
    their individual Sharpe ratios. This approach would ignore the potential negative
    impact on diversification due to a probable large positive correlation between
    some of individually best assets, and there is no reason to believe that such
    a portfolio would be optimal. Therefore, we should demand that the optimal portfolio
    constructed by minimising *L*(q) + *L*[penalty](q) should outperform the portfolio
    of *M* individually best assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can compare the results for the optimal 24-asset portfolio
    selected from the universe of 48 assets (for 10,000 portfolio instances simulated
    with *ρ* = 0*.*1, *μ* = 0*.*075, *σ* = 0*.*15; as before, we assumed a constant
    risk-free interest rate *r*[0] = 0*.*015). Table [3.2](#x1-78012r2) displays the
    Sharpe ratio distribution statistics obtained for the sample QUBO coefficient
    mapping schemes provided by Table [3.1](#x1-76001r1)  [[296](Biblography.xhtml#XVenturelli2019)].
    The results are presented in the format: **mean** (25th percentile; 75th percentile).'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  |'
  prefs: []
  type: TYPE_TB
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  | Mapping schemes for b [ij] |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |'
  prefs: []
  type: TYPE_TB
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  | D | E | F |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Mapping | A | 4.7 (2.5; 6.4) | 4.5 (2.1; 6.1) | 4.0 (1.7; 5.5) |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| schemes | B | 4.8 (2.7; 6.5) | 4.3 (2.0; 5.9) | 4.2 (2.0; 5.8) |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| for a[i] | C | 5.0 (3.0; 6.7) | 4.8 (2.6; 6.3) | 4.6 (2.5; 6.1) |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.2: Sharpe ratio distribution statistics for different mapping schemes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the portfolio of individually best assets, the Sharpe ratio distribution
    statistics look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'mean: 3.8 25th percentile: 2.6 75th percentile: 4.7'
  prefs: []
  type: TYPE_NORMAL
- en: On average, the Sharpe ratio of the optimal portfolio is larger than that of
    the portfolio of individually best assets by 0*.*8, although some QUBO coefficient
    mapping schemes produce better results than others. Figure [3.3](#3.3) illustrates
    a better performance of the optimal portfolio found through the minimisation of
    the cost function *L*(q) + *L*[penalty](q) in comparison with the portfolio consisting
    of 24 individually best assets for the mapping schemes A and D.
  prefs: []
  type: TYPE_NORMAL
- en: Our second task is to understand how the time to solution scales with the problem
    size and whether quantum annealing can demonstrate a material speedup compared
    with the classical algorithm. It would be interesting to see what happens when
    we remove the constraint on the number of assets in the optimal portfolio. The
    portfolio optimisation results shown in Figure [3.3](#3.3) were obtained for *M*
    = *N∕*2, which is arguably the hardest combinatorial problem with a constraint
    on the number of assets, based on the size of the search space  [[175](Biblography.xhtml#XKondratyev2019)].
    From a brute force approach perspective, the problem becomes even harder computationally
    if we remove this constraint due to the solution space growing with *N* as 2^N
    instead of ![---N!---- M!(N− M)!](img/file353.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-78014r3: Sharpe ratio histogram (QUBO coefficients mapping schemes
    A and D). M = N∕2\. ](img/file354.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Sharpe ratio histogram (QUBO coefficients mapping schemes A and
    D). M = N∕2\.'
  prefs: []
  type: TYPE_NORMAL
- en: The removal of the cardinality constraint is also warranted by the fact that
    a large energy scale *P* in expression ([3.3.1](#x1-750001)) is typically associated
    with precision issues connected to the analog nature of the quantum annealing
    machine and the fact that there is a physical maximum to the energy that can be
    controllably programmed on local elements of the quantum chip. However, several
    hybrid quantum-classical strategies can be put in place to overcome this limitation.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, we observe that shifting artificially the Sharpe ratio values
    by a constant amount ±Δ (and adding buckets according to the prescription chosen,
    e.g., Table [3.1](#x1-76001r1)) will essentially amount to forcing the ground
    state solution of the unconstrained problem to have more or less a desired number
    of assets selected. Hence, while not solving the same problem, we could imagine
    a solver of a similarly constrained problem that will enclose the quantum annealing
    runs in a classical loop that checks for the number of selected assets *m*(Δ)
    in the best found solution with Δ = 0, then increases or decreases the individual
    desirability of the assets according to whether *m* is larger or smaller than
    *M* and runs again until *m*(Δ) = *M* for Δ = Δ^⋆. While in this case it is an
    approximation of the original problem, this sort of hybridisation scheme is not
    uncommon for quantum-assisted solvers  [[285](Biblography.xhtml#XTran2016)] and
    the number of expected rounds of runs should scale proportionally to log [2](Δ^⋆)
    as per a binary search, introducing a prefactor over the time-to-solution complexity
    that should stay manageable. Other hybrid approaches could also be put forward
    to deal with the constraint, such as fixing some asset selections in pre-processing
    via sample persistence  [[154](Biblography.xhtml#XKarimi2017)].
  prefs: []
  type: TYPE_NORMAL
- en: As per the preceding arguments, in our benchmark case study, we focus on running
    the unconstrained problem, setting Δ = 0\. Table [3.3](#x1-78016r3) provides the
    characteristics of the benchmark instance set  [[296](Biblography.xhtml#XVenturelli2019)].
    For a problem of the given size, the table reports the median number of assets
    in the optimal portfolio (and the minimum and the maximum in parenthesis), over
    30 instances, for the unconstrained portfolio optimisation problem.
  prefs: []
  type: TYPE_NORMAL
- en: '| Problem | Number of assets |'
  prefs: []
  type: TYPE_TB
- en: '| size | in the optimal portfolio |'
  prefs: []
  type: TYPE_TB
- en: '| N | (unconstrained problem) |'
  prefs: []
  type: TYPE_TB
- en: '| 42 | 16 (−7,+6) |'
  prefs: []
  type: TYPE_TB
- en: '| 48 | 17 (−6,+5) |'
  prefs: []
  type: TYPE_TB
- en: '| 54 | 19 (−7,+12) |'
  prefs: []
  type: TYPE_TB
- en: '| 60 | 23 (−13,+15) |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.3: Benchmark instance set characterisation.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.5 Establishing quantum speedup
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The aim is to solve representative portfolio instances at the limit of programmability
    for the D-Wave 2000Q quantum annealer. D-Wave 2000Q features 2,048 physical qubits;
    however, due to the limited connectivity of the D-Wave 2000Q *Chimera* graph,
    we can embed a maximum of 64 logical binary variables on a fully connected graph.
    Practically, we limit ourselves by working with up to 60 logical qubits, which
    means that the largest search space for our benchmarks is around 60!*∕*(30!)²
    ≃ 10^(17) if *M* = *N∕*2\. This constraint dictates the configuration of the instance
    set, which consists of 30 randomly generated instances for *N* = {42*,*48*,*54*,*60}
    assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned in Chapter [2](Chapter_2.xhtml#x1-480002), a common metric to
    benchmark the performance of non-deterministic iterative heuristics against quantum
    annealing is the Time-to-Solution (TTS)   [[250](Biblography.xhtml#XRonnow2014)].
    The latter is defined as the expected number of independent runs of the annealer
    in order to find the ground state with probability (confidence level) *α* ∈ (0*,*1):'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ log(1−-α-) TTS = trunlog(1− p), ](img/file355.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: where *t*[run] is the running time elapsed for a single run – either *τ* for
    forward annealing (see Section [3.2.1](#x1-720001)), or 2*τ* + *ρ* for reverse
    annealing (see Section [3.2.2](#x1-730002)) – and *p* is the probability of finding
    the optimum of the objective function in that single shot.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [3.4](#3.4) displays the TTS results for the GA, the forward QA solver,
    and the reverse QA solver for the unconstrained portfolio optimisation problem
    encoded using the mapping schemes A and D  [[296](Biblography.xhtml#XVenturelli2019)].
    In the figure, the markers are the median values and the error bars indicate the
    30th and the 70th percentiles over the 30-instance set. All TTS are measured,
    not counting the time required to run the greedy descent that initialises the
    initial ansatz 𝒮, nor the overhead times for operating the quantum annealer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-79003r4: Time-to-solution (99% confidence level): GA, forward and
    reverse quantum annealing. Unconstrained portfolio optimisation problem encoded
    using the mapping schemes A and D. ](img/file356.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Time-to-solution (99% confidence level): GA, forward and reverse
    quantum annealing. Unconstrained portfolio optimisation problem encoded using
    the mapping schemes A and D.'
  prefs: []
  type: TYPE_NORMAL
- en: The GA can also be initialised by the greedy search heuristics, and this also
    decreases the TTS required for the GA to find the global minimum. As was experimentally
    established in  [[296](Biblography.xhtml#XVenturelli2019)], the best results are
    obtained for the smallest possible annealing time and pause time (1 µs). In the
    median case, we observe one to three orders of magnitude in speedup when applying
    reverse quantum annealing with respect to forward quantum annealing or classical
    benchmark.
  prefs: []
  type: TYPE_NORMAL
- en: It is likely that the non-monotonic behaviour of the reverse quantum annealing
    TTS for *N* = 54 is not of fundamental significance but is due to the noise associated
    with the finite, small size of our instance set. Although the small size of the
    instance set makes it difficult to draw a definite conclusion about the scaling
    of QA with the problem size, it appears that reverse quantum annealing displays
    similar scaling to GAs for portfolios of up to *N* = 54 assets – as illustrated
    by the dashed regression lines. A worse scaling for the limit case of *N* = 60
    assets is probably due to the fact that, in this case, the physical qubit chains
    become too long and more likely to be broken. It is worth noting that for the
    same reason, *N* = 60 is also a very hard case for forward annealing. Reverse
    annealing displays significantly better scaling in comparison with forward annealing.
    While parameter *β* in ([2.3.2](Chapter_2.xhtml#x1-570002)) for forward annealing
    is equal to 0.3, it becomes 0.1 for reverse annealing.
  prefs: []
  type: TYPE_NORMAL
- en: Discrete portfolio optimisation is an NP-hard problem that can be solved on
    a quantum annealer using a hybrid quantum-classical reverse annealing technique
    with several orders of magnitude in quantum speedup (ignoring the measurement
    and system reset computational overheads). Although it is too early to say whether
    quantum annealing can become a widely adopted portfolio optimisation tool, there
    are indications that as technology and theory progress, it could represent a viable
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we applied quantum annealing to solving a discrete portfolio
    optimisation problem. We started with the principles of quadratic unconstrained
    binary optimisation and looked at several examples of NP-hard optimisation problems
    and their QUBO formulations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we introduced the concept of a quantum annealing protocol and specified
    two such protocols: forward annealing and reverse annealing. We also specified
    the classical benchmark: the genetic algorithm, an evolutionary search heuristic
    ideally suited for operations on binary variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we had all the necessary building blocks, we translated a sample discrete
    portfolio optimisation problem into QUBO and experimented with solving its instances
    on a D-Wave 2000Q quantum annealer. We collected sufficient statistics on various
    problem sizes to compare the performance of forward and reverse quantum annealing
    with the classical benchmark. We obtained encouraging results in terms of TTS,
    especially for the reverse quantum annealing protocol.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to apply quantum annealing to the problem
    of construction of a robust classifier. The proposed solution – quantum boosting
    – is a hybrid quantum-classical classifier (trained quantumly and run classically)
    that performs on a par with the standard classical models and, sometimes, outperforms
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Join our book’s Discord space
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Join our Discord community to meet like-minded people and learn alongside more
    than 2000 members at: [https://packt.link/quantum](https://packt.link/quantum)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
