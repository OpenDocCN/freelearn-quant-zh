["```py\nlibrary(RCurl)\nget_price <- function(){\n\n```", "```py\na <- getURL(\"https://www.bitcoinwisdom.com/markets/bitstamp/btcusd\", ssl.verifypeer=0L, followlocation=1L)\n\n```", "```py\n n <- as.numeric(regexpr(\"id=market_bitstampbtcusd>\", a))\n a <- substr(a, n, n + 100)\n n <- as.numeric(regexpr(\">\", a))\n m <- as.numeric(regexpr(\"</span>\", a))\n a <- substr(a, n + 1, m - 1)\n as.numeric(a)\n}\n\n```", "```py\nlibrary(XML)\nas.numeric(xpathApply(htmlTreeParse(a, useInternalNodes = TRUE), '//span[@id=\"market_bitstampbtcusd\"]', xmlValue)[[1]])\n\n```", "```py\nDrawChart <- function(time_frame_in_minutes,\n number_of_candles = 25, l = 315.5, u = 316.5) {\n\n OHLC <- matrix(NA, 4, number_of_candles)\n OHLC[, number_of_candles] <- get_price()\n dev.new(width = 30, height = 15)\n par(bg = rgb(.9, .9, .9))\n plot(x = NULL, y = NULL, xlim = c(1, number_of_candles + 1),\n ylim = c(l, u), xlab = \"\", ylab = \"\", xaxt = \"n\", yaxt = \"n\")\n abline(h = axTicks(2), v = axTicks(1), col = rgb(.5, .5, .5), lty = 3)\n axis(1, at = axTicks(1), las = 1, cex.axis = 0.6,\n labels = Sys.time() - (5:0) * time_frame_in_minutes)\n axis(2, at = axTicks(2), las = 1, cex.axis = 0.6)\n box()\n allpars = par(no.readonly = TRUE)\n while(TRUE) {\n start_ <- Sys.time()\n while(as.numeric(difftime(Sys.time(), start_, units = \"mins\")) < \n time_frame_in_minutes) {\n OHLC[4,number_of_candles] <- get_price()\n OHLC[2,number_of_candles] <- max(OHLC[2,number_of_candles], OHLC[4,number_of_candles])\nOHLC[3,number_of_candles] <- min(OHLC[3,number_of_candles], OHLC[4,number_of_candles])\n frame()\n par(allpars) \n abline(h = axTicks(2), v=axTicks(1), col = rgb(.5,.5,.5), lty = 3)\n axis(1, at = axTicks(1), las = 1, cex.axis = 0.6, labels = Sys.time()-(5:0)*time_frame_in_minutes)\n axis(2, at = axTicks(2), las = 1, cex.axis = 0.6)\n box()\n for(i in 1:number_of_candles) { \n polygon(c(i, i + 1, i + 1, i),\n c(OHLC[1, i], OHLC[1, i], OHLC[4, i], OHLC[4, i]), col = ifelse(OHLC[1,i] <= OHLC[4,i], rgb(0,0.8,0), rgb(0.8,0,0)))\n lines(c(i+1/2, i+1/2), c(OHLC[2,i], max(OHLC[1,i], OHLC[4,i])))\n lines(c(i+1/2, i+1/2), c(OHLC[3,i], min(OHLC[1,i], OHLC[4,i])))\n }\n abline(h = OHLC[4, number_of_candles], col = \"green\", lty = \"dashed\")\n }\n OHLC <- OHLC[, 2:number_of_candles]\n OHLC <- cbind(OHLC, NA)\n OHLC[1,number_of_candles] <- OHLC[4,number_of_candles-1]\n }\n}\n\n```", "```py\nDrawChart(30,50)\n\n```", "```py\nlibrary(quantmod)\nbitcoin <- read.table(\"Bitcoin.csv\", header = T, sep = \";\", row.names = 1)\nbitcoin <- tail(bitcoin, 150)\nbitcoin <- as.xts(bitcoin)\ndev.new(width = 20, height = 10)\nchartSeries(bitcoin, dn.col = \"red\", TA=\"addRSI(10);addEMA(10)\")\n\n```", "```py\nlibrary(quantmod)\nbitcoin <- read.table(\"Bitcoin.csv\", header = T, sep = \";\", row.names = 1)\nbitcoin <- tail(bitcoin, 150)\nbitcoin <- as.xts(bitcoin)\ndev.new(width = 20, height = 10)\nchartSeries(bitcoin, dn.col = \"red\", TA=\"addMACD();addSMA(10)\")\n\n```", "```py\nlibrary(quantmod)\nOHLC <- function(d) {\n windows(20,10)\n chartSeries(d, dn.col = \"red\")\n}\n\n```", "```py\nis.trend <- function(ohlc,i,j){\n\n```", "```py\navg1 = mean(ohlc[(i-25):i,4])\navg2 = mean(ohlc[(j-25):j,4])\nif(avg1 >= avg2) return(FALSE)\n\n```", "```py\nohlc <- ohlc[i:j, ]\n n <- nrow(ohlc)\n candle_l <- pmin(ohlc[, 1], ohlc[, 4])\n valley <- rep(FALSE, n)\n for (k in 2:(n - 1))\n valley[k] <- ((candle_l[k-1] >= candle_l[k]) & (candle_l[k+1] >= candle_l[k]))\n z <- candle_l[valley]\n if (all(z == cummax(z))) return(TRUE)\n FALSE\n}\n\n```", "```py\nis.trend.rev <- function(ohlc, i, j) {\n if (is.trend(ohlc, i, j) == FALSE) return(FALSE)\n last_candle <- ohlc[j + 1, ]\n\n reverse_candle <- ohlc[j + 2, ]\n ohlc <- ohlc[i:j, ]\n if (last_candle[4] < last_candle[1]) return(FALSE)\n if (last_candle[4] < max(ohlc[,c(1,4)])) return(FALSE)\n if (reverse_candle[1] < last_candle[4] |\n reverse_candle[4] >= last_candle[1]) return(FALSE)\n TRUE\n}\n\n```", "```py\nbitcoin <- read.table(\"Bitcoin.csv\", header = T, sep = \";\", row.names = 1)\nn <- nrow(bitcoin)\nresult <- c(0,0)\nfor (a in 26:726) {\n for (b in (a + 3):min(n - 3, a + 100)) {\n if (is.trend.rev(bitcoin, a,b) & b - a > 10 )\n result <- rbind(result, c(a,b))\n if (b == n)\n break\n }\n}\n\nz <- aggregate(result, by = list(result[, 2]), FUN = min)[-1, 2:3]\nfor (h in 1:nrow(z)) {\n OHLC(bitcoin[z[h, 1]:z[h, 2] + 2,])\n title(main = z[h, ])\n}\n\n```", "```py\ndata <- read.csv(\"Bitcoin.csv\", header = TRUE, sep = \",\")\ndata2 <- data[order(as.Date(data$Date, format = \"%Y-%m-%d\")), ]\nprice <- data2$Close\nHLC <- matrix(c(data2$High, data2$Low, data2$Close), nrow = length(data2$High))\n\n```", "```py\nbitcoin.lr <- diff(log(price))\ninstall.packages(\"TTR\")\nlibrary(TTR)\n\n```", "```py\nrsi    <- RSI(price)\nMACD   <- MACD(price)\nmacd   <- MACD[, 1]\nwill   <- williamsAD(HLC)\ncci    <- CCI(HLC)\nSTOCH  <- stoch(HLC)\nstochK <- STOCH[, 1]\nstochD <- STOCH[, 1]\n\n```", "```py\nInput <- matrix(c(rsi[700:939], cci[700:939], macd[700:939],will[700:939], stochK[700:939], stochD[700:939]), nrow = 240)\nTarget <- matrix(c(bitcoin.lr[701:940]), nrow = 240)\ntrainingdata <- cbind(Input, Target)\ncolnames(trainingdata) <- c(\"RSI\", \"CCI\", \"MACD\", \"WILL\", \"STOCHK\", \"STOCHD\", \"Return\")\n\n```", "```py\ninstall.packages(\"caret\")\nlibrary(caret)\n\n```", "```py\ntrainIndex <- createDataPartition(bitcoin.lr[701:940], p = .9, list = FALSE)\nbitcoin.train <- trainingdata[trainIndex, ]\nbitcoin.test <- trainingdata[-trainIndex, ]\n\n```", "```py\ninstall.packages(\"nnet\")\nlibrary(nnet)\n\n```", "```py\nbest.network <- matrix(c(5, 0.5))\nbest.rmse <- 1\nfor (i in 5:15)\n for (j in 1:3) {\n bitcoin.fit <- nnet(Return ~ RSI + CCI + MACD + WILL + STOCHK + STOCHD, data = bitcoin.train, maxit = 1000, size = i, decay = 0.01 * j, linout = 1)\n bitcoin.predict <- predict(bitcoin.fit, newdata = bitcoin.test)\n bitcoin.rmse <- sqrt(mean ((bitcoin.predict â€“ bitcoin.lr[917:940])^2))\n if (bitcoin.rmse<best.rmse) {\n best.network[1, 1] <- i\n best.network[2, 1] <- j\n best.rmse <- bitcoin.rmse\n }\n }\n\n```", "```py\nInputTest <- matrix(c(rsi[940:969], cci[940:969], macd[940:969], will[940:969], stochK[940:969], stochD[940:969]), nrow = 30)\nTargetTest <- matrix(c(bitcoin.lr[941:970]), nrow = 30) Testdata <- cbind(InputTest,TargetTest)\ncolnames(Testdata) <- c(\"RSI\", \"CCI\", \"MACD\", \"WILL\", \"STOCHK\", \"STOCHD\", \"Return\")\n\n```", "```py\nbitcoin.fit <- nnet(Return ~ RSI + CCI + MACD + WILL + STOCHK + STOCHD, data = trainingdata, maxit = 1000, size = best.network[1, 1], decay = 0.1 * best.network[2, 1], linout = 1)\nbitcoin.predict1 <- predict(bitcoin.fit, newdata = Testdata)\n\n```", "```py\nfor (i in 1:20) {\n bitcoin.fit <- nnet(Return ~ RSI + CCI + MACD + WILL + STOCHK + STOCHD, data = trainingdata, maxit = 1000, size = best.network[1, 1], decay = 0.1 * best.network[2, 1], linout = 1) \n bitcoin.predict <- predict(bitcoin.fit, newdata = Testdata)\n bitcoin.predict1 <- (bitcoin.predict1 + bitcoin.predict) / 2\n}\n\n```", "```py\nmoney <- money2 <- matrix(0,31)\nmoney[1,1] <- money2[1,1] <- 100\nfor (i in 2:31) {\n direction1 <- ifelse(bitcoin.predict1[i - 1] < 0, -1, 1)\n direction2 <- ifelse(TargetTest[i - 1] < 0, -1, 1)\n money[i, 1] <- ifelse((direction1 - direction2) == 0, money[i-1,1]*(1+abs(TargetTest[i - 1])),\n money[i-1,1]*(1-abs(TargetTest[i - 1])))\n money2[i, 1] <- 100 * (price[940 + I - 1] / price[940])\n}\n\n```", "```py\nx <- 1:31\nmatplot(cbind(money, money2), type = \"l\", xaxt = \"n\",\n ylab = \"\", col = c(\"black\", \"grey\"), lty = 1)\nlegend(\"topleft\", legend = c(\"Neural network\", \"Benchmark\"),\n pch = 19, col = c(\"black\", \"grey\"))\naxis(1, at = c(1, 10, 20, 30),\n lab = c(\"2014-04-08\", \"2014-04-17\", \"2014-04-27\", \"2014-05-07\"))\nbox()\nmtext(side = 1, \"Test dataset\", line = 2)\nmtext(side = 2, \"Investment value\", line = 2)\n\n```", "```py\nall_files <- list.files(\"data\")\nd <- read.table(file.path(\"data\", all_files[[1]]),\n sep = \",\", header = FALSE)\ncolnames(d) = c(\"date\", substr(all_files[[1]], 1, nchar(all_files[[1]]) - 4))\nfor (i in 2:length(all_files)) {\n d2 <- read.table(file.path(\"data\", all_files[[i]]), sep = \",\", header = FALSE)\n colnames(d2) = c(\"date\", substr(all_files[[i]], 1, nchar(all_files[[i]])-4))\n d <- merge(d, d2, sort = FALSE)\n}\n\n```", "```py\nlog_opt <- function(x, d, r = NA) {\n x <- c(x, 1 - sum(x))\n n <- ncol(d) - 1\n d[\"distance\"] <- c(1, dist(d[2:ncol(d)])[1:(nrow(d) - 1)])\n if (is.na(r)) r <- quantile(d$distance, 0.05)\n d[\"similarity\"] <- d$distance <= r\n d[\"similarity\"] <- c(d[2:nrow(d), \"similarity\"], 0)\n d <- d[d[\"similarity\"] == 1, ]\n log_return <- log(as.matrix(d[, 2:(n + 1)]) %*% x)\n sum(log_return)\n}\n\n```", "```py\nlog_optimization <- function(d, r = NA) {\n today <- d[1, 1]\n m <- ncol(d)\n constr_mtx <- rbind(diag(m - 2), rep(-1, m - 2))\n b <- c(rep(0, m - 2), -1)\n opt <- constrOptim(rep(1 / (m - 1), m - 2), function(x) -1 * log_opt(x, d), NULL, constr_mtx, b)\n result <- rbind(opt$par)\n rownames(result) <- today\n result\n}\n\n```", "```py\nsimulation <- function(d) {\n a <- Position( function(x) substr(x, 1, 2) == \"96\", d[, 1])\n b <- Position( function(x) substr(x, 1, 2) == \"97\", d[, 1])\n result <- log_optimization(d[b:a,])\n result <- cbind(result, 1 - sum(result))\n result <- cbind(result, sum(result * d[b + 1, 2:6]), sum(rep(1 / 5, 5) * d[b + 1, 2:6]))\n colnames(result) = c(\"w1\", \"w2\", \"w3\", \"w4\", \"w5\", \"Total return\", \"Benchmark\")\n for (i in 1:2490) {\n print(i)\n h <- log_optimization(d[b:a + i, ])\n h <- cbind(h, 1 - sum(h))\n h <- cbind(h, sum(h * d[b + 1 + i, 2:6]), sum(rep(1/5,5) * d[b + 1 + i, 2:6]))\n result <- rbind(result,h)\n }\n result\n}\nA <- simulation(d)\n\n```", "```py\nmatplot(cbind(cumprod(A[, 6]), cumprod(A[, 7])), type = \"l\",\n xaxt = \"n\", ylab = \"\", col = c(\"black\",\"grey\"), lty = 1)\nlegend(\"topright\", pch = 19, col = c(\"black\", \"grey\"),\n legend = c(\"Logoptimal portfolio\", \"Benchmark\"))\naxis(1, at = c(0, 800, 1600, 2400), lab = c(\"1997-01-02\", \"2001-03-03\", \"2003-05-13\", \"2006-07-17\"))\n\n```"]