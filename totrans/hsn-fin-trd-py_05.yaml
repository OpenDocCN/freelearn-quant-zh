- en: '*Chapter 3*: High-Speed Scientific Computing Using NumPy'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces us to NumPy, a high-speed Python library for matrix
    calculations. Most data science/algorithmic trading libraries are built upon NumPy's
    functionality and conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following key topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to NumPy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating NumPy n-dimensional arrays (ndarrays)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data types used with NumPy arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexing of ndarrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic ndarray operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File operations on ndarrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python code used in this chapter is available in the `Chapter03/numpy.ipynb`
    notebook in the book's code repository.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to NumPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multidimensional heterogeneous arrays can be represented in Python using lists.
    A list is a 1D array, a list of lists is a 2D array, a list of lists of lists
    is a 3D array, and so on. However, this solution is complex, difficult to use,
    and extremely slow.
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary design goals of the NumPy Python library was to introduce
    high-performant and scalable structured arrays and vectorized computations.
  prefs: []
  type: TYPE_NORMAL
- en: Most data structures and operations in NumPy are implemented in C/C++, which
    guarantees their superior speed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating NumPy ndarrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **ndarray** is an extremely high-performant and space-efficient data structure
    for multidimensional arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the NumPy library, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will start creating a 1D ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: Creating 1D ndarrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following line of code creates a 1D ndarray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s inspect the type of the array with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that the array is a NumPy ndarray, as can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can easily create ndarrays of two dimensions or more.
  prefs: []
  type: TYPE_NORMAL
- en: Creating 2D ndarrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a 2D ndarray, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The result has two rows and each row has two values, so it is a 2 x 2 ndarray,
    as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Creating any-dimension ndarrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An ndarray can construct arrays with arbitrary dimensions. The following code
    creates an ndarray of 2 x 2 x 2 x 2 dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The representation of the array is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'NumPy ndarrays have a `shape` attribute that describes the ndarray''s dimensions,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet shows that `arr1D` is a one-dimensional array with five
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can inspect the `shape` attribute on `arr2D` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the output describes it as being a 2 x 2 ndarray, as we can see
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In practice, there are certain matrices that are more frequently used, such
    as a matrix of 0s, a matrix of 1s, an identity matrix, a matrix containing a range
    of numbers, or a random matrix. NumPy provides support for generating these frequently
    used ndarrays with one command.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ndarray with np.zeros(...)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `np.zeros(...)` method creates an ndarray populated with all 0s, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is all 0s, with dimensions being 2 x 5, as illustrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating an ndarray with np.ones(...)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`np.ones(...)` is similar, but each value is assigned a value of 1 instead
    of 0\. The method is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a 2 x 2 ndarray with every value set to 1, as illustrated in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Creating an ndarray with np.identity(...)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often in matrix operations we need to create an identity matrix, which is available
    in the `np.identity(...)` method, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a 3 x 3 identity matrix with 1s on the diagonals and 0s everywhere
    else, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Creating an ndarray with np.arange(...)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`np.arange(...)` is the NumPy equivalent of the Python `range(...)` method.
    This generates values with a start value, end value, and increment, except this
    returns NumPy ndarrays instead, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The ndarray returned is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: By default, values start at 0 and increment by 1.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ndarray with np.random.randn(…)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`np.random.randn(…)` generates an ndarray of specified dimensions, with each
    element populated with random values drawn from a standard normal distribution
    (`mean=0`, `std=1`), as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is a 2 x 2 ndarray with random values, as illustrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Data types used with NumPy ndarrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NumPy ndarrays are homogenous—that is, each element in an ndarray has the same
    data type. This is different from Python lists, which can have elements with different
    data types (heterogenous).
  prefs: []
  type: TYPE_NORMAL
- en: The `np.array(...)` method accepts an explicit `dtype=` parameter that lets
    us specify the data type that the ndarray should use. Common data types used are
    `np.int32`, `np.float64`, `np.float128`, and `np.bool`. Note that `np.float128`
    is not supported on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: The primary reason why you should be conscious about the various numeric types
    for ndarrays is the memory usage—the more precision the data type provides, the
    larger memory requirements it has. For certain operations, a smaller data type
    may be just enough.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a numpy.float64 array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a 128-bit floating-values array, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Creating a numpy.bool array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can create an ndarray by converting specified values to the target type.
    In the following code example, we see that even though integer data values were
    provided, the resulting ndarray has `dtype` as `bool`, since the data type was
    specified to be `np.bool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The values are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We observe that the integer values (`-1, 0, 1`) were converted to `bool` values
    (`True, False, True`). `0` gets converted to `False`, and all other values get
    converted to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: ndarrays' dtype attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ndarrays have a `dtype` attribute to inspect the data type, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is a NumPy `dtype` object with a `float64` value, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Converting underlying data types of ndarray with numpy.ndarrays.astype(...)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can easily convert the underlying data type of an ndarray to any other compatible
    data type with the `numpy.ndarrays.astype(...)` method. For example, to convert
    `arr1D` from `np.float64` to `np.int64`, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This reflects the new data type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When `numpy.ndarray.astype(...)` converts to a narrower data type, it will
    truncate the values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This converts `arr1D` to the following integer-valued ndarray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The original floating values (1.1, 2.2, …) are converted to their truncated
    integer values (1, 2, …).
  prefs: []
  type: TYPE_NORMAL
- en: Indexing of ndarrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Array indexing refers to the way of accessing a particular array element or
    elements. In NumPy, all ndarray indices are zero-based—that is, the first item
    of an array has index `0`. Negative indices are understood as counting from the
    end of the array.
  prefs: []
  type: TYPE_NORMAL
- en: Direct access to an ndarray's element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Direct access to a single ndarray's element is one of the most used forms of
    access.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code builds a 3 x 3 random-valued ndarray for our use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `arr` ndarray has the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can index the first element with integer index `0`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the first row of the `arr` ndarray, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can access the element at the second column of the first row by using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'ndarrays also support an alternative notation to perform the same operation,
    as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'It accesses the same element as before, as can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `numpy.ndarray[index_0, index_1, … index_n]` notation is especially more
    concise and useful when accessing ndarrays with very large dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Negative indices start from the end of the ndarray, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the last row of the ndarray, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: ndarray slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While single ndarray access is useful, for bulk processing we require access
    to multiple elements of the array at once (for example, if the ndarray contains
    all daily prices of an asset, we might want to process only all Mondays' prices).
  prefs: []
  type: TYPE_NORMAL
- en: Slicing allows access to multiple ndarray records in one command. Slicing ndarrays
    also works similarly to slicing of Python lists.
  prefs: []
  type: TYPE_NORMAL
- en: The basic slice syntax is *i:j:k*, where *i* is the index of the first record
    we want to include, *j* is the stopping index, and *k* is the step.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing all ndarray elements after the first one
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To access all elements after the first one, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns all the rows after the first one, as illustrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Fetching all rows, starting from row 2 and columns 1 and 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similarly, to fetch all rows starting from the second one, and columns up to
    but not including the third one, run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a 2 x 2 ndarray as expected, as can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Slicing with negative indices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More complex slicing notation that mixes positive and negative index ranges
    is also possible, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a less intuitive way of finding the slice of an element at the second
    row and at the second column, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Slicing with no indices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Slicing with no indices yields the entire row/column. The following code generates
    a slice containing all elements on the third row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code generates a slice of the original `arr` ndarray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Setting values of a slice to 0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Frequently, we will need to set certain values of an ndarray to a given value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s generate a slice containing the second row of `arr` and assign it to
    a new variable, `arr1`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`arr1` now contains the last row, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s set every element of `arr1` to the value `0`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, `arr1` now contains all 0s, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s re-inspect our original `arr` ndarray, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that our operation on the `arr1` slice also changed the original `arr`
    ndarray. This brings us to the most important point: ndarray slices are views
    into the original ndarrays, not copies.'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember this when working with ndarrays so that we do not
    inadvertently change something we did not mean to. This design is purely for efficiency
    reasons, since copying large ndarrays incurs large overheads.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a copy of an ndarray, we explicitly call the `numpy.ndarray.copy(...)`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s change some values in the `arr_copy` ndarray, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the change in `arr_copy` in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s inspect the original `arr` ndarray as well, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We see that the original ndarray is unchanged since `arr_copy` is a copy of
    `arr` and not a reference/view to it.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean indexing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NumPy provides multiple ways of indexing ndarrays. NumPy arrays can be indexed
    by using conditions that evaluate to `True` or `False`. Let''s start by regenerating
    an `arr` ndarray, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a 3 x 3 ndarray with random values, as can be seen in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s revisit the output of running the following code, which is really just
    calling the `np.less(...)` `np.less(arr, 0)`) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates another ndarray of `True` and `False` values, where `True` means
    the corresponding element in `arr` was negative and `False` means the corresponding
    element in `arr` was not negative, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use that array as an index to `arr` to find the actual negative elements,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, this fetches the following negative values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine multiple conditions with `&` (and) and `|` (or) operators. Python''s
    `&` and `|` Boolean operators do not work on ndarrays since they are for scalars.
    An example of a `&` operator is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates an ndarray with the value `True`, where the elements are between
    `-1` and `1` and `False` otherwise, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw before, we can use that Boolean array to index `arr` and find the
    actual elements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is an array of elements that satisfied the condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Indexing with arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ndarray indexing also allows us to directly pass lists of indices of interest.
    Let''s first generate an ndarray of random values to use, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We can select the first and third rows, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is a 2 x 3 ndarray containing the two rows, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine row and column indexing using arrays, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives us the second column of the first and third rows,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also change the order of the indices passed, and this is reflected in
    the output. The following code picks out the third row followed by the first row,
    in that order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The output reflects the two rows in the order we expected (third row first;
    first row second), as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have learned how to create ndarrays and about the various ways to
    retrieve the values of their elements, let's discuss the most common ndarray operations.
  prefs: []
  type: TYPE_NORMAL
- en: Basic ndarray operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following examples, we will use an `arr2D` ndarray, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a 2 x 2 ndarray with values from `1` to `4`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Scalar multiplication with an ndarray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scalar multiplication with an ndarray has the effect of multiplying each element
    of the ndarray, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Linear combinations of ndarrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following operation is a combination of scalar and ndarray operations,
    as well as operations between ndarrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is what we would expect, as can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Exponentiation of ndarrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can raise each element of the ndarray to a certain power, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Addition of an ndarray with a scalar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Addition of an ndarray with a scalar works similarly, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Transposing a matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finding the transpose of a matrix, which is a common operation, is possible
    in NumPy with the `numpy.ndarray.transpose(...)` method, as illustrated in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This transposes the ndarray and outputs it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Changing the layout of an ndarray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `np.ndarray.reshape(...)` method allows us to change the layout (shape)
    of the ndarray without changing its data to a compatible shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to reshape `arr2D` from 2 x 2 to 4 x 1, we use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The new reshaped 4 x 1 ndarray is displayed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code example combines `np.random.randn(...)` and `np.ndarray.reshape(...)`
    to create a 3 x 3 ndarray of random values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated 3 x 3 ndarray is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Finding the minimum value in an ndarray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To find the minimum value in an ndarray, we use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Calculating the absolute value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `np.abs(...)` method, shown here, calculates the absolute value of an ndarray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The output ndarray is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Calculating the mean of an ndarray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `np.mean(...)` method, shown here, calculates the mean of all elements
    in the ndarray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The mean of the elements of `arr` is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'We can find the mean along the columns by specifying the `axis=` parameter,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the following array, containing the mean for each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can find the mean along the rows by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'That returns the following array, containing the mean for each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Finding the index of the maximum value in an ndarray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, we''re interested in finding where in an array its largest value is.
    The `np.argmax(...)` method finds the location of the maximum value in the ndarray,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the following value, to represent the location of the maximum
    value (`2.60439882`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The `np.argmax(...)` method also accepts the `axis=` parameter to perform the
    operation row-wise or column-wise, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'This finds the location of the maximum value on each row, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Calculating the cumulative sum of elements of an ndarray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To calculate the running total, NumPy provides the `np.cumsum(...)` method.
    The `np.cumsum(...)` method, illustrated here, finds the cumulative sum of elements
    in the ndarray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The output provides the cumulative sum after each additional element, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Notice the difference between a cumulative sum and a sum. A cumulative sum is
    an array of a running total, whereas a sum is a single number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying the `axis=` parameter to the `cumsum` method works similarly, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'This goes row-wise and generates the following array output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Finding NaNs in an ndarray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Missing or unknown values are often represented in NumPy using a **Not a Number**
    (**NaN**) value. For many numerical methods, these must be removed or replaced
    with an interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s set the second row to `np.nan`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The new ndarray has the NaN values, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The `np.isnan(...)` ufunc finds if values in an ndarray are NaNs, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is an ndarray with a `True` value where NaNs exist and a `False`
    value where NaNs do not exist, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Finding the truth values of x1>x2 of two ndarrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Boolean ndarrays are an efficient way of obtaining indices for values of interest.
    Using Boolean ndarrays is far more performant than looping over the matrix elements
    one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build another `arr1` ndarray with random values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a 3 x 3 ndarray, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, let''s build another `arr2` ndarray, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The `np.greater(...)` function is a binary ufunc that generates a `True` value
    when the left-hand-side value in the ndarray is greater than the right-hand-side
    value in the ndarray. This function can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is an ndarray of `True` and `False` values as described previously,
    as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The `>` infix operator, shown in the following snippet, is a shorthand of `numpy.greater(...)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is the same, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: any and all Boolean operations on ndarrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to relational operators, NumPy supports additional methods for testing
    conditions on matrices' values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code generates an ndarray containing `True` for elements that
    satisfy the condition, and `False` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `numpy.ndarray.any(...)` method returns `True` if any element
    is `True` and otherwise returns `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have at least one element that is `True`, so the output is `True`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, it accepts the common `axis=` parameter and behaves as expected, as
    we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'And the operation performed row-wise yields, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `numpy.ndarray.all(...)` method returns `True` when all elements
    are `True`, and `False` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the following, since not all elements are `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'It also accepts the `axis=` parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, each row has at least one `False` value, so the output is `False`, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Sorting ndarrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finding an element in a sorted ndarray is faster than processing all elements
    of the ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s generate a 1D random array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The ndarray contains the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The `np.sort(...)` method is pretty straightforward, as can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s inspect the original ndarray to see if it was modified by the `numpy.sort(...)`
    operation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows that the original array is unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `np.argsort(...)` method creates an array of indices that represent
    the location of each element in a sorted array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this operation generates the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'NumPy ndarrays have the `numpy.ndarray.sort(...)` method as well, which sorts
    arrays in place. This method is illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'After the call to `sort()`, we call `numpy.argsort(...)` to make sure the array
    was sorted, and this yields the following array that confirms that behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Searching within ndarrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finding indices of elements where a certain condition is met is a fundamental
    operation on an ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we start with an ndarray with consecutive values, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates the following ndarray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a second ndarray based on the first one, except this time the values
    in the second one are multiplied by `1000`, as illustrated in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we know `arr2` contains the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'We define another ndarray that contains 10 `True` and `False` values randomly,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'The values in the `cond` ndarray are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'The `np.where(...)` method allows us to select values from one ndarray or another,
    depending on the condition being `True` or `False`. The following code will generate
    an ndarray with a value picked from `arr1` when the corresponding element in the
    `cond` array is `True`; otherwise, the value is picked from `arr2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned array is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: File operations on ndarrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most NumPy arrays are read in from files and, after processing, written out
    back to files.
  prefs: []
  type: TYPE_NORMAL
- en: File operations with text files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key advantages of text files are that they are human-readable and compatible
    with any custom software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the following random array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'This array contains the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: The `numpy.savetxt(...)` method saves the ndarray to disk in text format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses a `fmt=''%0.2lf''` format string and specifies a
    comma delimiter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s inspect the `arr.csv` file written out to disk in the current directory,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'The **comma-separated values** (**CSV**) file contains the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'The `numpy.loadtxt(...)` method loads an ndarray from text file to memory.
    Here, we explicitly specify the `delimiter='',''` parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'And the ndarray read in from the text file contains the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: File operations with binary files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Binary files are far more efficient for computer processing—they save and load
    more quickly and are smaller than text files. However, their format may not be
    supported by other software.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `numpy.save(...)` method stores ndarrays in a binary format, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the `arr.npy` file is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15029_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `numpy.save(...)` method automatically assigns the `.npy` extension to binary
    files it creates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `numpy.load(...)` method, shown in the following code snippet, is used
    for reading binary files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'The newly read-in ndarray is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Another advantage of having binary file formats is that data can be stored with
    extreme precision, especially when dealing with floating values, which is not
    always possible with text files since there is some loss of precision in certain
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check if the old `arr` ndarray and the newly read-in `arr_new` array
    match exactly, by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate the following array, containing `True` if the elements are
    equal and `False` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: So, we see that each element matches exactly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to create matrices of any dimension in
    Python, how to access the matrices' elements, how to calculate basic linear algebra
    operations on matrices, and how to save and load matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Working with NumPy matrices is a principal operation for any data analysis since
    vector operations are machine-optimized and thus are much faster than operations
    on Python lists—usually between 5 and 100 times faster. Backtesting any algorithmic
    strategy typically consists of processing enormous matrices, and then the speed
    difference can translate to hours or days of saved time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we introduce the second most important library for data
    analysis: Pandas, built upon NumPy. NumPy provides support for data manipulations
    based upon DataFrames (a DataFrame is the Python version of an Excel worksheet—that
    is, a two-dimensional data structure where each column has its own type).'
  prefs: []
  type: TYPE_NORMAL
