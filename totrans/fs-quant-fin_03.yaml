- en: Chapter 3. Financial Mathematics and Numerical Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the reader will be introduced to the basic numerical analysis
    and algorithm implementation in F#. We will look at how integer and floating-point
    numbers are implemented, and we will also look at their respective limitations.
    The basic statistics are covered, and the existing functions in F# are studied
    and compared with custom implementations.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will build up the foundation of numerical analysis that can be
    used when we look at option pricing and volatility later on. We'll also use some
    of the functionality covered in the previous chapter to implement the mathematical
    functions for aggregate statistics and to illustrate their usefulness in real
    life.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing algorithms in F#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numerical concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing basic financial equations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Curve fitting and regression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrices and vectors in F#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the number representation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will show you how numbers are represented as integers or
    floating-point numbers in computers. Numbers form the foundation of computers
    and programming. Everything in a computer is represented by the binary numbers,
    ones and zeroes. Today, we have 64-bit computers that enable us to have a 64-bit
    representation of integers and floating-point numbers naively in the CPU. Let's
    take a deeper look at how integers and floating-point numbers are represented
    in the following two sections.
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we talk about integers, denoted as Z, we are talking specifically about
    machine-precision integers that are represented exactly in the computer with a
    sequence of bits. Also, an integer is a number that can be written without a fractional
    or decimal component and is denoted as Z by convention. For example, 0 is represented
    as 000000..., 1 is represented as ...000001, 2 is represented as ...000010, and
    so on. As you can see from this pattern, numbers are represented in the power
    of two. To represent negative numbers, the number range is divided into two halves
    and uses two's complement.
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about integer representation without any negative numbers, that
    is, numbers from zero and up, we talk about unsigned integers.
  prefs: []
  type: TYPE_NORMAL
- en: Two's complement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two's complement is a way of dividing a range of binary numbers into positive
    and negative decimal numbers. In this way, both positive and negative numbers
    can be represented in the computer. On the other hand, this means that the range
    of numbers is the half for two's complement in relation to the unsigned representation.
    Two's complement is the main representation used for signed integers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Two''s complement](img/4623OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The representation of integers in two's complement can be thought of as a ring,
    as illustrated in the preceding figure. The overflow occurs when the maximum allowed
    positive or negative value increases. Overflow simply means that we pass the barrier
    between positive and negative numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows some integers and the representation of their two''s
    complement:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Decimal | Two''s complement |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 127 | 0111 1111 |'
  prefs: []
  type: TYPE_TB
- en: '| 64 | 0100 0000 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0000 0001 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0000 0000 |'
  prefs: []
  type: TYPE_TB
- en: '| -1 | 1111 1111 |'
  prefs: []
  type: TYPE_TB
- en: '| -64 | 1100 0000 |'
  prefs: []
  type: TYPE_TB
- en: '| -127 | 1000 0001 |'
  prefs: []
  type: TYPE_TB
- en: '| -128 | 1000 0000 |'
  prefs: []
  type: TYPE_TB
- en: 'As you can see, the range for the 8-bit signed integers is from -128 to -127\.
    In more general terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two''s complement](img/4623OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Floating-point numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Floating-point numbers, denoted as R, represent a quantity where decimals are
    needed to define them. Another way of describing these numbers is to think of
    them as values represented as a quantity along a continuous line. They are needed
    to model things in real life, such as economic, statistical, and physical quantities.
    In the machine, floating-point numbers are represented by the IEEE 754 standard.
  prefs: []
  type: TYPE_NORMAL
- en: The IEEE 754 floating-point standard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The IEEE 754 floating-point standard describes floating-points using a mantissa
    and an exponent; see the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a 64-bit floating point number is made up of the following bit
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Sign bit | Exponent | Mantissa |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 bit | 11 bits | 52 bits |'
  prefs: []
  type: TYPE_TB
- en: '![The IEEE 754 floating-point standard](img/4623OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of floating-point numbers and their binary representations are shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Binary representation | Floating-point number |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0000000000000000 | 0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x3ff0000000000000 | 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0xc000000000000000 | -2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x4000000000000000 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x402E000000000000 | 15.0 |'
  prefs: []
  type: TYPE_TB
- en: 'F# Interactive is capable of decoding the representations of floating-point
    numbers in hexadecimal format into floating-points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try out the preceding binary representations in F# Interactive.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about numerical types in F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In F#, as in most other modern languages, there is a variety of numerical types.
    The main reason for this is to enable you, as a programmer, to choose the most
    appropriate numerical type at any given situation. Sometimes there is no need
    for a 64-bit integer as 8-bit will be enough for small numbers. Another aspect
    is memory efficiency and consumption, that is, 64-bit integers will consume eight
    times as much as 8-bit integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a table with the most common numerical types used in the F#
    code. They come in two main varieties; integers and floating-point numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| byte | 8-bit unsigned integers | 10uy, 0xA0uy |'
  prefs: []
  type: TYPE_TB
- en: '| sbyte | 8-bit signed integers | 10y |'
  prefs: []
  type: TYPE_TB
- en: '| int16 | 16-bit signed integers | 10s |'
  prefs: []
  type: TYPE_TB
- en: '| uint16 | 16-bit unsigned integers | 10us |'
  prefs: []
  type: TYPE_TB
- en: '| int, int32 | 32-bit signed integers | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| uint32 | 32-bit unsigned integers | 10u |'
  prefs: []
  type: TYPE_TB
- en: '| int64 | 64-bit signed integers | 10L |'
  prefs: []
  type: TYPE_TB
- en: '| uint64 | 64-bit unsigned integers | 10UL |'
  prefs: []
  type: TYPE_TB
- en: '| nativeint | Hardware-sized signed integers | 10n |'
  prefs: []
  type: TYPE_TB
- en: '| unativeint | Hardware-sized signed integers | 10un |'
  prefs: []
  type: TYPE_TB
- en: '| single, float32 | 32-bit IEEE 754 floating-point | 10.0f |'
  prefs: []
  type: TYPE_TB
- en: '| double, float | 64-bit IEEE 754 floating-point | 10.0 |'
  prefs: []
  type: TYPE_TB
- en: '| decimal | High-precision decimal | 10.0M |'
  prefs: []
  type: TYPE_TB
- en: '| bigint | Arbitrary precision integers | 10I |'
  prefs: []
  type: TYPE_TB
- en: '| complex | Complex numbers using 64-bit floats | Complex(10.0, 10.0) |'
  prefs: []
  type: TYPE_TB
- en: 'The following are some examples of how to use suffixes for integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Arithmetic operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arithmetic operators should be familiar to you; however, we'll cover them in
    this section for consistency. The operators work as expected, and the succeeding
    table illustrates this using an example for each one. The remainder operator that
    returns the remainder from an integer division is worth noticing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example to see this in more detail. First, we try to divide
    10 by 2, and the remainder is 0 as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to divide 10 by 3, we get 1 as the remainder, because 3 x 3 = 9,
    and 10 – 9 = 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table shows arithmetic operators with examples and a description:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Example | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| + | x + y | Addition |'
  prefs: []
  type: TYPE_TB
- en: '| - | x - y | Subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| * | x * y | Multiplication |'
  prefs: []
  type: TYPE_TB
- en: '| / | x / y | Division |'
  prefs: []
  type: TYPE_TB
- en: '| % | x % y | Remainder |'
  prefs: []
  type: TYPE_TB
- en: '| - | -x | Unary minus |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arithmetic operators do not check for overflow. If you want to check for overflow,
    you can use the `Checked` module. You can find more about the `Checked` module
    at [http://msdn.microsoft.com/en-us/library/vstudio/ee340296.aspfx](http://msdn.microsoft.com/en-us/library/vstudio/ee340296.aspfx).
  prefs: []
  type: TYPE_NORMAL
- en: Learning about arithmetic comparisons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arithmetic comparisons are used to compare two numbers for relationships. It''s
    good to know all the operators that are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Example | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| < | x < y | Less than |'
  prefs: []
  type: TYPE_TB
- en: '| <= | x <= y | Less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | x > y | Greater than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | x >= y | Greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| (=) | x = y | Equality |'
  prefs: []
  type: TYPE_TB
- en: '| <> | x <> y | Inequality |'
  prefs: []
  type: TYPE_TB
- en: '| min | min x y | Minimum |'
  prefs: []
  type: TYPE_TB
- en: '| max | max x y | Maximum |'
  prefs: []
  type: TYPE_TB
- en: 'Some examples of arithmetic comparisons are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also worth noticing that you can''t compare numbers of different types
    in F#. To do this, you have to convert one of them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Math operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table of mathematical operators covers the most basic mathematical
    functions that are expected to be found in a programming language or its standard
    libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Example | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| abs | abs x | Overloaded absolute value |'
  prefs: []
  type: TYPE_TB
- en: '| acos | acos x | Overloaded inverse cosine |'
  prefs: []
  type: TYPE_TB
- en: '| asin | asin x | Overloaded inverse sine |'
  prefs: []
  type: TYPE_TB
- en: '| atan | atan x | Overloaded inverse tangent |'
  prefs: []
  type: TYPE_TB
- en: '| ceil | ceil x | Overloaded floating-point ceil |'
  prefs: []
  type: TYPE_TB
- en: '| cos | cos x | Overloaded cosine |'
  prefs: []
  type: TYPE_TB
- en: '| exp | exp x | Overloaded exponent |'
  prefs: []
  type: TYPE_TB
- en: '| floor | floor x | Overloaded floating-point floor |'
  prefs: []
  type: TYPE_TB
- en: '| log | log x | Overloaded natural logarithm |'
  prefs: []
  type: TYPE_TB
- en: '| log10 | log10 x | Overloaded base-10 logarithm |'
  prefs: []
  type: TYPE_TB
- en: '| (**) | x ** y | Overloaded exponential |'
  prefs: []
  type: TYPE_TB
- en: '| pown | pown x y | Overloaded integer exponential |'
  prefs: []
  type: TYPE_TB
- en: '| round | round x | Overloaded rounding |'
  prefs: []
  type: TYPE_TB
- en: '| sin | sin x | Overloaded sine function |'
  prefs: []
  type: TYPE_TB
- en: '| sqrt | sqrt x | Overloaded square root function |'
  prefs: []
  type: TYPE_TB
- en: '| tan | tan x | Overloaded tangent function |'
  prefs: []
  type: TYPE_TB
- en: Conversion functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are no implicit conversions in F# as conversions have to be done manually
    using conversion routines. Conversion must be made explicitly between types using
    the operators that are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Example | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| byte | byte x | Overloaded conversion to a byte |'
  prefs: []
  type: TYPE_TB
- en: '| sbyte | sbyte x | Overloaded conversion to a signed byte |'
  prefs: []
  type: TYPE_TB
- en: '| int16 | int16 | Overloaded conversion to a 16-bit integer |'
  prefs: []
  type: TYPE_TB
- en: '| uint16 | uint16 | Overloaded conversion to an unsigned 16-bit integer |'
  prefs: []
  type: TYPE_TB
- en: '| int32, int | Int32 x, int x | Overloaded conversion to a 32-bit integer |'
  prefs: []
  type: TYPE_TB
- en: '| uint32 | uint32 x | Overloaded conversion to an unsigned 32-bit integer |'
  prefs: []
  type: TYPE_TB
- en: '| int64 | int64 x | Overloaded conversion to a 64-bit integer |'
  prefs: []
  type: TYPE_TB
- en: '| uint64 | uint64 x | Overloaded conversion to an unsigned 64-bit integer |'
  prefs: []
  type: TYPE_TB
- en: '| nativeint | nativeint x | Overloaded conversion to a native integer |'
  prefs: []
  type: TYPE_TB
- en: '| unativeint | unativeint x | Overloaded conversion to an unsigned native integer
    |'
  prefs: []
  type: TYPE_TB
- en: '| float, double | float x, double x | Overloaded conversion to a 64-bit IEEE
    floating-point number |'
  prefs: []
  type: TYPE_TB
- en: '| float32, single | float32 x, single x | Overloaded conversion to a 32-bit
    IEEE floating-point number |'
  prefs: []
  type: TYPE_TB
- en: '| decimal | decimal x | Overloaded conversion to a System.decimal number |'
  prefs: []
  type: TYPE_TB
- en: '| char | char x | Overloaded conversion to a System.Char value |'
  prefs: []
  type: TYPE_TB
- en: '| enum | enum x | Overloaded conversion to a typed enum value |'
  prefs: []
  type: TYPE_TB
- en: This means that there will never be any automatic type conversion behind the
    scenes that may lead to loss of precision. For example, numbers are not converted
    from floating-points to integers just to fit the code that you have written. The
    compiler will tell you that there is an error in the code before converting it
    (it will never be converted by the compiler). The positive side about this is
    that you always know the representation of your numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll look at statistics using both built-in functions and
    simple custom ones. Statistics are used a lot throughout quantitative finance.
    Larger time series are often analyzed, and F# has great support for sequences
    of numbers; some of its power will be illustrated in the examples mentioned in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Aggregated statistics is all about statistics on aggregated data such as sequences
    of numbers collected from measurements. It's useful to know the average value
    in such a collection; this tells us where the values are centered. The `min` and
    `max` values are also useful to determine the extremes in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: In F#, the `Seq` module has this functionality built-in. Let's take a look at
    how to use it in each case using an example.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the sum of a sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider a sequence of 100 random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can calculate the sum of the preceding sequence, `data`, using the pipe
    operator and then the module function `Seq.sum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the result, `sum`, will vary from time to time due to the fact that
    we use a random number generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You might think that the `sum` function is not the most useful one; but there
    are times you need it, and knowing about its existence in the module library will
    save you time.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the average of a sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this example, let''s modify the random seed function a bit to generate
    500 numbers between 0 and 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected value of this sequence is 5 because of the distribution of the
    random function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The value may vary a bit due to the fact that we generate numbers randomly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the average value is almost 5\. If we generate more numbers, we
    will soon come closer and closer to the theoretical expected value of 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Calculating the minimum of a sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of iterating the sequence and keeping track of the minimum value using
    some kind of a loop construct with a temporary variable, we lend ourselves towards
    the functional approach in F#. To calculate the minimum of a sequence, we use
    the module function `Seq.min`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This looks a lot like the preceding code seen, except that we generate 10 random
    numbers and inspect the values in the list. If we manually look for the smallest
    value and then compare it to the one calculated by F#, we see that they match.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the maximum of a sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following example, we''ll use `Seq.max` to calculate the maximum number
    of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Calculating the variance and standard deviation of a sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have already used the existing functions for our statistical analysis.
    Now, let's implement variance and standard deviation.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating variance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s use the following function and calculate the variance for a dice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A dice has six discrete outcomes, one to six, where every outcome has equal
    probability. The expected value is 3.5, (1 + 2 + 3 + 4 + 5 + 6)/6\. The variance
    of a dice is calculated using the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Calculating standard deviation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We start by implementing the standard deviation function using the previously
    defined `variance` function. According to statistics, standard deviation is the
    square root of the variance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function works just fine, but to illustrate the power of sequences,
    we will implement the standard deviation using the `fold` function. The `fold`
    function will apply a given function to every element and accumulate the result.
    The `0.0` value in the end just means that we don''t have an initial value. You
    may remember this from the section about `fold` in the previous chapter. If we
    were to fold using multiplication, `1.0` is used instead as the initial value.
    In the end, we just pass the sum to the square root function, `sqrt`, and we are
    done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s verify using some sample data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can go back and analyze the random data that was generated and used
    earlier when we looked at the build in the sequence functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the fact that the square of the standard deviation is equal to
    the variance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Looking at an example application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The example application that we''ll look at in this section is a combination
    of the parts that we looked at in this chapter and will simply produce an output
    with statistics about the given sequence of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Evaluating the code results in an output of the statistical properties of the
    random sequence generated is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This means that the sequence has an approximate mean value of 5.15 and an approximate
    standard deviation of 2.94\. Using these facts, we can rebuild the distribution
    assuming that the numbers are distributed according to any of the known distributions,
    such as normal distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Math.NET library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of implementing your own functions for numerical support, there is an
    excellent library called **Math.NET**. It's an open-source library covering fundamental
    mathematics such as linear algebra and statistics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Math.NET library consists of the following libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Math.NET numerics**: Numerical computing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Math.NET neodym**: Signal processing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Math.NET linq algebra**: Computer algebra'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Math.NET yttrium**: Experimental network computer algebra'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we'll look at Math.NET numerics, and see how it can help us
    in our F# programming. First, we need to make sure that Math.NET is installed
    on our system.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Math.NET library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Math.NET library can be installed using the built-in **Package Manager**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the Math.NET library](img/4623OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Open the **Package Manager Console** by going to **View** | **Other Windows**
    | **Package Manager Console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Wait for the installation to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read more about the Math.NET project on the project''s website: [http://www.mathdotnet.com/](http://www.mathdotnet.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to random number generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by looking at the various ways of generating random numbers. Random
    numbers are frequently used in statistics and simulations. They are used extensively
    in the Monte Carlo simulations. Before we start looking at Math.NET and how to
    generate random numbers, we need a little bit of the background theory.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo-random numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In computers and programming, random numbers often refer to pseudo-random numbers.
    Pseudo-random numbers appear to be random, but they are not. In other words, they
    are deterministic if some properties of the algorithm and the seed that is used
    are known. The seed is the input to the algorithm to generate the number. Often,
    one chooses the seed to be the current time of the system or another unique number.
  prefs: []
  type: TYPE_NORMAL
- en: The random number generator in the `System.Random` class that is provided with
    the .NET platform is based on a subtractive random number generator algorithm
    by *Donald E. Knuth*. This algorithm will generate the same series of numbers
    if the same seed is used.
  prefs: []
  type: TYPE_NORMAL
- en: Mersenne Twister
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Mersenne Twister pseudo random number generator is capable of producing
    less deterministic numbers in an efficient way. These properties make this algorithm
    one of the most popular ones used today. The following is an example of how to
    use this algorithm in Math.NET:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In F# Interactive, we can generate some numbers using Mersenne Twister:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Probability distributions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probability distributions are commonly used in statistics and finance. They
    are used to analyze and categorize a set of samples to investigate their statistical
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Normal distribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Normal distribution is one of the most commonly used probability distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Math.NET, normal distribution can be used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the preceding example, we create a normal distribution with zero mean
    and a standard deviation of one. We can also retrieve the mean, variance, and
    standard deviation from a distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the mean and standard deviation is the same as we specified in
    the constructor of the `Normal` class. It''s also possible to generate random
    numbers from a distribution. We can use the preceding distribution to generate
    some random numbers, from the properties that are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Math.NET library, there are also other distributions such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Poisson
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log normal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Erlang
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binomial
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Math.NET, there is also great support for descriptive statistics that can
    be used to determine the properties of a collection of samples. The samples can
    be numbers from a measurement or generated by the same library.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll look at an example where we'll analyze a collection of
    samples with known properties, and see how the `DescriptiveStatistics` class can
    help us out.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by generating some data to be analyzed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the conversion from `Seq` to `List`; this is done because otherwise,
    `samples` will be a lazy collection. This means that the collection will be a
    set of different numbers every time it''s used in the program, which is not what
    we want in this case. Next we instantiate the `DescriptiveStatistics` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It will take the samples that were previously created and create an object
    that describes the statistical properties of the numbers in the `samples` list.
    Now, we can get some valuable information about the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look closer at the mean, variance, and standard deviation respectively,
    we see that they correspond well with the expected values for the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Linear regression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linear regression is heavily used in statistics where sample data is analyzed.
    Linear regression tells the relationship between two variables. It is currently
    not part of Math.NET but can be implemented using it. Regression in Math.NET is
    an asked-for feature; and hopefully, it will be supported natively by the library
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Using the least squares method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's look at one of the most commonly used methods in linear regression, the
    least squares method. It's a standard approach to find the approximate solution
    using the least squares method. The least squares method will optimize the overall
    solution with respect to the squares of the error, which means that it will find
    the solution that best fits the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an implementation of the least squares method in F# using
    Math.NET for the linear algebra part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The independent data `y` and the dependent data `x` are used as inputs to the
    solver. You can use any linear relationship here, between `x` and `y`. The regression
    coefficients will tell us the properties of the regression line, `y` = `ax` +
    `b`.
  prefs: []
  type: TYPE_NORMAL
- en: Using polynomial regression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we're going to look at a method for fitting a polynomial to
    data points. This method is useful when the relationship in the data is better
    described by a polynomial, such as a second or third degree one. We'll use this
    method in [Chapter 6](ch06.html "Chapter 6. Exploring Volatility"), *Exploring
    Volatility*, where we'll fit a second degree polynomial to a option data to construct
    a graph over the volatility smile. We'll lay out the foundations needed for that
    use case in this section.
  prefs: []
  type: TYPE_NORMAL
- en: We'll continue to use Math.NET for our linear algebra calculations, to solve
    for the coefficients for a polynomial of a second degree.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start out by generating some sample data for a polynomial:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using polynomial regression](img/4623OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we generate x-values from `-10.0` to `10.0` with increments of `0.2`,
    and y-values using these x-values and the preceding equation with added noise.
    To accomplish this, the normal distribution with zero mean and 1.0 in standard
    deviation is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use the linear algebra functions from Math.NET to implement the least
    square estimation for the coefficients. In mathematical terms, this can be expressed
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using polynomial regression](img/4623OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This means we will use the matrix A, which stores the x-values and the y-vector
    to estimate the coefficient vector c. Let''s look at the following code to see
    how this is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The values in the coefficient vector are in reverse order, which means they
    correspond to a polynomial that fits the data, but the coefficient is reversed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The values are pretty close to the polynomial we used as the input in the preceding
    code. The following is a graph of the sample data points together with the fitted
    curve. The graph is made using FSharpChart, which we'll look into in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using polynomial regression](img/4623OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Polynomial regression using Math.net
  prefs: []
  type: TYPE_NORMAL
- en: 'The curious reader can use the following snippet to produce the preceding graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Learning about root-finding algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll learn about the different methods used in numerical analysis
    to find the roots of functions. Root-finding algorithms are very useful, and we
    will learn more about their applications when we talk about volatility and implied
    volatility.
  prefs: []
  type: TYPE_NORMAL
- en: The bisection method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will look at a method for finding the roots of a function
    using the bisection method. This method will be used later in this book to numerically
    find the implied volatility for an option that is given a certain market price.
    The bisection method uses iteration and repeatedly bisects an interval for the
    next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function implements bisection in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Looking at an example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we will look at an example of solving the roots of a quadratic equation.
    The equation, x^2 - x- 6, is plotted in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Looking at an example](img/4623OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The roots of the preceding quadratic equation can easily be seen in the figure.
    Otherwise, there are analytical methods of solving it; for example, the method
    of completing the square. The roots of the equation are -2 and 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create an anonymous function in F# to describe the one that we are
    interested in solving the roots for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test the preceding function using the roots that we found in the preceding
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as expected. Now, we can continue and use the lambda function
    as an argument to the `bisect` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The first two arguments, `0` and `25`, are used to keep track of the iterations.
    We pass in `0` because we want to start from iteration 0 and then iterate 25 times.
    The next argument is the function itself that we defined in the preceding code
    as `f`. The next two arguments are limits, that is, the range within which we
    can look for the root. And the last one is just a value for the accuracy used
    for comparison inside the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now inspect the two variables and see if we find the roots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: They are almost equal to the analytical solution of -2 and 3 respectively. This
    is something that is typical for numerical analysis. The solutions will almost
    never be exact. In every step, some inaccuracy is added due to the floating-point
    numbers, rounding, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Finding roots using the Newton–Raphson method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Newton-Raphson method, or simply Newton''s method, usually converges faster
    than the bisection method. The Newton-Raphson method also needs the derivative
    of the function, which can be a problem in some cases. This is especially true
    when there is no analytical solution available. The following implementation is
    a modification of the bisection method using the derivative of the function to
    determine if a solution has been found. Let''s look at the implementation of Newton''s
    method in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: One of the drawbacks of using the preceding method is that we use a fixed point
    convergence criteria, `abs(newtonX - x0) < tol`, which means that we can be far
    from the actual solution when this criteria is met.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at an example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can now try to find the square root of two, which is expected to be 1.41421\.
    First, we need the function itself, `fun x -> (x**2.0 – 2.0)`. We also need the
    derivative of the same function, `x -> (2.0*x)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we use the Newton-Raphson method to find the root of the function, x^2
    - 2\. Using F# Interactive, we can investigate this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the answer we would expect, and the method works for finding roots!
    Notice that if we change the starting value, `x0`, from `1.0` to `-1.0`, we''ll
    get the negative root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is also a valid solution to the equation, so be aware of this when you
    use this method for solving the roots. It can be helpful to plot the function,
    as we did in the section about the bisection method, to get a grip on where to
    start from.
  prefs: []
  type: TYPE_NORMAL
- en: Finding roots using the secant method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The secant method, which doesn''t need the derivative of the function, is an
    approximation of the Newton-Raphson method. It uses the finite difference approximation
    in iterations. The following is a recursive implementation in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Looking at an example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at an example where we use the secant method to find one root of
    a function. We''ll try to find the positive root of `612`, which is a number just
    under the square of 25 (25 x 25 = 625):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked deeper into F# and numerical analysis and how well
    the two fit together because of the functional syntax of the language. We covered
    algorithm implementation, basic numerical concerns, and the Math.NET library.
    After reading this chapter, you will be more familiar with both F# and numerical
    analysis and be able to implement algorithms yourself. At the end of the chapter,
    an example using the bisection method was covered. This method will prove to be
    very useful later on when we talk about Black-Scholes and implied volatility.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build on what we learned so far and extend our
    current knowledge with data visualization, basic GUI programming, and plotting
    financial data.
  prefs: []
  type: TYPE_NORMAL
