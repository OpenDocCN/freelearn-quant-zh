["```py\n    import yfinance as yf\n    import numpy as np\n    import pandas as pd\n    import quantstats as qs \n    ```", "```py\n    ASSETS = [\"META\", \"AMZN\", \"AAPL\", \"NFLX\", \"GOOG\"]\n    n_assets = len(ASSETS)\n    prices_df = yf.download(ASSETS,\n                            start=\"2020-01-01\",\n                            end=\"2021-12-31\",\n                            adjusted=True) \n    ```", "```py\n    returns = prices_df[\"Adj Close\"].pct_change().dropna() \n    ```", "```py\n    portfolio_weights = n_assets * [1 / n_assets] \n    ```", "```py\n    portfolio_returns = pd.Series(\n        np.dot(portfolio_weights, returns.T), \n        index=returns.index\n    ) \n    ```", "```py\n    qs.plots.snapshot(portfolio_returns,\n                      title=\"1/n portfolio's performance\",\n                      grayscale=True) \n    ```", "```py\n    qs.reports.metrics(portfolio_returns,\n                       benchmark=\"SPY\",\n                       mode=\"basic\",\n                       prepare_returns=False) \n    ```", "```py\nqs.reports.html(portfolio_returns, \n                benchmark=\"SPY\", \n                title=\"1/n portfolio\",\n                download_filename=\"EW portfolio evaluation.html\") \n```", "```py\nqs.extend_pandas() \n```", "```py\nprint(f\"Sharpe ratio: {portfolio_returns.sharpe():.2f}\")\nprint(f\"Sortino ratio: {portfolio_returns.sortino():.2f}\") \n```", "```py\nSharpe ratio: 1.36\nSortino ratio: 1.96 \n```", "```py\n[method for method in dir(qs.stats) if method[0] != \"_\"] \n```", "```py\n    import yfinance as yf\n    import numpy as np\n    import pandas as pd \n    ```", "```py\n    N_PORTFOLIOS = 10 ** 5\n    N_DAYS = 252\n    ASSETS = [\"META\", \"TSLA\", \"TWTR\", \"MSFT\"]\n    ASSETS.sort()\n    n_assets = len(ASSETS) \n    ```", "```py\n    prices_df = yf.download(ASSETS,\n                            start=\"2021-01-01\",\n                            end=\"2021-12-31\",\n                            adjusted=True) \n    ```", "```py\n    returns_df = prices_df[\"Adj Close\"].pct_change().dropna()\n    avg_returns = returns_df.mean() * N_DAYS\n    cov_mat = returns_df.cov() * N_DAYS \n    ```", "```py\n    np.random.seed(42)\n    weights = np.random.random(size=(N_PORTFOLIOS, n_assets))\n    weights /=  np.sum(weights, axis=1)[:, np.newaxis] \n    ```", "```py\n    portf_rtns = np.dot(weights, avg_returns)\n    portf_vol = []\n    for i in range(0, len(weights)):\n        vol = np.sqrt(\n            np.dot(weights[i].T, np.dot(cov_mat, weights[i]))\n        )\n        portf_vol.append(vol)\n    portf_vol = np.array(portf_vol)  \n    portf_sharpe_ratio = portf_rtns / portf_vol \n    ```", "```py\n    portf_results_df = pd.DataFrame(\n        {\"returns\": portf_rtns,\n         \"volatility\": portf_vol,\n         \"sharpe_ratio\": portf_sharpe_ratio}\n    ) \n    ```", "```py\n    N_POINTS = 100\n    ef_rtn_list = []\n    ef_vol_list = []\n    possible_ef_rtns = np.linspace(portf_results_df[\"returns\"].min(),\n                                   portf_results_df[\"returns\"].max(),\n                                   N_POINTS)\n    possible_ef_rtns = np.round(possible_ef_rtns, 2)    \n    portf_rtns = np.round(portf_rtns, 2)\n    for rtn in possible_ef_rtns:\n        if rtn in portf_rtns:\n            ef_rtn_list.append(rtn)\n            matched_ind = np.where(portf_rtns == rtn)\n            ef_vol_list.append(np.min(portf_vol[matched_ind])) \n    ```", "```py\n    MARKERS = [\"o\", \"X\", \"d\", \"*\"]\n    fig, ax = plt.subplots()\n    portf_results_df.plot(kind=\"scatter\", x=\"volatility\",\n                          y=\"returns\", c=\"sharpe_ratio\",\n                          cmap=\"RdYlGn\", edgecolors=\"black\",\n                          ax=ax)\n    ax.set(xlabel=\"Volatility\",\n           ylabel=\"Expected Returns\",\n           title=\"Efficient Frontier\")\n    ax.plot(ef_vol_list, ef_rtn_list, \"b--\")\n    for asset_index in range(n_assets):\n        ax.scatter(x=np.sqrt(cov_mat.iloc[asset_index, asset_index]),\n                   y=avg_returns[asset_index],\n                   marker=MARKERS[asset_index],\n                   s=150, color=\"black\",\n                   label=ASSETS[asset_index])\n    ax.legend()\n    plt.show() \n    ```", "```py\nmax_sharpe_ind = np.argmax(portf_results_df[\"sharpe_ratio\"])\nmax_sharpe_portf = portf_results_df.loc[max_sharpe_ind]\nmin_vol_ind = np.argmin(portf_results_df[\"volatility\"])\nmin_vol_portf = portf_results_df.loc[min_vol_ind] \n```", "```py\nMaximum Sharpe Ratio portfolio ----\nPerformance\nreturns: 45.14% volatility: 20.95% sharpe_ratio: 215.46%\nWeights\nMETA: 2.60% MSFT: 95.17% TSLA: 2.04% TWTR: 0.19% \n```", "```py\nMinimum Volatility portfolio ----\nPerformance\nreturns: 40.05% volatility: 20.46% sharpe_ratio: 195.76%\nWeights\nMETA: 17.35% MSFT: 78.16% TSLA: 0.23% TWTR: 4.26% \n```", "```py\nfig, ax = plt.subplots()\nportf_results_df.plot(kind=\"scatter\", x=\"volatility\",\n                      y=\"returns\", c=\"sharpe_ratio\",\n                      cmap=\"RdYlGn\", edgecolors=\"black\",\n                      ax=ax)\nax.scatter(x=max_sharpe_portf[\"volatility\"],\n           y=max_sharpe_portf[\"returns\"],\n           c=\"black\", marker=\"*\",\n           s=200, label=\"Max Sharpe Ratio\")\nax.scatter(x=min_vol_portf[\"volatility\"],\n           y=min_vol_portf[\"returns\"],\n           c=\"black\", marker=\"P\",\n           s=200, label=\"Minimum Volatility\")\nax.set(xlabel=\"Volatility\", ylabel=\"Expected Returns\",\n       title=\"Efficient Frontier\")\nax.legend()\nplt.show() \n```", "```py\n    import numpy as np\n    import scipy.optimize as sco\n    from chapter_11_utils import print_portfolio_summary \n    ```", "```py\n    def  get_portf_rtn(w, avg_rtns):\n        return np.sum(avg_rtns * w)\n    def  get_portf_vol(w, avg_rtns, cov_mat):\n        return np.sqrt(np.dot(w.T, np.dot(cov_mat, w))) \n    ```", "```py\n    def  get_efficient_frontier(avg_rtns, cov_mat, rtns_range):\n\n        efficient_portfolios = []\n\n        n_assets = len(avg_returns)\n        args = (avg_returns, cov_mat)\n        bounds = tuple((0,1) for asset in range(n_assets))\n        initial_guess = n_assets * [1. / n_assets, ]\n\n        for ret in rtns_range:\n            constr = (\n                {\"type\": \"eq\",\n                 \"fun\": lambda x: get_portf_rtn(x, avg_rtns) - ret},\n                {\"type\": \"eq\", \n                 \"fun\": lambda x: np.sum(x) - 1}\n            )\n            ef_portf = sco.minimize(get_portf_vol, \n                                    initial_guess, \n                                    args=args, method=\"SLSQP\", \n                                    constraints=constr,\n                                    bounds=bounds)\n            efficient_portfolios.append(ef_portf)\n\n        return efficient_portfolios \n    ```", "```py\n    rtns_range = np.linspace(-0.1, 0.55, 200) \n    ```", "```py\n    efficient_portfolios = get_efficient_frontier(avg_returns,\n                                                  cov_mat,\n                                                  rtns_range) \n    ```", "```py\n    vols_range = [x[\"fun\"] for x in efficient_portfolios] \n    ```", "```py\n    fig, ax = plt.subplots()\n    portf_results_df.plot(kind=\"scatter\", x=\"volatility\",\n                          y=\"returns\", c=\"sharpe_ratio\",\n                          cmap=\"RdYlGn\", edgecolors=\"black\",\n                          ax=ax)\n    ax.plot(vols_range, rtns_range, \"b--\", linewidth=3)\n    ax.set(xlabel=\"Volatility\",\n           ylabel=\"Expected Returns\",\n           title=\"Efficient Frontier\")\n    plt.show() \n    ```", "```py\n    min_vol_ind = np.argmin(vols_range)\n    min_vol_portf_rtn = rtns_range[min_vol_ind]\n    min_vol_portf_vol = efficient_portfolios[min_vol_ind][\"fun\"]\n    min_vol_portf = {\n        \"Return\": min_vol_portf_rtn,\n        \"Volatility\": min_vol_portf_vol,\n        \"Sharpe Ratio\": (min_vol_portf_rtn / min_vol_portf_vol)\n    } \n    ```", "```py\n    print_portfolio_summary(min_vol_portf,\n                            efficient_portfolios[min_vol_ind][\"x\"],\n                            ASSETS,\n                            name=\"Minimum Volatility\") \n    ```", "```py\nMinimum Volatility portfolio ----\nPerformance\nReturn: 40.30% Volatility: 20.45% Sharpe Ratio: 197.10%\nWeights\nMETA: 15.98% MSFT: 79.82% TSLA: 0.00% TWTR: 4.20% \n```", "```py\n    def  neg_sharpe_ratio(w, avg_rtns, cov_mat, rf_rate):\n        portf_returns = np.sum(avg_rtns * w)\n        portf_volatility = np.sqrt(np.dot(w.T, np.dot(cov_mat, w)))\n        portf_sharpe_ratio = (\n            (portf_returns - rf_rate) / portf_volatility\n        )\n        return -portf_sharpe_ratio \n    ```", "```py\n    n_assets = len(avg_returns)\n    RF_RATE = 0\n    args = (avg_returns, cov_mat, RF_RATE)\n    constraints = ({\"type\": \"eq\",\n                    \"fun\": lambda x: np.sum(x) - 1})\n    bounds = tuple((0,1) for asset in range(n_assets))\n    initial_guess = n_assets * [1. / n_assets]\n    max_sharpe_portf = sco.minimize(neg_sharpe_ratio,\n                                    x0=initial_guess,\n                                    args=args,\n                                    method=\"SLSQP\",\n                                    bounds=bounds,\n                                    constraints=constraints) \n    ```", "```py\n    max_sharpe_portf_w = max_sharpe_portf[\"x\"]\n    max_sharpe_portf = {\n        \"Return\": get_portf_rtn(max_sharpe_portf_w, avg_returns),\n        \"Volatility\": get_portf_vol(max_sharpe_portf_w, \n                                    avg_returns,\n                                    cov_mat),\n        \"Sharpe Ratio\": -max_sharpe_portf[\"fun\"]\n    } \n    ```", "```py\n    print_portfolio_summary(max_sharpe_portf,\n                            max_sharpe_portf_w,\n                            ASSETS,\n                            name=\"Maximum Sharpe Ratio\") \n    ```", "```py\nMaximum Sharpe Ratio portfolio ----\nPerformance\nReturn: 45.90% Volatility: 21.17% Sharpe Ratio: 216.80%\nWeights\nMETA: 0.00% MSFT: 96.27% TSLA: 3.73% TWTR: 0.00% \n```", "```py\n    import cvxpy as cp \n    ```", "```py\n    avg_returns = avg_returns.values\n    cov_mat = cov_mat.values \n    ```", "```py\n    weights = cp.Variable(n_assets)\n    gamma_par = cp.Parameter(nonneg=True)\n    portf_rtn_cvx = avg_returns @ weights\n    portf_vol_cvx = cp.quad_form(weights, cov_mat)\n    objective_function = cp.Maximize(\n        portf_rtn_cvx - gamma_par.*.portf_vol_cvx\n    )\n    problem = cp.Problem(\n        objective_function,\n        [cp.sum(weights) == 1, weights >= 0]\n    ) \n    ```", "```py\n    N_POINTS = 25\n    portf_rtn_cvx_ef = []\n    portf_vol_cvx_ef = []\n    weights_ef = []\n    gamma_range = np.logspace(-3, 3, num=N_POINTS)\n    for gamma in gamma_range:\n        gamma_par.value = gamma\n        problem.solve()\n        portf_vol_cvx_ef.append(cp.sqrt(portf_vol_cvx).value)\n        portf_rtn_cvx_ef.append(portf_rtn_cvx.value)\n        weights_ef.append(weights.value) \n    ```", "```py\n    weights_df = pd.DataFrame(weights_ef,\n                              columns=ASSETS,\n                              index=np.round(gamma_range, 3))\n    ax = weights_df.plot(kind=\"bar\", stacked=True)\n    ax.set(title=\"Weights allocation per risk-aversion level\",\n           xlabel=r\"$\\gamma$\",\n           ylabel=\"weight\")\n    ax.legend(bbox_to_anchor=(1,1)) \n    ```", "```py\n    fig, ax = plt.subplots()\n    ax.plot(portf_vol_cvx_ef, portf_rtn_cvx_ef, \"g-\")\n    for asset_index in range(n_assets):\n         plt.scatter(x=np.sqrt(cov_mat[asset_index, asset_index]),\n                     y=avg_returns[asset_index],\n                     marker=MARKERS[asset_index],\n                     label=ASSETS[asset_index],\n                     s=150)\n    ax.set(title=\"Efficient Frontier\",\n           xlabel=\"Volatility\",\n           ylabel=\"Expected Returns\")\n    ax.legend() \n    ```", "```py\nx_lim = [0.2, 0.6]\ny_lim = [0.4, 0.6]\nfig, ax = plt.subplots(1, 2)\nax[0].plot(vols_range, rtns_range, \"g-\", linewidth=3)\nax[0].set(title=\"Efficient Frontier - Minimized Volatility\",\n          xlabel=\"Volatility\",\n          ylabel=\"Expected Returns\",\n          xlim=x_lim,\n          ylim=y_lim)\nax[1].plot(portf_vol_cvx_ef, portf_rtn_cvx_ef, \"g-\", linewidth=3)\nax[1].set(title=\"Efficient Frontier - Maximized Risk-Adjusted Return\",\n          xlabel=\"Volatility\",\n          ylabel=\"Expected Returns\",\n          xlim=x_lim,\n          ylim=y_lim) \n```", "```py\nmax_leverage = cp.Parameter()\nprob_with_leverage = cp.Problem(objective_function, \n                                [cp.sum(weights) == 1, \n                                cp.norm(weights, 1) <= max_leverage]) \n```", "```py\nLEVERAGE_RANGE = [1, 2, 5]\nlen_leverage = len(LEVERAGE_RANGE)\nN_POINTS = 25\n\nportf_vol_l = np.zeros((N_POINTS, len_leverage))\nportf_rtn_l = np.zeros(( N_POINTS, len_leverage))\nweights_ef = np.zeros((len_leverage, N_POINTS, n_assets))\n\nfor lev_ind, leverage in enumerate(LEVERAGE_RANGE):\n    for gamma_ind in range(N_POINTS):\n        max_leverage.value = leverage\n        gamma_par.value = gamma_range[gamma_ind]\n        prob_with_leverage.solve()\n        portf_vol_l[gamma_ind, lev_ind] = cp.sqrt(portf_vol_cvx).value\n        portf_rtn_l[gamma_ind, lev_ind] = portf_rtn_cvx.value\n        weights_ef[lev_ind, gamma_ind, :] = weights.value \n```", "```py\nfig, ax = plt.subplots()\nfor leverage_index, leverage in enumerate(LEVERAGE_RANGE):\n    plt.plot(portf_vol_l[:, leverage_index], \n             portf_rtn_l[:, leverage_index], \n             label=f\"{leverage}\")\nax.set(title=\"Efficient Frontier for different max leverage\",\n       xlabel=\"Volatility\",\n       ylabel=\"Expected Returns\")\nax.legend(title=\"Max leverage\") \n```", "```py\nfig, ax = plt.subplots(len_leverage, 1, sharex=True)\nfor ax_index in range(len_leverage):\n    weights_df = pd.DataFrame(weights_ef[ax_index], \n                              columns=ASSETS, \n                              index=np.round(gamma_range, 3))\n    weights_df.plot(kind=\"bar\", \n                    stacked=True, \n                    ax=ax[ax_index], \n                    legend=None) \n    ax[ax_index].set(\n        ylabel=(f\"max_leverage = {LEVERAGE_RANGE[ax_index]}\"\n                \"\\n weight\")\n    )\nax[len_leverage - 1].set(xlabel=r\"$\\gamma$\")\nax[0].legend(bbox_to_anchor=(1,1))\nax[0].set_title(\"Weights allocation per risk aversion level\",\n                fontsize=16) \n```", "```py\n    import yfinance as yf\n    import pandas as pd\n    from pypfopt.expected_returns import returns_from_prices\n    from pypfopt.hierarchical_portfolio import HRPOpt\n    from pypfopt.discrete_allocation import (DiscreteAllocation, \n                                             get_latest_prices)\n    from pypfopt import plotting \n    ```", "```py\n    ASSETS = [\"AAPL\", \"MSFT\", \"AMZN\", \"GOOG\", \"META\",\n              \"V\", \"NVDA\", \"MA\", \"PYPL\", \"NFLX\"]\n    prices_df = yf.download(ASSETS,\n                            start=\"2021-01-01\",\n                            end=\"2021-12-31\",\n                            adjusted=True)\n    prices_df = prices_df[\"Adj Close\"] \n    ```", "```py\n    rtn_df = returns_from_prices(prices_df) \n    ```", "```py\n    hrp = HRPOpt(returns=rtn_df)\n    hrp.optimize() \n    ```", "```py\n    weights = hrp.clean_weights()\n    print(weights) \n    ```", "```py\n    OrderedDict([('AAPL', 0.12992), ('AMZN', 0.156), ('META', 0.08134), ('GOOG', 0.08532), ('MA', 0.10028), ('MSFT', 0.1083), ('NFLX', 0.10164), ('NVDA', 0.04466), ('PYPL', 0.05326), ('V', 0.13928)]) \n    ```", "```py\n    hrp.portfolio_performance(verbose=True, risk_free_rate=0); \n    ```", "```py\n    Expected annual return: 23.3%\n    Annual volatility: 19.2%\n    Sharpe Ratio: 1.21 \n    ```", "```py\n    fig, ax = plt.subplots()\n    plotting.plot_dendrogram(hrp, ax=ax)\n    ax.set_title(\"Dendogram of cluster formation\")\n    plt.show() \n    ```", "```py\n    latest_prices = get_latest_prices(prices_df)\n    allocation_finder = DiscreteAllocation(weights,\n                                           latest_prices,\n                                           total_portfolio_value=50000)\n    allocation, leftover = allocation_finder.lp_portfolio()\n    print(allocation)\n    print(leftover) \n    ```", "```py\n{'AAPL': 36, 'AMZN': 2, 'META': 12, 'GOOG': 2, 'MA': 14, 'MSFT': 16, 'NFLX': 8, 'NVDA': 7, 'PYPL': 14, 'V': 31}\n12.54937744140625 \n```", "```py\n    from pypfopt.expected_returns import mean_historical_return\n    from pypfopt.risk_models import CovarianceShrinkage\n    from pypfopt.efficient_frontier import EfficientFrontier\n    from pypfopt.plotting import plot_efficient_frontier \n    ```", "```py\n    mu = mean_historical_return(prices_df)\n    S = CovarianceShrinkage(prices_df).ledoit_wolf() \n    ```", "```py\n    ef = EfficientFrontier(mu, S)\n    fig, ax = plt.subplots()\n    plot_efficient_frontier(ef, ax=ax, show_assets=True)\n    ax.set_title(\"Efficient Frontier\") \n    ```", "```py\n    ef = EfficientFrontier(mu, S)\n    weights = ef.max_sharpe(risk_free_rate=0)\n    print(ef.clean_weights()) \n    ```", "```py\n    OrderedDict([('AAPL', 0.0), ('AMZN', 0.0), ('META', 0.0), ('GOOG', 0.55146), ('MA', 0.0), ('MSFT', 0.11808), ('NFLX', 0.0), ('NVDA', 0.33046), ('PYPL', 0.0), ('V', 0.0)]) \n    ```"]