- en: Chapter 2. Introduction to Python Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the most important issues related to Python
    modules, which are packages written by experts or any individual to serve a special
    purpose. In this book, we will use about a dozen modules in total. Thus, knowledge
    related to modules is critical in our understanding of Python and its application
    to finance. In particular, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Python modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to NumPy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to SciPy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to `matplotlib`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to `statsmodels`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to pandas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python modules related to finance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the pandas_reader module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two financial calculators written in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to install a Python module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a Python module?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A module is a package or group of programs that is written by an expert, user,
    or even a beginner who is usually very good in a specific area, to serve a specific
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a Python module called quant is for quantitative financial analysis.
    quant combines two modules of SciPy and `DomainModel`. The module contains a domain
    model that has exchanges, symbols, markets, and historical prices, among other
    things. Modules are very important in Python. In this book, we will discuss about
    a dozen modules implicitly or explicitly. In particular, we will explain five
    modules in detail: NumPy, SciPy, `matplotlib`, `statsmodels`, and Pandas.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of November 16, 2016, there are 92,872 Python modules (packages) with different
    areas available according to the Python Package Index.
  prefs: []
  type: TYPE_NORMAL
- en: For the financial and insurance industries, there are 384 modules currently
    available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that we want to estimate the square root of `3` by using the `sqrt()`
    function. However, after issuing the following lines of code, we will encounter
    an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason is that the `sqrt()` function is not a built-in function. A built-in
    function could be viewed as an existing function when Python is launched. To use
    the `sqrt()` function, we need to import the math module first, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the `sqrt()` function, we have to type `math.sqrt()` if we use the `import
    math` command to import or upload the math module. In the preceding code, the
    `round()` function is used to control the number of decimal places. In addition,
    after issuing the command of `dir()`, we will see the existence of the math module,
    which is the last one in the output shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, when a module is preinstalled, we could use `import x_module`
    to upload it. For instance, the math module is preinstalled. Later in the chapter,
    we will see how to find all built-in modules. In the preceding output, after issuing
    the command `dir()`, we also observe `__builtins__`. There are two underscores,
    before and after `builtin`. This `__builtins__` module is different from other
    built-in modules, such as the `math` module. It is for all built-in functions
    and other objects. Again, the command of `dir(__builtins__)` could be issued to
    list all built-in functions, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding output, we find a function called `pow()`. The command of
    `help(pow)` could be used to find more information about this specific function;
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, it is a good idea to adopt a short name for an imported module.
    To save some typing effort when programming, we could use the command `import
    x_module as short_name` as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When calling a specific function contained in an imported module, we use the
    module''s short name, as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Although users are free to choose any short names for an imported module, it
    is a great idea to respect some conventions, such as using `np` for NumPy and
    `sp` for SciPy. One added advantage of using such commonly used short names is
    to make our programs more readable to others. To show all functions in an imported
    module, the `dir(module)` command could be used, as shown in the following lines
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that in [Chapter 1](ch01.html "Chapter 1. Python Basics"), *Python Basics*,
    `import math` and `from math import *` are compared. Generally speaking, to make
    your programs simpler, you could use `from math import *`. This is especially
    true for a beginner who has just started to learn Python programming. Let''s take
    a look at the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all functions contained in the module will be available directly. On the
    other hand, if we use `import math`, we have to add the module name as a prefix,
    such as `math.sqrt()` instead of `sqrt()`. After getting more familiar with Python,
    it is a good idea to use the import module format instead of using `from module
    import *`. There are two reasons behind such a preference:'
  prefs: []
  type: TYPE_NORMAL
- en: First, users know exactly from which module the function comes from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second, we might have written our own function with the same name as the function
    contained in another module. A module name ahead of a function will distinguish
    it from our own function, as shown in the following lines of code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `del()` function is used to remove an imported/uploaded module which is
    deemed unnecessary, as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if we use `from math import *`, we cannot remove all functions,
    just issue `del math`. We have to remove those individual functions separately.
    The following two commands demonstrate such an effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, we could import only a few needed functions. To price a European
    call option, several functions are needed, such as `log()`, `exp()`, `sqrt()`
    and `cdf()`. `cdf()` is the function for cumulative standard normal distribution.
    To make those four functions available, we specify their names, as shown in the
    following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete codes for pricing Black-Scholes-Merton call options are given
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'One example of calling the `bsCall` function is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To find all available modules, a help window should be activated first. After
    that, issue modules. The result is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If this is your first time using Python, you should definitely check out the
    tutorial on the internet at [http://docs.python.org/3.5/tutorial/](http://docs.python.org/3.5/tutorial/).
  prefs: []
  type: TYPE_NORMAL
- en: Enter the name of any module, keyword, or topic to get help on writing Python
    programs and using Python modules. To quit this help utility and return to the
    interpreter, just type `quit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a list of available modules, keywords, symbols, or topics, type `modules`,
    `keywords`, `symbols`, or `topics`. Each module also comes with a one-line summary
    of what it does; to list the modules whose name or summary contain a given string
    such as `spam`, type `modules spam`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we issue modules under the Python `help>` prompt as shown in the following
    screenshot (to save space, only the first part of it is shown):'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a Python module?](img/B06175_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To find a specific module, we just type `modules` followed by the module''s
    name. Assume that we are interested in the module called `cmd`. Then, we issue
    `modules cmd` in the help window; see the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a Python module?](img/B06175_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get more information on modules, navigate to **All Programs** | `Python
    3.5` | `Python 3.5 Module Docs`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a Python module?](img/B06175_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After clicking `Python 3.5 Module Docs (32-bit)`, we will get more information.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to NumPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following examples, the `np.size()` function from NumPy shows the number
    of data items of an array, and the `np.std()` function is used to calculate standard
    deviation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Compared with a Python array, a NumPy array is a contiguous piece of memory
    that is passed directly to LAPACK, which is a software library for numerical linear
    algebra under the hood, so that matrix manipulation is very fast in Python. An
    array in NumPy is like a matrix in MATLAB. Unlike lists in Python, an array should
    contain the same data type, as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The real data type is `float64`, and the default for numerical values is also
    `float64`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we could view that the `np.array()` function converts
    a list with the same data type, an integer in this case, to an array. To change
    the data type, it should be specified with the second input value, `dtype`, as
    shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, `dtype` is the keyword specifying the data type. For
    a list, different data types could coexist without causing any problems. However,
    when converting a list containing different data types into an array, an error
    message will appear, as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To show all functions contained in Numpy, `dir(np)` is used after the Numpy
    module is imported.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows the first few lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, a better way is to generate an array containing all functions as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To show the functions from `200` to `250`, `x[200:250]` is typed; see the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It is easy to find out more information about a specific function. After issuing
    `dir(np)`, the `std()` function appears, among others. To seek more information
    about this function, `help(np.std)` is used. The following shows only a few lines
    of code for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The function returns the standard deviation, a measure of the spread of a distribution,
    of the array elements. The standard deviation is computed for the flattened array
    by default, otherwise over the specified axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Introduction to SciPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following are a few examples based on the functions enclosed in the SciPy
    module. The `sp.npv()` function estimates the present values for a given set of
    cash flows with the first cash flow happening at time zero. The first input value
    is the discount rate, and the second input is an array of all cash flows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is one example. Note that the `sp.npv()` function is different
    from the Excel `npv()` function. We will explain why this is so in [Chapter 3](ch03.html
    "Chapter 3. Time Value of Money"), *Time Value of Money*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `sp.pmt()` function is used to answer the following question.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the monthly cash flow to pay off a mortgage of $250,000 over 30 years
    with an annual percentage rate (APR) of 4.5 percent, compounded monthly? The following
    code shows the answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the preceding result, the monthly payment will be $1,266.71\. It might
    be quite strange that we have a negative value. Actually, this `sp.pmt()` function
    mimics the equivalent function in Excel, as we will see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to SciPy](img/B06175_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The input values are: the effective period rate, the number of the period,
    and the present value. By the way, the number in a pair of parentheses means a
    negative one.'
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, just ignore the negative sign. In [Chapter 3](ch03.html "Chapter 3. Time
    Value of Money"), *Time Value of Money*, this so-called Excel convention will
    be discussed in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the `sp.pv()` function replicates the Excel `PV()` function. For
    the `sp.pv()` function, its input format is `sp.pv(rate, nper, pmt, fv=0.0, when=''end'')`,
    where `rate` is the discount rate, `nper` is the number of periods, `pmt` is the
    period payment, and `fv` is the future value with a default value of zero. The
    last input variable specifies whether the cash flows are at the end of each time
    period or at the beginning of each period. By default, it is at the end of each
    period. The following commands show how to call this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `sp.fv()` function has a setting similar to that of `sp.pv()`. In finance,
    we estimate both arithmetic and geometric means, which are defined in the following
    formulas.
  prefs: []
  type: TYPE_NORMAL
- en: 'For *n* numbers of *x*, that is, *x1*, *x2*, *x3*, and *xn*, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to SciPy](img/B06175_02_05.jpg)![Introduction to SciPy](img/B06175_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, ![Introduction to SciPy](img/B06175_02_26.jpg) and ![Introduction to
    SciPy](img/B06175_02_27.jpg). Assume that we have three numbers of *a*, *b*, and
    *c*. Then their arithmetic mean is *(a+b+c)/3*, while their geometric mean is
    *(a*b*c)^(1/3)*. For three values of `2`, `3`, and `4`, we have the following
    two means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If *n* returns are given, the formula to estimate their arithmetic mean remains
    the same. However, the geometric mean formula for returns is different, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to SciPy](img/B06175_02_07.jpg)![Introduction to SciPy](img/B06175_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To estimate a geometric mean, the `sp.prod()` function would be applied. The
    function gives us the products of all data items; see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, a simple Python function could be written with just two lines to
    calculate a geometric mean for a set of given returns; see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It is easy to call the preceding function; see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Two other useful functions are `sp.unique()` and `sp.median()`, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Python''s `sp.pv()`, `sp.fv()`, and `sp.pmt()` functions behave like Excel''s
    `pv()`, `fv()`, and `pmt()` functions, respectively. They have the same sign convention:
    the sign of the present value is the opposite of the future value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, to estimate a present value if we enter a positive
    future value, we will end up with a negative present value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There are several ways to find out all the functions contained in the SciPy
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we can read related manuals. Secondly, we can issue the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To save space, only a few lines of the output are shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we could save all the functions to a vector (array); see the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Introduction to matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphs and other visual representations have become more important in explaining
    many complex financial concepts, trading strategies, and formulas.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discuss the `matplotlib` module, which is used to create
    various types of graphs. In addition, the module will be used intensively in [Chapter
    10](ch10.html "Chapter 10. Options and Futures"), *Options and Futures*, when
    we discuss the famous Black-Scholes-Merton option model and various trading strategies.
    The `matplotlib` module is designed to produce publication-quality figures and
    graphs. The `matplotlib` module depends on NumPy and SciPy, which were discussed
    in the previous sections. To save generated graphs, there are several output formats
    available, such as PDF, Postscript, SVG, and PNG.
  prefs: []
  type: TYPE_NORMAL
- en: How to install matplotlib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If Python was installed by using the Anaconda super package, then `matplotlib`
    is preinstalled already. After launching Spyder, type the following line to test.
    If there is no error, it means that we have imported/uploaded the module successfully.
    This is the beauty of using a super package such as Anaconda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: To install the `matplotlib` module or other modules independently, see the *Module
    dependency – how to install a module* section.
  prefs: []
  type: TYPE_NORMAL
- en: Several graphical presentations using matplotlib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to understand the usage of the `matplotlib` module is through examples.
    The following example could be the simplest one since it has just three lines
    of Python code. The objective is to link several points. By default, the `matplotlib`
    module assumes that the *x* axis starts at zero and moves by one on every element
    of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot of command lines illustrates this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Several graphical presentations using matplotlib](img/B06175_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After typing the last command of `show()` and hitting the *Enter* key, the above-right
    graph will appear. At the top of the graph, a set of icons (functions) are available.
    By clicking them, we could adjust our image or save our image. After closing the
    preceding figure, we could return to the Python prompt. On the other hand, if
    we issue `show()` a second time, nothing will happen. To show the preceding graph
    again, we have to issue both `plot([1,2,3,9])` and `show()`. Two labels could
    be added for both the *x* axis and *y* axis as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding graph is shown in the following screenshot on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Several graphical presentations using matplotlib](img/B06175_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next example presents two cosine functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Several graphical presentations using matplotlib](img/B06175_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding code, the `linspace()` function has four input values: `start`,
    `stop`, `num`, and `endpoint`. In the preceding example, we will start from *-3.1415916*
    and stop at *3.1415926*, with *256* values between. In addition, the endpoints
    will be included. By the way, the default value of `num` is *50*. The following
    example shows the scatter pattern. First, the `np.random.normal()` function is
    used to generate two sets of random numbers. Since `n` is `1024`, we have 1,024
    observations for both `X` and `Y` variables. The key function is `scatter(X,Y)`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Several graphical presentations using matplotlib](img/B06175_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a more complex graph showing the stock movement. Let''s look at the
    code first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding graph is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Several graphical presentations using matplotlib](img/B06175_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Introduction to statsmodels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`statsmodels` is a powerful Python package for many types of statistical analysis.
    Again, if Python was installed via Anaconda, then the module was installed at
    the same time. In statistics, **ordinary least square** (**OLS**) regression is
    a method for estimating the unknown parameters in a linear regression model. It
    minimizes the sum of squared vertical distances between the observed values and
    the values predicted by the linear approximation. The OLS method is used extensively
    in finance. Assume that we have the following equation, where *y* is an *n* by
    *1* vector (array), and *x* is an *n* by *(m+1)* matrix, a return matrix (*n*
    by *m*), plus a vector that contains *1* only. *n* is the number of observations,
    and *m* is the number of independent variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to statsmodels](img/B06175_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following program, after generating the `x` and `y` vectors, we run
    an OLS regression (a linear regression). The `x` and `y` are artificial data.
    The last line prints the parameters only (the intercept is `1.28571420` and the
    slope is `0.35714286`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To find out more information about this module, the `dir()` function could
    be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'For various submodules, `dir()` could be used as well; see the example shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding output, it can be seen that 16 functions start with the
    word `read`; see the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `read_clipboard` | Input data from a clipboard |'
  prefs: []
  type: TYPE_TB
- en: '| `read_csv` | Input data from a csv (comma separated value) |'
  prefs: []
  type: TYPE_TB
- en: '| `read_excel` | Input data from an Excel file |'
  prefs: []
  type: TYPE_TB
- en: '| `read_fwf` | Input data with a fixed width |'
  prefs: []
  type: TYPE_TB
- en: '| `read_gbq` | Load data from Google BigQuery |'
  prefs: []
  type: TYPE_TB
- en: '| `read_hdf` | Read HDF5 format data |'
  prefs: []
  type: TYPE_TB
- en: '| `read_html` | Input data from a web page |'
  prefs: []
  type: TYPE_TB
- en: '| `read_json` | Read JSON (JavaScript Object Notation) data |'
  prefs: []
  type: TYPE_TB
- en: '| `read_msgpack` | MessagePack is a fast, compact binary serialization format,
    suitable for similar data to JSON |'
  prefs: []
  type: TYPE_TB
- en: '| `read_pickle` | Input a Python dataset called pickle |'
  prefs: []
  type: TYPE_TB
- en: '| `read_sas` | Input data from a SAS dataset |'
  prefs: []
  type: TYPE_TB
- en: '| `read_sql` | Input data from SQL database |'
  prefs: []
  type: TYPE_TB
- en: '| `read_sql_query` | Input data from a query |'
  prefs: []
  type: TYPE_TB
- en: '| `read_sql_table` | Read SQL database table into a DataFrame |'
  prefs: []
  type: TYPE_TB
- en: '| `read_stata` | Input data from a Stata dataset |'
  prefs: []
  type: TYPE_TB
- en: '| `read_table` | Input data from a text file |'
  prefs: []
  type: TYPE_TB
- en: Table 2.1 A list of functions used to input data
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Introduction to pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pandas` module is a powerful tool used to process various types of data,
    including economics, financial, and accounting data. If Python was installed on
    your machine via Anaconda, then the `pandas` module was installed already. If
    you issue the following command without any error, it indicates that the `pandas`
    module was installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we generate two time series starting from January
    1, 2013\. The names of those two time series (columns) are `A` and `B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we import both NumPy and `pandas` modules. The `pd.date_range()` function
    is used to generate an index array. The `x` variable is a pandas DataFrame with
    dates as its index. Later in this chapter, we will discuss the `pd.DataFrame()`
    function. The `columns()` function defines the names of those columns. Because
    the `seed()` function is used in the program, anyone can generate the same random
    values. The `describe()` function offers the properties of those two columns,
    such as mean and standard deviation. Again, we call such a function, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To show all functions contained in the `pandas` module, the command of `dir(pd)`
    is used after importing the module; see the following code and the corresponding
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If going through the preceding list carefully, we will see the same functions
    starting with `read_`, shown in Table 2.1, as those contained in the `statsmodels`
    module. This type of duplication makes our program job a little bit easier. Assume
    that we plan to replace missing values (`NaN`) with the mean of the time series.
    The two functions used are `mean()` and `fillna()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'From the output on the right-hand side, the fourth observation of `NaN` is
    replaced with a mean of 1.75\. In the following code, we generate a DataFrame
    by using the `dataFrame()` function contained in the `pandas` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Since, in the program, the `numpy.random.seed()` function is used, different
    users will get the same random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'At the moment, readers might be confused why we would get the same random values
    while trying to get a set of random numbers. This topic will be discussed and
    explained in more detail in [Chapter 12](ch12.html "Chapter 12. Monte Carlo Simulation"),
    *Monte Carlo Simulation*. In the following code, how to use different ways to
    interpolate is presented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding graph is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to pandas](img/B06175_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Usually, different languages have their own types of datasets.
  prefs: []
  type: TYPE_NORMAL
- en: For example, SAS has its datasets with an extension of `.sas7bdat`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For R, its extensions could be .`RData`, `.rda`, or `.rds`. This is true for
    Python to have its own datasets. One type of dataset is with an extension of `.pickle`
    or `.pkl`. Let''s generate a pickle dataset; see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The last command saves the variable to a pickle dataset called `test.pkl` under
    the current working directory. To save the pickle dataset to a file under a specific
    address, that is, an absolute address, we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To read a pickle dataset, the `pd.read_pickle()` function is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Merging two different sets is one of the common procedures researchers are
    routinely doing. The objective of the following program is to merge two datasets
    based on their common variable called `key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial values for `x` and `y`, plus the merged dataset, called `z`, are
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'For finance, time series occupy a unique position since many datasets are in
    the form of time series, such as stock prices and returns. Thus, knowing how to
    define a `date` variable and study related functions is essential for processing
    economics, financial, and accounting data. Let''s look at a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between two dates can be easily estimated; see the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'From the `pandas` module, one submodule called `datetools` is quite useful;
    see the list of functions contained in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is one example to use the `weekday()` function contained in the `pandas`
    module. This function will be essential when tests are conducted to test the so-called
    Weekday-Effect. This test will be explained in detail in [Chapter 4](ch04.html
    "Chapter 4. Sources of Data"), *Sources of Data*. So let''s see the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Under certain situations, users might want to stack data together or the other
    way around; see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The comparison of the original dataset and the stacked datasets is given here.
    The left-hand side is the original dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The opposite operation of stock is to apply the `unstack()` function; see the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This operation could be applied to generate a return matrix if the input dataset
    is sorted by stock ID and date, that is, a dataset viewed as stacked one stock
    after another.
  prefs: []
  type: TYPE_NORMAL
- en: Python modules related to finance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since this book is applying Python to finance, the modules (packages) related
    to finance will be our first priority.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table presents about a dozen Python modules or submodules related
    to finance:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Numpy.lib.financial` | Many functions for corporate finance and financial
    management. |'
  prefs: []
  type: TYPE_TB
- en: '| `pandas_datareader` | Retrieves data from Google, Yahoo! Finance, FRED, Fama-French
    factors. |'
  prefs: []
  type: TYPE_TB
- en: '| `googlefinance` | Python module to get real-time (no delay) stock data from
    Google Finance API. |'
  prefs: []
  type: TYPE_TB
- en: '| `yahoo-finance` | Python module to get stock data from Yahoo! Finance. |'
  prefs: []
  type: TYPE_TB
- en: '| `Python_finance` | Download and analyze Yahoo! Finance data and develop trading
    strategies. |'
  prefs: []
  type: TYPE_TB
- en: '| `tstockquote` | Retrieves stock quote data from Yahoo! Finance. |'
  prefs: []
  type: TYPE_TB
- en: '| `finance` | Financial risk calculations. Optimized for ease of use through
    class construction and operator overload. |'
  prefs: []
  type: TYPE_TB
- en: '| `quant` | Enterprise architecture for quantitative analysis in finance. |'
  prefs: []
  type: TYPE_TB
- en: '| `tradingmachine` | A backtester for financial algorithms. |'
  prefs: []
  type: TYPE_TB
- en: '| `economics` | Functions and data manipulation for economics data. Check the
    following link for better understanding:[https://github.com/tryggvib/economics](https://github.com/tryggvib/economics).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FinDates` | Deals with dates in finance. |'
  prefs: []
  type: TYPE_TB
- en: Table 2.2 A list of modules or submodules related to finance
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To find out more information about economics, finance or accounting, go to
    the following web pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Location |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Python Module Index (v3.5) | [https://docs.python.org/3/py-modindex.html](https://docs.python.org/3/py-modindex.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| PyPI – the Python Package Index | [https://pypi.python.org/pypi](https://pypi.python.org/pypi)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Python Module Index (v2.7) | [https://docs.python.org/2/py-modindex.html](https://docs.python.org/2/py-modindex.html)
    |'
  prefs: []
  type: TYPE_TB
- en: Table 2.3 Websites related to Python modules (packages)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Introduction to the pandas_reader module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Via this module, users can download various economics and financial via Yahoo!
    Finance, Google Finance, **Federal Reserve Economics Data** (**FRED**), and Fama-French
    factors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that the `pandas_reader` module is installed. For detail on how to install
    this module, see the *How to install a Python module* section. First, let''s look
    at the simplest example, just two lines to get IBM''s trading data; see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We could use a dot head and dot tail to show part of the results; see the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This module will be explained again in more detail in [Chapter 4](ch04.html
    "Chapter 4. Sources of Data"), *Sources of Data*.
  prefs: []
  type: TYPE_NORMAL
- en: Two financial calculators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next chapter, many basic financial concepts and formulas will be introduced
    and discussed. Usually, when taking corporate finance or financial management,
    students rely on either Excel or a financial calculator to conduct their estimations.
    Since Python is the computational tool, a financial calculator written in Python
    would definitely enhance our understanding of both finance and Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the first financial calculator, written in Python, from `Numpy.lib.financial`;
    see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The functions that will be used and discussed in [Chapter 3](ch03.html "Chapter 3. Time
    Value of Money"), *Time Value of Money*, include `fv()`, `irr()`, `nper()`, `npv()`,
    `pmt()`, `pv()`, and `rate()`. One example of using `pv()` is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The second financial calculator is supplied by the author. There are many advantages
    of using this second financial calculator. First, all its functions possess the
    same format of the formulas from textbooks.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, there is no Excel sign convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `pv_f()` function will depend on the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two financial calculators](img/B06175_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The function called `pvAnnuity()` is based on the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two financial calculators](img/B06175_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Second, the formula of estimating the present value of one future cash flow
    is separated from the formula to estimate the present value of an annuity. This
    would help students, especially beginners, avoid unnecessary confusions.
  prefs: []
  type: TYPE_NORMAL
- en: For a comparison, the `numpy.lib.financial.pv()` function actually combines
    both equations (6) and (7). We will discuss this in more detail in [Chapter 3](ch03.html
    "Chapter 3. Time Value of Money"), *Time Value of Money*. Third, for each function,
    many examples are offered. It means users spend less time trying to figure out
    the meaning of individual functions. Fourth, this second financial calculator
    offers more functions than the `numpy.lib.financial` submodule can offer. Last
    but not least, users eventually learn to how to write their own financial calculator
    in Python. For more detail, see the last section in [Chapter 3](ch03.html "Chapter 3. Time
    Value of Money"), *Time Value of Money*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use such a financial calculator, users should download a file called `fincal.cpython-35.syc`
    at the author''s website ([http://canisius.edu/~yany/fincal.cpython-35.pyc](http://canisius.edu/~yany/fincal.cpython-35.pyc)).
    Assume that the executable file is saved under `c:/temp/`. To add `c:/temp/` to
    the Python path, click the rightmost Python logo on the menu bar; see the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two financial calculators](img/B06175_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After clicking the logo shown in the preceding screenshot, users will see the
    screen shown on the left in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two financial calculators](img/B06175_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After clicking **Add path**, type `c:/temp/`; see the screen shown on the right
    in the preceding screenshot. Now, we could use `import fincal` to use all functions
    contained inside the module. In [Chapter 3](ch03.html "Chapter 3. Time Value of
    Money"), *Time Value of Money*, we show how to produce such a `fincal` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the usage of each function, use the `help()` function; see the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding information, users know the objective of the function, the
    definitions of three input values, the formula used, plus a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to install a Python module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If Python was installed via Anaconda, there is a good chance that many of the
    modules discussed in this book have been installed together with Python. If Python
    was installed independently, users could use PyPi to install or update.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we are interested in installing NumPy. On Windows, we have the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If `Python.exe` is on the path, we could open a DOS window first, then issue
    the preceding line. If `Python.exe` is not on the path, we open a DOS window,
    then move to the location of the `Python.exe` file; for an example, see the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to install a Python module](img/B06175_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For a Mac, we have the following codes. Sometimes, after running the preceding
    command, you might receive the following message asking for an update of PiP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to install a Python module](img/B06175_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The command line to update `pip` is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'See the result shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to install a Python module](img/B06175_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To install NumPy independently, on Linux or OS X, we issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To install a new Python module for Anaconda, we have the following list. See
    the link at [http://conda.pydata.org/docs/using/pkgs.html](http://conda.pydata.org/docs/using/pkgs.html)
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `conda list` | Lists all of your packages in the active environment |'
  prefs: []
  type: TYPE_TB
- en: '| `conda list -n snowflakes` | Lists all of your packages installed into a
    non-active environment named `snowflakes` |'
  prefs: []
  type: TYPE_TB
- en: '| `conda search beautiful-soup` | Installs a package such as `Beautiful Soup`
    into the current environment, using `conda install` as follows |'
  prefs: []
  type: TYPE_TB
- en: '| `conda install --name bunnies quant` | Installs Python module (package) called
    `quant` |'
  prefs: []
  type: TYPE_TB
- en: '| `conda info` | Gets more information |'
  prefs: []
  type: TYPE_TB
- en: Table 2.4 A list of commands using conda to install a new package
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following screenshot shows what you will see after the command of `conda
    info` is issued:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to install a Python module](img/B06175_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following example is related to the installation of the Python module called
    `pandas_datareader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to install a Python module](img/B06175_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After answering `y`, the following result will appear after the module is completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to install a Python module](img/B06175_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get the versions of various modules, we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Module dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the very beginning of this book, we argued that one of the advantages of
    using Python is that it is a rich source of hundreds of special packages called
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid duplicated efforts and to save time in developing new modules, later
    modules choose to use functions developed on early modules; that is, they depend
    on early modules.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage is obvious because developers can save lots of time and effort
    when building and testing a new module. However, one disadvantage is that installation
    becomes difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two competing approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: The first approach is to bundle everything together and make sure that all parts
    play together nicely, thus avoiding the pain of installing *n* packages independently.
    This is wonderful, assuming that it works. A potential issue is that the updating
    of individual modules might not be reflected in the super package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second approach is to use minimal dependencies. It causes fewer headaches
    for the package maintainer, but for users who have to install several components,
    it can be more of a hassle. Linux has a better way: using the package installer.
    The publishers of the package can declare dependencies and the system tracks them
    down, assuming they are in the Linux repository. SciPy, NumPy, and quant are all
    set up like that, and it works great.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do we have to install NumPy independently if our Python was installed via Anaconda?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of using a super package to install many modules simultaneously?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you find all the functions contained in NumPy or SciPy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many ways are there to import a specific function contained in SciPy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is wrong with the following operation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How can we print all the data items for a given array?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is wrong with the following lines of code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Find out the meaning of `skewtest` included in the stats submodule (SciPy),
    and give an example of using this function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between an arithmetic mean and a geometric mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Debug the following lines of code, which are used to estimate a geometric mean
    for a given set of returns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write a Python program to estimate both arithmetic and geometric means for a
    given set of returns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find out the meaning of `zscore()` included in the `stats` submodule (SciPy),
    and offer a simple example of using this function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is wrong with the following lines of code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is module dependency and how do you deal with it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages and disadvantages of writing a module that depends on
    other modules?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you use the financial functions contained in NumPy; for example, the
    `pv()` or `fv()` functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For functions contained in `numpy.lib.financial`, are there similar functions
    contained in SciPy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you use the functions contained in the `fincal` module, generated by
    the author?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where can you find a list of all Python modules?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you find more information about Python modules related to finance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have discussed one of the most important properties of
    Python: modules. A module is a package written by an expert or any individual
    to serve a special purpose. The knowledge related to modules is essential in our
    understanding of Python and its application to finance. In particular, we have
    introduced and discussed the most important modules, such as NumPy, SciPy, `matplotlib`,
    `statsmodels`, `pandas`, and `pandas_reader`. In addition, we have briefly mentioned
    module dependency and other issues. Two financial calculators written in Python
    were also presented. In [Chapter 3](ch03.html "Chapter 3. Time Value of Money"),
    *Time Value of Money*, we will discuss many basic concepts associated with finance,
    such as the present value of one future cash flow, present value of perpetuity,
    present value of growing perpetuity, present value of annuity, and formulas related
    to future values. In addition, we will discuss definitions of **Net Present Value**
    (**NPV**), **Internal Rate of Return** (**IRR**), and Payback period. After that,
    several investment decision rules will be explained.'
  prefs: []
  type: TYPE_NORMAL
