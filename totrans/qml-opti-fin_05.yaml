- en: '6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qubits and Quantum Logic Gates
  prefs: []
  type: TYPE_NORMAL
- en: A computation can be broadly defined as a transformation of one memory state
    into another. Put slightly differently, a computation is a function that transforms
    information  [[281](Biblography.xhtml#XTegmark2017)]. In the case of classical
    digital computing, the fundamental memory unit is a *binary digit* (bit) of information.
    Functions that operate on bits of information are called *logic gates*. Logic
    gates are Boolean functions that can be combined into *circuits* capable of performing
    addition and multiplication, as well as more complex operations. In logic gates,
    the number of output bits does not have to be the same as the number of input
    bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'A computation may seem to be an abstract mathematical concept but it always
    requires some physical system in order to be executed. It does not matter what
    this physical system is: billiard balls, electric switches, transistors, or anything
    else – the computation is substrate independent. However, it is always some physical
    process that changes the state of the system in a controlled way.'
  prefs: []
  type: TYPE_NORMAL
- en: Classical digital computing requires some physical implementation of two distinct
    deterministic states (usually denoted as 0 and 1) and a set of gates that perform
    controlled transitions between them. In the following sections, we will see how
    classical digital computation can be implemented, what set of basis operations
    is required, and how the logic of classical computation can be extended to more
    general logic of quantum computation, of which classical computing is just a special
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 Binary Digit (Bit) and Logic Gates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we rapidly review classical logic gates and their universality,
    in order to draw a parallel later to quantum gates.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.1 Logic gates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A logic gate is an implementation of a Boolean function, a logical operation
    performed on one or more binary inputs that produces a single binary output. Logic
    gates are represented by their *truth tables*. A truth table has one column for
    each input variable, and one final column showing all of the possible results
    of the logical operation that the table represents. Each row of the truth table
    contains one possible configuration (a single bit or a bitstring) of the input
    variables, and the result of the operation for those values.
  prefs: []
  type: TYPE_NORMAL
- en: Figures and Tables [6.1](#6.1), [6.2](#6.2), [6.3](#6.3), and [6.4](#6.4) are
    schematic circuit representations of the AND, OR, NAND (not AND), and XOR (exclusive
    OR) logic gates as well as their corresponding truth tables.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-121007r1: AND gate diagram and truth table. ](img/file455.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: AND gate diagram and truth table.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-121009r2: OR gate diagram and truth table. ](img/file456.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: OR gate diagram and truth table.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-121011r3: NAND gate diagram and truth table. ](img/file457.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: NAND gate diagram and truth table.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-121013r4: XOR gate diagram and truth table. ](img/file458.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: XOR gate diagram and truth table.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.2 NAND as a universal logic gate
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Logic gates can be combined into circuits where the output of one is the input
    of another. This allows us i) to implement more complex operators than basic Boolean
    functions and ii) to implement all necessary Boolean functions using only a small
    number of easy-to-build logic gates. For example, all Boolean functions can be
    constructed using only a NAND gate and a fan-out operation. This makes NAND a
    *universal* gate in classical computing. Figure [6.5](#6.5) illustrates this by
    presenting the decomposition of four basic logic gates (NOT, AND, OR, XOR) into
    circuits consisting only of NAND gates.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-122002r5: Examples of logic gates decomposition into NAND gates
    and fan-out operations. ](img/file459.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Examples of logic gates decomposition into NAND gates and fan-out
    operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.3 Building an addition operator from the NAND gates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Figure [6.6](#6.6) shows how NAND and XOR gates can be combined into a circuit
    that implements the basic addition operator. As we know, the XOR gate itself can
    be constructed from the combination of NAND gates. The addition operator takes
    three 1-bit binary numbers as inputs and outputs two 1-bit binary numbers that
    can be read as a 2-bit bitstring (a 2-bit binary number). This 2-bit binary number
    can be translated into its integer number representation – an integer number between
    0 and 3 as shown in the truth table (Table [6.1](#x1-123004r1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-123002r6: Addition operator: the input is three 1-bit binary numbers
    and the output is a single 2-bit binary number. ](img/file460.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Addition operator: the input is three 1-bit binary numbers and
    the output is a single 2-bit binary number.'
  prefs: []
  type: TYPE_NORMAL
- en: '| input 1 | input 2 | input 3 | output 1 | output 2 | binary | integer |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 | 0 | 00 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 | 1 | 01 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 0 | 1 | 01 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 0 | 1 | 01 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 1 | 0 | 10 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 1 | 0 | 10 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 1 | 0 | 10 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 1 | 11 | 3 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.1: Addition operator truth table.'
  prefs: []
  type: TYPE_NORMAL
- en: Computation is a transformation of one memory state into another. Functions
    that perform such transformations are called logic gates. Logic gates are fully
    specified by their truth tables. A universal logic gate is one from which all
    other Boolean functions can be constructed. We only need to find an efficient
    physical realisation of a universal gate in order to perform computations of arbitrary
    complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2 Physical Realisations of Classical Bits and Logic Gates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have so far defined bits and classical logic gates from a theoretical computer
    science point of view. We now provide an overview of the most efficient hardware
    techniques used to effectively implement such operations.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.1 Implementation of the NAND gate
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The NAND gate (together with the fan-out operator) is a universal gate in classical
    digital computing. Therefore, it should be sufficient to find a practical physical
    implementation of the NAND Boolean function in order to build a universal computer.
    Figure [6.7](#6.7) displays several possible realisations of the NAND gate using
    different technologies, from electrical switches to semiconductors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Relay Logic:** Switches are interpreted as bits with 0 = open and 1 = closed.
    When switches A and B are both closed, an electromagnet opens switch C. If either
    or both of switches A and B are open, the circuit is broken and an electromagnet
    cannot open switch C.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resistor-Transistor (RT) Logic:** Voltages are interpreted as bits with 0 = zero
    volts and 1 = 3 volts. When wires A and B are both at +3 volts, the two transistors
    conduct electricity and wire C drops to zero volts. If either or both of inputs A
    and B are zero volts, the corresponding transistors do not conduct and output C
    stays at +3 volts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complementary Metal-Oxide-Semiconductor (CMOS) Logic:** Similar to RT logic,
    voltages are interpreted as bits with 0 = zero volts and 1 = 3 volts. The PMOS
    transistor is open when the input is 1 (+3 volts) and closed when the input is 0
    (zero volts). NMOS is the logical opposite of PMOS. The PMOS circuit is placed
    between the voltage and the output. The NMOS circuit is placed between the output
    and the ground.'
  prefs: []
  type: TYPE_NORMAL
- en: If both of the A and B inputs are high, both the NMOS transistors will conduct,
    neither of the PMOS transistors will conduct, and a conductive path will be established
    between the output, C, and the ground thus bringing the output low. If both of
    the A and B inputs are low, then neither of the NMOS transistors will conduct,
    while both of the PMOS transistors will conduct, establishing a conductive path
    between the output and the voltage source, bringing the output high. If either
    of the A or B inputs is low, one of the NMOS transistors will not conduct, one
    of the PMOS transistors will, and a conductive path will be established between
    the output and the voltage source, bringing the output high. Therefore, the circuit
    implements the NAND gate as the only configuration of the two inputs that results
    in a low output is when both are high.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-125004r7: Physical realisations of the NAND gate. ](img/file461.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Physical realisations of the NAND gate.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2 Implementation of the RAM memory cell
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Random Access Memory (RAM) is used to store instructions and data currently
    used by the CPU. It is called *volatile memory* in the sense that it is wiped
    out when the computer is switched off. RAM may consist of many billions of elementary
    *memory cells*, with each memory cell being able to store one bit of information.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to build a universal logic gate, we can try to design a
    circuit that would implement the elementary memory unit we need to build RAM.
    For example, Figure [6.8](#6.8) shows how the memory cell can be built from four
    NAND logic gates.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-126004r8: Construction of the elementary memory cell from NAND gates.
    ](img/file462.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: Construction of the elementary memory cell from NAND gates.'
  prefs: []
  type: TYPE_NORMAL
- en: '| D | E | Q | Q |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | Q | Q |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | Q | Q |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.2: Memory cell truth table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The circuit in Figure [6.8](#6.8) has two input pins, D (Data) and E (Enabler),
    and two output pins, Q and Q (NOT Q). The truth table (Table [6.2](#x1-126006r2))
    of the memory cell circuit explains how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: When the enabler input E is set to 1, the output Q can be set to the data input
    D.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the enabler input E is set to 0, the output Q cannot be changed – it retains
    its value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the key features that allow the circuit to serve as a memory cell.
  prefs: []
  type: TYPE_NORMAL
- en: Computation is substrate independent. Any physical system that can exist in
    two discrete, stable states with controlled transitions between them can be used
    to implement gate model digital computing. At the same time, some of the implementations
    are more efficient (faster, cheaper, more reliable) than others.
  prefs: []
  type: TYPE_NORMAL
- en: These classical logic gates provide a natural framework to understand their
    quantum formulations, which we’ll investigate now.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3 Quantum Binary Digit (Qubit) and Quantum Logic Gates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Quantum bits and quantum logic gates are the quantum computing counterparts
    of classical bits and logic gates. While they share common features, the quantum
    aspects yield a multitude of specific properties, which are the subject of this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.1 Computation according to the laws of quantum mechanics
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Classical logic gates operating on bits implement Boolean functions, forming
    the basis of digital classical computing. As we have seen, there are many possible
    physical implementations of a classical bit – a system that has two distinct,
    stable states with controlled transitions between them. What can we say about
    such a system from the quantum mechanical point of view?
  prefs: []
  type: TYPE_NORMAL
- en: As we know from Chapter [1](Chapter_1.xhtml#x1-220001), any such system may
    exist in a superposition of states, and the state of a qubit ![|ψ⟩](img/file463.jpg)
    is described by the expression
  prefs: []
  type: TYPE_NORMAL
- en: '![|ψ⟩ = α |0 ⟩+ β |1⟩ , ](img/file464.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *α* and *β* are complex numbers satisfying
  prefs: []
  type: TYPE_NORMAL
- en: '| ![&#124;α&#124;2 + &#124;β&#124;2 = 1\. ](img/file465.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: The coefficients *α* and *β* are *probability amplitudes*. Any attempt to *measure*
    the state ![|ψ ⟩](img/file466.jpg) results in getting ![|0⟩](img/file467.jpg)
    with probability |*α*|², and ![|1⟩](img/file468.jpg) with probability |*β*|².
    The measurement consists in coupling the quantum system to the environment, which
    collapses the superposition. After the measurement, the system is in the measured
    state and further measurements on the same basis will always yield the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Since the qubit state ![|ψ⟩](img/file469.jpg) is described by two complex probability
    amplitudes satisfying ([6.3.1](#x1-1280001)), we can say that the state of a qubit
    is a unit vector in the two-dimensional complex vector space. In other words,
    the state ![|ψ ⟩](img/file470.jpg) can be written as the vector
  prefs: []
  type: TYPE_NORMAL
- en: '| ![⌊ ⌋ ⌊ ⌋ ⌊ ⌋ ⌈ α⌉ = α ⌈1⌉ + β ⌈0⌉ . β 0 1 ](img/file471.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: This means that the basis states ![|0 ⟩](img/file472.jpg) and ![|1⟩](img/file473.jpg)
    are represented by the standard orthonormal basis vectors
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ⌊ ⌋ ⌊ ⌋ &#124;0⟩ := ⌈1 ⌉, &#124;1⟩ := ⌈0 ⌉ . 0 1 ](img/file474.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'The standard orthonormal basis ![|0⟩](img/file475.jpg) and ![|1⟩](img/file476.jpg)
    is not the only possible choice of the basis vectors. Any pair of *linearly independent*
    unit vectors ![|u⟩](img/file477.jpg) and ![|v ⟩](img/file478.jpg) from the complex
    two-dimensional vector space can serve as a basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![α &#124;0⟩+ β &#124;1⟩ = α ′ &#124;u ⟩+ β′ &#124;v⟩. ](img/file479.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: For example, we can use the Hadamard basis {![|+ ⟩](img/file480.jpg)*,*![|−
    ⟩](img/file481.jpg)} defined by
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ⌊ 1 ⌋ ⌊ 1 ⌋ 1 1 &#124; √--&#124; 1 1 &#124; √---&#124; &#124;+⟩ := √--&#124;0⟩+
    √--&#124;1⟩ = ⌈ 12⌉ and &#124;− ⟩ := √--&#124;0⟩− √---&#124;1⟩ = ⌈ 21 ⌉ . 2 2
    √--- 2 2 − √--- 2 2 ](img/file482.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: The basis is determined by the measurement process or the physical realisation
    of the quantum computer  [[80](Biblography.xhtml#XDawar)].
  prefs: []
  type: TYPE_NORMAL
- en: It is important to specify the choice of the basis. For example, the vector
  prefs: []
  type: TYPE_NORMAL
- en: '| ![⌊ -1-⌋ &#124; √2-&#124; ⌈ 1 ⌉ √2- ](img/file483.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: measured in the standard orthonormal basis (the *computational basis*) gives
    outcomes ![|0⟩](img/file484.jpg) and ![|1⟩](img/file485.jpg) with equal probability
    1*∕*2\. Measured in the Hadamard basis, it gives the outcome ![|+ ⟩](img/file486.jpg)
    with probability 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The state of a two-qubit system can be represented by a unit vector in the four-dimensional
    complex vector space. In this case, the standard orthonormal basis consists of
    four orthonormal unit vectors
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ &#124;1&#124; &#124; 0&#124; &#124; 0&#124; &#124;0&#124;
    &#124;&#124;0&#124;&#124; &#124;&#124; 1&#124;&#124; &#124;&#124; 0&#124;&#124;
    &#124;&#124;0&#124;&#124; &#124;00⟩ := &#124; &#124; , &#124;01⟩ := &#124; &#124;,
    &#124;10⟩ := &#124; &#124; , &#124;11⟩ := &#124; &#124; , &#124;⌈0&#124;⌉ &#124;⌈
    0&#124;⌉ &#124;⌈ 1&#124;⌉ &#124;⌈0&#124;⌉ 0 0 0 1 ](img/file487.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'and the system state is described by four probability amplitudes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![&#124;ψ ⟩ = α &#124;00⟩+ β &#124;01⟩+ γ &#124;10⟩ + δ &#124;11⟩, ](img/file488.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: 'with *α,β,γ,δ* ∈ℂ such that |*α*|² + |*β*|² + |*γ*|² + |*δ*|² = 1\. The basis
    vectors ([6.3.1](#x1-1280001)) of the two-qubit states are constructed as *tensor
    products* of the individual qubit basis vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ⌊ ⌊ ⌋⌋ ⌊ ⌋ ⌊ ⌊ ⌋⌋ ⌊ ⌋ &#124; ⌈1 ⌉&#124; 1 &#124; ⌈0⌉&#124; 0 &#124;&#124;
    1⋅ 0 &#124;&#124; &#124;&#124; 0&#124;&#124; &#124;&#124;1 ⋅ 1 &#124;&#124; &#124;&#124;1&#124;&#124;
    &#124;00⟩ = &#124;0⟩⊗ &#124;0⟩ = &#124;&#124; ⌊ ⌋&#124;&#124; = &#124;&#124; &#124;&#124;,
    &#124;01⟩ = &#124;0⟩⊗&#124;1⟩ = &#124;&#124; ⌊ ⌋&#124;&#124; = &#124;&#124; &#124;&#124;
    , &#124; 1 &#124; &#124;⌈ 0&#124;⌉ &#124; 0 &#124; &#124;⌈0&#124;⌉ ⌈ 0⋅⌈ ⌉⌉ ⌈0
    ⋅⌈ ⌉⌉ 0 0 1 0 ](img/file489.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: '| ![ ⌊ ⌊ ⌋⌋ ⌊ ⌋ ⌊ ⌊ ⌋⌋ ⌊ ⌋ &#124; 0⋅⌈1 ⌉&#124; &#124; 0&#124; &#124;0 ⋅⌈0⌉&#124;
    &#124;0&#124; &#124;&#124; 0 &#124;&#124; &#124; 0&#124; &#124;&#124; 1 &#124;&#124;
    &#124;0&#124; &#124;10⟩ = &#124;1⟩⊗ &#124;0⟩ = &#124;&#124; ⌊ ⌋&#124;&#124; =
    &#124;&#124; &#124;&#124;, &#124;11⟩ = &#124;1⟩⊗&#124;1⟩ = &#124;&#124; ⌊ ⌋&#124;&#124;
    = &#124;&#124; &#124;&#124; . &#124;⌈ ⌈1 ⌉&#124;⌉ &#124;⌈ 1&#124;⌉ &#124;⌈ ⌈0⌉&#124;⌉
    &#124;⌈0&#124;⌉ 1⋅ 0 1 ⋅ 1 0 1 ](img/file490.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: Generally, the *n*-qubit system can exist in any superposition of the 2^n basis
    states and requires 2^n probability amplitudes to be fully specified.
  prefs: []
  type: TYPE_NORMAL
- en: Computation is a transformation of the memory state. The qubit states are transformed
    by an application of quantum logic gates. Quantum logic gates are unitary linear
    operators that are represented by unitary matrices. The action of a quantum logic
    gate on a specific quantum state is found by multiplying the unitary matrix representing
    the gate by the vector representing the state. The result is the new quantum state.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.2 Qubit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is convenient to visualise the state of a qubit as a point on the unit sphere,
    named the Bloch sphere after physicist Felix Bloch. Every point on the Bloch sphere
    is uniquely specified by two angles, *𝜃* ∈ [0*,π*] and *ϕ* ∈ [0*,*2*π*], as shown
    in Figure [6.3.2](#x1-1290002).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9: Quantum state |ψ ⟩ on the Bloch sphere. ](img/file492.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: Quantum state ![|ψ ⟩](img/file491.jpg) on the Bloch sphere.'
  prefs: []
  type: TYPE_NORMAL
- en: With the mapping
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ( ) ( ) 𝜃- iϕ 𝜃- α = cos 2 , β = e sin 2 , ](img/file493.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'we obtain the canonical representation of the qubit state:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ⌊ ( 𝜃) ⌋ &#124; cos -- &#124; &#124;ψ⟩ = α &#124;0⟩+ β &#124;1⟩ = &#124;⌈
    (2 ) &#124;⌉. eiϕsin 𝜃- 2 ](img/file494.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: A transformation of the qubit state can be visualised as a transition from one
    point on the Bloch sphere to another. Therefore, the unitary matrix (quantum logic
    gate) that performs this transformation can be seen as a rotation operator and
    we can speak about *rotation* as a synonym of gate operation and *rotation* *angles*
    as gate parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.3 One-qubit quantum logic gates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unlike classical computing where we can only define two logic gates operating
    on a single bit (the identity gate and the NOT gate), quantum computing has infinitely
    many single qubit logic gates: any unitary 2 × 2 matrix (rotation) is a quantum
    logic gate. Some of these gates are more important (or easier to implement) than
    others. Below we provide detailed descriptions of some of them, starting with
    the identity I and the Pauli matrices X, Y, and Z. The action of the I gate is
    obvious – it leaves the state of the qubit unchanged; Pauli matrices perform rotation
    of the qubit state by *π* radians around, respectively, the *x*, *y*, and *z*
    axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ 1 0 0 1 0 − i 1 0 I = ⌈ ⌉ , X = ⌈ ⌉ , Y = ⌈ ⌉ , Z = ⌈
    ⌉ . 0 1 1 0 i 0 0 − 1 ](img/file495.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'We can easily verify by performing simple algebraic operations that the X gate
    flips the bit and that the Z gate flips the phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ X gate: ⌈0 1⌉ ⌈1⌉ = ⌈0 ⌉ , ⌈0 1⌉ ⌈0⌉ = ⌈1⌉ . 1
    0 0 1 1 0 1 0 ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ 1 0 1 1 1 0 0 0 Z gate: ⌈ ⌉ ⌈ ⌉ = ⌈ ⌉ ,
    ⌈ ⌉ ⌈ ⌉ = − ⌈ ⌉ . 0 − 1 0 0 0 − 1 1 1 ](img/file496.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'These operations can be visualised with the help of the following graphical
    representation of the quantum gates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10: Graphical representation of the X and Z gates. ](img/file497.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: Graphical representation of the X and Z gates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, horizontal lines represent *quantum registers* and boxes represent quantum
    gates. Together, quantum registers and quantum gates form the graphical representation
    of *quantum circuits* – the sequence of quantum gates that transform the quantum
    state, thus implementing quantum computation. The quantum circuits are read from
    left to right: the initial quantum state is shown at the left end of the quantum
    circuit and the final state is shown at the right end. Often, the last operator
    on the quantum register is the *measurement* *operator*. Following measurement
    (in the computational basis), a qubit is transformed into a classical bit and
    its value is a known binary number.'
  prefs: []
  type: TYPE_NORMAL
- en: Since the X gate flips the state of the qubit, it is also called the NOT gate.
    Similarly, the Z gate that flips the phase of the qubit state is known as the PHASE
    gate.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can draw a direct analogy between the NOT gate in classical computing and
    the NOT gate in quantum computing but there are quantum gates that perform operations
    that do not exist in classical computing. One such example is the ![√NOT--](img/file498.jpg)
    gate (represented by the matrix M introduced in Section [1.2.1](Chapter_1.xhtml#x1-360001)).
    In classical computing, we do not have a function that, when applied twice, would
    flip the bit. But such a function exists in quantum computing:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ⌊ ⌋ √---- √ -- 1-⌈1 + i 1 − i⌉ NOT ≡ X = 2 1 − i 1 + i . ](img/file499.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: 'We know that one of the main sources of power of quantum computing is the ability
    of a qubit to exist in a superposition of basis states. But how can we put a qubit
    that was initialised as ![|0 ⟩](img/file500.jpg) (or ![|1⟩](img/file501.jpg))
    in a superposition of states ![|0 ⟩](img/file502.jpg) and ![|1 ⟩](img/file503.jpg)?
    The answer is the Hadamard gate, H, which creates an equal superposition of states
    ![|0⟩](img/file504.jpg) and ![|1⟩](img/file505.jpg) when applied to either state
    ![|0⟩](img/file506.jpg) or state ![|1⟩](img/file507.jpg):'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ⌊ ⌋ H = √1-⌈1 1 ⌉ , 2 1 − 1 ](img/file508.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: '| ![ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ 1 1-- 1 1-- 0 0 -1- 1 -1- 0 H ⌈ ⌉ = √2-⌈ ⌉ + √2-⌈
    ⌉ and H⌈ ⌉ = √2-⌈ ⌉− √2-⌈ ⌉. 0 0 1 1 0 1 ](img/file509.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: '![Figure 6.11: Graphical representation of the Hadamard H gate. ](img/file510.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Graphical representation of the Hadamard H gate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, the Hadamard H gate is its own inverse, so that the second application
    of the Hadamard gate reverses the action of the first (mathematically, H² = I,
    or H = H^(−1)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12: Hadamard H gate applied twice. ](img/file511.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Hadamard H gate applied twice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other useful one-qubit gates are the *phase shift* gates where the phase
    is shifted by *π∕*2 and *π∕*4 rather than by *π* as is the case for the Z (PHASE)
    gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ⌊ ⌋ ⌊ ⌋ S = ⌈1 0 ⌉ and T = ⌈1 0 ⌉ . 0 eiπ∕2 0 eiπ∕4 ](img/file512.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: Finally, it is necessary to mention the *adjustable* one-qubit gates that perform
    rotation of the qubit state around a specific axis by an arbitrary angle *𝜃*.
    For any given gate G, define
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( ) RG(𝜃) := exp − 1-i𝜃G . 2 ](img/file513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using Lemma [1](Chapter_1.xhtml#x1-30002r1) in Chapter [1](Chapter_1.xhtml#x1-220001),
    we can then immediately compute R[X], R[Y] and R[Z] as
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ⌊ (𝜃) (𝜃)⌋ R (𝜃) = ⌈ cos 2 − isin 2 ⌉ , X − isin(𝜃) cos (𝜃) ⌊ 2 2⌋ cos(𝜃)
    − sin (𝜃) RY(𝜃) = ⌈ (2) ( 2) ⌉ , sin 𝜃2 cos 𝜃2 ⌊ ⌋ ⌈e −i𝜃∕2 0 ⌉ RZ(𝜃) = i𝜃∕2 .
    0 e ](img/file514.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: The adjustable gates play a very important role in Parameterised Quantum Circuits
    (PQC), which we consider in the following chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.4 Two-qubit quantum logic gates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Similar to one-qubit gates specified by unitary 2 × 2 matrices, we can construct
    any number of multi-qubit gates. The *n*-qubit gates would be represented by 2^n
    × 2^n unitary matrices. Since multi-qubit gates act on several qubits at the same
    time, they can be used to *entangle* them – i.e., make their states depend on
    each other. We also have a possibility to create conditional operators, where
    an operator is applied to a target qubit only if a control qubit is in state ![|1⟩](img/file515.jpg).
    Such gates are called *controlled* gates and we consider below some of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Controlled gates are shown in the quantum circuit as a straight line connecting
    two quantum registers. One quantum register represents the control qubit, and
    is indicated by the dot placed at the end of the line connecting the quantum registers.
    Another quantum register represents the target qubit: the desired conditional
    operator is put on this register. Figure [6.13](#6.13) illustrates this by displaying
    a Controlled Y (CY) gate. Here, *q*[1] is the quantum register representing the
    control qubit, *q*[2] is the quantum register representing the target qubit, and
    the operator applied to the target qubit is Y.'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ⌊ ⌋ &#124; 1 0 0 0 &#124; &#124; 0 1 0 0 &#124; CY = &#124;&#124; &#124;&#124;.
    &#124;⌈ 0 0 0 − i&#124;⌉ 0 0 i 0 ](img/file516.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: '![Figurex1-131004r13: CY gate. ](img/file517.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: CY gate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Controlled NOT gate, usually denoted as CNOT or CX, is another example
    of a two-qubit controlled gate. It consists of applying the Pauli X gate to the
    target qubit if the control qubit is in state ![|1⟩](img/file518.jpg) and is given
    by the following unitary matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ⌊ ⌋ &#124; 1 0 0 0&#124; &#124;&#124; 0 1 0 0&#124;&#124; CNOT ≡ CX =
    &#124;&#124; &#124;&#124;. ⌈ 0 0 0 1⌉ 0 0 1 0 ](img/file519.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: This gate is often represented in the quantum circuit by an XOR logical symbol
    (circled plus) placed on the target qubit quantum register since its truth table
    (for the target qubit) coincides with the truth table of the XOR logic gate.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14: CX (CNOT) gate. ](img/file520.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: CX (CNOT) gate.'
  prefs: []
  type: TYPE_NORMAL
- en: '| *q*[1] | *q*[2] | *q*′[1] | *q*′[2] |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.3: Truth table for CX (CNOT) gate.'
  prefs: []
  type: TYPE_NORMAL
- en: Seen differently, note that we in fact have the equality
  prefs: []
  type: TYPE_NORMAL
- en: '![CX |q1q2⟩ = |q1⟩ |q1 ⊕ q2⟩, ](img/file521.jpg)'
  prefs: []
  type: TYPE_IMG
- en: for any *q*[1]*,q*[2] ∈{0*,*1}, where ⊕ denotes addition modulo 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CZ gate is a Pauli Z (phase flip) applied to the target qubit conditional
    on the control qubit being in state ![|1⟩](img/file522.jpg) and is given by the
    following unitary matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ⌊ ⌋ &#124;1 0 0 0 &#124; &#124;&#124;0 1 0 0 &#124;&#124; CPHASE ≡ CZ
    = &#124; &#124;. &#124;⌈0 0 1 0 &#124;⌉ 0 0 0 − 1 ](img/file523.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'Interestingly, for CZ it does not really matter which qubit is the target qubit
    and which is the control qubit – the result is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15: CZ (CPHASE) gates. ](img/file524.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: CZ (CPHASE) gates.'
  prefs: []
  type: TYPE_NORMAL
- en: The SWAP gate swaps the states of two qubits. The ![√----- SWAP](img/file525.jpg)
    gate is universal in the sense that any multi-qubit gate can be constructed from
    only ![√ ----- SWAP](img/file526.jpg) and single qubit gates.
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ⌊ ⌋ ⌊ ⌋ &#124;1 0 0 0&#124; &#124; 1 0 0 0&#124; &#124;&#124;0 0 1 0&#124;&#124;
    √----- &#124;&#124; 0 1+2i 1−2i 0&#124;&#124; SWAP = &#124;&#124; &#124;&#124;
    , SWAP = &#124;&#124; 1−i 1+i &#124;&#124;. ⌈0 1 0 0⌉ ⌈ 0 2 2 0⌉ 0 0 0 1 0 0 0
    1 ](img/file527.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'Very often, the choice of the set of universal gates from which all other gates
    can be constructed is dictated by the characteristics of the physical system used
    to perform quantum computation. The ![√----- SWAP](img/file528.jpg) is a *native
    gate* in the systems that exploit exchange interactions  [[221](Biblography.xhtml#XNemirovsky2021)].
    Related gates such as iSWAP and ![√ ------ iSWAP](img/file529.jpg) are natural
    gates in the systems with Ising-like interactions  [[244](Biblography.xhtml#XRasmussen2020)]:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ⌊ ⌋ ⌊ ⌋ 1 0 0 0 1 0 0 0 &#124;&#124; &#124;&#124; &#124;&#124; 1 i &#124;&#124;
    &#124;0 0 i 0&#124; √ ------ &#124;0 √2- √2- 0&#124; iSWAP = &#124;&#124;0 i 0
    0&#124;&#124; , iSWAP = &#124;&#124;0 √i- √1- 0&#124;&#124; . ⌈ ⌉ ⌈ 2 2 ⌉ 0 0
    0 1 0 0 0 1 ](img/file530.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'An example of an adjustable two-qubit gate is the XY gate, which is a rotation
    by some angle *𝜃* between the ![|01⟩](img/file531.jpg) and ![|10⟩](img/file532.jpg)
    states:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ⌊ ⌋ &#124; 1 0( ) 0( ) 0&#124; &#124;&#124; 0 cos 𝜃2 isin 𝜃2 0&#124;&#124;
    XY(𝜃) = &#124;&#124; ( 𝜃) (𝜃) &#124;&#124; . ⌈ 0 isin 2 cos 2 0⌉ 0 0 0 1 ](img/file533.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: Note that XY(*π*) = iSWAP and XY(*π∕*2) = ![√------ iSWAP](img/file534.jpg).
    Together with CZ, the iSWAP gate plays an important role in the construction of
    quantum circuits since any two-qubit gate can be expressed with at most three CZ
    or three iSWAP gates  [[2](Biblography.xhtml#XAbrams2019)].
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.5 The Toffoli gate
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The classical Toffoli gate, invented by Tommaso Toffoli  [[284](Biblography.xhtml#XToffoli1980)],
    is a three-bit logic gate, which is universal in classical computing. In quantum
    computing, it is a three-qubit Controlled Controlled NOT (CCNOT) gate that is
    represented by the following quantum circuit, where the qubit C is the target
    qubit and the qubits A and B are the control qubits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16: Toffoli (CCNOT) gate. ](img/file535.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.16: Toffoli (CCNOT) gate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The classical Toffoli gate is given by the following truth table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| A | B | C | A′ | B′ | C′ |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.4: Truth table for Toffoli gate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The quantum Toffoli gate is represented by the unitary matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ⌊ ⌋ &#124;1 0 0 0 0 0 0 0&#124; &#124;&#124;0 1 0 0 0 0 0 0&#124;&#124;
    &#124; &#124; &#124;&#124;0 0 1 0 0 0 0 0&#124;&#124; &#124;&#124;0 0 0 1 0 0
    0 0&#124;&#124; CCNOT = &#124;&#124; &#124;&#124;. &#124;&#124;0 0 0 0 1 0 0 0&#124;&#124;
    &#124;0 0 0 0 0 1 0 0&#124; &#124;&#124; &#124;&#124; &#124;⌈0 0 0 0 0 0 0 1&#124;⌉
    0 0 0 0 0 0 1 0 ](img/file536.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'It is clear from the Toffoli gate truth table that it also implements the AND
    and NAND gates. With C = 0 it can be viewed as the AND gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![if C = 0 : C ′ = A AND B. ](img/file537.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'And with C = 1 it can be viewed as the NAND gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ′ if C = 1 : C = A NAND B. ](img/file538.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'The Toffoli gate can be decomposed into a quantum circuit consisting of CNOT
    and one-qubit gates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17: Decomposition of the Toffoli (CCNOT) gate. The "dagger" superscript
    after the gate symbol such as T† indicates the adjoint operator (see Section 1.1.1).
    ](img/file539.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.17: Decomposition of the Toffoli (CCNOT) gate. The "dagger" superscript
    after the gate symbol such as T^† indicates the *adjoint* operator (see Section [1.1.1](Chapter_1.xhtml#x1-240001)).'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the Toffoli circuit allows us to implement the NAND gate, which
    is universal in classical computing, demonstrates the fact that quantum computing
    can perform all operations which are possible on classical computers. In other
    words, quantum computers can simulate classical computers. At the same time, we
    have seen examples of quantum operations that do not have their analogues in classical
    computing. In the most general case, classical simulation of an *n*-qubit quantum
    system would require the ability to store 2^n probability amplitudes – an impossible
    task for *n* larger than several hundred as there would not be enough matter in
    the visible universe to implement such classical memory. Consequently, quantum
    computation is more general than classical computation. Computation, as a concept,
    is really quantum computation. Classical computation is just a special case of
    quantum one  [[32](Biblography.xhtml#XBernhardt2019)].
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computing offers a wider range of logic gates than classical computing.
  prefs: []
  type: TYPE_NORMAL
- en: The Toffoli gate demonstrates that quantum computers can perform all operations
    implementable on classical computers. At the same time, an attempt to simulate
    quantum computing classically will immediately run into memory issues.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed, quantum gates correspond to unitary matrices, which have the property
    of being invertible. Since quantum circuits are fundamentally classical and tensor
    products of such matrices, they can easily be inverted, yielding the concept of
    *reversible computing*, which we focus on in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 6.4 Reversible Computing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The importance of the Toffoli gate goes beyond mere universality. It is a universal
    *reversible* logic gate, meaning that it can serve as a basis for reversible computing.
    Here, we should note that *all* quantum logic gates that are represented by unitary
    matrices are reversible. So, what does reversible computing mean?
  prefs: []
  type: TYPE_NORMAL
- en: Reversible computing is a model of computation where the computational process
    is time-reversible. It also means that no information is lost through the computation
    process and we can always reconstruct the initial state. The ability to physically
    realise reversible computing is hugely important due to the deep physical link
    between loss of information and generation of heat.
  prefs: []
  type: TYPE_NORMAL
- en: According to the principle formulated by Landauer  [[183](Biblography.xhtml#XLandauer1961)],
    in order for a computational process to be physically reversible, it must also
    be logically reversible. Fundamentally, this is due to the fact that the act of
    computation can only be performed by some physical system and is subject to the
    physical laws of thermodynamics.
  prefs: []
  type: TYPE_NORMAL
- en: The loss of information leads to the increase in information entropy. Similarly,
    the increase in thermodynamic entropy leads to the generation of heat. In both
    cases, we are moving from the more ordered state to the less ordered state, which
    is an irreversible process.
  prefs: []
  type: TYPE_NORMAL
- en: This can be illustrated by the definitions of entropy (as a measure of disorder)
    in both statistical mechanics and information theory. Entropy in statistical mechanics
    is given by
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ∑ S = − kB pilog (pi), i ](img/file540.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: where *k*[B] is the Boltzmann constant and *p*[i] is the probability of the
    microstate *i* taken from the equilibrium ensemble (macroscopic thermodynamic
    state), while entropy in information theory is given by
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ∑ H = − pilog2(pi), i ](img/file541.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: where *p*[i] is the probability of the message *i* taken from the message space.
  prefs: []
  type: TYPE_NORMAL
- en: A very high probability of a particular microstate and a very high probability
    of a specific message indicate highly ordered systems with low entropy. The entropy
    is maximised (and information is minimised) when the microstates/messages are
    uniformly distributed.
  prefs: []
  type: TYPE_NORMAL
- en: Any probability distribution can be approximated arbitrarily closely by some
    thermodynamic system  [[219](Biblography.xhtml#XMyrvold2021)]. If *h* is information
    (bits) per particle, then for *N* particles the entropy measured in the *natural
    unit of information* (1 bit = log(2) nat) is given by the expression
  prefs: []
  type: TYPE_NORMAL
- en: '| ![S = − kB log (2)N h. ](img/file542.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: In energy units, *k*[B]*T* log(2) of heat is generated for each bit of information
    lost. Here, *T* is the temperature of the heat sink (in Kelvins). For example,
    if we take *T* = 300K (approx. 27C), then the minimum possible amount of energy
    required to erase one bit of information is 2.87 zJ (zeptojoule).
  prefs: []
  type: TYPE_NORMAL
- en: In practical terms, it means that every *logically irreversible* operation (e.g.,
    NAND or XOR gates) must be accompanied by the corresponding entropy increase and
    generation of heat. As the energy efficiency of the computation process becomes
    progressively more important, efforts to develop reversible computing are increasing
    since it may prove difficult for traditional technology based on the laws of classical
    physics to progress very far beyond current levels of energy efficiency if reversible
    computing principles are not used  [[106](Biblography.xhtml#XFrank2017)].
  prefs: []
  type: TYPE_NORMAL
- en: In contrast with classical computing, all quantum computing operations are reversible
    (except measurement). This means that the quantum advantage is likely to be demonstrated
    not only in quantum speedup and the expressive power of quantum circuits but also
    in achieving superior energy efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: We have so far seen forward and backward (reversible) quantum operations. However,
    what fundamentally distinguishes quantum computing from classical computing is
    the concept of entanglement.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5 Entanglement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The key aspect of quantum computing is entanglement, which allows for quantum
    states to encode more information than the sum of their individual components.
    We explain this in detail here and provide examples for two-qubit systems.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.1 Quantum entanglement and why it matters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An *n*-qubit system can exist in any superposition of the 2^n basis states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ n 2∑ −1 ci |i⟩ = c0 |00...00⟩ + c1 |00...01⟩+ ...+ c2n−1 |11 ...11⟩, i=0
    ](img/file543.jpg)'
  prefs: []
  type: TYPE_IMG
- en: with
  prefs: []
  type: TYPE_NORMAL
- en: '![ n 2∑ −1 2 |ci| = 1\. i=0 ](img/file544.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If such a state can be represented as a tensor product of individual qubit states
    then the qubit states are *not entangled*. For example, it is easy to check that
  prefs: []
  type: TYPE_NORMAL
- en: '|  | ![ 1 --√-- 4 2](img/file545.jpg)![(√ -- √-- √ -- √ -- ) 3 &#124;000⟩+
    &#124;001⟩ + 3 &#124;010⟩+ 3 &#124;011 ⟩+ 3 &#124;100⟩+ &#124;101⟩ + 3 &#124;110⟩+
    3 &#124;111⟩](img/file546.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = ![( 1 1 ) √---&#124;0⟩ + √---&#124;1⟩ 2 2](img/file547.jpg)⊗![( -- )
    1 √ 3 --&#124;0⟩+ --- &#124;1 ⟩ 2 2](img/file548.jpg)⊗![( -- ) √ 3 1 ---&#124;0⟩+
    -&#124;1⟩ 2 2](img/file549.jpg)*,* | (6.5.1) |  |'
  prefs: []
  type: TYPE_TB
- en: so that the quantum state is not entangled (only in superposition). An *entangled*
    state cannot be represented as a tensor product of individual qubit states.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the two-qubit state
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ 1 1 √--&#124;00⟩+ √--&#124;11⟩ 2 2 ](img/file550.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: does not allow a tensor product decomposition. Namely, for any *a,b,c,d* ∈ℂ
    such that |*a*|² + |*b*|² = |*c*|² + |*d*|² = 1, we have
  prefs: []
  type: TYPE_NORMAL
- en: '| ![-1- -1- √2-&#124;00⟩+ √2--&#124;11⟩ ⁄= (a &#124;0⟩ + b &#124;1⟩)⊗ (c &#124;0⟩+
    d &#124;1⟩). ](img/file551.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: We notice that we need 2^n probability amplitudes to describe the state on the
    left side of ([6.5.1](#x1-135002r1)) while we only need 2*n* probability amplitudes
    to describe the state on the right side of ([6.5.1](#x1-135002r1)). The number
    of probability amplitudes needed to fully describe the state of a system is directly
    related to the amount of information the system can store. Entanglement allows
    us to encode a significantly larger amount of information than is possible with
    individual independent qubits. One can say that most of the information encoded
    in the state of a quantum mechanical system is stored non-locally in the correlations
    between the qubit states. This non-locality of information is one of the major
    distinguishing features of quantum computing over classical computing and is essential
    for a number of applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if we measure the entangled qubits? In ([6.5.1](#x1-135002r1))
    both qubits are in the state of equal superposition, i.e., if we measure the first
    qubit we will get both 0 and 1 with probability 1/2\. If instead we measure the
    second qubit we will also get 0 and 1 with equal probability. However, the situation
    is completely different if we measure the second qubit after the first has already
    been measured. In this case, the state of the second qubit is fully determined
    by the act of measuring the first qubit and there is no longer any uncertainty
    about its value: if the first qubit was measured as 0, the second qubit is also
    in state 0 and if the first qubit was measured as 1, the second qubit is also
    in state 1\. In other words, measuring one qubit collapses the superposition and
    has an immediate effect on the other.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.2 Entangling qubit states with two-qubit gates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Qubit states can be entangled with the help of two-qubit gates. The two-qubit
    state given by ([6.5.1](#x1-135002r1)) is known as one of the four maximally entangled
    Bell states. It can be constructed from the unentangled state ![|00⟩](img/file552.jpg):'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![&#124;00⟩ = (1 ⋅ &#124;0⟩+ 0 ⋅ &#124;1⟩) ⊗ (1 ⋅ &#124;0⟩+ 0 ⋅ &#124;1⟩)
    ](img/file553.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'by applying the *Bell circuit* consisting of H and CNOT gates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18: Bell circuit. ](img/file554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.18: Bell circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this circuit on the unentagled states ![|01⟩](img/file555.jpg), ![|10⟩](img/file556.jpg),
    and ![|11⟩](img/file557.jpg) will result in the construction of the other three
    Bell states:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ 1 &#124;01⟩ → √--(&#124;01⟩+ &#124;10⟩), 2 ](img/file558.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: '| ![ 1 &#124;10⟩ → √--(&#124;01⟩− &#124;10⟩), 2 ](img/file559.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: '| ![ 1 &#124;11⟩ → √--(&#124;00⟩− &#124;11⟩). 2 ](img/file560.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: Entanglement can be achieved with other two-qubit gates as well. Depending on
    the hardware implementation, it may be a SWAP, a CPHASE, or some other fixed two-qubit
    gate, or it can be an adjustable two-qubit gate such as XY(*𝜃*).
  prefs: []
  type: TYPE_NORMAL
- en: Entanglement allows us to store most of the information in the correlations
    between the states rather than in the states of individual qubits.
  prefs: []
  type: TYPE_NORMAL
- en: Entanglement is one of the main sources of the expressive power of quantum circuits
    that underpins our search for the quantum advantage.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that entanglement is a distinctive feature of quantum computing. We now
    see how it comes into play when analysing the quantum equivalents of classical
    logic gate decompositions studied in Section [6.1](#x1-1200001).
  prefs: []
  type: TYPE_NORMAL
- en: 6.6 Quantum Gate Decompositions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most widely used NISQ computing technologies are trapped ions and superconducting
    qubits. In both cases, one-qubit gates are much faster than two-qubit gates (by
    an order of magnitude). Additionally, one-qubit gates have much higher fidelity
     [[46](Biblography.xhtml#XBruzewicz2019), [164](Biblography.xhtml#XKjaergaard2019)].
    This means that we can treat one-qubit gates as computationally inexpensive and
    should not worry too much about their quantities. At the same time, we have to
    be economical with two-qubit gates: out of two equivalent circuits, the one with
    the smaller number of two-qubit gates would generally perform better. Therefore,
    we should be aware of the two-qubit gates that are native to any particular system
    – gates that can be implemented naturally using standard hardware control techniques.
    More complex gates can be decomposed into a sub-circuit of the native gates but
    an even better solution would be to specify the algorithm that takes advantage
    of the native gates and bypasses the need of having non-native two-qubit gates.
    For example, Rigetti’s Aspen system  [[275](Biblography.xhtml#XStrauch2003)] is
    based on the superconducting qubits with two native two-qubit gates CZ and XY
    – constructing a circuit based on these gates rather than, e.g., SWAP gates would
    achieve better performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is not always practical or desirable to make an algorithm hardware
    dependent. And since the choice of the native gates is inevitably limited, it
    is useful to keep in mind several basic decompositions. The following relationships
    can be verified by direct calculations and play an important role in quantum circuit
    construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19: CZ gate decomposition into CX and Hadamard gates. ](img/file561.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.19: CZ gate decomposition into CX and Hadamard gates.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-137003r20: CX gate decomposition into CZ and Hadamard gates. ](img/file562.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.20: CX gate decomposition into CZ and Hadamard gates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the limited connectivity of NISQ devices (nearest neighbours for most
    qubits), the SWAP gate that swaps the states of the qubits is especially useful
    and its efficient implementation using available native gates is very important.
    The SWAP gate can be represented by a sub-circuit consisting of three CX gates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.21: SWAP gate decomposition into three CX gates. ](img/file563.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.21: SWAP gate decomposition into three CX gates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking into account the relationship between CX and CZ gates in Figure [6.20](#6.20),
    the SWAP gate can also be decomposed into a sub-circuit of three CZ and a handful
    of one-qubit Hadamard gates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22: SWAP gate decomposition into three CZ and six Hadamard gates.
    ](img/file564.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.22: SWAP gate decomposition into three CZ and six Hadamard gates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, the SWAP gate can be implemented with the help of three iSWAP
    gates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-137013r23: SWAP gate decomposition into three iSWAP gates (iSWAP
    = XY(π)) and three √- X gates. ](img/file566.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.23: SWAP gate decomposition into three iSWAP gates (iSWAP = XY(π))
    and three ![√- X](img/file565.jpg) gates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easy to verify by direct calculations that the circuit on the right side
    of Figure [6.23](#6.23) performs the following transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ |0| |0| | 0| ||1|| ||0|| ( π )|| 0|| ( π ) |0⟩⊗ |1⟩ ≡ | | −→
    | | = exp i-- | | ≡ exp i- |1⟩ ⊗ |0⟩, |⌈0|⌉ |⌈ i|⌉ 2 |⌈ 1|⌉ 2 0 0 0 ](img/file567.jpg)![
    ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ |0| |0| | 0| ||0|| || i|| ( π )|| 1|| ( π ) |1⟩⊗ |0⟩ ≡ | | −→ | |
    = exp i-- | | ≡ exp i- |0⟩ ⊗ |1⟩. |⌈1|⌉ |⌈0|⌉ 2 |⌈ 0|⌉ 2 0 0 0 ](img/file568.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The coefficient exp![(iπ ∕2)](img/file569.jpg) is a *global phase* and can
    be ignored. We can do this because a global phase is not *observable*: measuring
    the states ![|ψ⟩](img/file570.jpg) and exp(i*ϕ*)![|ψ⟩](img/file571.jpg) will yield
    the same result (i.e., the same states with the same probabilities) for any *ϕ*
    ∈ℝ. Said differently, two states differing only by a global phase represent the
    same physical system.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we mention the iSWAP representation of the CNOT gate. To do this, we
    need two iSWAP and several one-qubit gates as shown in Figure [6.24](#6.24).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-137016r24: CNOT gate decomposition into two iSWAP gates (iSWAP =
    XY(π)) and several one-qubit rotation gates. ](img/file572.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.24: CNOT gate decomposition into two iSWAP gates (iSWAP = XY(π)) and
    several one-qubit rotation gates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CNOT gate applies the NOT gate to the target qubit if the control qubit
    is in state ![|1⟩](img/file573.jpg) while leaving the control qubit state unchanged.
    This is exactly what we see when we apply the circuit shown on the right side
    of Figure [6.24](#6.24) to the states ![|10⟩](img/file574.jpg) and ![|11⟩](img/file575.jpg):'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ |0| | 0 | | 0| ||0|| || 0 || ( π )|| 0|| ( π) |1⟩⊗ |0⟩ ≡ ||
    || − → || || = exp − i- || || ≡ exp − i- |1⟩⊗ |1⟩, ⌈1⌉ ⌈ 0 ⌉ 4 ⌈ 0⌉ 4 0 1√−i 1
    2 ](img/file576.jpg)![ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ 0 0 0 || || || || ( )|| || ( ) |1⟩⊗ |1⟩ ≡ ||0||
    − → || 0 || = exp − iπ || 0|| ≡ exp − iπ |1⟩⊗ |0⟩. |⌈0|⌉ |⌈ 1√−i|⌉ 4 |⌈ 1|⌉ 4
    2 1 0 0 ](img/file577.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, the accumulated unobservable global phase is exp![(− iπ∕4)](img/file578.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Decomposition of non-native two-qubit gates into the subcircuits consisting
    of the native two-qubit gates and high fidelity one-qubit gates allows us to build
    hardware-independent quantum algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Mimicking the setup for classical logic gates above, we now investigate how
    qubits and quantum logic gates can be effectively (physically) realised.
  prefs: []
  type: TYPE_NORMAL
- en: 6.7 Physical Realisations of Qubits and Quantum Gates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that the theoretical framework for quantum bits and quantum gates has been
    set, it is important to understand how these can actually be realised from a hardware
    point of view.
  prefs: []
  type: TYPE_NORMAL
- en: 6.7.1 The DiVincenzo criteria
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The modern approach to building quantum computing hardware was marked by the
    set of requirements for the physical implementation of quantum computation proposed
    in 2000 by DiVincenzo  [[87](Biblography.xhtml#XDiVincenzo2000)]. These requirements,
    now known as the "DiVincenzo criteria", are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1\. A scalable physical system with well characterised qubits.** A qubit
    being “well characterised” means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: its physical parameters should be accurately known, including the internal Hamiltonian
    of the qubit, which determines the qubit energy eigenstates. Typically, the ground
    state is taken as ![|0⟩](img/file579.jpg) and the first excited state is taken
    as ![|1⟩](img/file580.jpg);
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the presence of and couplings to other states of the qubit;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the couplings to external fields, needed to manipulate the state of the qubit;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the interactions with other qubits, needed to implement multi-qubit gates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2\. The ability to initialise the state of the system to a simple fiducial**
    **state, such as an all-zero state.** This requirement arises from the clear need
    to initialise quantum registers to a known value before the start of the computation.
    Another motivation for this requirement is the fact that quantum error correction
    requires a continuous, fresh supply of qubits in a low-entropy state (![|0⟩](img/file581.jpg)
    state). The need for a continuous supply of 0s, rather than just an initial supply,
    is a non-trivial problem that may rule out some of the potentially promising qubit
    implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. Long relevant decoherence times, much longer than the gate** **operation
    time.** Decoherence can be viewed as the loss of information from a quantum system
    into the environment. Coupling with the environment leads to entanglement between
    the system and environment and the transfer of quantum information to the surroundings.
    As a result, the system dynamics is no longer unitary and the computation becomes
    irreversible (though the combined system plus environment evolves in a unitary
    fashion). This means that the quantum computer behaves as a classical machine.
    Therefore, it is important to preserve coherence for sufficiently long time to
    ensure that the uniquely quantum features of this style of computation have a
    chance to come into play. The term “relevant” emphasises that a physical system
    that realises a qubit can have many decoherence times pertaining to different
    degrees of freedom but many of these can be irrelevant to the functioning of this
    system as a qubit.'
  prefs: []
  type: TYPE_NORMAL
- en: '**4\. A universal set of quantum gates.** In all the physical implementations,
    only particular sorts of Hamiltonians can be turned on and off. In most cases,
    we are limited by only two-body (two-qubit) interactions. This poses a problem
    for a quantum computation specified with multi-qubit unitary transformations.
    Fortunately, these can always be re-expressed in terms of sequences of one- and
    two-qubit gates, and the two-qubit gates can be of just one type, which is "native"
    to a particular implementation (e.g., CNOT, CPHASE, or XY).'
  prefs: []
  type: TYPE_NORMAL
- en: '**5\. A qubit-specific measurement capability.** This is a straightforward
    requirement for the efficient quantum computing process: the result of a computation
    must be read out, and this requires the ability to measure specific qubits.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many possible realisations of quantum computers satisfying the DiVincenzo
    criteria. The fundamental building blocks of quantum computers – qubits – can
    be constructed from electrons, photons, trapped ions, neutral atoms, superconducting
    circuits, to name just a few possibilities. Essentially, any quantum mechanical
    system that can exist in a superposition of two distinct states with controlled
    transitions between them can serve as a physical realisation of a qubit. This
    can be the spin of an electron ("up", "down") or the polarisation of a photon
    ("vertical", "horizontal"). In this section, we start with considering how the
    DiVincenzo criteria can be satisfied by superconducting qubits.
  prefs: []
  type: TYPE_NORMAL
- en: 6.7.2 Superconducting qubits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Qubits constructed from tiny superconducting circuits are strong candidates
    for the scalable physical realisation of the principles of digital quantum computing.
    In a normal conductor, the charge carriers are individual electrons. Electrons
    are spin-![12](img/file582.jpg) elementary particles (fermions) satisfying the
    Pauli principle: no two fermions can simultaneously occupy the same state. In
    a superconducting circuit, the basic charge carriers are pairs of electrons (known
    as Cooper pairs), which are bosons (the total spin of a Cooper pair is an integer
    number) and can occupy the same quantum energy level. This effect is known as
    the Bose-Einstein condensate. The condensate wave function allows designing and
    measuring macroscopic quantum effects. The parameters of the superconducting circuits
    may be designed by setting the classical values of the electrical elements that
    compose them, e.g., adjusting the capacitance and inductance.'
  prefs: []
  type: TYPE_NORMAL
- en: This gives us a concrete idea of how to build macroscopic qubits with desired
    quantum properties. Let us first have a look at the system known as Quantum Harmonic
    Oscillator (QHO) shown schematically in Figure [6.25](#6.25). Before explaining
    the physical aspects, let us have a look at its mathematical justification.
  prefs: []
  type: TYPE_NORMAL
- en: From classical to quantum harmonic oscillator
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider a simple harmonic oscillator, namely a spring on a flat frictionless
    surface, attached on one side to an unmovable object and on the other side to
    a movable one (say, a weight). In the equilibrium state, in the resting position,
    nothing moves. After applying some force, say by pulling (or pushing) the movable
    object, the spring starts oscillating due to its restoring force *F*[R]. Hooke’s
    law states that this force is proportional to the extension, namely
  prefs: []
  type: TYPE_NORMAL
- en: '![FR (x(t)) = − kx(t), ](img/file583.jpg)'
  prefs: []
  type: TYPE_IMG
- en: starting from *x*(0) = *x*[0] ∈ℝ, where *x*(*t*) denotes the position of the
    spring at time *t* and *k* is the spring constant. Newton’s second law of motion
    also states that
  prefs: []
  type: TYPE_NORMAL
- en: '![FR(x(t)) = ma (t), ](img/file584.jpg)'
  prefs: []
  type: TYPE_IMG
- en: for *t* ≥ 0, where *a*(*t*) denotes the acceleration at time *t*, and *m* is
    the mass of the spring. Since *a*(*t*) = *ẍ*(*t*), combining the two equations
    yields, for each *t* ≥ 0,
  prefs: []
  type: TYPE_NORMAL
- en: '![¨x(t) = − k-x(t), m ](img/file585.jpg)'
  prefs: []
  type: TYPE_IMG
- en: starting from *x*(0) = *x*[0], which is the equation of motion for the simple
    oscillator. It is a simple one-dimensional second order linear ordinary differential
    equation, which can be solved simply as
  prefs: []
  type: TYPE_NORMAL
- en: '| ![x(t) = x0cos(ωt)+ v0sin(ωt), for all t ≥ 0, ω ](img/file586.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∘ -k- ω := -- and v0 := ˙x(0) m ](img/file587.jpg)'
  prefs: []
  type: TYPE_IMG
- en: are, respectively, the natural frequency of the oscillator and the speed. Trigonometric
    manipulations show that ([6.7.2](#x1-1410002)) can equivalently be written as
  prefs: []
  type: TYPE_NORMAL
- en: '| ![x(t) = α cos(ωt − φ), for all t ≥ 0, ](img/file588.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∘ -------- 2 v20- -v0- α := x0 + ω2 and tan(φ) := ωx0\. ](img/file589.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Recall now that the potential energy 𝔙 is the energy stored in the oscillator
    when it is extended or compressed, i.e. (considering *x* = 0 as the equilibrium
    state),
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∫ x(t) k 𝔙 (x,t) = − FR(z)dz = --x(t)2\. 0 2 ](img/file590.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The total energy of the system is then the sum of the kinetic and the potential
    energies:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 𝔈[total](*t*) | = 𝔈[kinetic](*t*) + 𝔙(*x*(*t*)) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = ![m- 2](img/file591.jpg)*v*(*t*)² + ![k- 2](img/file592.jpg)*x*(*t*)²*.*
    |'
  prefs: []
  type: TYPE_TB
- en: 'Using the explicit solution ([6.7.2](#x1-1410002)), with *ω* := ![∘ -- k- m](img/file593.jpg)
    we obtain:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 𝔈[total](*t*) | = ![m- 2](img/file594.jpg)![( ( ) ) d- α cos(ωt− φ ) dt](img/file595.jpg)²
    + ![k- 2](img/file596.jpg)![(](img/file597.jpg)*α* cos(*ωt* − *φ*)![)](img/file598.jpg)²
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | = ![m α2ω2 --2----](img/file599.jpg)sin(*ωt* − *φ*)² + ![mα2 ω2 --2----](img/file600.jpg)cos(*ωt*
    − *φ*)² |'
  prefs: []
  type: TYPE_TB
- en: '|  | = ![ 2 2 m-α-ω-- 2](img/file601.jpg) = ![ 2 kα-- 2](img/file602.jpg)*.*
    |'
  prefs: []
  type: TYPE_TB
- en: 'In this classical setting, we see that the total energy of the system can take
    a continuum of values. The quantum counterpart is fundamentally different and
    we shall see below that it is in fact quantised (giving rise to the "quantum"
    theory), as originally proposed by Bohr in 1913, and later detailed by Schrödinger
    and Heisenberg in 1926\. Recall now the general form of the time-dependent Schrödinger
    equation describing the evolution of a system over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![iℏ dΨ(x,t)-= ℋ Ψ(x,t), dt ](img/file603.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: where ℋ represents the Hamiltonian of the system. Since the latter (representing
    the energy of the system) is the sum of the kinetic energy and the potential energy,
    we have
  prefs: []
  type: TYPE_NORMAL
- en: '![ 2 2 ℋ = 𝔈kinetic + 𝔈potential =-p- + 𝔙 = − -ℏ- d---+ 𝔙, 2m 2m dx2 ](img/file604.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'where *m* is the mass of the particle, ℏ is the usual Planck constant, 𝔙 is
    the potential representing the environment, and *p* is the momentum operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ d p = − iℏ--. dx ](img/file605.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Plugging this Hamiltonian into ([6.7.2](#x1-1410002)) yields
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ dΨ (x,t) ( ℏ2 d2 ) iℏ--------= − -----2-+ 𝔙 (x) Ψ (x,t). dt 2m dx ](img/file606.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: Since the potential 𝔙 does not depend on time, separation of variables, with
    Ψ(*x,t*) = *ψ*(*x*)*u*(*t*), gives
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( ) ′ -ℏ2 ′′ iℏψ(x)u (t) = −2m ψ (x)+ 𝔙 (x)ψ(x) u(t), ](img/file607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: or else
  prefs: []
  type: TYPE_NORMAL
- en: '![ u′(t) − ℏ22mψ ′′(x )+ 𝔙 (x)ψ(x) iℏ u(t) = --------ψ-(x-)--------. ](img/file608.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since both sides depend on a different variable, they must be equal to a constant,
    say *E*, and we thus obtain the ordinary differential equation
  prefs: []
  type: TYPE_NORMAL
- en: '![ u-′(t) iℏ u(t) = E, ](img/file609.jpg)'
  prefs: []
  type: TYPE_IMG
- en: as well as the eigenvalue equation
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ℏ2 ℋ ψ (x ) = −---ψ ′′(x) + 𝔙 (x )ψ (x) = E ψ (x ). 2m ](img/file610.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: The first one immediately admits the solution, with normalisation *u*(0) = 1,
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( iEt ) u(t) = exp − --- . ℏ ](img/file611.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The eigenvalue equation ([6.7.2](#x1-1410002)) can be solved, for example, by
    spectral method. In fact, it can be proved (and we refer the interested reader
    to  [[258](Biblography.xhtml#Xschwabl2007quantum), Section 3.1] for details) that
    the operator ℋ here admits a finite spectrum, with the set of (eigenvalues, eigenfunctions)
    {(*E*[n]*,ψ*[n])}[n≥0] given by
  prefs: []
  type: TYPE_NORMAL
- en: '| ![( ( 1) &#124;&#124;{ En = n + -- ℏω, 2( )1∕4 ( 2 ) (∘ ---- ) &#124;&#124;(
    ψn (x) = √-1--- mω-- exp − m-ωx-- Hn m-ω-x , 2nn! πℏ 2ℏ ℏ ](img/file612.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: for each *n* ≥ 0*,x* ∈ℝ, where *H*[n] denotes the *n*-th physicists’ Hermite
    polynomial
  prefs: []
  type: TYPE_NORMAL
- en: '![ n ( ) Hn (z) := (− 1)nez2-d e−z2 . dzn ](img/file613.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Physical representation of the QHO
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A schematic representation of the QHO is shown in Figure [6.25](#6.25). In this
    system, energy oscillates between electrical energy in the capacitor *C* and magnetic
    energy in the inductor *L*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-142001r25: Quantum Harmonic Oscillator (QHO). ](img/file614.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.25: Quantum Harmonic Oscillator (QHO).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Hamiltonian of this system is identical to the one describing a particle
    in a one-dimensional quadratic potential  [[177](Biblography.xhtml#XKrantz2019)].
    The solution to the eigenvalue problem above (see ([6.7.2](#x1-1410002))) gives
    an infinite series of eigenstates (![|n⟩](img/file615.jpg))[n≥0], whose corresponding
    eigenenergies, (*E*[n])[n≥0], are all equidistantly spaced as can be seem from ([6.7.2](#x1-1410002)):'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![En+1 − En = ℏ ωr, for all n ≥ 0, ](img/file616.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: where the resonant frequency, *ω*[r], is given by the Thompson formula  [[283](Biblography.xhtml#XTomawski2021)]
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ωr = √-1--. LC ](img/file617.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: Our first task is to define a computational subspace consisting of only two
    energy states, ![|0⟩](img/file618.jpg) and ![|1⟩](img/file619.jpg), usually the
    lowest two energy eigenstates in between which transitions can be driven without
    also exciting other levels in the system. However, we cannot use the lowest two
    energy eigenstates of the QHO for this purpose since the quantum logic gate operations
    depend on frequency selectivity. The equidistant level-spacing of the QHO makes
    this impossible.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we need to add anharmonicity (or non-linearity) into the system.
    We require the transition frequencies *ω*[01] between eigenstates ![|0⟩](img/file620.jpg)
    and ![|1⟩](img/file621.jpg) and *ω*[12] between eigenstates ![|1⟩](img/file622.jpg)
    and ![|2⟩](img/file623.jpg) to be sufficiently different in order to be individually
    addressable. The required non-linearity can be introduced by replacing the inductor *L*
    with the Josephson junction module *J*, as shown schematically in Figure [6.7.2](#x1-142001r2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.26: Qubit implemented as Quantum Anharmonic Oscillator (QAO). The
    two lowest energy eigenstates |0⟩ and |1⟩ form the qubit’s computational space.
    ](img/file626.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.26: Qubit implemented as Quantum Anharmonic Oscillator (QAO). The
    two lowest energy eigenstates ![|0⟩](img/file624.jpg) and ![|1⟩](img/file625.jpg)
    form the qubit’s computational space.'
  prefs: []
  type: TYPE_NORMAL
- en: The Josephson junction is the key element that transforms a superconducting
    circuit into a qubit. The description of the Josephson effect (the quantum tunnelling
    of the Cooper pairs) is outside the scope of this book but interested readers
    are encouraged to learn more about it from the excellent Feynman’s Lectures on
    Physics  [[101](Biblography.xhtml#XFeynman)].
  prefs: []
  type: TYPE_NORMAL
- en: After introducing the Josephson module to the circuit (the electric circuit
    symbol for the Josephson junction is an "X"), the potential energy no longer has
    the parabolic form (as a function of the superconducting phase), but rather takes
    a cosinusoidal form, which makes the energy spectrum non-equidistant. Now we can
    identify the two lowest energy eigenstates as a qubit computational subspace  [[177](Biblography.xhtml#XKrantz2019), [204](Biblography.xhtml#XMartinis2009)].
  prefs: []
  type: TYPE_NORMAL
- en: 'A superconducting loop with two Josephson junctions in either arm is very sensitive
    to the magnetic flux enclosed  [[119](Biblography.xhtml#XGrundmann2005)]. In the
    following, we shall use a more compact symbol for the Josephson junction subcircuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.27: Josephson junction module subcircuit. ](img/file627.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.27: Josephson junction module subcircuit.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Remark:** It may also be possible to form a computational subspace using
    the three lowest energy eigenstates: ![|0⟩](img/file628.jpg), ![|1⟩](img/file629.jpg)
    and ![|2⟩](img/file630.jpg). In this case, we would have a physical realisation
    of a *qutrit*, whose superposition state vector, ![|ψ⟩](img/file631.jpg), can
    be represented as a linear combination of the three orthonormal basis states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![|ψ⟩ = α |0⟩+ β |1⟩+ γ |2⟩, ](img/file632.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *α,β,γ* ∈ℂ are probability amplitudes such that |*α*|² + |*β*|² + |*γ*|²
    = 1\. Qutrits increase the amount of information encoded in a single element,
    enable techniques that decrease readout errors  [[200](Biblography.xhtml#XMallet2009)]
    and reduce the cost of decomposing three-qubit gates into basic two-qubit components  [[132](Biblography.xhtml#XHill2021)].
  prefs: []
  type: TYPE_NORMAL
- en: Controlling and measuring superconducting qubits
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Having satisfied the first DiVincenzo requirement (well defined qubit), we have
    to demonstrate how superconducting qubits can be controlled, coupled together
    to build scalable systems, and measured. We start with the control and measurement
    of the superconducting qubit states.
  prefs: []
  type: TYPE_NORMAL
- en: The capacitive coupling between a resonator (or a feedline) and the superconducting
    qubit allows for microwave control to implement single-qubit rotations as well
    as certain two-qubit gates  [[177](Biblography.xhtml#XKrantz2019)]. Figure [6.28](#6.28)
    provides a schematic representation of the superconducting qubit coupled to a
    microwave source (also referred to as a *qubit drive*). The qubit is controlled
    by the pulses of microwave radiation. The control parameters are the frequency,
    the phase and the duration of the pulses.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-143001r28: Qubit capacitively coupled to the feedline. ](img/file633.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.28: Qubit capacitively coupled to the feedline.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure [6.29](#6.29) shows the qubit that is capacitively coupled to a microwave
    resonator (non-linear) whose frequency is shifted by the qubit state  [[254](Biblography.xhtml#XSchmitt2015)].
    This frequency shift is exploited for reading the qubit state using the dispersive
    readout method. When sending a microwave pulse to the resonator, the phase of
    the reflected (or transmitted) signal conveys information on the qubit state.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-143003r29: Qubit readout circuit that features a non-linear resonator
    with Josephson junction. ](img/file634.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.29: Qubit readout circuit that features a non-linear resonator with
    Josephson junction.'
  prefs: []
  type: TYPE_NORMAL
- en: Entanglement with superconducting qubits
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For the implementation of multi-qubit gates (and, therefore, entanglement),
    qubits must be connected. The connectivity of superconducting qubits is realised
    via capacitive coupling – either directly or with the help of a coupler as shown
    schematically in Figure [6.30](#6.30), where capacitive coupling is achieved via
    a coupler in the form of a linear resonator  [[177](Biblography.xhtml#XKrantz2019)].
  prefs: []
  type: TYPE_NORMAL
- en: The fixed-frequency superconducting qubits typically feature longer coherence
    times and are less sensitive to flux noise. The two-qubit gate developed for these
    qubits is the cross-resonance gate CR. In the schematic circuit diagram of two
    fixed-frequency superconducting qubits coupled through a linear resonator (Figure [6.30](#6.30)),
    the CR gate is realised when qubit 1 is driven at the frequency of qubit 2.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-144002r30: Capacitive coupling via coupler (linear resonator). Qubit
    1 and Qubit 2 are fixed-frequency qubits with frequencies ω1 and ω2 respectively.
    ](img/file635.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.30: Capacitive coupling via coupler (linear resonator). Qubit 1 and
    Qubit 2 are fixed-frequency qubits with frequencies ω[1] and ω[2] respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The unitary matrix representation of the CR(*𝜃*) gate is given by the following  [[240](Biblography.xhtml#XQiskitRZXGate)]:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ( ) CR(𝜃) = RZ⊗X(𝜃) = exp − 1-i𝜃σz ⊗ σx ⌊ 2 ⌋ cos(𝜃) − isin (𝜃) 0 0 &#124;
    2( ) ( 2) &#124; &#124;&#124; − isin 𝜃2 cos 𝜃2 0 0 &#124;&#124; = &#124;&#124;
    (𝜃 ) (𝜃)&#124;&#124;, ⌈ 0 0 cos 2( ) isin( 2) ⌉ 0 0 isin 𝜃2 cos 𝜃2 ](img/file636.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: where the effective rotation angle *𝜃* is a function of the physical characteristics
    of the qubits, the coupler, and the driving microwave pulse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the form of ([6.7.2](#x1-144002r2)), the CR(*𝜃*) gate can also be denoted
    as the ZX(*𝜃*) gate. This also tells us how we can use the cross-resonance gate
    to generate a CNOT gate (up to a global phase exp(−i*π∕*4)) in combination with
    only one-qubit gates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.31: CNOT gate decomposition into ZX, RX and RZ gates. ](img/file637.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.31: CNOT gate decomposition into ZX, R[X] and R[Z] gates.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.7.3 Photonic qubits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At the time of writing, it is not clear which qubit construction technology
    will become the industry standard, if any. There are a lot of exciting experiments
    and technological breakthroughs ahead of us. The superconducting qubits clearly
    satisfy the DiVincenzo criteria but there are many other interesting solutions
    at various stages of development.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the possibilities is to encode qubits in photons. Single photons are
    largely free of noise and can be easily manipulated to realise one-qubit gates.
    A qubit can be encoded in any of multiple photon’s degrees of freedom: temporal,
    path, and polarisation. One-qubit gates can be implemented using *birefringent
    waveplates* and conversion between polarisation and path encoding can be achieved
    using a *polarising beam splitter*  [[225](Biblography.xhtml#XOBrien2008)], where
    ![|0⟩](img/file638.jpg) or ![|1⟩](img/file639.jpg) represents a photon in the
    upper or lower path, respectively (see Figure [6.33](#6.33)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know, in order to entangle qubits, we need to find a suitable physical
    implementation of two-qubit gates. Let us have a look at the possible realisation
    of the CNOT gate using photonic qubits. First of all, we notice that the CNOT
    gate can be expressed in terms of the CPHASE gate, which can be naturally implemented
    on the photonics hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.32: CNOT gate decomposition into CPHASE and H gates. ](img/file640.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.32: CNOT gate decomposition into CPHASE and H gates.'
  prefs: []
  type: TYPE_NORMAL
- en: When the control qubit is in state ![|0⟩](img/file641.jpg) the two H gates cancel
    each other, and when it is in state ![|1⟩](img/file642.jpg) the combination of
    the gates acts as a NOT gate.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [6.33](#6.33) displays schematic representation of the possible photonic
    implementation of the CNOT gate  [[225](Biblography.xhtml#XOBrien2008)]. The two
    paths used to encode the target qubit are mixed at a 50% reflecting beam splitter
    (BS) that performs the Hadamard operation. If the phase shift is not applied,
    the second beam splitter (second Hadamard gate) undoes the first by returning
    the target qubit to the same state it started in. This is an example of classical
    interference. If a *π* phase shift is applied, the target qubit is flipped.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-145004r33: Photonic implementation of the CNOT gate. ](img/file643.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.33: Photonic implementation of the CNOT gate.'
  prefs: []
  type: TYPE_NORMAL
- en: When the control qubit is in state ![|0⟩](img/file644.jpg), the *π*-phase shift
    is not applied, while it is applied when the control qubit is in state ![|1⟩](img/file645.jpg).
    A CNOT gate must implement this phase shift when the control qubit is in the ![|1⟩](img/file646.jpg)
    path, otherwise not.
  prefs: []
  type: TYPE_NORMAL
- en: Although the proposed realisation of the CNOT gate is simple in principle, it
    is a hard practical problem to find a material with optical non-linearity strong
    enough to implement the conditional phase shift  [[225](Biblography.xhtml#XOBrien2008)].
    However, it is possible to achieve a CNOT gate with the help of single photon
    sources, single photon detectors, and linear optical circuits consisting of beam
    splitters as was proposed by Knill, Laflamme, and Milburn  [[165](Biblography.xhtml#XKLM2001)].
    The first integrated photonic CNOT gate for polarisation-encoded qubits was demonstrated
    in  [[74](Biblography.xhtml#XCrespi2011)].
  prefs: []
  type: TYPE_NORMAL
- en: 6.7.4 Trapped ion qubits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another promising approach to building large-scale quantum computers is based
    on the trapped ion technology  [[68](Biblography.xhtml#XCirac1995)]. Ions (positively
    charged atoms that lost an electron) are *trapped* in the electromagnetic field
    potential, which fixes their positions in space. The quantum chip is cooled and
    placed in the vacuum chamber. The ions themselves are cooled and made almost motionless
    by the laser beams that drain their energy through the rapid absorption-emission
    of photons (ions emit photons of slightly higher frequency than absorbed photons,
    thus losing their kinetic energy).
  prefs: []
  type: TYPE_NORMAL
- en: 'The most widely used technique is a *linear trap* shown in Figure [6.34](#6.34).
    The two states of the *i*-th qubit can be identified with the internal states
    of the corresponding ion: a ground state ![|g⟩](img/file647.jpg)[i] and an excited
    state ![|e⟩](img/file648.jpg)[i]. The trapped ions do not sit perfectly still
    but can oscillate around their equilibrium positions. Figure [6.34](#6.34) depicts
    a situation where *N* ions are confined in a linear trap and interact with different
    laser beams in standing wave configurations  [[67](Biblography.xhtml#XCirac1993)].'
  prefs: []
  type: TYPE_NORMAL
- en: The confinement of the motion along the *x*-, *y*-, and *z*-axes can be described
    by a harmonic potential of frequencies *ω*[x] ≪ *ω*[y], *ω*[z] respectively. Additionally,
    the Coulomb repulsion between the positively charged ions provides the coupling
    of the motion of the ions along the *x*-axis. The collective motion (excitation)
    along the *x* axis, if present, behaves as a quasiparticle called a *phonon*.
    We denote the state of the Centre-of-Mass (CM) mode of *N* ions moving in the
    *x*-direction as ![|0⟩](img/file649.jpg) (no phonon) or ![|1⟩](img/file650.jpg)
    (one phonon).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figurex1-146003r34: Schematic representation of the linear ion trap. ](img/file651.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.34: Schematic representation of the linear ion trap.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the laser beam at the right frequency, it is possible to exclusively
    excite either a single ion or the CM mode. Addressing a single ion (and, thus,
    implementing a one-qubit gate) is straightforward. Let us see how we can implement
    a multi-qubit gate needed to create entanglement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following protocol that implements a two-qubit gate was proposed by Cirac
    and Zoller  [[68](Biblography.xhtml#XCirac1995)]. First, we note that the excited
    state ![|e⟩](img/file652.jpg)[i] is not unique and depends on the polarisation
    of the laser beam applied to ion *i*. If we have two possible polarisations, which
    we denote as *q* = 0 and *q* = 1, then the corresponding excited states are denoted
    as ![|e0⟩](img/file653.jpg)[i] and ![|e1⟩](img/file654.jpg)[i]. The computational
    basis is {![|g⟩](img/file655.jpg)[i]*,*![|e0⟩](img/file656.jpg)[i]}. The protocol
    reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Apply a *π* laser pulse with polarisation *q* = 0 to excite the *i*-th ion.
    The *π* laser pulse has the meaning of a laser pulse applied for time *π∕ω*, where
    *ω* is a characteristic frequency of the trapped ion system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Direct the laser to the *j*-th ion and turn it on for a time of a 2*π* pulse
    with polarisation *q* = 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Direct the laser back to the *i*-th ion and turn it on for a time of a *π* pulse
    with polarisation *q* = 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The effect of this procedure is to change the sign of the state only when both
    ions are initially excited as shown in Table [6.5](#table6.5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.5: Two-qubit gate (CPHASE) with the trapped ion qubits. ](img/file657.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 6.5: Two-qubit gate (CPHASE) with the trapped ion qubits.'
  prefs: []
  type: TYPE_NORMAL
- en: We note that the state of the CM mode is restored to the initial state ![|0⟩](img/file658.jpg)
    (no phonon) after the process. The protocol realises the CPHASE two-qubit gate.
  prefs: []
  type: TYPE_NORMAL
- en: Trapped ion-based qubits are characterised by longer coherence time (how long
    the quantum state survives) and higher fidelity (accuracy of the gate operations)
    in comparison with the superconducting qubits. On the flip side, superconducting
    qubits enjoy orders of magnitude shorter gate times.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to many possible physical realisations of a classical bit, there exist
    many competing quantum computing technologies. It is too early to say which one
    will become the ultimate winner in the long run, or whether multiple technologies
    will co-exist by occupying their respective niches.
  prefs: []
  type: TYPE_NORMAL
- en: We now have all the tools, theoretical and physical, to actually build quantum
    circuits. In the next section, we discuss the quantum hardware and quantum simulators
    that would allow us to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 6.8 Quantum Hardware and Simulators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The current state-of-the-art quantum computing technology demonstrates impressive
    qubit fidelity and coherence time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Qubits made of superconducting circuits (coherence time: ∼ 10µs)   [[164](Biblography.xhtml#XKjaergaard2019)]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| one-qubit gate |  | two-qubit gate |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Gate time: | ∼ 10^(−2)µs | Gate time: | ∼ 10^(−2)-10^(−1)µs |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Fidelity: | 99.9% | Fidelity: | 99.7% |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'Table 6.6: Superconducting qubits.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Qubits made of trapped ions (coherence time: *>* 10⁷µs)  [[46](Biblography.xhtml#XBruzewicz2019)]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| one-qubit gate |  | two-qubit gate |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Gate time: | ∼ 1-10µs | Gate time: | ∼ 10µs |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Fidelity: | 99.9999% | Fidelity: | 99.9% |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'Table 6.7: Trapped ion qubits.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Even more importantly, the pace of technological improvements remains very fast.
    Recent experiments conducted by MIT researchers on superconducting qubits  [[277](Biblography.xhtml#XSung2021)]
    demonstrated a possibility to sharply reduce errors in two-qubit gates, bringing
    two-qubit gate fidelity for CZ and iSWAP gates to near 99.9%. Interestingly, this
    improvement in two-qubit gate fidelity has been achieved through the introduction
    of tunable couplers (Figure [6.30](#6.30) schematically shows a two-qubit interaction
    via a coupler). To eliminate the error generating qubit-qubit interactions, the
    higher energy levels of the coupler were used to cancel out the problematic interactions.
    As was schematically shown in Figure [6.7.2](#x1-142001r2), the higher energy
    levels are usually ignored, although they have a non-negligible contribution.
    Better control and design of the coupler is key to tailoring the qubit-qubit interaction
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a big step towards implementing *error correction*: additional qubits
    can be added to improve the robustness of quantum computation. Qubit errors can
    be actively addressed by adding redundancy. However, in order for the hardware
    redundancy to be practical, higher qubit fidelity is required. Different error
    correction protocols require different fidelity thresholds, and 99.9% two-qubit
    gate fidelity is not a bad place to start.'
  prefs: []
  type: TYPE_NORMAL
- en: However, we are still some years away from sufficiently fault-tolerant quantum
    computers. This is why it is useful (and even necessary) to experiment with quantum
    simulators – classical computers operating according to the logic of quantum computing.
    There is nothing preventing classical digital computers from operating according
    to the laws of quantum computing except for prohibitive memory requirements. The
    state of an *n*-qubit quantum system can be stored in classical memory as 2^n
    probability amplitudes. This prevents most classical computers from performing
    quantum computing operations on more than 35-40 qubits. But it is perfectly feasible
    to run quantum computing programs on up to 25-30 quantum registers.
  prefs: []
  type: TYPE_NORMAL
- en: Although quantum simulators can only operate on a relatively small number of
    qubits, they are *ideal* quantum computers that do not suffer from any type of
    quantum hardware imperfections. This makes them invaluable in testing principles
    and small-scale versions of quantum algorithms. They can be used for the proof-of-concept
    and to help develop new ideas in a situation where actual quantum hardware is
    still too noisy and not readily available.
  prefs: []
  type: TYPE_NORMAL
- en: There are many open-source quantum simulators (and, even, specialised quantum
    computing programming languages). In this book, we investigate the performance
    of various quantum algorithms using `Qiskit`  [[238](Biblography.xhtml#XIBM2019)]
    – an open-source Python package that implements the logic of quantum computing
    in an intuitive and user-friendly way. Qiskit also owes its popularity to a well-written
    and highly educational textbook with many well-thought-out examples that make
    it a pleasure to learn the principles of quantum computing. The `Qiskit` package
    and the textbook are available from
  prefs: []
  type: TYPE_NORMAL
- en: '`https://qiskit.org/`'
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '`https://qiskit.org/textbook/preface.html`'
  prefs: []
  type: TYPE_NORMAL
- en: The field of quantum programming is growing fast and several languages or software
    development kits are now competing. Quantum instruction sets such as `Quil`, `cQASM`,
    `OpenQASM`, and `Blackbird` allow us to translate high-level algorithms into physical
    instructions run on quantum computers. They are used in quantum software development
    kits (QSDKs) to represent quantum circuits. The most important QSDKs at the time
    of writing are
  prefs: []
  type: TYPE_NORMAL
- en: '`Ocean` (D-Wave)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Forest` (Rigetti)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qiskit` (IBM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cirq` (Google)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Quantum Development Kit` (Microsoft)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Braket SDK` (Amazon)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProjectQ` (ETH Zurich)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Strawberry Fields` (Xanadu)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel to these QSDKs, quantum programming languages have been developed,
    both of the imperative type (step-by-step instructions) such as `QCL`, `QMASM`,
    and `Silq` and of the functional type such as `QML`, `Quantum Lambda Calculus`,
    `QFC`, `QPL`, and `Q`*♯*.
  prefs: []
  type: TYPE_NORMAL
- en: We observed an exceptionally fast pace of quantum computing hardware development
    over the last several years, with multiple technological breakthroughs. Additionally,
    the progress on the quantum software development side assists in relaxing requirements
    for the physical qubits needed to build fault-tolerant quantum computers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we covered and contrasted the basic elements of classical
    and quantum computing. We started with the concept of a fundamental memory unit
    (bit) and functions that transform the memory states (logic gates). We also provided
    examples of the possible physical realisations of the logic gates and a memory
    cell – this highlights the fundamental dualism of both classical and quantum computing:
    computation is substrate independent but its practical realisation requires the
    existence of a suitable physical system.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we introduced the concept of the qubit and its canonical mathematical
    representation. Visualisation of a qubit with the help of the Bloch sphere allows
    for the natural representation of single qubit quantum gates as rotation operators.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we studied two-qubit gates and their matrix representation. We learned
    how to assemble one-qubit and multi-qubit gates into quantum circuits – a good
    example is the Bell circuit, which creates a maximally entangled state of two
    qubits from the completely unentangled initial states. We also touched on the
    important topics of reversible computing and cutting edge quantum hardware.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce a particular type of quantum circuit,
    so-called Parameterised Quantum Circuits, that provide great flexibility for applications.
    We will also explore various data encoding schemes – the mapping of samples from
    the classical datasets into the corresponding quantum states.
  prefs: []
  type: TYPE_NORMAL
- en: Join our book’s Discord space
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Join our Discord community to meet like-minded people and learn alongside more
    than 2000 members at: [https://packt.link/quantum](https://packt.link/quantum)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
