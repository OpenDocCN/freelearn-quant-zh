- en: Chapter 5. Algorithmic Trading
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章 算法交易
- en: Algorithmic trading is defined as the buying and selling of financial instruments
    using predefined rules called algorithms. Traders use predictive modeling, time
    series modeling, and machine learning to predict the price, return, or direction
    of movement of the asset.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 算法交易被定义为使用预定义规则（称为算法）进行金融工具的买卖。交易者使用预测建模、时间序列建模和机器学习来预测资产的价格、回报或价格变动方向。
- en: Algorithms are developed by quantitative traders or quantitative researchers
    and tested on historical data. Algorithms go through rigorous testing before they
    are used for live trading. Technical indicator-based trading can also come under
    algorithm trading if it is fully automated. However, sometimes quantitative traders
    also use fundamental data such as market capitalization, cash flow, debt to equity
    ratio, and so on to define rules for algorithms. People are free to use any technique
    to define rules for algorithms. Very recently, investment or trading firms have
    started to dive deep into machine learning methods to predict price, return, or
    direction movement.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 算法由量化交易员或量化研究员开发，并在历史数据上进行测试。算法在用于实时交易之前会经过严格的测试。如果技术指标完全自动化，则基于技术指标的交易也可以归入算法交易。然而，有时量化交易员也会使用基本数据，如市值、现金流、债务股本比率等，来定义算法规则。人们可以自由使用任何技术来定义算法规则。最近，投资或交易公司开始深入研究机器学习方法，以预测价格、回报或价格变动方向。
- en: I will be covering machine learning-based trading in the next chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在下一章介绍基于机器学习的交易。
- en: 'In this chapter, I will be covering some trading strategies that are commonly
    used in the industry, along with their implementation. Specifically, I will cover
    the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍一些在行业中常用的交易策略及其实现。具体来说，我将涵盖以下主题：
- en: Momentum or directional trading
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动量或方向性交易
- en: Pairs trading
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配对交易
- en: Capital asset pricing model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资本资产定价模型
- en: Multi factor model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多因子模型
- en: Portfolio construction
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投资组合构建
- en: 'For this, I will require specific R packages such as `quantmod`, `tseries`,
    `xts`, `zoo`, and `PerformanceAnalytics`, which you can install using the following
    command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我将需要一些特定的R包，如`quantmod`、`tseries`、`xts`、`zoo`和`PerformanceAnalytics`，你可以使用以下命令安装它们：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once you have installed any package, you should load it into the workspace
    to use its functionalities, and for that, you should include the following command
    in your R code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了某个包，你应该将其加载到工作区以使用其功能，为此，你需要在R代码中包含以下命令：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Momentum or directional trading
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动量或方向性交易
- en: Momentum trading is trading when the instrument is trending up or down or, in
    other words, continuation in the trend as like historical winners are expected
    to be winners and historical losers are expected to lose. You bet on the direction
    of the instrument and you aim for buying at a low price and selling at a high
    price. I will not cover the pros and cons and what the different types of momentum
    trading strategies are. It is left to the trader to devise any idea. I will cover
    how to implement momentum trading rules and backtest using historical data in
    R. Stock return depends on various factors, and later in this chapter, I will
    show you how to use the multifactor model which explains stock return.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 动量交易是指在金融工具价格上涨或下跌时进行交易，换句话说，就是跟随趋势继续交易，就像历史上的赢家预期会继续赢，历史上的输家预期会继续输一样。你押注于金融工具的方向，目标是以低价买入，高价卖出。我不会介绍动量交易策略的优缺点以及不同类型的动量交易策略，这些留给交易者自己去设计。我将介绍如何在R中实现动量交易规则并使用历史数据进行回测。股票回报取决于多种因素，在本章后面，我将向你展示如何使用多因子模型来解释股票回报。
- en: Let me start with simple technical indicators.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我从简单的技术指标开始。
- en: 'Technical indicators are implemented in the `quantmod` package so I will be
    using `quantmod` for this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 技术指标在`quantmod`包中实现，所以我将使用`quantmod`来处理：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have to start by loading the `quantmod` package into the R workspace and
    the first line explains how to do it. Next we extract the **Dow Jones Index**
    (**DJI**) data from the Yahoo repository. The data consists of many columns, such
    as `DJI.Open`, `DJI.High`, `DJI.Low`, `DJI.Close`, and so on. This can be seen
    using the `head` (`dji`) command. The next line shows how to extract only close
    prices and store in new `variabledji`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须首先将`quantmod`包加载到R工作空间中，第一行代码解释了如何操作。接下来，我们从Yahoo数据仓库提取**道琼斯指数**（**DJI**）数据。数据包含多个列，例如`DJI.Open`、`DJI.High`、`DJI.Low`、`DJI.Close`等。可以使用`head`（`dji`）命令查看这些列。下一行展示了如何提取仅包含收盘价的数据并存储到新的`variabledji`中：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding line shows the `dji` class, which is `xts`, and `zoo` means `dji`
    is in time index format, so I used the following command to extract `dji` data
    between two specified dates:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行显示了`dji`类为`xts`，并且`zoo`表示`dji`是按时间索引格式存储的，因此我使用以下命令提取`dji`数据，在两个指定日期之间：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Delt()` converts the raw closing prices to return and by default it is one
    period return:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delt()`将原始收盘价转换为回报，默认情况下，它计算的是一个周期的回报：'
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can use `Delt()` to calculate any period return using the parameter `k`.
    However, there is an option to calculate the normal return or logarithmic return
    of a stock price as well. In the following command, I used `k=1:3`, which means
    we are calculating the `dji` return for lag `1` to `3` incremented by `1`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Delt()`函数计算任意周期的回报，使用参数`k`来指定周期。然而，也有选项可以计算股票价格的正常回报或对数回报。在以下命令中，我使用了`k=1:3`，意味着我们正在计算从滞后期`1`到`3`的`dji`回报，步长为`1`：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can see the output of the preceding command using `head()`. In the following
    result, `Delt.1`, `Delt.2`, and `Delt.3` are returned for lag `1`, `2`, and `3`
    respectively:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`head()`查看前述命令的输出。在以下结果中，`Delt.1`、`Delt.2`和`Delt.3`分别是滞后期`1`、`2`和`3`的回报：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding output has a few `NA`s, which are because of data starting. For
    the first column, the first point does not have any reference value to calculate
    the return. So the first point will be `NA` and then from the second point onward,
    we get return values. In the second column, we have to calculate the return of
    current data points from two data points before it, which is not possible for
    the first two data points, leaving first two `NA`s, and on similar lines, three
    `NA`s in the third column.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前述输出中有几个`NA`值，这是因为数据的起始点。在第一列中，第一个点没有任何参考值来计算回报。因此，第一个点将是`NA`，从第二个点开始，我们得到回报值。在第二列中，我们需要计算当前数据点与前两个数据点的回报，对于前两个数据点，这是不可能的，因此它们是`NA`，类似地，第三列中的前三个数据点也是`NA`。
- en: 'The function `Delt()` has a few more parameters and each parameter has its
    type, which is specific to this function. Sometimes it is necessary to look into
    the output, what kind of return it generates, and in which format it generates
    output. If you would like to know more about the function, and its parameters
    along with examples, you can do so using the following command, which will open
    another window explaining all the details about this function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delt()`函数有更多的参数，每个参数都有其特定的类型，这些类型对该函数是特定的。有时需要查看输出，了解它生成的是哪种回报以及输出的格式。如果你想了解更多有关该函数及其参数的内容和示例，可以使用以下命令，打开另一个窗口，详细解释该函数的所有细节：'
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The Dow Jones Index closing price in *Figure 5.1* shows a clear trend. We have
    to define a set of indicators, rules which are able to generate signals at appropriate
    times, and have the potential to generate a positive return on investment. It
    is very important to understand the generalization capacity of the model and for
    that we should divide the dataset in two smaller datasets, one dataset consisting
    of 70-80% of the data and the second dataset consisting of the remaining 20-30%
    of the data. The first dataset is called the in-sample dataset and the second
    is called the out-sample dataset:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.1*中的道琼斯指数收盘价显示了一个明显的趋势。我们需要定义一组指标和规则，这些指标和规则能够在适当的时机生成信号，并有可能带来正向的投资回报。理解模型的泛化能力非常重要，因此我们应当将数据集分为两个较小的数据集，一个数据集包含70-80%的数据，另一个数据集包含剩余的20-30%的数据。第一个数据集称为训练集（in-sample
    dataset），第二个数据集称为测试集（out-sample dataset）：'
- en: '![Momentum or directional trading](img/00076.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![动量或趋势交易](img/00076.jpeg)'
- en: 'Figure 5.1: Dow Jones Index closing price and return series'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：道琼斯指数收盘价和回报系列
- en: 'To backtest our strategy idea and its generalization power, we have to divide
    the dataset into two smaller datasets called in-sample and out-sample datasets.
    Here I am going to define four dates. `in_sd` defines the date by which the in-sample
    data starts, and `in_ed` the in-sample end date. Similarly, `out_sd` and `out_ed`
    are defined for the out-sample start and end dates. The dates are defined in order
    as our data is in time series format and we are interested in building a model
    on historical data which would be used on real-time data, that is, a dataset which
    has dates later than historical data:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回测我们的策略理念及其泛化能力，我们必须将数据集分成两个较小的数据集，分别称为样本内数据集和样本外数据集。这里我将定义四个日期。`in_sd`定义了样本内数据开始的日期，`in_ed`定义了样本内数据结束的日期。类似地，`out_sd`和`out_ed`分别定义了样本外数据开始和结束的日期。由于我们的数据是时间序列格式，所以日期是按顺序定义的，我们有兴趣建立一个基于历史数据的模型，并应用于实时数据，也就是说，数据集的日期必须晚于历史数据：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The variables `in_dji` and `in_ret_dji` contain the Dow Jones Index closing
    price and return respectively within the in-sample dates defined previously, and
    `out_dji` and `out_ret_dji` contain the Dow Jones Index closing price and return
    data respectively for the out-sample dates defined previously:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`in_dji`和`in_ret_dji`分别包含之前定义的样本内日期范围内的道琼斯指数收盘价和回报数据，而`out_dji`和`out_ret_dji`分别包含之前定义的样本外日期范围内的道琼斯指数收盘价和回报数据：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The purpose of creating an in-sample and out-sample is logical and helps to
    control human bias towards parameter estimation. We should use in-sample data
    to backtest our strategy, estimate the optimal set of parameters, and evaluate
    its performance. The optimal set of parameters has to be applied on out-sample
    data to understand the generalization capacity of rules and parameters. If the
    performance on out-sample data is pretty similar to in-sample data, we assume
    the parameters and rule set have good generalization power and can be used for
    live trading.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建样本内和样本外数据集的目的是合理的，有助于控制人为偏差对参数估计的影响。我们应该使用样本内数据来回测我们的策略，估计最佳参数集，并评估其性能。最佳参数集必须应用于样本外数据，以理解规则和参数的泛化能力。如果在样本外数据上的表现与样本内数据非常相似，我们可以认为这些参数和规则集具有良好的泛化能力，可以用于实时交易。
- en: 'I will use **moving average convergence divergence** (**MACD**) and **Bollinger**
    band indicators to generate automated trading signals. MACD and Bollinger band
    indicators are calculated using the following two lines of code. I used the same
    parameter values in both of these functions; however, you can use the parameters
    which you think are best for your dataset. The output variable `macd` contains
    the MACD indicator and its signal value; however, the output variable bb contains
    the lower band, average, upper band, and percentage Bollinger band:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用**移动平均收敛发散**（**MACD**）和**布林带**指标来生成自动化交易信号。MACD和布林带指标通过以下两行代码计算得出。我在这两个函数中使用了相同的参数值；不过，你可以使用你认为最适合数据集的参数。输出变量`macd`包含MACD指标及其信号值；而输出变量`bb`包含下轨、平均值、上轨和百分比布林带：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first line creates the variable `signal` and initializes it with `NULL`.
    In the second line, I generated a buy signal (`1`) when `dji` is above the upper
    Bollinger band and the `macd` value is above its `macd-signal` value; a sell signal
    (`-1`) when `dji` is down the lower Bollinger band and `macd` is less than its
    `macd-signal` value; and out of market when the signal is `0`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了变量`signal`并将其初始化为`NULL`。在第二行，当`dji`超过上轨布林带且`macd`值高于其`macd-signal`值时，我生成了买入信号（`1`）；当`dji`低于下轨布林带且`macd`小于其`macd-signal`值时，生成了卖出信号（`-1`）；当信号为`0`时，表示不在市场中：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I had generated for both long and short; however, you can implement a long
    only or short only strategy as well. You can also modify this signal generation
    mechanism and use any other exit criterion you want. We haven''t included any
    transaction cost and slippage cost to calculate its performance as none of the
    strategies are directly for trading. These strategies are used just to show the
    implementation mechanism:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为多头和空头都生成了信号；不过，你也可以仅实施多头或空头策略。你还可以修改此信号生成机制，使用任何你希望的其他退出标准。我们没有包含任何交易成本和滑点成本来计算其性能，因为这些策略并非直接用于交易。这些策略仅用于展示实现机制：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Trade return is calculated using the return of the Dow Jones Index and the previous
    day signal. I will use the package `PerformanceAnalytics` to calculate various
    matrices of strategy performance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 交易收益是通过道琼斯指数的收益和前一天的信号计算的。我将使用`PerformanceAnalytics`包来计算策略表现的各种矩阵。
- en: 'First you should load this package into the R workspace:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你应该将此包加载到R工作空间中：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Cumulative and annualized return of the strategy can be calculated using the
    preceding two lines of code. `Chart.PerformanceSummary` plots cumulative and daily
    return along with drawdown at a given point of time, as can be seen in *Figure
    5.2*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 策略的累积收益和年化收益可以通过前面两行代码进行计算。`Chart.PerformanceSummary`在给定时间点绘制累积收益和日收益图，并显示回撤，如*图
    5.2*所示：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Momentum or directional trading](img/00077.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![动量或方向性交易](img/00077.jpeg)'
- en: 'Figure 5.2: Cumulative return, daily return, and drawdown of strategy'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：策略的累积收益、日收益和回撤
- en: 'To understand more about the performance of trade returns, you have to use
    the `summary()` command. `summary()` will give the minimum, first quartile, median,
    mean, third quartile, and maximum of all trade return on a daily basis. The variable
    `trade_return` has a few `NA`s as well and `summary()` shows the number of `NA`s
    as well. In the following line of code, we first convert `trade_return` to a time
    series object because it generates output in a specific format. The output shows
    minimum, first quartile, median, third quartile, maximum, and `NA`. `NA` has the
    value `20`, which means `trade_return` has `20``NA`s:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于交易收益的表现，你需要使用`summary()`命令。`summary()`将显示所有交易收益的最小值、第一个四分位数、中位数、均值、第三个四分位数和最大值。变量`trade_return`中也有一些`NA`，`summary()`会显示`NA`的数量。在下面的代码行中，我们首先将`trade_return`转换为时间序列对象，因为它会生成特定格式的输出。输出显示了最小值、第一个四分位数、中位数、第三个四分位数、最大值和`NA`。`NA`的值为`20`，这意味着`trade_return`中有`20`个`NA`值：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The following are a few commands to calculate the performance of the strategy
    on in-sample trade return.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些计算策略在样本数据上表现的命令。
- en: The first command is to calculate the maximum drawdown of trade return throughout
    the trading period and we can see that `0.1173028` means the maximum drawdown
    is 11.73%. The second and third commands are to calculate the daily and annualized
    standard deviation for trade returns. Next is the `VaR` calculation for strategy
    return and the last two commands are to calculate the Sharpe ratio of the strategy
    on a daily and annualized basis respectively.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令是计算整个交易期间的最大回撤，我们可以看到`0.1173028`表示最大回撤为11.73%。第二个和第三个命令是计算交易收益的日标准差和年化标准差。接下来是策略收益的`VaR`计算，最后两个命令分别计算策略的日度和年化夏普比率。
- en: 'The Sharpe ratio on a daily basis is `0.01621421` and annualized is `0.2289401`.
    The Sharpe ratio has two parameters: `Rf` and `FUN`. `Rf` is for risk-free rate
    of interest and `FUN` is for the denominator. In the Sharpe ratio calculation,
    I used `FUN=StdDev`; it could also be `VaR`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 日度夏普比率为`0.01621421`，年化夏普比率为`0.2289401`。夏普比率有两个参数：`Rf`和`FUN`。`Rf`是无风险利率，`FUN`是分母。在夏普比率的计算中，我使用了`FUN=StdDev`；它也可以是`VaR`：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, if we find the performance is good for the in-sample data then we can
    use this strategy on the out-sample data and calculate all the matrices for the
    out-sample data and check for the consistency in strategy performance. The next
    two lines are to calculate the moving average, and convergence divergence and
    Bollinger band for out of sample data:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们发现样本数据的表现很好，那么我们可以将此策略应用于出样本数据，计算所有出样本数据的矩阵，并检查策略表现的一致性。接下来的两行代码用于计算出样本数据的移动平均线、趋同发散和布林带：
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next I use these out-sample indicators and generate signals like we generated
    for the in-sample data:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我使用这些出样本指标并生成像我们为样本数据生成的信号：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Trade return and all its relevant metrics for out-sample data are calculated
    using the following lines of code. These are like the in-sample data:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码行计算出样本数据的交易收益及其相关指标。这些数据与样本数据类似：
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'I implemented this strategy for one particular time series, that is, the **Dow
    Jones Index** (**DJI**); however, you can test this same strategy on other stocks
    as well and understand strategy behavior across the universe of stocks. If you
    find the strategy performs better on most of the stocks, it shows consistency
    in the idea and it might work well on real-time trading as well. It''s very important
    to note here that even if one particular strategy works well on a few stocks,
    we should not forget to check the variance of the portfolio. Let me show you an
    example. I calculate the variance of the DJI time series return:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我为一个特定的时间序列实现了这个策略，即**道琼斯指数**（**DJI**）；但是，你也可以在其他股票上测试这个策略，并了解它在整个股票宇宙中的表现。如果你发现这个策略在大多数股票上表现较好，这表明这个思路具有一致性，并且可能在实时交易中也能有效。这里非常重要的一点是，即使某个特定策略在少数股票上表现良好，我们也不应忽视检查投资组合的方差。让我给你举个例子。我计算了道琼斯指数时间序列回报的方差：
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, I used `na.rm=T` to remove `Nan` in the time series.
    Now I import another symbol, which is `S&P 500`, into the workspace. The next
    line of code imports `S&P 500` into the workspace:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我使用了`na.rm=T`来去除时间序列中的`Nan`。现在我将另一个符号`S&P 500`导入到工作空间中。接下来的代码将`S&P 500`导入工作空间：
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now I extract only the closing price of `S&P 500` and refine it between two
    dates.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我提取了`S&P 500`的收盘价，并在两日期之间进行了精细化处理。
- en: 'Next I calculate the return of `S&P 500`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我计算了`S&P 500`的回报：
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'I also calculate the variance of the `S&P 500` series return:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我还计算了`S&P 500`系列回报的方差：
- en: '[PRE24]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now I combine both time series returns and calculated variance of sum of two
    returns:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将两个时间序列的回报率合并，并计算这两个回报率之和的方差：
- en: '[PRE25]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We find the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下结果：
- en: '[PRE26]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we can see, `0.000218383` ≠`8.093402e-05` + `8.590805e-05`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`0.000218383` ≠ `8.093402e-05` + `8.590805e-05`。
- en: 'What causes this difference is very important to understand. If we go back
    to the basics of probability theory, we find the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 造成这种差异的原因非常重要。如果我们回顾概率论的基础，我们会发现以下内容：
- en: '[PRE27]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, `ρ` is the correlation between `X` and `Y`; `σX` is the standard deviation
    of X; and `σY` is standard deviation of `Y`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`ρ`是`X`和`Y`之间的相关性；`σX`是X的标准差；`σY`是Y的标准差。
- en: 'We calculate the standard deviation of `ret_dji`, `ret_snp` and correlation
    between `ret_dji` and `ret_snp` using the following commands:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令计算`ret_dji`、`ret_snp`的标准差以及`ret_dji`和`ret_snp`之间的相关性：
- en: '[PRE28]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The correlation between `ret_dji` and `ret_snp` is `0.3090576`. Now we put these
    values into the equation 5.2 and you will see both sides are equal. It means if
    two stocks are positively correlated, they cause an increase in the variance of
    the portfolio as compared to the sum of variance of two individual stocks. If
    we are able to pick two stocks which are uncorrelated, that is, *correlation =
    0*, then the variance of the portfolio would be the linear sum of two individual
    securities; or if we manage to pick two stocks with negative correlation then
    the variance of the portfolio would be less than the sum of two individual stocks.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`ret_dji`和`ret_snp`之间的相关性是`0.3090576`。现在我们将这些值代入方程5.2，你会看到两边是相等的。这意味着，如果两只股票是正相关的，它们会导致投资组合的方差比两只股票的单独方差之和更高。如果我们能挑选出两只不相关的股票，也就是*相关性
    = 0*，那么投资组合的方差将是两只个股方差的线性和；或者，如果我们选中了两只负相关的股票，那么投资组合的方差将小于两只股票的方差之和。'
- en: 'So we have to look at the correlation matrix of the stocks in the portfolio
    to figure out which stocks would help to minimize risk. As we have only two stocks
    in the portfolio, I created `port_ret` as a data frame which consists of NAs,
    number of rows same as the number of data points, and two columns:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们必须查看投资组合中股票的相关性矩阵，以确定哪些股票有助于最小化风险。由于投资组合中只有两只股票，我创建了一个名为`port_ret`的数据框，其中包含NAs，行数与数据点的数量相同，且有两列：
- en: '[PRE29]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The next two commands copy `ret_dji` into the first column and `ret_snp` into
    the second column of the data frame:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两条命令将`ret_dji`复制到数据框的第一列，将`ret_snp`复制到第二列：
- en: '[PRE30]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we can calculate the correlation matrix of stocks in the portfolio. The
    following code calculates the correlation of stock 1 with stock 2:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以计算投资组合中股票的相关性矩阵。以下代码计算股票1与股票2的相关性：
- en: '[PRE31]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding correlation matrix has `NA`s and these are because the `port_ret`
    data frame has `NA` somewhere, so we have to remove `NA` from the data frame and
    `is.na()` helps us to get rid of this `NA`. The following code filters `port_ret`
    from `NA` and then calculates the correlation matrix:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述相关性矩阵中有`NA`值，这是因为`port_ret`数据框中某处存在`NA`，因此我们需要从数据框中删除`NA`，`is.na()`帮助我们去除这些`NA`。以下代码过滤掉`port_ret`中的`NA`，然后计算相关性矩阵：
- en: '[PRE32]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As correlation between two stocks is order independent that is the reason that
    diagonal elements are same. It is rarely possible to find a pair of stocks which
    are uncorrelated or perfectly correlated. More negative correlation shows better
    diversification. As the correlation increases, diversification becomes less relevant,
    as the variance of the portfolio increases with the increase in the correlation.
    That is the reason correlation is one of the most important criteria to select
    stocks in a portfolio and to control the risk of the portfolio.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 两只股票之间的相关性是顺序无关的，这就是为什么对角线元素相同的原因。很少能找到一对不相关或完全相关的股票。更负的相关性表明更好的多样化。当相关性增加时，多样化变得不那么重要，因为随着相关性的增加，投资组合的方差也会增加。这就是为什么相关性是选择股票和控制投资组合风险的最重要标准之一。
- en: Pairs trading
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配对交易
- en: You are familiar with the concept of diversification. For diversification, we
    have to choose negative correlated stocks; however, in pairs trading, we can choose
    stocks with positive correlation and enter opposite trades in both of the stocks.
    Enter a buy position for the stock which is undervalued and short the stock which
    is overvalued.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该熟悉多样化的概念。为了实现多样化，我们需要选择负相关的股票；然而，在配对交易中，我们可以选择正相关的股票，并在这两只股票中进行相反的交易。对于被低估的股票，进行买入操作；对于被高估的股票，进行卖空操作。
- en: 'The variance of the X - Y portfolio is defined as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: X - Y 投资组合的方差定义如下：
- en: '[PRE33]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Pairs trading is a market-neutral strategy, as the difference in two stocks
    is uncorrelated or correlated close to zero with the overall market. I will show
    you how to start pairs trading using the distance approach. I will use same two
    time series, Dow Jones Index, and S&P 500 for pairs trading and explain how the
    distance-based approach can be implemented in R.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 配对交易是一种市场中性策略，因为两只股票的差异与整体市场不相关或接近零相关。我将展示如何使用距离法开始配对交易。我将使用相同的两只时间序列，分别是道琼斯指数和标普500指数，来进行配对交易，并解释如何在R中实现基于距离的方法。
- en: Distance-based pairs trading
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于距离的配对交易
- en: 'Different time series might have different scaling and so you first normalize
    the series. I did it using an initial investment of 1 and then taking cumulative
    return of this investment:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的时间序列可能具有不同的缩放，因此你需要先对序列进行归一化。我通过使用初始投资1来进行归一化，然后计算该投资的累积回报：
- en: '[PRE34]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following commands calculate the cumulative return of the investment which
    was started at 1\. This way, we can track the relative performance of series one
    against the second series and the last command is to calculate the difference
    between the two series:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令计算了从1开始的投资的累积回报。通过这种方式，我们可以追踪第一条序列与第二条序列的相对表现，最后一个命令是计算两条序列之间的差异：
- en: '[PRE35]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![Distance-based pairs trading](img/00078.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![基于距离的配对交易](img/00078.jpeg)'
- en: 'Figure 5.3: Normalized prices for Dow Jones Index and S&P 500'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：道琼斯指数和标普500指数的归一化价格
- en: 'The formula to calculate cumulative return is defined here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 计算累积回报的公式定义如下：
- en: '[PRE36]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now I used the `plot()` command to plot normalized prices `norm_dji` and `type="l"`,
    help to connect all points in the graph and generate a line graph. You will get
    dots if you do not use this and `ylim=c(0.5,2)` is used to scale the vertical
    axis. I also used `lines()` to plot another series on the same graph so that we
    can at least look at both series in the same figure. `ylab` is for labeling along
    the y axis:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我使用`plot()`命令绘制了归一化价格`norm_dji`，并通过`type="l"`帮助连接图中的所有点，生成折线图。如果不使用这个命令，图中将只显示点，`ylim=c(0.5,2)`用于缩放纵轴。我还使用了`lines()`在同一图表上绘制了另一条序列，这样我们就可以在同一图中查看两条序列。`ylab`用于标记y轴：
- en: '[PRE37]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `legend` command helps to place the box at the top-right corner in the plot
    which mentioned DJI and `S&P500` series are plotted. The parameter `lty` is used
    for the type of line in the plot; `lty=1` means solid line. The next plot is used
    to plot the difference between normalized prices.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`legend`命令帮助在图表的右上角放置一个框，标明图中绘制的是DJI和`S&P500`序列。参数`lty`用于设置图中的线型；`lty=1`表示实线。下一个图表用于绘制归一化价格之间的差异。'
- en: When you look at this plot, you will realize that the distance between both
    series is converging and diverging before index 500 and after that, diverging
    continuously. As this pair doesn't converge frequently, you should not consider
    using it for pairs trading. You have to find another pair which diverge and converge
    frequently on historical data, which implies some similarity in both series fundamentals
    on historical data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看这个图表时，你会发现这两个系列的距离在500号索引之前会趋于接近，之后则会持续发散。由于这个配对并不经常会收敛，因此你不应该考虑将其用于配对交易。你需要寻找另一个历史数据中经常收敛和发散的配对，这意味着这两个系列在历史数据上有某些基本面的相似性。
- en: I chose **Exxon Mobil** (**XOM**) and **Chevron corporation** (**CVX**) for
    this. *Figure 5.4* shows normalized price series and their difference along with
    the signals generated for trading.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了**埃克森美孚**（**XOM**）和**雪佛龙公司**（**CVX**）作为示例。*图 5.4*展示了标准化价格序列及其差异，同时显示了为交易生成的信号。
- en: Normalized prices are not going very far from each other for a long time, as
    can be seen in *Figure 5.4*. This pair seems to be a good member for distance
    based pairs trading.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在*图 5.4*中所看到的，标准化价格并没有长时间地远离彼此。这个配对似乎是基于距离的对冲交易的好选择。
- en: 'We calculate `norm_xom` and `norm_cvx` like we calculated `norm_dji` and `norm_snp`
    and plot these using the following commands:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像计算`norm_dji`和`norm_snp`一样计算`norm_xom`和`norm_cvx`，并使用以下命令将它们绘制出来：
- en: '[PRE38]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You have to look into the class of these two variables. Both of these are matrices,
    as can be seen above, and this has to be an `xts`, `zoo` object. So the next thing
    you have to do is to convert these matrix objects into an `xts`, `zoo` object:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要查看这两个变量的类别。正如上面所看到的，这两个都是矩阵，并且必须是`xts`、`zoo`对象。所以接下来你需要做的就是将这些矩阵对象转换为`xts`、`zoo`对象：
- en: '[PRE39]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`xts()` does this job and converts both of these into `xts` objects:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`xts()`函数完成这个工作，将这两个对象都转换为`xts`对象：'
- en: '[PRE40]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Mean, standard deviation of the normalized price difference is calculated as
    follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化价格差异的均值和标准差可以按如下方式计算：
- en: '[PRE41]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![Distance-based pairs trading](img/00079.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![基于距离的配对交易](img/00079.jpeg)'
- en: 'Figure 5.4: Normalized price series, difference, and trading signals'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：标准化价格序列、差异和交易信号
- en: 'The upper (`ub`) and lower bounds (`lb`) of the difference series can be calculated
    by adding and subtracting *n* times standard deviation from the mean:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 差异序列的上界（`ub`）和下界（`lb`）可以通过从均值中加减*n*倍标准差来计算：
- en: '[PRE42]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Finding optimal parameter values for *n* is not straightforward. We either have
    to use the hit and trial method to come up with the optimal value of *n* or use
    a grid-based parameter optimizer to find the optimal value.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找*n*的最优参数值并不是一件简单的事。我们要么得使用反复试验的方法来找到最优的*n*值，要么使用基于网格的参数优化器来找到最优值。
- en: As an example, here I used `n = 1` just for the sake of demonstration. A buy
    signal (`1`) is generated when the difference value is lower than the lower band,
    and a short signal (`-1`) is generated when the difference is above the upper
    band; otherwise the signal is hold (`0`).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个示例，这里我使用了`n = 1`仅仅是为了演示。当差异值低于下轨时，会产生一个买入信号（`1`）；当差异值高于上轨时，会产生一个卖出信号（`-1`）；否则信号保持（`0`）。
- en: 'When the difference value, that is, the spread, is above the upper band, we
    speculate it will return to its mean value as, historically, it has been there
    most of the time. Similarly, when the spread is below the lower band, even in
    this case, we speculate it will return to its mean value:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当差异值，即价差，超过上轨时，我们推测它会回归到均值，因为历史上它大多数时间都在这个范围内。同样，当价差低于下轨时，我们也推测它会回归到均值：
- en: '[PRE43]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here I used the full time series of difference values to calculate mean and
    standard deviation, as can be seen previously where I calculated `me` and `std`.
    You can also calculate mean and standard deviation dynamically on a rolling window.
    This dynamic mean and standard deviation will change signal generation, and entry
    and exit will be even more frequent.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我使用了完整的差异值时间序列来计算均值和标准差，正如之前我计算`me`和`std`一样。你也可以在滚动窗口上动态地计算均值和标准差。这种动态的均值和标准差会改变信号的生成，进出场的频率也会更高。
- en: 'Dynamic mean and standard deviations can be calculated using `rollapply()`.
    You should define dataset, length, and function in `rollapply()`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 动态的均值和标准差可以通过`rollapply()`函数来计算。在`rollapply()`中你应该定义数据集、长度和函数：
- en: '[PRE44]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `plot()` function plots the signal as presented in *Figure 5.4*. A non-zero
    signal value shows our participation in the market and zero means we are not participating
    in the market:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot()`函数绘制了如*图5.4*所示的信号。非零信号值表示我们参与了市场，零值意味着我们没有参与市场：'
- en: '[PRE45]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Difference in normalized prices is also called spread. As we are generating
    signals using spread, we will be trading spread instead of individual stock. So,
    we have to clearly understand what is meant by spread trading. When I say buy,
    it means I am buying spread, which implies long position on XOM and short position
    on CVX or short on XOM and long on CVX when we have short signal. The following
    two lines calculate the spread and trade return:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化价格的差异也叫做价差。由于我们是通过价差生成信号，因此我们将交易的是价差而非单一股票。所以，我们必须清楚地理解什么是价差交易。当我说买入时，意味着我在买入价差，这就意味着在XOM上做多，在CVX上做空，或者当我们收到卖出信号时，在XOM上做空，在CVX上做多。以下两行计算了价差和交易回报：
- en: '[PRE46]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The variable named `spread_return` is the return spread, `trade_return` is the
    return of trade, and cost is the expenses to carry out trading activities; it
    includes transaction cost, brokerage cost, and slippage.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`spread_return`表示回报价差，`trade_return`表示交易回报，cost表示执行交易活动的费用；包括交易成本、经纪费用和滑点。
- en: The purpose of this book is only to teach you R coding, not to generate profitable
    trading ideas. So, I considered the cost as 0, but you have to incorporate the
    appropriate cost while backtesting your ideas and putting money into a real account.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目的仅是教你R语言编程，而不是产生盈利的交易理念。因此，我将成本设为0，但你在回测你的策略并将资金投入实际账户时，必须考虑适当的成本。
- en: 'Now we apply performance measure commands to extract a performance summary:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应用绩效测量命令来提取绩效摘要：
- en: '[PRE47]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'All key performance indicators can be calculated using the following commands.
    All these commands have already been used in the Momentum trading section:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所有关键绩效指标可以通过以下命令计算。这些命令已经在动量交易部分使用过：
- en: '[PRE48]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Figure 5.5* shows cumulative performance, daily return, and drawdown on a
    day-to-day basis for this distance-based pairs trading strategy:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.5*展示了此基于距离的配对交易策略的累积表现、每日回报和每日最大回撤：'
- en: '![Distance-based pairs trading](img/00080.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![基于距离的配对交易](img/00080.jpeg)'
- en: 'Figure 5.5: Cumulative return of strategy, return, and drawdown on a daily
    basis'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：策略的累积回报、回报和每日最大回撤
- en: Here I demonstrated an approach to implement the distance-based pairs trading
    model practically. You should segregate the data into in-sample and out-sample
    datasets. Optimization of parameters should be done using in-sample data and validate
    those parameters for out-sample data. I have already shown you this approach in
    the Momentum trading section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我展示了一种实现基于距离的配对交易模型的实际方法。你应该将数据分为样本内和样本外数据集。参数优化应使用样本内数据进行，随后验证这些参数在样本外数据中的表现。我已经在动量交易部分向你展示了这一方法。
- en: Correlation based pairs trading
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于相关性的配对交易
- en: Another, traditional way to trade in pairs is correlation. You have to pick
    a pair which is highly correlated historically and the spread of the pair is least
    correlated with market benchmark. A trading opportunity occurs whenever you see
    correlation strength weakens. This is also on the premise of mean reversion and
    traders bet on correlation reversion to its mean whenever they see significant
    deviation in correlation from its mean at least by *n* times standard deviation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种传统的配对交易方式是基于相关性。你需要选择一对历史上高度相关的股票，并且该对股票的价差与市场基准的相关性最小。每当你看到相关性强度减弱时，就意味着出现了交易机会。这也建立在均值回归的前提下，交易者会在看到相关性与其均值发生显著偏离，至少偏离*n*倍标准差时，押注相关性会回归到其均值。
- en: 'A market-neutral strategy can be implemented in two different ways:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 市场中性策略可以通过两种不同的方式实现：
- en: Beta neutral
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贝塔中性
- en: Dollar neutral
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美元中性
- en: Beta neutrality means the beta of the spread is close to zero; this can be reached
    by choosing two stocks or instruments whose betas are almost same. However, dollar
    neutral means you are only a little exposed to the market as investment in long
    stock is offset by the amount you receive on short trade.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 贝塔中性意味着价差的贝塔接近零；这可以通过选择两只贝塔几乎相同的股票或工具来实现。然而，美元中性意味着你只对市场有微弱的暴露，因为在做多股票的投资通过做空交易获得的资金被抵消。
- en: Practically, even if we are little exposed to the market doesn't mean that we
    have no risk or little risk. Risk has to be managed properly to make a profitable
    trade. Here I am going to show you how to implement the correlation based pairs
    trading model.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，即使我们在市场上的暴露较少，也不意味着我们没有风险或风险很小。风险需要妥善管理才能实现盈利的交易。接下来，我将向你展示如何实现基于相关性的配对交易模型。
- en: First of all, you have to create a data frame which consist of returns of XOM
    and CVX as I am using XOM and CVX as my pair of stocks.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要创建一个数据框，其中包含 XOM 和 CVX 的收益，因为我将 XOM 和 CVX 作为我的配对股票。
- en: 'The first column is for XOM and the second is for CVX returns:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列是 XOM，第二列是 CVX 的收益：
- en: '[PRE49]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The type of this can be checked using `class()` and you see that the data is
    of `data.frame` type. You have to convert it to an `xts` object and this can be
    done using the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `class()` 函数检查该数据的类型，结果显示该数据属于 `data.frame` 类型。你需要将其转换为 `xts` 对象，可以使用以下代码来实现：
- en: '[PRE50]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now you can check the type of the data; it is of type `xts`, `zoo`. Next, I
    created a function named correlation, with one single parameter `x`, which calculates
    the correlation between the first and second columns of `x` and returns the correlation:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以检查数据的类型，它是 `xts` 和 `zoo` 类型。接下来，我创建了一个名为 correlation 的函数，接受一个参数 `x`，该函数计算
    `x` 的第一列和第二列之间的相关性并返回相关性：
- en: '[PRE51]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'I used `rollapply()` which does calculations on a rolling window basis as per
    the function rolling window length defined in this function. Here I supplied four
    parameters to this: the first parameter is the data which is used for calculation,
    the second for window length, the third for the function to be used for calculation,
    and the fourth to direct the function whether calculation should on done on each
    column separately.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了 `rollapply()` 函数，它基于滚动窗口的方式进行计算，窗口长度由此函数中的滚动窗口长度参数定义。在这里，我提供了四个参数：第一个参数是用于计算的数据，第二个是窗口长度，第三个是用于计算的函数，第四个是指示函数是否应对每一列单独计算。
- en: I used data length as `252`, the function is correlation which has been defined
    above, and `by.column=FALSE`, which means this function is not applied on columns
    separately.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用的数据长度为 `252`，函数是前面定义的 correlation，`by.column=FALSE` 表示该函数不会对每一列单独应用。
- en: 'So this keeps on moving and using the last 10 data points to calculate correlation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个过程会不断进行，并使用最后 10 个数据点来计算相关性：
- en: '[PRE52]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The strategy continuously monitors the performance of two historically correlated
    securities. When the correlation between the two securities temporarily weakens,
    that is, one stock moves up while the other moves down, the pairs trade would
    be to short the outperforming stock and to long the underperforming one, betting
    that the spread between the two would eventually converge.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 该策略持续监控两个历史相关证券的表现。当这两只证券之间的相关性暂时减弱时，即一只股票上涨而另一只股票下跌，配对交易策略将是做空表现较好的股票并做多表现较差的股票，赌注是这两者之间的价差最终会收敛。
- en: The divergence within a pair can be caused by temporary supply/demand changes,
    large buy/sell orders for one security, reaction for important news about one
    of the companies, and so on.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 配对之间的背离可能是由于暂时的供需变化、大量买入/卖出某一证券的订单、某一公司发布的重要新闻反应等原因引起的。
- en: '*Figure 5.6* shows the correlation between XOM and CVX returns at rolling length
    `252`. You can see that almost every time, correlation is over 0.6\. It shows
    this pair''s high correlation persists almost every day:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.6* 显示了在滚动窗口长度为 `252` 时，XOM 和 CVX 收益之间的相关性。你可以看到，几乎每次相关性都超过了 0.6，表明这个配对的高相关性几乎每天都在持续：'
- en: '![Correlation based pairs trading](img/00081.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![基于相关性的配对交易](img/00081.jpeg)'
- en: 'Figure 5.6: Correlation between returns of XOM and CVX'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：XOM 和 CVX 收益之间的相关性
- en: 'Normally, correlation greater than 0.8 is considered as strong correlation
    and less than 0.5 as weak correlation. You also need to calculate the hedge ratio
    of XOM and CVX, which can be calculated by dividing the XOM price and CVX price:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，相关性大于 0.8 被视为强相关，小于 0.5 被视为弱相关。你还需要计算 XOM 和 CVX 的对冲比率，可以通过将 XOM 价格除以 CVX
    价格来计算：
- en: '[PRE53]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then you have to calculate the mean and standard deviation of the hedge ratio
    and upper and lower bounds. In the distance based model, I presented a technique
    to use static mean and standard deviation; however, in this section, I am presenting
    rolling-window-based mean and standard deviation for the calculation of bounds.
    As the mean and standard deviation will be function of time so the upper and lower
    bounds. I used `rollapply()` to calculate the rolling mean and standard deviation
    of spread for every 14 data points:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要计算对冲比率的均值和标准差，以及上下边界。在基于距离的模型中，我提出了使用静态均值和标准差的技术；然而，在这一部分，我展示了基于滚动窗口的均值和标准差，用于计算边界。由于均值和标准差将是时间的函数，因此上下边界也将随时间变化。我使用`rollapply()`函数计算每14个数据点的滚动均值和标准差：
- en: '[PRE54]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you look at preceding two commands, you will see the parameter n, which
    is arbitrary and should be optimized. Once you have bounds, you should go for
    signal generation and this can be done using the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看前面的两个命令，你会看到参数n，这是一个任意值，应该进行优化。一旦你有了边界，你就可以进行信号生成，下面的代码可以实现这一操作：
- en: '[PRE55]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'It generates a short signal (`-1`) when the hedge ratio is over the upper band
    and generates a buy signal (`1`) when the hedge ratio is down the lower band.
    Then, calculate the signal at lag `1` and use it to generate an exit signal when
    the hedge ratio crosses the rolling mean. Short signal implies short `1` unit
    of XOM and long hedge ratio time CVX; however, buy signal implies long `1` unit
    on XOM and short hedge ratio time CVX. You should use the following commands to
    calculate spread return and trade return:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当对冲比率超过上界时，它会生成一个卖出信号（`-1`）；当对冲比率低于下界时，会生成一个买入信号（`1`）。然后，计算滞后`1`时刻的信号，并在对冲比率穿越滚动均值时生成退出信号。卖出信号表示卖空`1`单位的XOM并做多对冲比率与CVX的乘积；买入信号则表示买入`1`单位的XOM并做空对冲比率与CVX的乘积。你应该使用以下命令计算价差回报和交易回报：
- en: '[PRE56]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Once you have done that, you should analyze the quality of these signals, so
    you need to calculate all metrics of trade return, which can be calculated using
    the commands mentioned in earlier sections, particularly the Momentum trading
    and Distance based pairs trading sections. You also need to optimize parameters
    using in-sample data and use those optimized parameters for out-sample data to
    really get strategy performance on out-sample data.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，你需要分析这些信号的质量，因此你需要计算所有的交易回报指标，这些可以通过前面章节提到的命令来计算，特别是动量交易和基于距离的配对交易部分。你还需要使用样本内数据优化参数，并使用这些优化后的参数来测试样本外数据，真正评估策略在样本外数据上的表现。
- en: Co-integration based pairs trading
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于协整的配对交易
- en: Co-integration based pairs trading is the latest arsenal in pairs trading and
    its use is picking up very fast these days.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 基于协整的配对交易是配对交易领域的最新武器，近年来其使用速度非常快。
- en: 'Co-integration considers the regression of one price series against another
    price series. As these series are non-stationary, the regression results will
    be spurious if these series are not co-integrated. Co-integration becomes crucial
    when we have to regress non-stationary series. You first check the time series
    you are using is non-stationary. You need to load the package `tseries` into your
    workspace and the data used in this section is from January 1, 2014 to December
    31, 2014:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 协整考虑了一系列价格与另一系列价格的回归。由于这些系列是非平稳的，如果这些系列没有协整关系，那么回归结果将是虚假的。当我们需要回归非平稳系列时，协整变得至关重要。你首先需要检查你所使用的时间序列是否是非平稳的。你需要将`tseries`包加载到工作空间中，且本部分使用的数据是2014年1月1日到2014年12月31日的数据：
- en: '[PRE57]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Augmented `Dickey-Fuller` test:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 增广的`Dickey-Fuller`检验：
- en: '[PRE58]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can see the `Dicky-Fuller` statistic is `-1.4326`, which is higher than
    `-3.43`. This implies the series is non-stationary and you can also check the
    first difference of the series:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`Dicky-Fuller`统计量为`-1.4326`，高于`-3.43`。这意味着该序列是非平稳的，你也可以检查该序列的第一差分：
- en: '[PRE59]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As `diff` contain `NA`, you should consider only non-NAs and use `adf.test()`
    to test it for unit roots. The `Dickey-Fuller` statistic using the first difference
    of time series is `-11.97`, which is less than `-3.43`, which shows the first
    difference is stationary and this suggests XOM is integrated of order `1`, that
    is, `O(1)`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`diff`包含`NA`，你应该只考虑非NA值，并使用`adf.test()`来检验单位根。使用时间序列的第一差分得到的`Dickey-Fuller`统计量为`-11.97`，小于`-3.43`，这表明第一差分是平稳的，且表明XOM是1阶积分的，即`O(1)`。
- en: 'Now I am going to fit the model for XOM and CVX using `lm()`. `lm()` corresponds
    to the linear model and it regresses XOM against CVX original prices and `0` in
    `lm()` means regression without intercept:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我要使用`lm()`来拟合XOM和CVX的模型。`lm()`对应于线性模型，它回归XOM相对于CVX的原始价格，`lm()`中的`0`表示没有截距的回归：
- en: '[PRE60]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'A summary of the model can be looked into using the `summary()` command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`summary()`命令查看模型的摘要：
- en: '[PRE61]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The next thing is we have to extract residuals from the variable called `model`
    and test it for unit roots, which you have to do using the following command.
    You can see in the output that the `Dickey-Fuller` statistic is `-2.6088`, which
    is greater than `-3.43`, which implies that there is unit root. In probability
    theory, unit root has an important feature which needs to be verified. The presence
    of unit root causes inference problems as time series with unit root inflate which
    does not converge or keep on diverging. Non-stationary time series have unit root
    and they do not converge. Finding of unit root implies XOM and CVX are not co-integrated:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是提取来自名为`model`的变量的残差，并对其进行单位根测试，您可以使用以下命令来完成此操作。你可以看到输出中`Dickey-Fuller`统计量为`-2.6088`，大于`-3.43`，这意味着存在单位根。在概率论中，单位根有一个重要特性需要验证。单位根的存在会导致推断问题，因为具有单位根的时间序列会膨胀，不会收敛，或者持续发散。非平稳的时间序列具有单位根，它们不会收敛。单位根的存在意味着XOM和CVX并未协整：
- en: '[PRE62]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Mobil (XOM) and hedge ratio times BP Plc (BP) along with its residuals. If you
    look at the prices series, you can see the closeYou have to find another pair
    which is co-integrated, so let us try to find another pair. Let me show you co-integration
    between **Exxon Mobil** (**XOM**) and BP Plc (BP).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 移动公司（XOM）和对冲比率乘以BP公司（BP），以及它们的残差。如果你查看价格序列，你会发现两者之间有很强的相关性。你必须找到另一个协整的配对，所以让我们尝试找另一个配对。让我向你展示**埃克森美孚**（**XOM**）和BP公司（BP）之间的协整关系。
- en: 'Extract XOM and BP Price closing prices using `GetSymbols()` and use them to
    regress to establish the relationship:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GetSymbols()`提取XOM和BP的收盘价，并使用这些数据回归以建立它们之间的关系：
- en: '[PRE63]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here, the `Dickey-Fuller` statistic is `-3.9007`, which is less than critical
    value at 95% confidence value (`-3.43`) so this doesn''t have unit root and this
    pair is stationary:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Dickey-Fuller`统计量为`-3.9007`，小于95%置信水平下的临界值（`-3.43`），所以这没有单位根，这对是平稳的：
- en: '[PRE64]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '*Figure 5.7* shows the XOM and hedge ratio times for BP price series and its
    spread. `plot()` and `lines()` are used to plot this figure. Now, as the residuals
    are mean reverting, so the next target is to generate bounds and signal using
    the following commands:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.7* 显示了XOM和对冲比率乘以BP价格序列及其价差。`plot()`和`lines()`用于绘制该图。现在，由于残差是均值回归的，因此下一步是使用以下命令生成界限和信号：'
- en: '[PRE65]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The preceding two commands have the parameter n, which is arbitrary and should
    be optimized:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个命令有一个参数n，它是任意的，应该进行优化：
- en: '[PRE66]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '*Figure 5.7* shows the series **Exxon Mobil** (**XOM**) and hedge ratio times
    BP Plc (BP) along with its residuals. If you look at the prices series, you can
    see the close relation between both series and these two series do not deviate
    too much for so long. If these deviate at all, very soon they return close by:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.7* 显示了**埃克森美孚**（**XOM**）和对冲比率乘以BP公司（BP）的价格序列以及它们的残差。如果你查看价格序列，你可以看到这两个序列之间的紧密关系，并且这两个序列不会长时间偏离太远。如果它们有偏离的话，很快它们就会恢复接近：'
- en: '![Co-integration based pairs trading](img/00082.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![基于协整的配对交易](img/00082.jpeg)'
- en: 'Figure 5.7: Series of XOM and hedge ratio times BP along with their spread
    series'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：XOM和对冲比率乘以BP的序列以及它们的价差序列
- en: As you have generated signals, you should calculate the performance of the strategy,
    as can be done using the commands I mentioned in the Momentum trading or Distance
    based pairs trading sections.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经生成了信号，接下来应该计算策略的表现，方法可以参考我在动量交易或基于距离的配对交易部分中提到的命令。
- en: Capital asset pricing model
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资本资产定价模型
- en: 'The **capital asset pricing model** (**CAPM**) model helps to gauge risk contributed
    by security or portfolio to its benchmark and is measured by beta (![Capital asset
    pricing model](img/00033.jpeg)). Using the CAPM model, we can estimate the expected
    excess return of an individual security or portfolio which is proportional to
    its beta:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**资本资产定价模型**（**CAPM**）帮助评估证券或投资组合对基准的风险贡献，风险通过贝塔值来衡量 (![资本资产定价模型](img/00033.jpeg))。通过CAPM模型，我们可以估计单个证券或投资组合的预期超额回报，这与其贝塔值成正比：'
- en: '![Capital asset pricing model](img/00083.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![资本资产定价模型](img/00083.jpeg)'
- en: 'Here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里：
- en: '*E(Ri)*: Expected return of security'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*E(Ri)*：证券的预期回报'
- en: '*E(Rm)*: Expected return of market'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*E(Rm)*: 市场预期收益率'
- en: '*Ri*: Rate of return of security'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ri*: 证券的收益率'
- en: '*Rf*: Risk Free rate of return'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Rf*: 无风险收益率'
- en: '*Rm*: Benchmark or market return'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Rm*: 基准或市场收益率'
- en: '![Capital asset pricing model](img/00084.jpeg): Beta of the security'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![资本资产定价模型](img/00084.jpeg): 证券的贝塔值'
- en: CVX is regressed against DJI using linear model as per equation 5.4.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: CVX 与 DJI 通过线性模型回归，如公式 5.4 所示。
- en: 'Here I used zero as risk-free return in the following command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我在以下命令中使用了零作为无风险收益率：
- en: '[PRE67]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You can see the intercept term in the above result is alpha (`-0.0002013`) and
    coefficient for `ret_dji` is beta (`1.1034521`). However, you can also use the
    `PerformanceAnalytics` package to calculate CAPM alpha and beta using `CAPM.alpha()`
    and `CAPM.beta()`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到上面的结果中的截距项是 alpha（`-0.0002013`），而 `ret_dji` 的系数是贝塔（`1.1034521`）。不过，你也可以使用
    `PerformanceAnalytics` 包，通过 `CAPM.alpha()` 和 `CAPM.beta()` 来计算 CAPM 的 alpha 和
    beta。
- en: 'The following command shows how to use this whose result are same as preceding
    one:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令展示了如何使用此方法，结果与之前相同：
- en: '[PRE68]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The beta value from `CAPM.beta()` is the same as the coefficient, and `CAPM.alpha()`
    is the same as intercept in the above regression. You can also see a scatter plot
    of the returns and its fitted lines:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `CAPM.beta()` 获得的贝塔值与回归中的系数相同，而 `CAPM.alpha()` 与回归中的截距相同。你还可以看到收益率及其拟合线的散点图：
- en: '[PRE69]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '*Figure 5.8* shows the fitted line has a positive slope, which implies positive
    correlation between the returns. We can check this statement using the following
    command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.8* 显示拟合线具有正斜率，这意味着收益率之间存在正相关。我们可以使用以下命令验证这一说法：'
- en: '[PRE70]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '![Capital asset pricing model](img/00085.jpeg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![资本资产定价模型](img/00085.jpeg)'
- en: 'Figure 5.8: Scatter plot of DJI and CVS return and its fitted line'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '图 5.8: DJI 和 CVS 收益率的散点图及其拟合线'
- en: Multi factor model
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多因子模型
- en: The multi factor model can be used to decompose returns and calculate risk.
    The factors are constructed using pricing, fundamental, and analyst estimates
    data. I will use Systematic Investor Toolbox for this section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 多因子模型可以用来分解收益并计算风险。因子是通过定价、基本面和分析师预期数据构建的。在这一部分，我将使用系统化投资工具箱。
- en: The `gzcon()` function creates a connection and reads data in compressed format.
    Once we create a connection, we also have to close the connection.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`gzcon()` 函数创建一个连接并读取压缩格式的数据。创建连接后，我们还需要关闭连接。'
- en: 'The following commands explain this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令解释了这个过程：
- en: '[PRE71]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The following function is used to fetch Dow Jones components data from [http://money.cnn.com](http://money.cnn.com)
    and `join()` is taken from Systematic Investor Toolbox:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数用于从 [http://money.cnn.com](http://money.cnn.com) 获取道琼斯成分股数据，`join()` 来自系统化投资工具箱：
- en: '[PRE72]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The next single line of code is a call to the preceding function, which extracts
    the Dow Jones constituent list:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码调用了前面的函数，用于提取道琼斯成分股列表：
- en: '[PRE73]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The following commands explain how to extract fundamental data for the last
    80 months of all companies in the tickers list. These commands will take a few
    minutes to extract data so it is recommended to save the data once you extract
    it and later you should use the `load()` command to load it:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令解释了如何提取所有公司在 tickers 列表中过去 80 个月的基本面数据。这些命令会花费几分钟时间提取数据，因此建议在提取数据后保存数据，之后应使用
    `load()` 命令加载它：
- en: '[PRE74]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The next set of commands is the same as preceding code, but to extract price
    data:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下一组命令与之前的代码相同，但用于提取价格数据：
- en: '[PRE75]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The subsequent function creates various date variables in date format:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 后续的函数会创建各种日期格式的日期变量：
- en: '[PRE76]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now you have extracted price and fundamental data, you should use this data
    to construct various fundamental factors such as EPS, number of shares outstanding,
    market capitalization, market value to book value, and so on. This loop calculates
    fundamental factors for every ticker one by one and creates a list:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经提取了价格和基本面数据，你应该使用这些数据来构建各种基本面因子，如每股收益、流通股数、市场市值、市值与账面价值比等。这个循环会为每个股票代码逐个计算基本面因子并创建一个列表：
- en: '[PRE77]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Next, I filtered the preceding data for the period starting at `1995` and lasting
    at `2011`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我筛选了前面的数据，时间范围从 `1995` 年到 `2011` 年：
- en: '[PRE78]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Prices for all tickers can be extracted and NAN can be replaced with previous
    values using the following commands:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 所有股票的价格可以通过以下命令提取，并且 NAN 可以用之前的值替换：
- en: '[PRE79]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now you have to construct fundamental ratios using fundamental factors and
    prices. I created three ratios; however, you can create any number of ratios that
    you would like to consider. I created market capitalization, EPS to price ratio,
    and book value to price:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要使用基本因素和价格构建基本比率。我创建了三个比率；不过，你可以创建任何你想要考虑的比率。我创建了市值、市盈率比率和账面价值比率：
- en: '[PRE80]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'As scaling for all of these ratios might be different, before moving on, we
    shouldn''t forget to standardize it. I calculated the Z score to standardize this
    data:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些比率的量纲可能不同，在继续之前，我们不应该忘记对其进行标准化。我计算了 Z 分数来标准化这些数据：
- en: '[PRE81]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Calculate the average of all the normalized factors:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 计算所有标准化因子的平均值：
- en: '[PRE82]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'As of now, we have daily data and created financial ratios on a daily basis.
    You can convert it to any frequency you desire. I converted it to monthly frequency
    and extracted data for the last day of the month:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有的是日数据，并且已经基于日数据创建了财务比率。你可以将其转换为任何你需要的频率。我将其转换为月频，并提取了每个月最后一天的数据：
- en: '[PRE83]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This is how you should calculate monthly return and its `lag`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你应该如何计算月度回报及其 `lag`：
- en: '[PRE84]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Marker capitalization at the end of every month can be calculated using the
    following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 每个月最后一天的市值可以通过以下方式计算：
- en: '[PRE85]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Extract all ratios for the last day of the month:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 提取每个月最后一天的所有比率：
- en: '[PRE86]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Next you should calculate quantiles, which can be calculated using the following
    commands. I created five quantiles, and the average next month return of each
    quantile is calculated using the earning price factor. Quantiles are created month
    by ranging stocks based on EP factor:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来你应该计算分位数，可以通过以下命令计算。我创建了五个分位数，并且使用盈利价格因子计算了每个分位数的下个月平均回报。分位数是通过按 EP 因子对股票进行月份排序来创建的：
- en: '[PRE87]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The top and bottom are very extreme and should be used to create a spread (Q5
    - Q1). The dynamics of this spread helps to design and develop an investing strategy,
    that is, momentum or mean reverting:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最高和最低极值非常极端，应该用来创建一个差距（Q5 - Q1）。这个差距的动态有助于设计和开发投资策略，即动量或均值回归：
- en: '[PRE88]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now you should run cross-sectional regression to estimate alpha and portfolio
    loadings and these can be calculated using the following commands:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该运行横截面回归来估计 alpha 和投资组合负荷，这些可以通过以下命令计算：
- en: '[PRE89]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We can also use these alpha and beta to estimate future portfolio return as
    well.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用这些 alpha 和 beta 来估计未来的投资组合回报。
- en: Portfolio construction
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投资组合构建
- en: 'Investors are interested in reducing risk and maximizing return of their investment
    and creating a portfolio does this job provided we have constructed it by keeping
    in mind the investor risk-return profile. I will guide you through creating an
    efficient frontier that can help you to measure risk with respect to your return
    expectation. For that, I will start extracting data for four securities. The first
    line of code creates a new environment to store data; the next few lines are for
    symbols list, data starting date, and extracting data using `getSymbols()`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 投资者的目标是减少风险并最大化投资回报，创建一个投资组合可以实现这一目标，前提是我们在构建时考虑了投资者的风险-回报特征。我将指导你如何创建一个有效前沿，帮助你根据预期回报衡量风险。为此，我将开始提取四个证券的数据。第一行代码创建一个新的环境来存储数据；接下来的几行是关于符号列表、数据起始日期，以及使用
    `getSymbols()` 提取数据：
- en: '[PRE90]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The next for loop stores individual stock data in a list, and calculates the
    day''s gain and a data frame consisting of closing prices of all stocks in portfolio:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的 for 循环将个别股票数据存储在一个列表中，并计算当天的收益，以及一个包含所有投资组合股票收盘价的数据框：
- en: '[PRE91]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The return, average return for each stocks, and covariance matrix can be calculated
    using the following commands:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令计算每只股票的收益、平均收益以及协方差矩阵：
- en: '[PRE92]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'I will be using the following weights to assign to portfolio:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用以下权重来分配给投资组合：
- en: '[PRE93]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now you have to browse link [http://faculty.washington.edu/ezivot/econ424/portfolio.r](http://faculty.washington.edu/ezivot/econ424/portfolio.r)
    and save this R code in the file `portfolio.R`. You should use the following command
    to access the function developed under `portoflio.R`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要浏览链接 [http://faculty.washington.edu/ezivot/econ424/portfolio.r](http://faculty.washington.edu/ezivot/econ424/portfolio.r)，并将这个
    R 代码保存到文件 `portfolio.R` 中。你应该使用以下命令来访问在 `portfolio.R` 中开发的函数：
- en: '[PRE94]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'To calculate portfolio expected return and standard deviations, we require
    return, weights, and covariance matrix. Now we have all the data and can use the
    following commands to generate portfolio expected return and risk:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算投资组合的预期收益和标准差，我们需要收益、权重和协方差矩阵。现在我们已经拥有所有数据，并可以使用以下命令来生成投资组合的预期收益和风险：
- en: '[PRE95]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The global minimum variance portfolio is obtained using the following command.
    You can see here that portfolio weights are different compared to weights in the
    previous command and this set of weights helps to generate a portfolio which has
    lower standard deviation:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 全球最小方差投资组合可以使用以下命令获得。你可以看到这里的投资组合权重与前一个命令中的权重不同，这一组权重有助于生成标准差较低的投资组合：
- en: '[PRE96]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now suppose you want to generate a portfolio which has `0.0002` as the expected
    return. The following command will help generate portfolio weights and standard
    deviation for the portfolio of expected return `0.0002`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你想生成一个预期收益为`0.0002`的投资组合。以下命令将帮助生成该预期收益为`0.0002`的投资组合的权重和标准差：
- en: '[PRE97]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'A tangency portfolio is a portfolio of risky assets which has the highest Sharpe''s
    slope. To compute this, I used the `tangency.portfolio()` function:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 切线投资组合是一个风险资产组合，具有最高的夏普比率斜率。为了计算这一点，我使用了` tangency.portfolio()`函数：
- en: '[PRE98]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We have already calculated the global minimum variance portfolio, and the other
    portfolio with maximum expected return can be considered as the second portfolio.
    Call these portfolios *P1* and *P2* respectively. Now, for any ![Portfolio construction](img/00032.jpeg),
    another portfolio can be constructed as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经计算了全球最小方差投资组合，另一个具有最大预期收益的投资组合可以视为第二个投资组合。分别将这些投资组合称为*P1*和*P2*。现在，对于任何 ![投资组合构建](img/00032.jpeg)，可以按以下方式构建另一个投资组合：
- en: '![Portfolio construction](img/00086.jpeg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![投资组合构建](img/00086.jpeg)'
- en: 'The efficient frontier can be calculated using the following command. This
    generates `50` portfolios using ![Portfolio construction](img/00032.jpeg) in the
    range `-2` to `2`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令计算有效前沿。这将生成`50`个投资组合，使用 ![投资组合构建](img/00032.jpeg)，范围从 `-2` 到 `2`：
- en: '[PRE99]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Next, in *Figure 5.9*, I plotted the efficient frontier, red and blue points
    for minimum variance and tangency portfolio, and tangent to the frontier:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在*图 5.9*中，我绘制了有效前沿、最小方差和切线投资组合的红蓝点，以及切线与前沿的切点：
- en: '[PRE100]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '![Portfolio construction](img/00087.jpeg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![投资组合构建](img/00087.jpeg)'
- en: 'Figure 5.9: Efficient frontier for portfolio and tangent line'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：投资组合的有效前沿与切线
- en: Questions
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How do you import stock data into the R workspace from Yahoo Finance?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从雅虎财经导入股票数据到 R 工作空间？
- en: How do you generate a momentum strategy using moving average crossover?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用移动平均交叉生成动量策略？
- en: Which package helps to calculate the performance metrics of a strategy?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个包帮助计算策略的绩效指标？
- en: How do you calculate the covariance matrix for a portfolio consisting of five
    stocks?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何计算一个由五只股票组成的投资组合的协方差矩阵？
- en: Extract MSFT data from Yahoo and test that the closing price series is non-stationary.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从雅虎提取 MSFT 数据，并测试收盘价系列是否是非平稳的。
- en: Use the distance method to generate trading signals which exit when the spread
    reverts to mean.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用距离法生成交易信号，当价差回归均值时退出。
- en: How do you test a pair of stocks for co-integration and write code to test it?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何测试一对股票的协整性，并编写代码进行测试？
- en: How do you calculate hedge ratio and how does it helps in trading?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何计算对冲比率，它如何帮助交易？
- en: How do you calculate portfolio beta? Show it using an example.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何计算投资组合的贝塔值？请用一个例子展示。
- en: How do you use the fundamental factor to create quantiles and quantile spread?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用基本面因子创建分位数和分位数差距？
- en: Write code to calculate portfolio expected `_return` and standard deviation.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码计算投资组合的预期`收益`和标准差。
- en: How do you calculate the efficient frontier and plot it using the R command?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何计算有效前沿并使用 R 命令绘制它？
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I presented different concepts of trading using R. I started
    with trend following strategy and explained in depth how the trading signals are
    generated and how various parameters related to its performance are captured.
    Momentum strategies was followed by pairs trading using three different methods.
    The first method covered was distance based pairs trading, the second was correlation
    based, and the third and final method was co-integration based pairs trading.
    Sometimes, trading in a portfolio is important to control the risk and reward
    ratio and for that I have covered capital asset pricing, the multi factor model,
    and portfolio construction. I used Systematic Investor Toolbox for implementing
    portfolio ideas.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我介绍了使用R进行交易的不同概念。 我从趋势跟踪策略开始，深入解释了交易信号是如何生成的，以及如何捕捉与其表现相关的各种参数。 动量策略之后是使用三种不同方法进行配对交易。
    第一种方法是基于距离的配对交易，第二种是基于相关性的，第三种也是最后一种方法是基于协整的配对交易。 有时，通过投资组合进行交易以控制风险和回报比是很重要的，为此我涵盖了资本资产定价、多因子模型和投资组合构建。
    我使用Systematic Investor Toolbox来实现投资组合理念。
- en: In the next chapter, I will explain trading strategies using machine learning
    algorithms, which are gaining in popularity. Machine learning algorithms learn
    automatically from historical market behavior and try to mimic this behavior.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将解释使用机器学习算法的交易策略，这些策略越来越受欢迎。 机器学习算法会自动从历史市场行为中学习，并尝试模仿这种行为。
