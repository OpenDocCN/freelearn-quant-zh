- en: Chapter 2. Learning More About F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a more detailed one about the F# language itself. The tutorial
    approach will continue with demonstrations using Visual Studio, together with
    detailed aspects of the language relevant to building the final trading system
    throughout the later part of the book. Most of the language building blocks will
    be covered with explanations and examples. This chapter is quite large, but it
    is essential to understand the content provided here to be able to follow along
    throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: Structuring a program into modules and namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More about data structures and types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursive functions and their role in functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining functional and object-oriented ideas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The imperative part of F#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parallel and asynchronous programming model in F#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Download the F# 3.0 Language Specification from Microsoft Research and use it
    side-by-side as you go along this chapter and the rest of the book. The specification
    provides a lot of useful details and answers potential questions from you as a
    reader.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring your F# program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you write larger programs, it becomes essential to be able to structure
    the code into hierarchical abstraction levels. This makes it possible to build
    larger programs, reuse existing code, and let others understand the code as well.
    In F# there are namespaces, modules, and object orientation together with types
    and data structures to do this. In object orientation, there are possibilities
    to make functions and variables private and to disable outside access. Object
    orientation will be covered in a section by itself later on.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have seen in Visual Studio, when you have created your F# projects,
    there exist various types of source code files. They have different extensions
    depending on their use. In this book we use `.fs` and `.fsx` files. The former
    is an F# source code file to be compiled and used in an executable program. The
    latter, `.fsx`, is used for F# scripts and interactive mode for prototyping. Scripts
    are excellent for prototyping and exploratory development, but not suitable for
    larger programs.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will cover the most common and useful techniques used in F# to structure
    the code into elegant, maintainable, and logical structures.
  prefs: []
  type: TYPE_NORMAL
- en: Looking into modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modules help in organizing and structuring the related code. They are a simple
    and elegant way of organizing your code into higher abstractions. They can be
    thought of as named collections of declarations, such as values, types, and function
    values. You have been using modules already without noticing. All files will automatically
    be declared as modules with the same name as the file. The same holds true for
    F# Interactive, where every execution will be wrapped into a module of its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider a file named `application.fs` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This file will be compiled in the same way as if it was explicitly declared
    as a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That means you don't have to explicitly declare modules in every file to accomplish
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Using functions and values in modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modules may look a lot like classes in object orientation. They even have access
    annotations to specify the rules for accessing their declared members. The main
    difference between modules and classes is that classes can be thought of as defining
    new types, where as modules are grouped functionalities and may be used before
    knowing the exact details needed to write the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how to declare modules and nested modules
    with values and functions, and how to access these members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, modules can be nested, and this enables you as a programmer
    to structure your code in an elegant way. The `f` function in the module `NestedModule`
    can access the values `x` and `y` in the parent module, without explicitly writing
    out its name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The order in which you declare and use your modules is essential because they
    are processed in a sequential order from top to bottom. The following snippet
    will not be able to find `Module2` in the first `let` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Reverse the order and the error is solved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Each member value of a module is made public by default. This means that each
    member has a default accessibility set by the compiler. Let''s go back to the
    following example and change the accessibility of the function `Version` to private:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, if you type it into the editor, there is an error because of
    the private annotation. This is quite neat. In this case, it may be more appropriate
    to use the annotation internally, which means the member is only accessible from
    within the same assembly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The available modifiers are public, internal, and private. The public modifier
    indicates that the annotated function or value can be accessed by all code, whereas
    private indicates that the function or value can only be accessed from the enclosing
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A namespace is a hierarchical categorization of modules, classes, and other
    namespaces. First we take a look at how we declare namespaces. Namespaces have
    to be the first declaration in the code file. They are useful when you want to
    distinguish functionality without having to put long names in front of, for example,
    modules or classes. They also minimize naming collisions between your code and
    the existing code. Here is the code discussed previously added into a namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will tell the compiler that we are in the namespace called `Namespace1.Library1`.
    Namespaces also force programmers to use patterns known to F#, C#, and other .NET
    language programmers. Namespaces are open, which means many source files can contribute
    to the same namespace. It''s also possible to have multiple namespaces in the
    same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows how to use namespaces and how to access modules
    within namespaces, which requires fully qualified names to be used. If you use
    the `open` keyword in F#, you don't need the fully qualified names and is equivalent
    to `using` in C#. Fully qualified names mean the full name, as used to access
    the function `Version` in the last `let` statement.
  prefs: []
  type: TYPE_NORMAL
- en: For namespaces, the private and public modifiers also exist and work in the
    same way as for modules, except that they work on the namespace level in the code.
    There also exists more granular control mechanisms for your code, such as `[<AutoOpen>]`,
    which will automatically open a module inside of a namespace. This is handy when
    `let` statements are needed to be defined inside namespaces to define values.
  prefs: []
  type: TYPE_NORMAL
- en: Looking deeper inside data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter we introduced some data structures of F# and scratched
    the surface of their functionality. In this section we will take a deeper look
    at several data structures and expressions used in many programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of what will be covered together with a short description
    to summarize their main characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Record types**: Record types are used to represent data and group pieces
    of data together by combining named values and types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Discriminated unions**: Discriminated unions are useful to represent heterogeneous
    data and support data that can be a set of named cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enumerations**: Enumerations in F# are almost identical to enumerations in
    other languages and are used to map labels to constant values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arrays**: Arrays are collections of a fixed size and must contain values
    of the same type. Large arrays of constant values can be compiled to efficient
    binary representations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lists**: Lists are ordered collections with elements of the same type, implemented
    as linked lists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequences**: In F#, sequences are lazy and are represented as a logical series
    of elements where the elements have to be of the same type. They are especially
    suited to represent a large ordered collection of data where all elements are
    not expected to be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sets**: Sets are unordered containers for unique data elements. Sets do not
    preserve the order of elements as they are inserted, nor do they permit duplicates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maps**: Maps are associative containers for key/value pairs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Options**: Options are an elegant way of enclosing a value that may or may
    not exist. It''s implemented using a discriminated union. Instead of checking
    for null values, options are preferred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strings**: Strings are sequences of characters and are the same as the .NET
    string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Record types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Record types are used to represent data and group pieces of data together by
    combining named values and types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we are interested in modeling an **open-high-low-close** (**OHLC**)
    bar using record types, it may look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can use the previously defined record to declare a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s consider another example, where we model a quote with `bid`, `ask`,
    and `midpoint`. The `midpoint()` function will be calculated from the `bid` and
    `ask` values, that is, the average of both. This can be done using record types
    and a member function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it looks a lot like the first example except for the member
    function `midpoint`. The member functions are able to access fields of the record
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we are interested in modifying the fields after the initialization,
    it''s simply a matter of adding the keyword `mutable` to the particular field
    of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This example is a lot like the one discussed previously, but here we are able
    to change the value of the bid field to `150.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to use record types in pattern matching, because this is
    one of the biggest reasons for using record types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In short, record types are:'
  prefs: []
  type: TYPE_NORMAL
- en: Used to represent data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Useful in pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used to group pieces of data together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lot like objects in object orientation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Powerful and useful features of F#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A combination of named values of types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different from classes because they are exposed as properties and without constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discriminated unions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Discriminated unions are useful to represent heterogeneous data and support
    data that can be a set of named cases. Discriminated unions represent a finite,
    well-defined set of choices. Discriminated unions are often the tool of choice
    to build more complicated data structures including linked lists and a wide range
    of trees.
  prefs: []
  type: TYPE_NORMAL
- en: Let's investigate some properties of discriminated unions and how they may be
    used by looking at an example. Here we define a type, `OrderSide`, which can either
    be buy-side or sell-side.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is handy and enables us to write elegant and clean code, doing what we
    want without any boilerplate coding at all. What about if we desired to have a
    function to be able to toggle the side of the order? In that case, buys becomes
    sells and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, there are two versions of the toggle function, `toggle1` and `toggle2`.
    The first version uses the match-with style, whereas the latter uses the shorthand
    version. The shorthand version is sometimes useful because it's shorter and easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: Let's extend our analysis of discriminated unions by introducing recursive fields.
    They are used to refer to the type itself and will enable you as a programmer
    to define more complex types. Here is an example where we define an option which
    can be either `Put` or `Call`, or a combination.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Another example of a recursive discriminated union is tree structures. Tree
    structures are useful to represent hierarchical structures.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Enumerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enumerations in F# are almost identical to enumerations in other languages,
    and are used to map labels to constant values. Enumerations are used to associate
    a label with a number or predefined values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we define a type, `RGB`, to map labels to values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And we use the enumeration to bind a value to the first color, Red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To summarize enumerations:'
  prefs: []
  type: TYPE_NORMAL
- en: It looks like discriminated unions, but they accept that the values can be specified
    as constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are used to represent constants with labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They only hold one piece of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are as safe as discriminated unions, because they can be created with unmapped
    values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays are mutable collections of a fixed size and must contain values of the
    same type. Large arrays of constant types can be compiled to efficient binary
    representations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In F#, arrays are created in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Because arrays are mutable, one can change a value in an array like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'All elements in an array have to be of the same type. Otherwise, the compiler
    will complain. Suppose you create an array with one floating point number and
    two integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will tell you that the types are inconsistent. Sometimes there
    is a need to initialize a data structure with values following a logical expression,
    called array comprehension in this case. For arrays, you can use the following
    expression to create one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing elements is straightforward and follows the same pattern for every
    data structure. It looks a lot like in other programming languages except for
    the dot in front of the indexing bracket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'One convenient feature is the slice notation, used to access a range of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And the same holds true for the reverse, selecting from the element with index
    2 to the end of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at two examples of initialization of arrays. It can be useful to
    initialize an array with zeroes. The array module has a function to do this. Have
    a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a totally empty array, have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many useful functions in an array module and we will just look at
    a few of them here. For example, appending two arrays can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `filter` function is a recurrent candidate, which is useful in many ways.
    The following will show you how it is applicable on arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check out the MSDN page for more details and examples on how to use the F# array
    at [http://msdn.microsoft.com/en-us/library/dd233214.aspx](http://msdn.microsoft.com/en-us/library/dd233214.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Interesting functions in an array module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following table, the most useful functions in an array module are presented.
    This table can be used as a short reference too:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Array.length a | Returns the length of array a |'
  prefs: []
  type: TYPE_TB
- en: '| Array.average a | Calculates the average of array a elements. It has to be
    of float or double data type |'
  prefs: []
  type: TYPE_TB
- en: '| Array.min a | Finds the minimum value of elements in array a |'
  prefs: []
  type: TYPE_TB
- en: '| Array.max a | Finds the maximum value of elements in array a |'
  prefs: []
  type: TYPE_TB
- en: '| Array.filter f a | Filters out the elements in array a matching the predicate
    in function f |'
  prefs: []
  type: TYPE_TB
- en: '| Array.find f a | Returns the first element in list a to match the predicate
    in function f |'
  prefs: []
  type: TYPE_TB
- en: '| Array.empty | Returns an empty array |'
  prefs: []
  type: TYPE_TB
- en: '| Array.isEmpty a | Indicates whether the array a is empty |'
  prefs: []
  type: TYPE_TB
- en: '| Array.exists f a | Checks whether an element exists in array a which matches
    the predicate f |'
  prefs: []
  type: TYPE_TB
- en: '| Array.sort a | Sorts the elements in array a in increasing order, see sortBy
    to use predicate |'
  prefs: []
  type: TYPE_TB
- en: '| Array.zip a b | Sorts the elements in array a in increasing order, see sortBy
    to use predicate |'
  prefs: []
  type: TYPE_TB
- en: '| Array.map f a | Calls the function f for every element in the array a and
    forms a new array |'
  prefs: []
  type: TYPE_TB
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section we will investigate lists in more detail and show how to use
    most of the module functions. Lists in F# are implemented as linked lists and
    are immutable. They work on lists, and may also be used to convert between lists
    and other collections.
  prefs: []
  type: TYPE_NORMAL
- en: Lists are ordered collections with elements of the same type; you cannot mix
    different types in the same list. First we look at how to create and initialize
    a list and then we investigate the module functions one by one. At the end of
    this section is a table summarizing all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make use of F# Interactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here we use a range to initialize a list. Expressions for lists are useful when
    you want a certain pattern or sequence described by a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now investigate two useful operators in lists. We do that using the
    two previously defined lists: `list1` and `list2`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The previously used operator (`::`) is called the concatenation operator or
    cons operator. Concatenation is an efficient O(1) operator, which prepends elements
    to the start of a list. This builds a new list from an element and a list. It''s
    possible to append two lists using an operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The concat operator (`@`) has a performance penalty because lists are immutable
    and the first list has to be copied, and should be avoided when performance is
    concerned. This will find the *n*th value of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate the average value of a list, use the function `List.average`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to use floats here, otherwise the compiler will complain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Minimum and maximum values of a list are found by `List.min` and `List.max`,
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a function, `List.append`, in the list module, equivalent to the operator
    `@`, which appends two lists together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s investigate three functions now: `filter`, `find`, and `exists`. They
    take a predicate function `f` and a list. The predicate function describes a condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `zip` function will create a new list using a pair-wise combination of
    the elements found in lists provided as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we want to summarize elements of a list. The function `List.fold` comes
    in handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equal to `55`, as expected. We can also find the geometrical sum using
    `List.fold`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use `1` as the initial value to fold, because it is a multiplication
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching and lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's look at pattern matching and lists, which is a common way to work with
    lists. Pattern matching provides for a powerful way to create recursive functions
    on lists. If we want to write a recursive function to get the length of a list,
    we can use pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding short example, pattern matching will make the
    code easy to read. The first match is for an empty list and the second uses the
    cons operator to match a list with a head and a tail. The tail is then used in
    the recursive function `all`, where the length `l` is increased by one for each
    iteration. Let's look at one more example. If we want to get the second last element
    of a list, we can use pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we can see how pattern matching can be used to express
    ideas in a clear manner. Because a list is constructed using the cons operator
    (`::`), we can match arbitrary patterns on lists using it. The first pattern will
    match `head :: tail :: []`, where `head` is the second last element in the list.'
  prefs: []
  type: TYPE_NORMAL
- en: Interesting functions in a list module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following table, the most usable functions in the list module are presented.
    This table can be used as a short reference too:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `List.nth a` | Returns the nth element of the list `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `List.average a` | Calculates the average of the list `a`; elements have
    to be of float or double data type |'
  prefs: []
  type: TYPE_TB
- en: '| `List.max a` | Finds the maximum value of elements in list `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `List.min a` | Finds the minimum value of elements in list `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `List.append a b` | Appends the two lists `a` and `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `List.filter f a` | Filters out the elements in list `a`, matching the predicate
    in function `f` |'
  prefs: []
  type: TYPE_TB
- en: '| `List.empty` | Returns an empty list |'
  prefs: []
  type: TYPE_TB
- en: '| `List.length a` | Returns the length of list `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `List.find f a` | Returns the first element in list `a` to match the predicate
    in function `f` |'
  prefs: []
  type: TYPE_TB
- en: '| `List.sort a` | Sorts the elements in list `a` in increasing order, see `sortBy`
    to use predicate |'
  prefs: []
  type: TYPE_TB
- en: '| `List.zip a b` | Combines list `a` and `b` element wise and forms a new list
    |'
  prefs: []
  type: TYPE_TB
- en: '| `List.exists f a` | Checks whether an element exists in list `a` that matches
    the predicate `f` |'
  prefs: []
  type: TYPE_TB
- en: '| `List.fold f s a` | Folds list `a` from left to right, using the function
    `f` with start value `s` |'
  prefs: []
  type: TYPE_TB
- en: '| `List.head a` | Returns the head of list `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `List.tail a` | Returns the tail of list `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `List.map f a` | Calls the function `f` for every element in list `a` and
    forms a new list |'
  prefs: []
  type: TYPE_TB
- en: Sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sequences are logical series' of elements where the elements have to be of the
    same type. They are especially suited to represent large ordered collections of
    data where not all elements are expected to be used. Sequences are lazily evaluated
    and are suitable for large collections of data since not all elements need to
    be held in memory. Sequence expressions represent sequences of data computed on
    demand. We will investigate sequences in the same fashion as in the previous sections,
    using F# Interactive to get a better feel for them, and we will also see how their
    module functions work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by looking at how to initialize and create sequences in various
    ways using F# Interactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: First we create a sequence defining the elements explicitly. Then, we use ranges.
    They work in the same way as for arrays and lists. The range expressions are also
    similar to other collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will find the *n*th value of the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the arguments are swapped in `Seq.nth` compared to, for example,
    the same function in the list module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Minimum and maximum values of a sequence are found by `Seq.min` and `Seq.max`,
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also append two sequences using the `Seq.append` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create an empty sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s investigate three functions now: `filter`, `find`, and `exists`. They
    take a predicate function, `f,` and a list. The predicate function describes a
    condition. They are identical to the list functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The first element of a sequence, the head, is obtained by calling `Seq.head`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Notice that there is no `Seq.tail`, that's because of how sequences are represented
    (they are lazy constructs).
  prefs: []
  type: TYPE_NORMAL
- en: Interesting functions in the sequence module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following table, the most useful functions in the sequence module are
    presented. This table can be used as a short reference too:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Seq.nth a` | Returns the nth element of sequence a |'
  prefs: []
  type: TYPE_TB
- en: '| `Seq.average a` | Calculates the average of sequence a. Elements have to
    be of float or double data type |'
  prefs: []
  type: TYPE_TB
- en: '| `Seq.min a` | Finds the maximum value of elements in sequence a |'
  prefs: []
  type: TYPE_TB
- en: '| `Seq.max a` | Finds the minimum value of elements in sequence a |'
  prefs: []
  type: TYPE_TB
- en: '| `Seq.append a b` | Appends the two sequences a and b |'
  prefs: []
  type: TYPE_TB
- en: '| `Seq.filter f a` | Filters out the elements in sequence a, matching the predicate
    in function f |'
  prefs: []
  type: TYPE_TB
- en: '| `Seq.empty` | Returns an empty sequence |'
  prefs: []
  type: TYPE_TB
- en: '| `Seq.find f a` | Returns the first element in sequence a to match the predicate
    in function f |'
  prefs: []
  type: TYPE_TB
- en: '| `Seq.sort a` | Sorts the elements in sequence a in an increasing order. See
    sortBy to use predicate |'
  prefs: []
  type: TYPE_TB
- en: '| `Seq.zip a b` | Combines list a and b element-wise and forms a new list |'
  prefs: []
  type: TYPE_TB
- en: '| `Seq.length a` | Returns the length of sequence a |'
  prefs: []
  type: TYPE_TB
- en: '| `Seq.exists f a` | Checks whether an element exists in sequence a which matches
    the predicate f |'
  prefs: []
  type: TYPE_TB
- en: '| `Seq.fold f s a` | Folds sequence a from left to right, using the function
    f with start value s |'
  prefs: []
  type: TYPE_TB
- en: '| `Seq.head` | Returns the head of sequence a |'
  prefs: []
  type: TYPE_TB
- en: '| `Seq.map f a` | Calls the function f for every element in sequence a and
    forms a new sequence |'
  prefs: []
  type: TYPE_TB
- en: Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sets are unordered containers for data elements. Sets do not preserve the order
    of elements as they are inserted, nor do they permit duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a set with three integer elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding set will be of the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The type inference works here as expected. Now let''s consider adding and inspecting
    elements in `s1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `s1` will not be modified due to its immutable characteristics. We
    can check whether `s1` contains 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes it''s helpful to create sequences from other data structures. In
    this case, from a sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'It works the same way as creating it from an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the length of a set, or in other words, to count the number of elements
    used, run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fold` function is also present in the module for sets and is used in the
    same way as for other collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be written using the shorthand version `(+)` for addition and
    `(*)` for multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The same holds true for `Set.exists`. The function takes a predicate and a
    set and returns true if there is any element matching the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '`Filter` is a variant of `exists`, which returns a new set of elements matching
    the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'An interesting function is the `partition` function. It will split the set,
    in this case, into two new sets: a set of elements which passes the predicate
    and one that doesn''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Think for a moment about how to write this `partition` function in an ordinary
    imperative language. Not as elegant if you ask me. Last but not least, we cover
    the `map` function. This function should be familiar to you at this stage. We
    use the old value of `s1` and simply add 2 to every element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the interesting functions in the `Set` module are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Set.count a` | Returns the number of elements in set `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `Set.empty` | Returns an empty set |'
  prefs: []
  type: TYPE_TB
- en: '| `Set.fold f s a` | Folds set `a` from left to right, using the function `f`
    with start value `s` |'
  prefs: []
  type: TYPE_TB
- en: '| `Set.exists f a` | Checks whether an element exists in set `a` which matches
    the predicate `f` |'
  prefs: []
  type: TYPE_TB
- en: '| `Set.filter` `f a` | Filters out the elements in sequence `a` matching the
    predicate in function `f` |'
  prefs: []
  type: TYPE_TB
- en: '| `Set.partition f a` | Creates a partition, two new sets, from set `a` using
    the predicate function `f` |'
  prefs: []
  type: TYPE_TB
- en: '| `Set.map` | Calls the function `f` for every element in set `a` and forms
    a new set |'
  prefs: []
  type: TYPE_TB
- en: Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maps are a special kind of set with associative key/value pairs. They are immutable,
    unordered data structures. They do not preserve the order of elements as they
    are inserted, nor do they permit duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maps are created in much the same way as sets, except we need a key as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can access the value using the key, `Age`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s possible to create maps from lists of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Because maps are a little different from the collections we covered so far,
    we will look at some of the more interesting functions in the `map` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To filter a map using a predicate, you may notice the small variation here
    compared to other collections. To ignore either the key or the value, one can
    replace it with an underscore (`_`), in the same way as in pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '`Maps.exists` works almost in the same way as filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Partitioning a map using a predicate can be useful. Here we do that using a
    fixed value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful module function for maps is `Map.containsKey`. This function
    checks whether the map contains a specific key or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Interesting functions in the map module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following table, the most useful functions in the `map` module are presented.
    This table can be used as a short reference too:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Map.add(k,v)` | Will create a new map with contents from the map together
    with the new entry `k,` `v` |'
  prefs: []
  type: TYPE_TB
- en: '| `Map.empty` | Creates an empty map |'
  prefs: []
  type: TYPE_TB
- en: '| `Map.filter f a` | Filters out elements in map `a` matching the predicate
    in function `f` |'
  prefs: []
  type: TYPE_TB
- en: '| `Map.exists f a` | Checks whether an element exists in set `a` which matches
    the predicate `f` |'
  prefs: []
  type: TYPE_TB
- en: '| `Map.partition f a` | Creates a partition, two new maps, from map `a` using
    the predicate function `f` |'
  prefs: []
  type: TYPE_TB
- en: '| `Map.containsKey k a` | Checks whether map `a` contains the key `k` |'
  prefs: []
  type: TYPE_TB
- en: '| `Map.fold f s a` | Folds map `a` from left to right, using the function `f`
    with start value `s` |'
  prefs: []
  type: TYPE_TB
- en: '| `Map.find f a` | Returns the first element in map `a` to match the predicate
    in function `f` |'
  prefs: []
  type: TYPE_TB
- en: Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Options are an elegant way of enclosing a value that may or may not exist. They
    are implemented using a discriminated union. Instead of checking for null values,
    options are preferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example where we use an integer option and pattern matching to investigate
    them further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use F# Interactive to investigate the types of options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The first option, `some`, contains an integer value as expected. And the other,
    `none`, is empty. This way, we don't need to use null values and check for them
    using conditions. We simply pass around option values instead. Along with options,
    `Nullable` is also available in F#, which explicitly represents the absence of
    a value.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Strings should be familiar to you already, and they work in the same way in
    F#. To use a more formal description of strings, we can say that strings are sequences
    of characters and are compatible with the .NET string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Interesting functions in the string module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following table, the most useful functions in the string module are presented.
    This table can be used as a short reference too.
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `String.length s` | Returns the length of the string `s` |'
  prefs: []
  type: TYPE_TB
- en: '| `String.Empty` | Creates an empty string |'
  prefs: []
  type: TYPE_TB
- en: '| `String.map f s` | Maps function `f` to every character in the string `s`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `String.IsNullOrEmpty` | Indicates whether the string `s` is null or empty
    |'
  prefs: []
  type: TYPE_TB
- en: '| `String.IsNullOrWhiteSpace` | Indicates whether the string `s` is null or
    consists only of white space characters |'
  prefs: []
  type: TYPE_TB
- en: '| `String.Copy s` | Creates a new string with the same character sequence as
    the string `s` |'
  prefs: []
  type: TYPE_TB
- en: '| `String.Concat s1 s2` | Concatenates the two strings `s1` and `s2` into a
    new string |'
  prefs: []
  type: TYPE_TB
- en: '| `String.exists f s` | Checks whether any character in `s` matches the predicate
    function `f` |'
  prefs: []
  type: TYPE_TB
- en: '| `String.Compare s1 s1` | Compares the two strings `s1` and `s2`. If they
    match, `0` is returned, otherwise, `-1` or `1` is returned depending on the comparison.
    |'
  prefs: []
  type: TYPE_TB
- en: Choosing data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this many data structures to choose from, it can be hard to know which
    one to choose during a specific problem. There are some rules to follow, and here
    is a short summary of the main characteristics of the individual data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays are efficient if you have to know the size of the collection beforehand.
    That means the size is fixed, and if you want to change the size, you have to
    create a new array and copy the elements over. On the other hand, random access
    is very fast; it can be done in constant time.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists are implemented using linked lists, which are items linked together using
    pointers. This means that traversing a linked list is not super-efficient, because
    a lot of pointers have to be followed. On the other hand, insertion is very fast
    at any position in the list. Also worth mentioning is that the lookup of the head
    element is a constant time operation.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sets are implemented as binary trees, where you can't have multiple values defined
    in the same set. Sets are useful when you don't care about the order and don't
    allow duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maps are like sets, except that they are extended to use key-value pairs instead
    of raw values. Maps are very efficient to lookup a value if you know the key.
  prefs: []
  type: TYPE_NORMAL
- en: More on functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we will continue and build on the foundation from the previous chapter
    on functional programming basics. We will examine some of the more advanced and
    at the same time useful constructs of the F# language.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recursion is a fundamental building block in functional programming. Many problems
    can be solved in a recursive fashion, and together with pattern matching, it makes
    up a powerful toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: To define a recursive expression, you use the keyword `rec`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the famous Fibonacci sequence, which is defined
    as the sum of the two previous numbers in a recursive sequence. The first two
    values are set to `0` and `1`, respectively, as seed values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Recursion is a powerful way of solving problems, and is often preferred in
    functional languages before loop constructs. Let''s look at three recursive functions
    to illustrate its flexibility and power:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will sum a list of elements recursively using the match construct
    on the list argument. The list is split for head and tail in the first match statement
    and then the function is called again with the tail part. If the list is empty,
    zero is returned. In the end, the sum of the list will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'To determine the length of a list, we slightly modify the `mysum` function
    to add one instead of the element for every element encountered. Of course there
    is a built-in function to do this, as we have seen before. The built-in function
    `map`, can be constructed using a recursion like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Understanding this function will give you a better understanding about the built-in
    functions and functional programming in general. Many functions can be defined
    using recursion and pattern matching. We will learn more about pattern matching
    in the later part.
  prefs: []
  type: TYPE_NORMAL
- en: Tail recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tail recursion is a way of optimizing the recursion and easing the callback
    stack. Every time a call is made to the function, a new stack frame is allocated
    on the stack. This will eventually case `StackOverflowException`. In other words,
    tail recursion is used when you expect thousands of iterations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tail recursion can be described as:'
  prefs: []
  type: TYPE_NORMAL
- en: An optimization technique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way to ease the stack and ensure there are no stack overflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes harder to understand and reason about
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate the concepts of tail recursion, we''ll convert a traditional
    recursively-defined function for the factorial. The factorial, *n!*, is a product
    of all positive numbers less than or equal to n. For example, 4! is defined as
    4 * 3 * 2 * 1, which is 24:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now verify if the function returns the correct value for 4! as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try out a somewhat larger factorial. The parameter doesn''t have to
    be big to result in a large answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Pattern matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pattern matching is used for control flow. It allows programmers to look at
    a value, test it against a series of conditions, and perform certain computations
    depending on whether that condition is met. It matches different patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet defines a function that matches the argument provided
    to the function with different patterns. This illustrates the basic idea behind
    pattern matching. We can modify it further.
  prefs: []
  type: TYPE_NORMAL
- en: Incomplete pattern matching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at an example of incomplete pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet is incomplete pattern matching, because we don''t
    consider values other than zero or one. The compiler will tell you this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This is also true if we consider a simple string pattern matcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This is fixed using a wildcard operator (`_`), like in the first example explained
    in the preceding snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Using guards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In imperative programming, we use `if` statements with expressions to express
    conditions. This is accomplished using pattern matching and guards. Guards use
    the keyword `when` to specify the condition. Let''s look at an example where this
    is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The name *guard* tells us something about their properties. They guard the pattern
    based on conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching in assignment and input parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pattern matching is also useful in assignments together with tuples, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding example, the pattern matching mechanism will
    assign the values to each name. This is handy for multiple assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also possible to use the wildcard to ignore a value in the assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Active patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Active patterns allow programmers to wrap ad hoc values and objects in union-like
    structures for use in pattern matching. First you define the partitioning of the
    input data using various expressions that act on the data. Each partition can
    have its own customized logic.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to verify whether an order is valid or not. Let's use the `Order`
    class, which will be introduced in a later section. The order can be valid and
    either a market or limit order, or simply invalid. Take a look at the `order`
    class further in the chapter if you are curious about how it is implemented or
    its properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by introducing an active pattern with a very simple one, namely one
    that figures out if a number is positive or negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use F# Interactive to explore the `TestNumber` function using different
    floating point numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we look at the active pattern to verify an order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s call `TestOrder` with some different order values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The code works, and you now know more about active patterns and how they can
    be used to make life simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Partial active patterns are used when parts of the input match, which is helpful
    in the case where strings need to be parsed to numbers. Let''s look at an example
    where single partial active patterns are used to make this clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The partial active pattern is used automatically in the matching inside the
    `testParse` function.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to look briefly at generics and how to define
    generic functions. The F# compiler is capable of finding out whether a function
    can be generic or not. This function together with type inference is a very powerful
    combination that allows for clean and easy-to-read code. Although, sometimes you
    want to specify your own functions as generic. If they are generic, they will
    be able to handle various types. Doing so will reduce the need of writing several
    functions with the same logic for every type involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to illustrate the concept described previously, we can take a look at
    a function that will create a list based on three parameters. This function is
    generic, so the type can be specified when used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use it in F# Interactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: First we use integers to create a list and the function creates a list for us.
    Secondly, the function is used with floats. And last but not least, we use ordinary
    strings. The function works in the same way here in all cases indifferent of the
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lazy evaluations or lazy computations are, as the name suggests, lazy. This
    means that they are not bothered until the last moment, which is when the value
    is needed. This type of evaluation can help improve the performance of the code.
    For example, sequences use lazy evaluation. Lazy evaluation also allows expensive
    computations to be defined without them being evaluated before they are needed.
    Lazy expressions are generic, and the type is determined when the expression is
    evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how you can define your own lazy constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now evaluate this function using F# Interactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute the function definition, the compiler will tell you that the
    value is not created; it''s lazy in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Units of measure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Units of measure are a way to associate signed integers and floating point numbers
    with units. The units can describe weight, length, volume, and currencies. One
    useful application of units of measure is currency and currency conversion. Units
    of measure are used to verify the types involved to ensure they are used correctly.
    All information about them is removed by the compiler after verification and is
    not part of the resulting executable program.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we take a look at the normal way of implementing currency conversion
    in F#. There is no guarantee that the actual rate is correct, or that the calculation
    uses the correct units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: There is no robust way to verify the correctness of the conversion made in the
    preceding snippet with respect to the units. Every value is just treated as floating
    point numbers. It can be of great importance to be able to verify the units involved.
    The Mars Climate Orbiter was lost at the end of September 1999 as a result of
    units. The software on the ground was producing pound-seconds instead of newton-seconds,
    which led the spacecraft to vaporize in the atmosphere of Mars.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same holds for currencies, where it''s of great importance to be able to
    verify the correctness of the units used. Let''s convert the preceding code to
    use the units of the `measure` construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the compiler will verify that the units are correct using the type information
    provided. Very handy indeed! What if we use the wrong units? We modify the code
    to include a measure for YEN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this in F# Interactive will result in an error with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The message is quite clear about what's wrong, and this is a great help for
    writing the correct code involving different units to be handled and converted
    in various ways.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous and parallel programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Asynchronous and parallel programming will be introduced in this section, together
    with events, thread pools, background workers, and the MailboxProcessor (agents).
    All these constructs exist with one purpose in life: to make life easier for the
    programmer. Modern computers have CPUs capable of executing several threads in
    parallel, which opens doors to new possibilities. These possibilities require
    a good toolkit for concurrent and parallel programming. F# is a very good candidate,
    and one of its design principles is to be a good fit in these types of situations.'
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Events are useful when you want a certain function to execute upon a specific
    event that will occur sometime in the future. This is often applicable to GUI
    programming, where a user will interact in some way with the interface. The pattern
    is called event-driven programming, where events drive the execution of the program.
    The following example illustrates this in a simple manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Here, a form is created, a regular .NET form. The parameters to the constructor
    sets the title, the visibility to `true`, and specifies it to be on top. Then,
    a `click` handler is installed, with a lambda function as the event handler. Upon
    execution, the function will simply print out a text message to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'In F#, you have the possibility to manipulate the event stream. This can be
    useful if there is a need to filter out certain events or do some manipulation.
    Events are first-class values in F#, which makes it possible to pass them around
    like other variables. Let''s take a look at how to filter out events. In the following
    example, the `click` events are filtered out depending on their coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Here, we modified the code to listen to the `MouseDown` event, which clicks
    in the form itself. The `MouseDown` events are then filtered depending on their
    coordinates, which are part of the event argument. If the event passes the filter,
    a function is called that prints the coordinates to the console. This filtering
    process can be very useful and makes it possible to create advanced filters and
    logic for events with code that's clean and easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Background workers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Say you make a program where you need calculations to take part. Sometimes
    these calculations will run for quite a long time. Background workers are a solution
    when you want to execute long running tasks that run in the background. The code
    will be executed in a separate thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an illustrative example of how to use background workers in the simplest
    manner. The worker will execute a function that simulates a calculation process
    and finally will notify us on completion. You can schedule tasks to be executed
    sequentially just by using the function `Add`. Here are two jobs executed in order,
    and finally we are notified upon completion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes it''s desirable to be able to cancel the execution in `Backgroundworker`.
    To be able to do this, we have to make some minor modifications to the preceding
    code. First we set a flag in the constructor, `WorkerSupportsCancellation = true,`
    and then we check a flag every time we iterate the calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this code, you will see no cancellation. Just that the code is prepared
    to handle a cancellation. To do a cancellation on the preceding execution, you
    need to run the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Use F# Interactive and run the main code for some iterations and then run the
    `CancelAsync()` function. This will terminate the background worker.
  prefs: []
  type: TYPE_NORMAL
- en: Threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Threads are essential parts in any modern software. In F#, threads are essentially
    .NET threads with all of the .NET functionality. If you have previous knowledge
    from any other .NET language, the following code will be familiar to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: We spawn a thread by passing a delegate to the `Thread` constructor. The thread
    will run the function `runMe`. The new part may be the way exceptions are handled.
    They are handled using pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to spawn many threads. And they will be executed concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Here, two threads are created and they run concurrently. Sometimes the output
    will be intervened; this is due to the fact that they have no synchronization.
    Spawning threads are quite costly, and will become noticeable if many threads
    are spawned and terminated. Every thread uses some memory, and if the threads
    are short lived, you better use a thread pool to enhance performance.
  prefs: []
  type: TYPE_NORMAL
- en: Thread pools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned in the previous section, spawning threads is quite costly. This
    is because it often involves the operating system itself to handle the task. If
    the threads are short lived, thread pools come to the rescue. A thread pool creates
    and terminates threads depending on the load. When a thread has finished executing
    a task, they sit in a queue waiting for the next task. F# uses the .NET `ThreadPool`
    class. This example will also be familiar to you if you have used the equivalent
    class in C# or any other .NET language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we enqueue three tasks to be executed by the thread pool.
    They will all be executed without being enqueued. This is because the thread pool
    will spawn up to the `ThreadPool.GetMaxThreads()` threads, which are usually 1024
    threads. Over that amount, they will be queued.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asynchronous code performs requests that are not completed immediately. That
    means they are doing operations that will be completed sometime in the future
    without blocking the current thread. Instead of waiting for that result to be
    available, multiple requests can be issued and the result will be handled as soon
    as it becomes available. This way of programming is called asynchronous programming.
    The program is not blocking just because of a result that is not yet available.
    Instead, as mentioned, the program will be notified when the result is ready.
    A common application is IO, where the CPU time can be used for something better
    than waiting for the IO operation to complete. There are often a lot of callbacks
    involved in asynchronous programming. Historically, asynchronous programming has
    been done in .NET using the **Asynchronous Programming Model** (**APM**).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MSDN has a detailed page about APM, that is, [http://msdn.microsoft.com/en-us/library/ms228963.aspx.](http://msdn.microsoft.com/en-us/library/ms228963.aspx.)
  prefs: []
  type: TYPE_NORMAL
- en: Without going into a lot of details about the APM and asynchronous callbacks,
    we will simply introduce the asynchronous workflows in F#. This enables us to
    write asynchronous code without the need for explicit callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: The F# asynchronous workflows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use asynchronous workflows, you simply wrap your code that you want to be
    asynchronous in the `async` block. It''s that simple, but the entire truth is
    not covered yet. There is one more thing. The code inside the `async` block has
    to be asynchronous in itself to make use of the asynchronous workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Here the expression is wrapped inside the `async` block. The expression is set
    up to run asynchronously by `Async.Start`, which means, without blocking the current
    thread. This is especially desirable if the current thread is the GUI thread.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you work with asynchronous code and expressions and want to bind them to
    values, you have to use a modified version of the original `let` keyword, `let!`.
  prefs: []
  type: TYPE_NORMAL
- en: This enables the execution to continue after the binding without blocking the
    current thread. It's a way of telling the binding that the value is asynchronous
    and will be used later, when the result is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: If we don't use the `let!` (let bang) operator here, `myFunction2` will have
    to wait for the result of the asynchronous request. We simply do not need the
    result in response right away, and can better utilize the CPU by running `myFunction2`
    instead of nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of using an async workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This example illustrates some of the concepts of asynchronous programming using
    parallel constructs. Here we will download data from Yahoo! finance using an asynchronous
    function in the `WebClient` class, `AsyncDownloadString`. This function takes
    a URL and downloads the content. In this case, the content will be CSV, containing
    the daily OHLC prices from 2010-01-01 until 2013-06-06\. We start by just downloading
    the data in parallel and counting the number of bytes fetched for each stock symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have seen how to download data in parallel and verified that it
    actually works, we will extend the example to do some useful operations on the
    data as well. The code is almost identical to the earlier one, except that we
    added a function, `getMaxPrice`, to parse the CSV and then iterate the sequence
    using pipes. We will then extract the maximum closing price for the entire period
    for each stock. All this is done in parallel, asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: We have now looked at two examples, or two versions of the same example. You
    can experiment and extend this example as much as you like to learn more about
    how to work with parallel and asynchronous constructs in F#.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel programming using TPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already covered parts of the asynchronous workflow in F# in the previous
    section. In this section, we'll focus on the .NET TPL (Task Parallel Library).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are also parallel sequences that you can explore on your own if you are
    interested.
  prefs: []
  type: TYPE_NORMAL
- en: The TPL is more useful than an asynchronous workflow; if the threads involved
    are going to do CPU work often. In other words, if there is less IO work to be
    done, the TPL is the one to be chosen. The TPL is part of the .NET framework 4,
    and can be used from all the .NET languages.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to program parallel programs is to replace for loops with `Parallel.For`
    and `Parallel.ForEach`, which is found in the `System.Threading` namespace. These
    two functions will enable loops to execute in parallel instead of in a sequence.
    Of course, it's not this simple in reality. For example, it's hard if the current
    iteration depends on another iteration, which is where you have a loop dependence.
  prefs: []
  type: TYPE_NORMAL
- en: MailboxProcessor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MailboxProcessor is also called an agent. Agents are constructs to support
    concurrent applications without too many insights into the implementation details.
    They are also more suitable where no shared memory is used, for example, in distributed
    computer systems with many nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The agent became famous from the Erlang programming language where it is called
    an actor. The concepts of actors have been partially implemented in various libraries
    for other programming languages. One major library is `Akka` for Scala, which
    is now part of the official Scala distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll introduce agents by looking at an example which keeps track of a maximum
    value. Every time a message is received, the agent recalculates the maximum value.
    It''s also possible to send a reset message. All communication with agents is
    handled using message passing. Messages are typically discriminated unions. This
    will be clear after we have walked through an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we make use of modules to illustrate how to structure the program
    when it becomes bigger. First we redefine `MailboxProcessor` to be called `Agent`,
    for simplicity. The module helpers then contain a function to generate a random
    number.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the module `MaxAgent` is defined with the `Agent` itself. The `Agent`
    reacts upon received messages using pattern matching. If the message is the reset
    message, the value is reset; otherwise, the agent updates the maximum value and
    waits for one second.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last three lines will create the agent and send it a random value. You
    can execute the last two lines in repetition to send multiple random values and
    update the agent. This will produce an output close to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s send a reset message and see what happens. Do this by using F# Interactive
    as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Now send some updates with random values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Agents are powerful constructs that act as state machines. You send messages
    to them and they change state depending on the logic they contain.
  prefs: []
  type: TYPE_NORMAL
- en: A brief look at imperative programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at imperative programming and object orientation.
    It's hard to do object orientation without involving imperative programming. In
    other words, mutable state. Mutable state and pure functional programming is not
    a good combination, in fact pure functional programming forbids mutable state
    totally. To our rescue, F# is not a pure functional programming language, so mutable
    state is allowed. With this knowledge, we can continue and learn about object
    orientation and how it's carried out in F#.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# is a multi-paradigm language where object orientation makes up parts of it.
    This makes the language interact seamlessly with the other .NET languages in the
    case of objects. Features that are well known because they are used in almost
    every modern programming language are imperative programming, object orientation,
    storing, and manipulating data. Combine imperative and functional programming;
    F# tried this and has in many ways succeeded. F# objects can have constructors,
    methods, properties (getters and setters), and fields.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes and objects are the foundation of **object-oriented programming** (**OOP**).
    They are used to model actions, processes, and any conceptual entities in applications.
    Apart from modules, classes are the most useful way in F# to represent and encapsulate
    data and related functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a class to represent orders in a trading system. The order will first
    have order-side, order-type, and a price. We''ll continue to extend the functionality
    of this class in this section to explore classes and object-orientation principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the newly-defined type, `order`, and investigate the member variables
    using F# Interactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Objects and members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll now extend the class `order` to have a function that will enable us
    to toggle the order-side. The order-side has to be mutable, and we need a member
    function that performs the actual work. The function to do this will be called
    `toggleOrderSide` and will use pattern matching for the discriminated union `OrderSide`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen previously, we investigate the changes to our class using F# Interactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: This may look like a lot of new stuff at once. But first we use the keyword
    mutable, to indicate that the value `S` is mutable. This is needed because we
    want to change its value on an already created object. The opposite is immutable,
    as we talked about in the previous chapter. Pattern matching takes care of the
    actual work, and the `←` operator is used to assign new values to mutable variables.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take a look at the MSDN article about values in F# at [http://msdn.microsoft.com/en-us/library/dd233185.aspx](http://msdn.microsoft.com/en-us/library/dd233185.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Methods and properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Wouldn't it be nice to be able to access the price and order-type fields using
    a better name like T or P? It's always a good tradition to name your objects,
    types, and functions in a clear and concise way. This enables both you and other
    programmers to understand the intention behind the code better.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s now possible to access the member values using the properties side and
    type, respectively. Properties are just another name for getters and setters.
    Getters and setters retrieve and change values. You can define members to be read
    only by omitting the setters, as for the `type` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Overloaded operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Overloaded operators can be useful if a specific functionality has to be exposed
    without calling a particular function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Look at the last line in this example; here we define an overloaded operator,
    a unary minus. This operator is defined to toggle the order-side of the order
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use F# Interactive to investigate this and how it is used in the code
    outside of the order object definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we first create the `order1` object and then we create `order2`
    to be defined as `-order1`. This will call the overloaded operator in the `order`
    class and toggle the order side. Compare the order sides in the last two outputs
    and see for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Using XML documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XML documentation is useful when you want to autogenerate documentation for
    your code. If you just put the documentation directly in a triple-slash comment,
    the entire content will be a summary. The other possibility is to use specific
    XML tags to specify which type of documentation the specific text belongs to.
    Doing that enables you, as a programmer, to document the code in a more versatile
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Useful XML tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some useful XML tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Tag | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `summary` | Summary describes code that is commented on |'
  prefs: []
  type: TYPE_TB
- en: '| `Returns` | Specifies what''s returned |'
  prefs: []
  type: TYPE_TB
- en: '| `Remark` | A remark or something to notice about the code |'
  prefs: []
  type: TYPE_TB
- en: '| `exception` | Specifies exceptions that may be thrown from the code |'
  prefs: []
  type: TYPE_TB
- en: '| `See also` | Enables you to link your documentation to other sections for
    more details |'
  prefs: []
  type: TYPE_TB
- en: Typical XML documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'XML documentation is used by Visual Studio and it''s IntelliSense to provide
    information about the code. Let''s add some XML documentation to a function that
    we have used before and investigate how it affects IntelliSense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The final result will look something like the following. Here you can see IntelliSense
    and how it includes the summary at the bottom in the tool tip box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Typical XML documentation](img/2_xml_documentation.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we looked into the F# language and its various features in more
    detail. The objective was to introduce in more detail relevant parts of the language
    to be used later throughout the book. F# is a big language and not all features
    are useful at once. There are many resources to explore on the Internet, and the
    F# 3.0 Specification is one of them. Some of the examples here were quite large
    and contain many of the features and aspects covered.
  prefs: []
  type: TYPE_NORMAL
- en: You will be well prepared for the next chapter if you have digested the material
    provided here. Next up is financial mathematics and numerical analysis.
  prefs: []
  type: TYPE_NORMAL
