- en: Chapter 2. Learning More About F#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 进一步了解 F#
- en: This chapter is a more detailed one about the F# language itself. The tutorial
    approach will continue with demonstrations using Visual Studio, together with
    detailed aspects of the language relevant to building the final trading system
    throughout the later part of the book. Most of the language building blocks will
    be covered with explanations and examples. This chapter is quite large, but it
    is essential to understand the content provided here to be able to follow along
    throughout the book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于 F# 语言本身的更详细内容。教程方法将继续使用 Visual Studio 进行演示，并结合本书后半部分涉及构建最终交易系统的语言细节。本章将涵盖大多数语言构建块，并通过解释和示例进行讲解。虽然本章内容较多，但要理解这里提供的内容，对于后续的学习至关重要。
- en: 'In this chapter, you will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章你将学习：
- en: Structuring a program into modules and namespaces
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将程序结构化为模块和命名空间
- en: More about data structures and types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于数据结构和类型的内容
- en: Recursive functions and their role in functional programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归函数及其在函数式编程中的作用
- en: Pattern matching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Combining functional and object-oriented ideas
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合函数式和面向对象的思想
- en: The imperative part of F#
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F#的命令式部分
- en: The parallel and asynchronous programming model in F#
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F#中的并行和异步编程模型
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Download the F# 3.0 Language Specification from Microsoft Research and use it
    side-by-side as you go along this chapter and the rest of the book. The specification
    provides a lot of useful details and answers potential questions from you as a
    reader.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 Microsoft Research 提供的 F# 3.0 语言规范，并在本章及本书其余部分的学习过程中一同查阅。该规范提供了许多有用的细节，并解答了你作为读者可能提出的疑问。
- en: Structuring your F# program
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化你的 F# 程序
- en: When you write larger programs, it becomes essential to be able to structure
    the code into hierarchical abstraction levels. This makes it possible to build
    larger programs, reuse existing code, and let others understand the code as well.
    In F# there are namespaces, modules, and object orientation together with types
    and data structures to do this. In object orientation, there are possibilities
    to make functions and variables private and to disable outside access. Object
    orientation will be covered in a section by itself later on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写较大的程序时，能够将代码结构化为层次化的抽象层次变得至关重要。这使得构建大型程序、重用现有代码以及让其他人理解代码成为可能。在 F# 中，有命名空间、模块和面向对象的结合，以及类型和数据结构来实现这一点。在面向对象编程中，可以使函数和变量变为私有，并禁用外部访问。面向对象编程将在后续章节单独讲解。
- en: As you may have seen in Visual Studio, when you have created your F# projects,
    there exist various types of source code files. They have different extensions
    depending on their use. In this book we use `.fs` and `.fsx` files. The former
    is an F# source code file to be compiled and used in an executable program. The
    latter, `.fsx`, is used for F# scripts and interactive mode for prototyping. Scripts
    are excellent for prototyping and exploratory development, but not suitable for
    larger programs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能在 Visual Studio 中看到的，当你创建 F# 项目时，会有各种类型的源代码文件。根据文件的用途，它们有不同的扩展名。在本书中，我们使用
    `.fs` 和 `.fsx` 文件。前者是一个 F# 源代码文件，需编译后用于可执行程序中；后者 `.fsx` 是用于 F# 脚本和交互模式的原型开发。脚本非常适合快速原型开发和探索性开发，但不适合用于较大的程序。
- en: Next, we will cover the most common and useful techniques used in F# to structure
    the code into elegant, maintainable, and logical structures.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍在 F# 中用于将代码结构化成优雅、可维护且符合逻辑的结构的最常见和最有用的技术。
- en: Looking into modules
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探讨模块
- en: Modules help in organizing and structuring the related code. They are a simple
    and elegant way of organizing your code into higher abstractions. They can be
    thought of as named collections of declarations, such as values, types, and function
    values. You have been using modules already without noticing. All files will automatically
    be declared as modules with the same name as the file. The same holds true for
    F# Interactive, where every execution will be wrapped into a module of its own.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 模块有助于组织和结构化相关代码。它们是将代码组织成更高抽象层次的简单而优雅的方式。可以将其视为值、类型和函数值等声明的命名集合。你已经在不自觉中使用了模块。所有文件会自动声明为与文件同名的模块。F#
    交互模式也是如此，每次执行的内容都会被包装成一个独立的模块。
- en: 'For example, consider a file named `application.fs` with the following content:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个名为 `application.fs` 的文件，其内容如下：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This file will be compiled in the same way as if it was explicitly declared
    as a module:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件将以与显式声明为模块相同的方式进行编译：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That means you don't have to explicitly declare modules in every file to accomplish
    this.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你不必在每个文件中显式声明模块来实现这一点。
- en: Using functions and values in modules
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在模块中使用函数和变量
- en: Modules may look a lot like classes in object orientation. They even have access
    annotations to specify the rules for accessing their declared members. The main
    difference between modules and classes is that classes can be thought of as defining
    new types, where as modules are grouped functionalities and may be used before
    knowing the exact details needed to write the class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 模块看起来很像面向对象中的类。它们甚至有访问注解来指定访问其声明的成员的规则。模块和类之间的主要区别是，类可以被看作是定义新类型，而模块是功能的集合，且在写类之前可能不需要知道具体的细节。
- en: 'The following example illustrates how to declare modules and nested modules
    with values and functions, and how to access these members:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何声明具有值和函数的模块及嵌套模块，以及如何访问这些成员：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, modules can be nested, and this enables you as a programmer
    to structure your code in an elegant way. The `f` function in the module `NestedModule`
    can access the values `x` and `y` in the parent module, without explicitly writing
    out its name.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，模块可以嵌套，这使得程序员能够以优雅的方式组织代码。模块`NestedModule`中的`f`函数可以访问父模块中的`x`和`y`值，而不必显式写出父模块的名称。
- en: 'The order in which you declare and use your modules is essential because they
    are processed in a sequential order from top to bottom. The following snippet
    will not be able to find `Module2` in the first `let` statement:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 声明和使用模块的顺序至关重要，因为它们是按从上到下的顺序依次处理的。以下代码片段将在第一个`let`语句中找不到`Module2`：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Reverse the order and the error is solved:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 反转顺序后，错误得以解决：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Each member value of a module is made public by default. This means that each
    member has a default accessibility set by the compiler. Let''s go back to the
    following example and change the accessibility of the function `Version` to private:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的每个成员变量默认是公开的。这意味着每个成员都有一个由编译器设置的默认可访问性。让我们回到以下示例，并将函数`Version`的可访问性更改为private：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, if you type it into the editor, there is an error because of
    the private annotation. This is quite neat. In this case, it may be more appropriate
    to use the annotation internally, which means the member is only accessible from
    within the same assembly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果你将其输入到编辑器中，由于private标注会出现错误。这非常整洁。在这种情况下，使用internal注解可能更为合适，这意味着成员仅能在同一程序集内访问。
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The available modifiers are public, internal, and private. The public modifier
    indicates that the annotated function or value can be accessed by all code, whereas
    private indicates that the function or value can only be accessed from the enclosing
    module.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的修饰符有public、internal和private。public修饰符表示标注的函数或变量可以被所有代码访问，而private表示该函数或变量只能从封闭模块中访问。
- en: Namespaces
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'A namespace is a hierarchical categorization of modules, classes, and other
    namespaces. First we take a look at how we declare namespaces. Namespaces have
    to be the first declaration in the code file. They are useful when you want to
    distinguish functionality without having to put long names in front of, for example,
    modules or classes. They also minimize naming collisions between your code and
    the existing code. Here is the code discussed previously added into a namespace:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是模块、类和其他命名空间的层次化分类。首先，我们来看一下如何声明命名空间。命名空间必须是代码文件中的第一个声明。当你希望区分功能而不必在模块或类前面加上冗长的名称时，命名空间非常有用。它们还可以最大限度地减少代码与现有代码之间的命名冲突。以下是之前讨论的代码，已被添加到一个命名空间中：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will tell the compiler that we are in the namespace called `Namespace1.Library1`.
    Namespaces also force programmers to use patterns known to F#, C#, and other .NET
    language programmers. Namespaces are open, which means many source files can contribute
    to the same namespace. It''s also possible to have multiple namespaces in the
    same file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉编译器我们处于名为`Namespace1.Library1`的命名空间中。命名空间还强制程序员使用F#、C#及其他.NET语言程序员熟悉的模式。命名空间是开放的，这意味着许多源文件可以贡献到同一个命名空间中。在同一文件中也可以有多个命名空间：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding example shows how to use namespaces and how to access modules
    within namespaces, which requires fully qualified names to be used. If you use
    the `open` keyword in F#, you don't need the fully qualified names and is equivalent
    to `using` in C#. Fully qualified names mean the full name, as used to access
    the function `Version` in the last `let` statement.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例展示了如何使用命名空间以及如何访问命名空间中的模块，这需要使用完整限定名。如果在 F# 中使用 `open` 关键字，则无需使用完整限定名，它相当于
    C# 中的 `using`。完整限定名指的是完整的名称，就像在最后的 `let` 语句中访问 `Version` 函数时所使用的名称。
- en: For namespaces, the private and public modifiers also exist and work in the
    same way as for modules, except that they work on the namespace level in the code.
    There also exists more granular control mechanisms for your code, such as `[<AutoOpen>]`,
    which will automatically open a module inside of a namespace. This is handy when
    `let` statements are needed to be defined inside namespaces to define values.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于命名空间，私有和公共修饰符也存在，并且与模块的工作方式相同，不同之处在于它们作用于代码中的命名空间级别。此外，还存在更细粒度的控制机制，例如 `[<AutoOpen>]`，它会自动打开命名空间中的模块。当需要在命名空间内定义
    `let` 语句以定义值时，这非常方便。
- en: Looking deeper inside data structures
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨数据结构
- en: In the previous chapter we introduced some data structures of F# and scratched
    the surface of their functionality. In this section we will take a deeper look
    at several data structures and expressions used in many programs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们介绍了 F# 中的一些数据结构，并简单了解了它们的功能。在本节中，我们将更深入地探讨许多在程序中常用的数据结构和表达式。
- en: 'The following is a list of what will be covered together with a short description
    to summarize their main characteristics:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将要介绍的内容，并附有简短的描述，总结它们的主要特征：
- en: '**Record types**: Record types are used to represent data and group pieces
    of data together by combining named values and types.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录类型**：记录类型用于表示数据，并通过组合命名值和类型将数据片段组合在一起。'
- en: '**Discriminated unions**: Discriminated unions are useful to represent heterogeneous
    data and support data that can be a set of named cases.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区分联合**：区分联合用于表示异构数据，并支持可以是多个命名情况的数据。'
- en: '**Enumerations**: Enumerations in F# are almost identical to enumerations in
    other languages and are used to map labels to constant values.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**枚举**：F# 中的枚举几乎与其他语言中的枚举相同，用于将标签映射到常量值。'
- en: '**Arrays**: Arrays are collections of a fixed size and must contain values
    of the same type. Large arrays of constant values can be compiled to efficient
    binary representations.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组**：数组是固定大小的集合，必须包含相同类型的值。大型常量数组可以编译为高效的二进制表示。'
- en: '**Lists**: Lists are ordered collections with elements of the same type, implemented
    as linked lists.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表**：列表是有序的集合，包含相同类型的元素，通常实现为链表。'
- en: '**Sequences**: In F#, sequences are lazy and are represented as a logical series
    of elements where the elements have to be of the same type. They are especially
    suited to represent a large ordered collection of data where all elements are
    not expected to be used.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列**：在 F# 中，序列是惰性求值的，表示为逻辑元素序列，其中所有元素必须具有相同的类型。它们特别适合表示一个大的有序数据集合，在该集合中，并非所有元素都会被使用。'
- en: '**Sets**: Sets are unordered containers for unique data elements. Sets do not
    preserve the order of elements as they are inserted, nor do they permit duplicates.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合**：集合是无序的容器，用于存储唯一的数据元素。集合不会保留插入时元素的顺序，也不允许重复元素。'
- en: '**Maps**: Maps are associative containers for key/value pairs.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射**：映射是用于存储键/值对的关联容器。'
- en: '**Options**: Options are an elegant way of enclosing a value that may or may
    not exist. It''s implemented using a discriminated union. Instead of checking
    for null values, options are preferred.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项**：选项是一种优雅的方式，用于封装可能存在或不存在的值。它是通过区分联合（discriminated union）来实现的。与检查空值不同，选项更为常用。'
- en: '**Strings**: Strings are sequences of characters and are the same as the .NET
    string.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串**：字符串是字符的序列，和 .NET 中的字符串相同。'
- en: Record types
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录类型
- en: Record types are used to represent data and group pieces of data together by
    combining named values and types.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类型用于表示数据，并通过组合命名值和类型将数据片段组合在一起。
- en: 'Suppose we are interested in modeling an **open-high-low-close** (**OHLC**)
    bar using record types, it may look something like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有兴趣使用记录类型来建模一个**开盘-最高-最低-收盘**（**OHLC**）柱状图，它可能如下所示：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we can use the previously defined record to declare a variable:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用先前定义的记录来声明一个变量：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s consider another example, where we model a quote with `bid`, `ask`,
    and `midpoint`. The `midpoint()` function will be calculated from the `bid` and
    `ask` values, that is, the average of both. This can be done using record types
    and a member function like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个示例，在这个示例中，我们用`bid`、`ask`和`midpoint`来建模一个报价。`midpoint()`函数将从`bid`和`ask`值计算出来，即两者的平均值。可以像这样使用记录类型和成员函数来实现：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, it looks a lot like the first example except for the member
    function `midpoint`. The member functions are able to access fields of the record
    type.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它与第一个示例非常相似，唯一不同的是成员函数`midpoint`。成员函数可以访问记录类型的字段。
- en: 'Suppose we are interested in modifying the fields after the initialization,
    it''s simply a matter of adding the keyword `mutable` to the particular field
    of interest:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有兴趣在初始化后修改字段，只需将`mutable`关键字添加到感兴趣的字段即可：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This example is a lot like the one discussed previously, but here we are able
    to change the value of the bid field to `150.0`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例与之前讨论的类似，但在这里我们可以将`bid`字段的值更改为`150.0`。
- en: 'Let''s look at how to use record types in pattern matching, because this is
    one of the biggest reasons for using record types:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在模式匹配中使用记录类型，因为这是使用记录类型的最大原因之一：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In short, record types are:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，记录类型是：
- en: Used to represent data
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于表示数据
- en: Useful in pattern matching
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模式匹配中很有用
- en: Used to group pieces of data together
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于将数据块组合在一起
- en: A lot like objects in object orientation
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很像面向对象中的对象
- en: Powerful and useful features of F#
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F#的强大且有用的特性
- en: A combination of named values of types
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型的命名值组合
- en: Different from classes because they are exposed as properties and without constructors
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与类不同，因为它们作为属性暴露，并且没有构造函数
- en: Discriminated unions
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 判别联合
- en: Discriminated unions are useful to represent heterogeneous data and support
    data that can be a set of named cases. Discriminated unions represent a finite,
    well-defined set of choices. Discriminated unions are often the tool of choice
    to build more complicated data structures including linked lists and a wide range
    of trees.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 判别联合用于表示异质数据，并支持可以是一组命名的情况的数据。判别联合表示一个有限且明确的选择集。判别联合通常是构建更复杂数据结构的首选工具，包括链表和各种树形结构。
- en: Let's investigate some properties of discriminated unions and how they may be
    used by looking at an example. Here we define a type, `OrderSide`, which can either
    be buy-side or sell-side.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看一个示例来研究判别联合的一些特性及其如何使用。在这里，我们定义一个类型`OrderSide`，它可以是买方或卖方。
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is handy and enables us to write elegant and clean code, doing what we
    want without any boilerplate coding at all. What about if we desired to have a
    function to be able to toggle the side of the order? In that case, buys becomes
    sells and vice versa.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常方便，使我们能够编写简洁优雅的代码，做到我们想要的而不需要任何样板代码。如果我们希望有一个函数能够切换订单的方向怎么办？在这种情况下，买方变成卖方，反之亦然。
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, there are two versions of the toggle function, `toggle1` and `toggle2`.
    The first version uses the match-with style, whereas the latter uses the shorthand
    version. The shorthand version is sometimes useful because it's shorter and easier
    to read.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，有两个版本的切换函数，`toggle1`和`toggle2`。第一个版本使用match-with风格，而后者使用简写版本。简写版本有时很有用，因为它更简洁、更易读。
- en: Let's extend our analysis of discriminated unions by introducing recursive fields.
    They are used to refer to the type itself and will enable you as a programmer
    to define more complex types. Here is an example where we define an option which
    can be either `Put` or `Call`, or a combination.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过引入递归字段来扩展对判别联合的分析。递归字段用于引用类型本身，并使你作为程序员能够定义更复杂的类型。这里是一个示例，我们定义一个可以是`Put`或`Call`，或两者组合的选项。
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Another example of a recursive discriminated union is tree structures. Tree
    structures are useful to represent hierarchical structures.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 递归判别联合的另一个示例是树形结构。树形结构用于表示层次化结构。
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Enumerations
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: Enumerations in F# are almost identical to enumerations in other languages,
    and are used to map labels to constant values. Enumerations are used to associate
    a label with a number or predefined values.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: F#中的枚举与其他语言中的枚举几乎相同，用于将标签映射到常量值。枚举用于将标签与数字或预定义值关联。
- en: 'Here we define a type, `RGB`, to map labels to values:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义一个类型`RGB`，将标签映射到值：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And we use the enumeration to bind a value to the first color, Red:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用枚举将一个值绑定到第一个颜色，红色：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To summarize enumerations:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 总结枚举：
- en: It looks like discriminated unions, but they accept that the values can be specified
    as constants
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它看起来像是判别联合类型，但它们允许值被指定为常量
- en: They are used to represent constants with labels
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们用于表示带有标签的常量
- en: They only hold one piece of data
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们只包含一个数据元素
- en: They are as safe as discriminated unions, because they can be created with unmapped
    values
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们和判别联合一样安全，因为它们可以使用未映射的值创建
- en: Arrays
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: Arrays are mutable collections of a fixed size and must contain values of the
    same type. Large arrays of constant types can be compiled to efficient binary
    representations.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是大小固定的可变集合，必须包含相同类型的值。大量相同类型的数组可以编译成高效的二进制表示。
- en: 'In F#, arrays are created in the following way:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，数组是通过以下方式创建的：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Because arrays are mutable, one can change a value in an array like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数组是可变的，所以可以像这样修改数组中的值：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'All elements in an array have to be of the same type. Otherwise, the compiler
    will complain. Suppose you create an array with one floating point number and
    two integers:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的所有元素必须是相同类型的，否则编译器会报错。假设你创建了一个包含一个浮点数和两个整数的数组：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The compiler will tell you that the types are inconsistent. Sometimes there
    is a need to initialize a data structure with values following a logical expression,
    called array comprehension in this case. For arrays, you can use the following
    expression to create one:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会告诉你类型不一致。有时需要使用逻辑表达式初始化数据结构，这在此称为数组推导。对于数组，可以使用以下表达式来创建一个：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Accessing elements is straightforward and follows the same pattern for every
    data structure. It looks a lot like in other programming languages except for
    the dot in front of the indexing bracket:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 访问元素非常直接，并且每种数据结构的访问模式都相同。它看起来与其他编程语言非常相似，只是索引括号前有一个点：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'One convenient feature is the slice notation, used to access a range of elements:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方便的特性是切片表示法，用于访问一系列元素：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And the same holds true for the reverse, selecting from the element with index
    2 to the end of the array:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的情况也适用于反向操作，选择从索引2到数组末尾的元素：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s look at two examples of initialization of arrays. It can be useful to
    initialize an array with zeroes. The array module has a function to do this. Have
    a look at the following code snippet:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看两个数组初始化的例子。初始化一个全是零的数组非常有用。数组模块提供了一个函数来做到这一点。请看以下代码片段：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To create a totally empty array, have a look at the following code snippet:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个完全空的数组，请参考以下代码片段：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There are many useful functions in an array module and we will just look at
    a few of them here. For example, appending two arrays can be done as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 数组模块中有很多有用的函数，下面我们只会看一些。例如，连接两个数组可以通过以下方式完成：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `filter` function is a recurrent candidate, which is useful in many ways.
    The following will show you how it is applicable on arrays:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`函数是一个常见的候选者，在很多场景中都非常有用。以下将展示它在数组上的应用：'
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Check out the MSDN page for more details and examples on how to use the F# array
    at [http://msdn.microsoft.com/en-us/library/dd233214.aspx](http://msdn.microsoft.com/en-us/library/dd233214.aspx).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 详情和示例请参考MSDN页面，了解如何在F#中使用数组：[http://msdn.microsoft.com/en-us/library/dd233214.aspx](http://msdn.microsoft.com/en-us/library/dd233214.aspx)。
- en: Interesting functions in an array module
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组模块中的有趣函数
- en: 'In the following table, the most useful functions in an array module are presented.
    This table can be used as a short reference too:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的表格中，列出了数组模块中最有用的函数。这个表格也可以作为简短的参考：
- en: '| Function | Description |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Array.length a | Returns the length of array a |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| Array.length a | 返回数组a的长度 |'
- en: '| Array.average a | Calculates the average of array a elements. It has to be
    of float or double data type |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| Array.average a | 计算数组a元素的平均值。它必须是float或double数据类型 |'
- en: '| Array.min a | Finds the minimum value of elements in array a |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| Array.min a | 查找数组a中元素的最小值 |'
- en: '| Array.max a | Finds the maximum value of elements in array a |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| Array.max a | 查找数组a中元素的最大值 |'
- en: '| Array.filter f a | Filters out the elements in array a matching the predicate
    in function f |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| Array.filter f a | 过滤数组a中符合函数f谓词的元素 |'
- en: '| Array.find f a | Returns the first element in list a to match the predicate
    in function f |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| Array.find f a | 返回列表a中第一个匹配函数f谓词的元素 |'
- en: '| Array.empty | Returns an empty array |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| Array.empty | 返回一个空数组 |'
- en: '| Array.isEmpty a | Indicates whether the array a is empty |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| Array.isEmpty a | 指示数组a是否为空 |'
- en: '| Array.exists f a | Checks whether an element exists in array a which matches
    the predicate f |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| Array.exists f a | 检查数组 a 中是否存在与谓词 f 匹配的元素 |'
- en: '| Array.sort a | Sorts the elements in array a in increasing order, see sortBy
    to use predicate |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| Array.sort a | 按升序排列数组 a 中的元素，若要使用谓词排序，请参见 sortBy |'
- en: '| Array.zip a b | Sorts the elements in array a in increasing order, see sortBy
    to use predicate |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| Array.zip a b | 按升序排列数组 a 中的元素，若要使用谓词排序，请参见 sortBy |'
- en: '| Array.map f a | Calls the function f for every element in the array a and
    forms a new array |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| Array.map f a | 对数组 a 中的每个元素调用函数 f，并生成一个新数组 |'
- en: Lists
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: In this section we will investigate lists in more detail and show how to use
    most of the module functions. Lists in F# are implemented as linked lists and
    are immutable. They work on lists, and may also be used to convert between lists
    and other collections.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将更详细地探讨列表，并展示如何使用模块中的大多数函数。F# 中的列表实现为链表，并且是不可变的。它们适用于列表，并且也可以用于在列表与其他集合之间进行转换。
- en: Lists are ordered collections with elements of the same type; you cannot mix
    different types in the same list. First we look at how to create and initialize
    a list and then we investigate the module functions one by one. At the end of
    this section is a table summarizing all of them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是有序的集合，包含相同类型的元素；你不能在同一个列表中混合不同的类型。首先，我们来看如何创建和初始化一个列表，然后我们逐个探讨模块函数。本节最后有一个表格，总结了所有的函数。
- en: 'Let''s make use of F# Interactive:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 F# Interactive：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here we use a range to initialize a list. Expressions for lists are useful when
    you want a certain pattern or sequence described by a function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用一个范围来初始化一个列表。当你想要一个特定模式或由函数描述的序列时，列表表达式非常有用。
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We''ll now investigate two useful operators in lists. We do that using the
    two previously defined lists: `list1` and `list2`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨列表中的两个有用运算符。我们将使用之前定义的两个列表：`list1` 和 `list2`。
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The previously used operator (`::`) is called the concatenation operator or
    cons operator. Concatenation is an efficient O(1) operator, which prepends elements
    to the start of a list. This builds a new list from an element and a list. It''s
    possible to append two lists using an operator:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之前使用的运算符 (`::`) 称为连接运算符或 cons 运算符。连接是一个高效的 O(1) 运算符，它将元素添加到列表的开头。它通过一个元素和一个列表构建一个新的列表。使用运算符也可以连接两个列表：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The concat operator (`@`) has a performance penalty because lists are immutable
    and the first list has to be copied, and should be avoided when performance is
    concerned. This will find the *n*th value of the list:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 连接运算符 (`@`) 会有性能损耗，因为列表是不可变的，必须复制第一个列表，因此在性能要求较高的场合应避免使用。这个方法将找到列表的 *n* 项值：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To calculate the average value of a list, use the function `List.average`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算一个列表的平均值，可以使用 `List.average` 函数：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We have to use floats here, otherwise the compiler will complain:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在这里使用浮动数，否则编译器会报错：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Minimum and maximum values of a list are found by `List.min` and `List.max`,
    respectively:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的最小值和最大值分别由 `List.min` 和 `List.max` 找到：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There is a function, `List.append`, in the list module, equivalent to the operator
    `@`, which appends two lists together:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表模块中有一个函数 `List.append`，等同于运算符 `@`，它将两个列表连接起来：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s investigate three functions now: `filter`, `find`, and `exists`. They
    take a predicate function `f` and a list. The predicate function describes a condition:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们研究三个函数：`filter`、`find` 和 `exists`。它们接受一个谓词函数 `f` 和一个列表。谓词函数描述了一个条件：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `zip` function will create a new list using a pair-wise combination of
    the elements found in lists provided as arguments:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip` 函数将使用提供作为参数的列表中的元素成对组合，创建一个新列表：'
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Suppose we want to summarize elements of a list. The function `List.fold` comes
    in handy:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要总结一个列表的元素。`List.fold` 函数非常有用：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is equal to `55`, as expected. We can also find the geometrical sum using
    `List.fold`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 `55`，符合预期。我们还可以使用 `List.fold` 计算几何和：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that we use `1` as the initial value to fold, because it is a multiplication
    operation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 `1` 作为折叠的初始值，因为这是一个乘法操作。
- en: Pattern matching and lists
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式匹配与列表
- en: Let's look at pattern matching and lists, which is a common way to work with
    lists. Pattern matching provides for a powerful way to create recursive functions
    on lists. If we want to write a recursive function to get the length of a list,
    we can use pattern matching.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下模式匹配与列表，这是一种常见的处理列表的方法。模式匹配为在列表上创建递归函数提供了强大的方式。如果我们想编写一个递归函数来计算列表的长度，可以使用模式匹配。
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see in the preceding short example, pattern matching will make the
    code easy to read. The first match is for an empty list and the second uses the
    cons operator to match a list with a head and a tail. The tail is then used in
    the recursive function `all`, where the length `l` is increased by one for each
    iteration. Let's look at one more example. If we want to get the second last element
    of a list, we can use pattern matching.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的简短示例所示，模式匹配使得代码易于阅读。第一个匹配是空列表，第二个使用`cons`运算符来匹配一个包含头部和尾部的列表。然后，尾部被用于递归函数`all`，在每次迭代中，长度`l`增加1。我们再看一个例子。如果我们想获取列表中的倒数第二个元素，可以使用模式匹配。
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the previous example, we can see how pattern matching can be used to express
    ideas in a clear manner. Because a list is constructed using the cons operator
    (`::`), we can match arbitrary patterns on lists using it. The first pattern will
    match `head :: tail :: []`, where `head` is the second last element in the list.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的示例中，我们可以看到如何使用模式匹配清晰地表达思想。由于列表是使用`::`运算符构造的，我们可以使用它来匹配任意模式。第一个模式将匹配`head
    :: tail :: []`，其中`head`是列表中的倒数第二个元素。'
- en: Interesting functions in a list module
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表模块中的有趣函数
- en: 'In the following table, the most usable functions in the list module are presented.
    This table can be used as a short reference too:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下表中，列出了列表模块中最常用的函数。这个表也可以作为一个简短的参考：
- en: '| Function | Description |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `List.nth a` | Returns the nth element of the list `a` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `List.nth a` | 返回列表`a`中的第n个元素 |'
- en: '| `List.average a` | Calculates the average of the list `a`; elements have
    to be of float or double data type |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `List.average a` | 计算列表`a`的平均值；元素必须是浮动或双精度数据类型 |'
- en: '| `List.max a` | Finds the maximum value of elements in list `a` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `List.max a` | 找出列表`a`中元素的最大值 |'
- en: '| `List.min a` | Finds the minimum value of elements in list `a` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `List.min a` | 找出列表`a`中元素的最小值 |'
- en: '| `List.append a b` | Appends the two lists `a` and `b` |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `List.append a b` | 将两个列表`a`和`b`连接起来 |'
- en: '| `List.filter f a` | Filters out the elements in list `a`, matching the predicate
    in function `f` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `List.filter f a` | 从列表`a`中过滤出符合函数`f`谓词的元素 |'
- en: '| `List.empty` | Returns an empty list |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `List.empty` | 返回一个空列表 |'
- en: '| `List.length a` | Returns the length of list `a` |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `List.length a` | 返回列表`a`的长度 |'
- en: '| `List.find f a` | Returns the first element in list `a` to match the predicate
    in function `f` |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `List.find f a` | 返回列表`a`中第一个符合函数`f`谓词的元素 |'
- en: '| `List.sort a` | Sorts the elements in list `a` in increasing order, see `sortBy`
    to use predicate |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `List.sort a` | 按升序排序列表`a`中的元素，见`sortBy`用于使用谓词 |'
- en: '| `List.zip a b` | Combines list `a` and `b` element wise and forms a new list
    |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `List.zip a b` | 按元素合并列表`a`和`b`，并形成一个新列表 |'
- en: '| `List.exists f a` | Checks whether an element exists in list `a` that matches
    the predicate `f` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `List.exists f a` | 检查列表`a`中是否有符合谓词`f`的元素 |'
- en: '| `List.fold f s a` | Folds list `a` from left to right, using the function
    `f` with start value `s` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `List.fold f s a` | 从左到右折叠列表`a`，使用函数`f`和初始值`s` |'
- en: '| `List.head a` | Returns the head of list `a` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `List.head a` | 返回列表`a`的头部 |'
- en: '| `List.tail a` | Returns the tail of list `a` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `List.tail a` | 返回列表`a`的尾部 |'
- en: '| `List.map f a` | Calls the function `f` for every element in list `a` and
    forms a new list |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `List.map f a` | 对列表`a`中的每个元素调用函数`f`，并形成一个新列表 |'
- en: Sequences
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列
- en: Sequences are logical series' of elements where the elements have to be of the
    same type. They are especially suited to represent large ordered collections of
    data where not all elements are expected to be used. Sequences are lazily evaluated
    and are suitable for large collections of data since not all elements need to
    be held in memory. Sequence expressions represent sequences of data computed on
    demand. We will investigate sequences in the same fashion as in the previous sections,
    using F# Interactive to get a better feel for them, and we will also see how their
    module functions work.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 序列是由元素组成的逻辑系列，元素必须是相同类型的。它们特别适合表示大型有序数据集合，其中并非所有元素都需要使用。序列是惰性求值的，适用于大数据集合，因为并非所有元素都需要保存在内存中。序列表达式表示按需计算的数据序列。我们将像前几节一样探讨序列，使用F#
    Interactive来更好地理解它们，并且我们还将看到它们的模块函数是如何工作的。
- en: 'Let''s start by looking at how to initialize and create sequences in various
    ways using F# Interactive:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看如何使用F# Interactive以多种方式初始化和创建序列：
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: First we create a sequence defining the elements explicitly. Then, we use ranges.
    They work in the same way as for arrays and lists. The range expressions are also
    similar to other collections.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们显式定义元素来创建一个序列。然后，我们使用范围表达式。它们的工作方式与数组和列表相同。范围表达式也与其他集合类似。
- en: 'This will find the *n*th value of the sequence:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这将找到序列的第*n*个值：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Notice that the arguments are swapped in `Seq.nth` compared to, for example,
    the same function in the list module:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`Seq.nth`中，参数的顺序与列表模块中相同函数的顺序有所不同：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Minimum and maximum values of a sequence are found by `Seq.min` and `Seq.max`,
    respectively:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 序列的最小值和最大值分别通过`Seq.min`和`Seq.max`找到：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can also append two sequences using the `Seq.append` function:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`Seq.append`函数连接两个序列：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This will create an empty sequence:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个空序列：
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s investigate three functions now: `filter`, `find`, and `exists`. They
    take a predicate function, `f,` and a list. The predicate function describes a
    condition. They are identical to the list functions:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们研究三个函数：`filter`、`find`和`exists`。它们接受一个谓词函数`f`和一个列表。谓词函数描述一个条件。它们与列表函数是相同的：
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The first element of a sequence, the head, is obtained by calling `Seq.head`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 序列的第一个元素（头部）通过调用`Seq.head`获得：
- en: '[PRE53]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice that there is no `Seq.tail`, that's because of how sequences are represented
    (they are lazy constructs).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里没有`Seq.tail`，这是因为序列的表示方式（它们是惰性构造的）。
- en: Interesting functions in the sequence module
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列模块中的有趣函数
- en: 'In the following table, the most useful functions in the sequence module are
    presented. This table can be used as a short reference too:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下表中，展示了序列模块中最有用的函数。这个表格也可以作为简短参考：
- en: '| Function | Description |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Seq.nth a` | Returns the nth element of sequence a |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `Seq.nth a` | 返回序列a的第n个元素 |'
- en: '| `Seq.average a` | Calculates the average of sequence a. Elements have to
    be of float or double data type |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `Seq.average a` | 计算序列a的平均值。元素必须是浮动或双精度数据类型 |'
- en: '| `Seq.min a` | Finds the maximum value of elements in sequence a |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `Seq.min a` | 查找序列a中元素的最大值 |'
- en: '| `Seq.max a` | Finds the minimum value of elements in sequence a |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `Seq.max a` | 查找序列a中元素的最小值 |'
- en: '| `Seq.append a b` | Appends the two sequences a and b |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `Seq.append a b` | 连接序列a和b |'
- en: '| `Seq.filter f a` | Filters out the elements in sequence a, matching the predicate
    in function f |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `Seq.filter f a` | 筛选出序列a中符合谓词f的元素 |'
- en: '| `Seq.empty` | Returns an empty sequence |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `Seq.empty` | 返回一个空序列 |'
- en: '| `Seq.find f a` | Returns the first element in sequence a to match the predicate
    in function f |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `Seq.find f a` | 返回序列a中第一个满足谓词f的元素 |'
- en: '| `Seq.sort a` | Sorts the elements in sequence a in an increasing order. See
    sortBy to use predicate |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `Seq.sort a` | 按升序排序序列a中的元素。若要使用谓词，请参见sortBy |'
- en: '| `Seq.zip a b` | Combines list a and b element-wise and forms a new list |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `Seq.zip a b` | 按元素将列表a和b组合，形成一个新列表 |'
- en: '| `Seq.length a` | Returns the length of sequence a |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `Seq.length a` | 返回序列a的长度 |'
- en: '| `Seq.exists f a` | Checks whether an element exists in sequence a which matches
    the predicate f |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `Seq.exists f a` | 检查序列a中是否存在满足谓词f的元素 |'
- en: '| `Seq.fold f s a` | Folds sequence a from left to right, using the function
    f with start value s |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `Seq.fold f s a` | 使用函数f和起始值s从左到右折叠序列a |'
- en: '| `Seq.head` | Returns the head of sequence a |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `Seq.head` | 返回序列a的头部 |'
- en: '| `Seq.map f a` | Calls the function f for every element in sequence a and
    forms a new sequence |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `Seq.map f a` | 对序列a中的每个元素调用函数f，并形成一个新序列 |'
- en: Sets
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: Sets are unordered containers for data elements. Sets do not preserve the order
    of elements as they are inserted, nor do they permit duplicates.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是无序的数据元素容器。集合不保留元素插入顺序，也不允许重复元素。
- en: 'Let''s create a set with three integer elements:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含三个整数元素的集合：
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The preceding set will be of the following type:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 上述集合将具有以下类型：
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The type inference works here as expected. Now let''s consider adding and inspecting
    elements in `s1`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推导在这里按预期工作。现在让我们考虑添加和检查`s1`中的元素：
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Note that `s1` will not be modified due to its immutable characteristics. We
    can check whether `s1` contains 9:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`s1`由于其不可变特性不会被修改。我们可以检查`s1`是否包含9：
- en: '[PRE57]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Sometimes it''s helpful to create sequences from other data structures. In
    this case, from a sequence:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，从其他数据结构创建序列是有帮助的。在这种情况下，从一个序列创建：
- en: '[PRE58]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'It works the same way as creating it from an array:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式与从数组中创建相同：
- en: '[PRE59]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To get the length of a set, or in other words, to count the number of elements
    used, run the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取集合的长度，或者换句话说，计算集合中元素的数量，可以运行以下代码：
- en: '[PRE60]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `fold` function is also present in the module for sets and is used in the
    same way as for other collections:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold` 函数也出现在集合模块中，并且与其他集合一样使用：'
- en: '[PRE61]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This can also be written using the shorthand version `(+)` for addition and
    `(*)` for multiplication:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以使用加法的简写版本 `(+)` 和乘法的简写版本 `(*)` 来写：
- en: '[PRE62]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The same holds true for `Set.exists`. The function takes a predicate and a
    set and returns true if there is any element matching the function:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Set.exists` 也是如此。该函数接受一个谓词和一个集合，如果有任何元素与该函数匹配，则返回 `true`：
- en: '[PRE63]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`Filter` is a variant of `exists`, which returns a new set of elements matching
    the function:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`Filter` 是 `exists` 的变体，它返回一个新的集合，包含匹配该函数的元素：'
- en: '[PRE64]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'An interesting function is the `partition` function. It will split the set,
    in this case, into two new sets: a set of elements which passes the predicate
    and one that doesn''t:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的函数是 `partition` 函数。它会将集合拆分，在本例中拆分为两个新集合：一个包含通过谓词的元素，另一个则不包含：
- en: '[PRE65]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Think for a moment about how to write this `partition` function in an ordinary
    imperative language. Not as elegant if you ask me. Last but not least, we cover
    the `map` function. This function should be familiar to you at this stage. We
    use the old value of `s1` and simply add 2 to every element:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想，如果你在一个普通的命令式语言中写这个 `partition` 函数会怎么样。如果你问我，写法没有那么优雅。最后但同样重要的是，我们讲解 `map`
    函数。这个函数此时应该对你来说很熟悉。我们使用 `s1` 的旧值，并简单地给每个元素加上 2：
- en: '[PRE66]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Some of the interesting functions in the `Set` module are as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set` 模块中一些有趣的函数如下：'
- en: '| Function | Description |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Set.count a` | Returns the number of elements in set `a` |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `Set.count a` | 返回集合 `a` 中的元素数量 |'
- en: '| `Set.empty` | Returns an empty set |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `Set.empty` | 返回一个空集合 |'
- en: '| `Set.fold f s a` | Folds set `a` from left to right, using the function `f`
    with start value `s` |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `Set.fold f s a` | 从左到右折叠集合 `a`，使用函数 `f` 和初始值 `s` |'
- en: '| `Set.exists f a` | Checks whether an element exists in set `a` which matches
    the predicate `f` |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `Set.exists f a` | 检查集合 `a` 中是否存在符合谓词 `f` 的元素 |'
- en: '| `Set.filter` `f a` | Filters out the elements in sequence `a` matching the
    predicate in function `f` |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `Set.filter` `f a` | 过滤序列 `a` 中与谓词函数 `f` 匹配的元素 |'
- en: '| `Set.partition f a` | Creates a partition, two new sets, from set `a` using
    the predicate function `f` |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `Set.partition f a` | 使用谓词函数 `f` 从集合 `a` 创建两个新的子集 |'
- en: '| `Set.map` | Calls the function `f` for every element in set `a` and forms
    a new set |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `Set.map` | 对集合 `a` 中的每个元素调用函数 `f`，并形成一个新的集合 |'
- en: Maps
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射
- en: Maps are a special kind of set with associative key/value pairs. They are immutable,
    unordered data structures. They do not preserve the order of elements as they
    are inserted, nor do they permit duplicates.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是一种特殊的集合，它包含关联的键/值对。它们是不可变的、无序的数据结构。它们不会保留插入元素的顺序，也不允许重复元素。
- en: 'Maps are created in much the same way as sets, except we need a key as well:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 映射的创建方式与集合非常相似，唯一不同的是我们还需要一个键：
- en: '[PRE67]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, we can access the value using the key, `Age`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用键 `Age` 来访问值：
- en: '[PRE68]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'It''s possible to create maps from lists of values:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过值的列表创建映射：
- en: '[PRE69]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Because maps are a little different from the collections we covered so far,
    we will look at some of the more interesting functions in the `map` module.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 由于映射与我们之前讨论的集合有所不同，我们将进一步了解 `map` 模块中一些更有趣的函数。
- en: 'To filter a map using a predicate, you may notice the small variation here
    compared to other collections. To ignore either the key or the value, one can
    replace it with an underscore (`_`), in the same way as in pattern matching:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用谓词过滤一个映射，你可能会注意到与其他集合相比，这里有一些小的变化。要忽略键或值，可以像模式匹配一样用下划线（`_`）替代它：
- en: '[PRE70]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`Maps.exists` works almost in the same way as filters:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`Maps.exists` 的工作方式几乎与过滤器相同：'
- en: '[PRE71]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Partitioning a map using a predicate can be useful. Here we do that using a
    fixed value:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用谓词对映射进行分区是很有用的。这里我们通过一个固定值来实现：
- en: '[PRE72]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Another useful module function for maps is `Map.containsKey`. This function
    checks whether the map contains a specific key or not:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的映射模块函数是 `Map.containsKey`。这个函数检查映射中是否包含特定的键：
- en: '[PRE73]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Interesting functions in the map module
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射模块中的有趣函数
- en: 'In the following table, the most useful functions in the `map` module are presented.
    This table can be used as a short reference too:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在下表中，列出了 `map` 模块中最有用的函数。此表也可以作为一个简短的参考：
- en: '| Function | Description |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Map.add(k,v)` | Will create a new map with contents from the map together
    with the new entry `k,` `v` |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `Map.add(k,v)` | 创建一个新映射，包含原映射的内容及新条目`k, v` |'
- en: '| `Map.empty` | Creates an empty map |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `Map.empty` | 创建一个空映射 |'
- en: '| `Map.filter f a` | Filters out elements in map `a` matching the predicate
    in function `f` |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `Map.filter f a` | 从映射`a`中过滤出符合函数`f`谓词的元素 |'
- en: '| `Map.exists f a` | Checks whether an element exists in set `a` which matches
    the predicate `f` |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `Map.exists f a` | 检查集合`a`中是否有元素符合谓词`f` |'
- en: '| `Map.partition f a` | Creates a partition, two new maps, from map `a` using
    the predicate function `f` |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `Map.partition f a` | 使用谓词函数`f`将映射`a`划分为两个新映射 |'
- en: '| `Map.containsKey k a` | Checks whether map `a` contains the key `k` |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `Map.containsKey k a` | 检查映射`a`中是否包含键`k` |'
- en: '| `Map.fold f s a` | Folds map `a` from left to right, using the function `f`
    with start value `s` |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `Map.fold f s a` | 从左到右折叠映射`a`，使用函数`f`和起始值`s` |'
- en: '| `Map.find f a` | Returns the first element in map `a` to match the predicate
    in function `f` |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `Map.find f a` | 返回映射`a`中第一个符合函数`f`谓词的元素 |'
- en: Options
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选项
- en: Options are an elegant way of enclosing a value that may or may not exist. They
    are implemented using a discriminated union. Instead of checking for null values,
    options are preferred.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 选项是一种优雅的方式，用于封装一个可能存在也可能不存在的值。它们通过判别联合来实现。与其检查`null`值，不如使用选项。
- en: 'Here is an example where we use an integer option and pattern matching to investigate
    them further:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，演示了我们如何使用整数选项和模式匹配进一步探讨它们：
- en: '[PRE74]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We can use F# Interactive to investigate the types of options:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用F# Interactive来研究选项的类型：
- en: '[PRE75]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The first option, `some`, contains an integer value as expected. And the other,
    `none`, is empty. This way, we don't need to use null values and check for them
    using conditions. We simply pass around option values instead. Along with options,
    `Nullable` is also available in F#, which explicitly represents the absence of
    a value.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项`some`包含一个整数值，符合预期。另一个选项`none`为空。这样，我们就不需要使用`null`值并通过条件检查它们。我们只需要传递选项值即可。F#中还提供了`Nullable`，明确表示值的缺失。
- en: Strings
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Strings should be familiar to you already, and they work in the same way in
    F#. To use a more formal description of strings, we can say that strings are sequences
    of characters and are compatible with the .NET string:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串应该已经对你很熟悉，并且它们在F#中的工作方式与其他语言相同。更正式地说，字符串是字符的序列，并且与.NET中的字符串兼容：
- en: '[PRE76]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Interesting functions in the string module
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串模块中的有趣函数
- en: In the following table, the most useful functions in the string module are presented.
    This table can be used as a short reference too.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在下表中，展示了字符串模块中最有用的函数。这张表也可以作为简短的参考。
- en: '| Function | Description |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `String.length s` | Returns the length of the string `s` |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `String.length s` | 返回字符串`s`的长度 |'
- en: '| `String.Empty` | Creates an empty string |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `String.Empty` | 创建一个空字符串 |'
- en: '| `String.map f s` | Maps function `f` to every character in the string `s`
    |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `String.map f s` | 将函数`f`应用到字符串`s`中的每个字符上 |'
- en: '| `String.IsNullOrEmpty` | Indicates whether the string `s` is null or empty
    |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `String.IsNullOrEmpty` | 判断字符串`s`是否为空或为`null` |'
- en: '| `String.IsNullOrWhiteSpace` | Indicates whether the string `s` is null or
    consists only of white space characters |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `String.IsNullOrWhiteSpace` | 判断字符串`s`是否为空或仅由空白字符组成 |'
- en: '| `String.Copy s` | Creates a new string with the same character sequence as
    the string `s` |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `String.Copy s` | 创建一个新的字符串，其字符序列与字符串`s`相同 |'
- en: '| `String.Concat s1 s2` | Concatenates the two strings `s1` and `s2` into a
    new string |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `String.Concat s1 s2` | 将两个字符串`s1`和`s2`连接成一个新的字符串 |'
- en: '| `String.exists f s` | Checks whether any character in `s` matches the predicate
    function `f` |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| `String.exists f s` | 检查字符串`s`中是否有字符符合谓词函数`f` |'
- en: '| `String.Compare s1 s1` | Compares the two strings `s1` and `s2`. If they
    match, `0` is returned, otherwise, `-1` or `1` is returned depending on the comparison.
    |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `String.Compare s1 s1` | 比较两个字符串`s1`和`s2`。如果它们相同，则返回`0`，否则根据比较结果返回`-1`或`1`。
    |'
- en: Choosing data structures
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择数据结构
- en: With this many data structures to choose from, it can be hard to know which
    one to choose during a specific problem. There are some rules to follow, and here
    is a short summary of the main characteristics of the individual data structures.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可选的数据结构很多，在特定问题中选择哪个可能很困难。这里有一些规则可供遵循，以下是各个数据结构的主要特征的简要总结。
- en: Arrays
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: Arrays are efficient if you have to know the size of the collection beforehand.
    That means the size is fixed, and if you want to change the size, you have to
    create a new array and copy the elements over. On the other hand, random access
    is very fast; it can be done in constant time.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要预先知道集合的大小，数组是高效的。这意味着数组的大小是固定的，如果你想更改大小，必须创建一个新数组并将元素复制过去。另一方面，随机访问非常快速；它可以在常数时间内完成。
- en: Lists
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: Lists are implemented using linked lists, which are items linked together using
    pointers. This means that traversing a linked list is not super-efficient, because
    a lot of pointers have to be followed. On the other hand, insertion is very fast
    at any position in the list. Also worth mentioning is that the lookup of the head
    element is a constant time operation.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 列表通过链表实现，链表是通过指针将项连接在一起的。这意味着遍历链表并不是特别高效，因为必须跟踪很多指针。另一方面，在链表的任何位置插入元素都非常快速。还值得一提的是，访问头部元素是一个常数时间操作。
- en: Sets
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: Sets are implemented as binary trees, where you can't have multiple values defined
    in the same set. Sets are useful when you don't care about the order and don't
    allow duplicates.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是通过二叉树实现的，其中同一个集合内不能定义多个相同的值。当你不关心顺序并且不允许重复时，集合非常有用。
- en: Maps
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射
- en: Maps are like sets, except that they are extended to use key-value pairs instead
    of raw values. Maps are very efficient to lookup a value if you know the key.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 映射类似于集合，只不过它们扩展为使用键值对而不是原始值。当你知道键时，映射在查找值时非常高效。
- en: More on functional programming
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多函数式编程内容
- en: Here we will continue and build on the foundation from the previous chapter
    on functional programming basics. We will examine some of the more advanced and
    at the same time useful constructs of the F# language.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将继续并在前一章的函数式编程基础上进行扩展。我们将考察一些 F# 语言中的更高级且同时非常实用的构造。
- en: Recursive functions
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归函数
- en: Recursion is a fundamental building block in functional programming. Many problems
    can be solved in a recursive fashion, and together with pattern matching, it makes
    up a powerful toolkit.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是函数式编程中的一个基本构建块。许多问题可以通过递归的方式解决，再加上模式匹配，它构成了一个强大的工具包。
- en: To define a recursive expression, you use the keyword `rec`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个递归表达式，使用关键字`rec`。
- en: 'Let''s start by looking at the famous Fibonacci sequence, which is defined
    as the sum of the two previous numbers in a recursive sequence. The first two
    values are set to `0` and `1`, respectively, as seed values:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从著名的斐波那契数列开始，斐波那契数列的定义是递归序列中前两个数的和。前两个值分别设置为`0`和`1`，作为种子值：
- en: '[PRE77]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Recursion is a powerful way of solving problems, and is often preferred in
    functional languages before loop constructs. Let''s look at three recursive functions
    to illustrate its flexibility and power:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一种强大的解决问题的方式，通常在函数式语言中优先于循环结构。让我们来看三个递归函数，展示它的灵活性和强大功能：
- en: '[PRE78]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This function will sum a list of elements recursively using the match construct
    on the list argument. The list is split for head and tail in the first match statement
    and then the function is called again with the tail part. If the list is empty,
    zero is returned. In the end, the sum of the list will be returned:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将递归地对一个元素列表求和，使用列表参数上的匹配构造。列表在第一个匹配语句中被拆分为头部和尾部，然后函数再次使用尾部部分进行调用。如果列表为空，将返回零。最终，列表的和将被返回：
- en: '[PRE79]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'To determine the length of a list, we slightly modify the `mysum` function
    to add one instead of the element for every element encountered. Of course there
    is a built-in function to do this, as we have seen before. The built-in function
    `map`, can be constructed using a recursion like this:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定列表的长度，我们稍微修改了`mysum`函数，在遇到每个元素时，添加一个 1，而不是该元素的值。当然，我们之前已经看到过有一个内置函数可以完成此操作。内置函数`map`可以使用类似于这样的递归来构建：
- en: '[PRE80]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Understanding this function will give you a better understanding about the built-in
    functions and functional programming in general. Many functions can be defined
    using recursion and pattern matching. We will learn more about pattern matching
    in the later part.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这个函数将帮助你更好地理解内置函数以及函数式编程的一般概念。许多函数可以通过递归和模式匹配来定义。我们将在后面的部分学习更多关于模式匹配的内容。
- en: Tail recursion
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾递归
- en: Tail recursion is a way of optimizing the recursion and easing the callback
    stack. Every time a call is made to the function, a new stack frame is allocated
    on the stack. This will eventually case `StackOverflowException`. In other words,
    tail recursion is used when you expect thousands of iterations.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归是一种优化递归并减轻回调堆栈负担的方法。每次调用函数时，都会在堆栈上分配一个新的堆栈帧。这最终会导致`StackOverflowException`。换句话说，当你预计会有数千次迭代时，就会使用尾递归。
- en: 'Tail recursion can be described as:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归可以描述为：
- en: An optimization technique
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种优化技术
- en: A way to ease the stack and ensure there are no stack overflows
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种减轻堆栈负担并确保没有堆栈溢出的方法
- en: Sometimes harder to understand and reason about
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时更难理解和推理
- en: 'To illustrate the concepts of tail recursion, we''ll convert a traditional
    recursively-defined function for the factorial. The factorial, *n!*, is a product
    of all positive numbers less than or equal to n. For example, 4! is defined as
    4 * 3 * 2 * 1, which is 24:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明尾递归的概念，我们将转换一个传统的递归定义的阶乘函数。阶乘，*n!*，是所有小于或等于n的正数的积。例如，4!定义为4 * 3 * 2 * 1，即24：
- en: '[PRE81]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can now verify if the function returns the correct value for 4! as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以验证该函数是否为4!返回正确的值，如下所示：
- en: '[PRE82]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Let''s try out a somewhat larger factorial. The parameter doesn''t have to
    be big to result in a large answer:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个稍微大的阶乘。参数不必很大，但可能会导致一个较大的结果：
- en: '[PRE83]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Pattern matching
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式匹配
- en: 'Pattern matching is used for control flow. It allows programmers to look at
    a value, test it against a series of conditions, and perform certain computations
    depending on whether that condition is met. It matches different patterns:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配用于控制流。它允许程序员查看一个值，将其与一系列条件进行测试，并根据条件是否满足执行某些计算。它匹配不同的模式：
- en: '[PRE84]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The preceding snippet defines a function that matches the argument provided
    to the function with different patterns. This illustrates the basic idea behind
    pattern matching. We can modify it further.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段定义了一个函数，该函数将提供给函数的参数与不同的模式进行匹配。这说明了模式匹配的基本思想。我们可以进一步修改它。
- en: Incomplete pattern matching
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不完全的模式匹配
- en: 'Let''s look at an example of incomplete pattern matching:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个不完全的模式匹配示例：
- en: '[PRE85]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The preceding code snippet is incomplete pattern matching, because we don''t
    consider values other than zero or one. The compiler will tell you this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段是一个不完全的模式匹配，因为我们没有考虑零或一以外的值。编译器会告诉你这一点：
- en: '[PRE86]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This is also true if we consider a simple string pattern matcher:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑一个简单的字符串模式匹配器，这一点也成立：
- en: '[PRE87]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This is fixed using a wildcard operator (`_`), like in the first example explained
    in the preceding snippet:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过通配符操作符（`_`）来修复，像前面片段中解释的第一个例子一样：
- en: '[PRE88]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Using guards
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用守卫
- en: 'In imperative programming, we use `if` statements with expressions to express
    conditions. This is accomplished using pattern matching and guards. Guards use
    the keyword `when` to specify the condition. Let''s look at an example where this
    is useful:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，我们使用带有表达式的`if`语句来表达条件。这是通过模式匹配和守卫来实现的。守卫使用关键字`when`来指定条件。让我们看一个例子，看看在哪里可以用到它：
- en: '[PRE89]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The name *guard* tells us something about their properties. They guard the pattern
    based on conditions.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '*guard*这个名字告诉我们它们的属性。它们基于条件来保护模式。'
- en: Pattern matching in assignment and input parameters
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式匹配在赋值和输入参数中的应用
- en: 'Pattern matching is also useful in assignments together with tuples, like this:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配在与元组一起的赋值中也很有用，像这样：
- en: '[PRE90]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'As you can see in the preceding example, the pattern matching mechanism will
    assign the values to each name. This is handy for multiple assignments:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的例子中看到的，模式匹配机制会将值分配给每个名称。这对于多个赋值很有用：
- en: '[PRE91]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'It''s also possible to use the wildcard to ignore a value in the assignment:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用通配符来忽略赋值中的一个值：
- en: '[PRE92]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Active patterns
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活跃模式
- en: Active patterns allow programmers to wrap ad hoc values and objects in union-like
    structures for use in pattern matching. First you define the partitioning of the
    input data using various expressions that act on the data. Each partition can
    have its own customized logic.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 活跃模式允许程序员将临时值和对象封装在类似联合体的结构中，以便在模式匹配中使用。首先，你通过作用于数据的各种表达式定义输入数据的分区。每个分区可以有自己的自定义逻辑。
- en: Suppose we want to verify whether an order is valid or not. Let's use the `Order`
    class, which will be introduced in a later section. The order can be valid and
    either a market or limit order, or simply invalid. Take a look at the `order`
    class further in the chapter if you are curious about how it is implemented or
    its properties.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想验证一个订单是否有效。我们可以使用将在后续章节介绍的`Order`类。订单可以是有效的，可以是市场订单或限价订单，或者仅仅是无效的。如果你对它的实现或属性感兴趣，可以在本章进一步查看`order`类。
- en: 'We start by introducing an active pattern with a very simple one, namely one
    that figures out if a number is positive or negative:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先引入一个非常简单的主动模式，即判断一个数字是正数还是负数：
- en: '[PRE93]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We can use F# Interactive to explore the `TestNumber` function using different
    floating point numbers:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 F# Interactive 来探索`TestNumber`函数，尝试不同的浮点数：
- en: '[PRE94]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Next, we look at the active pattern to verify an order:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下验证订单的主动模式：
- en: '[PRE95]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Let''s call `TestOrder` with some different order values:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用不同的订单值来调用`TestOrder`：
- en: '[PRE96]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The code works, and you now know more about active patterns and how they can
    be used to make life simpler.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 代码已经可以正常工作，你现在了解了更多关于主动模式及其如何简化生活的内容。
- en: 'Partial active patterns are used when parts of the input match, which is helpful
    in the case where strings need to be parsed to numbers. Let''s look at an example
    where single partial active patterns are used to make this clearer:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入的部分匹配时，会使用部分主动模式，这在需要将字符串解析为数字的情况下非常有用。让我们来看一个例子，单个部分主动模式的使用将使其更加清晰：
- en: '[PRE97]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The partial active pattern is used automatically in the matching inside the
    `testParse` function.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在`testParse`函数中的匹配操作里，部分主动模式会自动使用。
- en: Introducing generics
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入泛型
- en: In this section, we are going to look briefly at generics and how to define
    generic functions. The F# compiler is capable of finding out whether a function
    can be generic or not. This function together with type inference is a very powerful
    combination that allows for clean and easy-to-read code. Although, sometimes you
    want to specify your own functions as generic. If they are generic, they will
    be able to handle various types. Doing so will reduce the need of writing several
    functions with the same logic for every type involved.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要地介绍泛型以及如何定义泛型函数。F# 编译器能够判断一个函数是否可以是泛型的。这个函数与类型推断的结合是一个非常强大的组合，可以实现简洁且易于阅读的代码。不过，有时你可能想要明确指定自己的函数为泛型。如果它们是泛型的，它们将能够处理不同的类型。这样做可以减少为每个相关类型编写多个具有相同逻辑的函数的需要。
- en: 'Just to illustrate the concept described previously, we can take a look at
    a function that will create a list based on three parameters. This function is
    generic, so the type can be specified when used:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明前面描述的概念，我们可以看一个基于三个参数创建列表的函数。这个函数是泛型的，因此可以在使用时指定类型：
- en: '[PRE98]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Let''s use it in F# Interactive:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 F# Interactive 中使用它：
- en: '[PRE99]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: First we use integers to create a list and the function creates a list for us.
    Secondly, the function is used with floats. And last but not least, we use ordinary
    strings. The function works in the same way here in all cases indifferent of the
    types.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用整数来创建一个列表，函数会为我们创建一个列表。其次，函数用于浮点数。最后但同样重要的是，我们使用普通的字符串。在所有情况下，无论类型如何，函数都以相同的方式工作。
- en: Lazy evaluation
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 惰性求值
- en: Lazy evaluations or lazy computations are, as the name suggests, lazy. This
    means that they are not bothered until the last moment, which is when the value
    is needed. This type of evaluation can help improve the performance of the code.
    For example, sequences use lazy evaluation. Lazy evaluation also allows expensive
    computations to be defined without them being evaluated before they are needed.
    Lazy expressions are generic, and the type is determined when the expression is
    evaluated.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性求值或惰性计算顾名思义是懒惰的。这意味着它们在最后时刻才会被处理，也就是在需要值的时候。这种求值方式有助于提升代码的性能。例如，序列使用了惰性求值。惰性求值还允许定义昂贵的计算，而这些计算在实际需要之前不会被求值。惰性表达式是泛型的，类型会在表达式求值时确定。
- en: 'Let''s take a look at how you can define your own lazy constructs:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何定义你自己的惰性构造：
- en: '[PRE100]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We can now evaluate this function using F# Interactive:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 F# Interactive 来评估这个函数：
- en: '[PRE101]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'When you execute the function definition, the compiler will tell you that the
    value is not created; it''s lazy in the following way:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行函数定义时，编译器会告诉你值尚未创建；它是惰性求值的，具体表现如下：
- en: '[PRE102]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Units of measure
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量单位
- en: Units of measure are a way to associate signed integers and floating point numbers
    with units. The units can describe weight, length, volume, and currencies. One
    useful application of units of measure is currency and currency conversion. Units
    of measure are used to verify the types involved to ensure they are used correctly.
    All information about them is removed by the compiler after verification and is
    not part of the resulting executable program.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 测量单位是一种将有符号整数和浮动点数与单位关联的方法。单位可以描述重量、长度、体积和货币。测量单位的一个有用应用是货币和货币转换。测量单位用于验证涉及的类型，确保它们被正确使用。编译器在验证后会移除所有关于单位的信息，这些信息不会成为生成的可执行程序的一部分。
- en: 'First we take a look at the normal way of implementing currency conversion
    in F#. There is no guarantee that the actual rate is correct, or that the calculation
    uses the correct units:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们来看F#中实现货币转换的常见方式。不能保证实际的汇率是正确的，或者计算使用了正确的单位：
- en: '[PRE103]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: There is no robust way to verify the correctness of the conversion made in the
    preceding snippet with respect to the units. Every value is just treated as floating
    point numbers. It can be of great importance to be able to verify the units involved.
    The Mars Climate Orbiter was lost at the end of September 1999 as a result of
    units. The software on the ground was producing pound-seconds instead of newton-seconds,
    which led the spacecraft to vaporize in the atmosphere of Mars.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，没有一种可靠的方法来验证单位转换的正确性。每个值都只是被当作浮动点数来处理。验证所涉及的单位是否正确可能非常重要。1999年9月底，火星气候探测器因为单位问题丧失。地面软件生成了磅秒（pound-seconds），而不是牛顿秒（newton-seconds），这导致航天器在火星大气层中蒸发。
- en: 'The same holds for currencies, where it''s of great importance to be able to
    verify the correctness of the units used. Let''s convert the preceding code to
    use the units of the `measure` construct:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，对于货币来说，能够验证所使用单位的正确性非常重要。让我们将前面的代码修改为使用`measure`构造体的单位：
- en: '[PRE104]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Here the compiler will verify that the units are correct using the type information
    provided. Very handy indeed! What if we use the wrong units? We modify the code
    to include a measure for YEN:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，编译器将使用提供的类型信息验证单位是否正确。确实非常方便！如果我们使用了错误的单位怎么办？我们修改代码，加入一个日元（YEN）的测量单位：
- en: '[PRE105]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Running this in F# Interactive will result in an error with the following message:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在F# Interactive中运行此代码将导致一个错误，错误信息如下：
- en: '[PRE106]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The message is quite clear about what's wrong, and this is a great help for
    writing the correct code involving different units to be handled and converted
    in various ways.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 消息非常清晰地指出了哪里出错，这对于编写涉及不同单位的正确代码并处理和转换这些单位非常有帮助。
- en: Asynchronous and parallel programming
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步和并行编程
- en: 'Asynchronous and parallel programming will be introduced in this section, together
    with events, thread pools, background workers, and the MailboxProcessor (agents).
    All these constructs exist with one purpose in life: to make life easier for the
    programmer. Modern computers have CPUs capable of executing several threads in
    parallel, which opens doors to new possibilities. These possibilities require
    a good toolkit for concurrent and parallel programming. F# is a very good candidate,
    and one of its design principles is to be a good fit in these types of situations.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍异步和并行编程，以及事件、线程池、后台工作线程和邮箱处理器（代理）。所有这些构造体的存在都有一个共同的目的：让程序员的生活更轻松。现代计算机的CPU能够并行执行多个线程，这为新的可能性打开了大门。这些可能性需要一个优秀的并发和并行编程工具包。F#是一个非常好的候选语言，它的设计原则之一就是能够很好地适应这些类型的场景。
- en: Events
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: 'Events are useful when you want a certain function to execute upon a specific
    event that will occur sometime in the future. This is often applicable to GUI
    programming, where a user will interact in some way with the interface. The pattern
    is called event-driven programming, where events drive the execution of the program.
    The following example illustrates this in a simple manner:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 事件在你希望某个特定事件发生时执行某个函数时非常有用，这个事件可能会在未来某个时刻发生。这通常适用于GUI编程，在这种情况下，用户将以某种方式与界面进行交互。这个模式被称为事件驱动编程，其中事件推动程序的执行。下面的例子简单地说明了这一点：
- en: '[PRE107]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Here, a form is created, a regular .NET form. The parameters to the constructor
    sets the title, the visibility to `true`, and specifies it to be on top. Then,
    a `click` handler is installed, with a lambda function as the event handler. Upon
    execution, the function will simply print out a text message to the console.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这里创建了一个表单，一个常规的.NET表单。构造函数的参数设置了标题、可见性为`true`，并指定其始终显示在顶部。然后，安装了一个`click`事件处理器，使用一个lambda函数作为事件处理程序。执行时，该函数将简单地向控制台输出一条文本消息。
- en: 'In F#, you have the possibility to manipulate the event stream. This can be
    useful if there is a need to filter out certain events or do some manipulation.
    Events are first-class values in F#, which makes it possible to pass them around
    like other variables. Let''s take a look at how to filter out events. In the following
    example, the `click` events are filtered out depending on their coordinates:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，你可以操作事件流。如果需要过滤某些事件或进行某些操作，这非常有用。事件是F#中的一等公民，这使得它们可以像其他变量一样传递。我们来看看如何过滤事件。在下面的示例中，`click`事件根据其坐标进行过滤：
- en: '[PRE108]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Here, we modified the code to listen to the `MouseDown` event, which clicks
    in the form itself. The `MouseDown` events are then filtered depending on their
    coordinates, which are part of the event argument. If the event passes the filter,
    a function is called that prints the coordinates to the console. This filtering
    process can be very useful and makes it possible to create advanced filters and
    logic for events with code that's clean and easy to understand.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们修改了代码以监听`MouseDown`事件，该事件在表单本身中被点击。然后，`MouseDown`事件根据其坐标进行过滤，坐标是事件参数的一部分。如果事件通过过滤器，则调用一个函数，将坐标打印到控制台。这个过滤过程非常有用，可以创建复杂的事件过滤器和逻辑，代码简洁易懂。
- en: Background workers
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后台工作者
- en: 'Say you make a program where you need calculations to take part. Sometimes
    these calculations will run for quite a long time. Background workers are a solution
    when you want to execute long running tasks that run in the background. The code
    will be executed in a separate thread:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你编写了一个程序，其中需要进行计算。有时这些计算会运行很长时间。后台工作者是一个解决方案，当你希望执行长时间运行的任务并且这些任务在后台运行时。代码将在一个单独的线程中执行：
- en: '[PRE109]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Here is an illustrative example of how to use background workers in the simplest
    manner. The worker will execute a function that simulates a calculation process
    and finally will notify us on completion. You can schedule tasks to be executed
    sequentially just by using the function `Add`. Here are two jobs executed in order,
    and finally we are notified upon completion:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个说明性示例，展示了如何以最简单的方式使用后台工作者。工作者将执行一个模拟计算过程的函数，并在完成时通知我们。你可以通过使用`Add`函数安排任务按顺序执行。这里有两个任务按顺序执行，最后我们会在完成时收到通知：
- en: '[PRE110]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Sometimes it''s desirable to be able to cancel the execution in `Backgroundworker`.
    To be able to do this, we have to make some minor modifications to the preceding
    code. First we set a flag in the constructor, `WorkerSupportsCancellation = true,`
    and then we check a flag every time we iterate the calculation:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望能够取消`Backgroundworker`中的执行。为了实现这一点，我们需要对之前的代码做一些小的修改。首先，在构造函数中设置一个标志，`WorkerSupportsCancellation
    = true,`，然后在每次迭代计算时检查该标志：
- en: '[PRE111]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'If you run this code, you will see no cancellation. Just that the code is prepared
    to handle a cancellation. To do a cancellation on the preceding execution, you
    need to run the following line:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行此代码，你将看不到任何取消操作。只是代码已准备好处理取消。要取消先前的执行，你需要运行以下代码：
- en: '[PRE112]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Use F# Interactive and run the main code for some iterations and then run the
    `CancelAsync()` function. This will terminate the background worker.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 使用F#交互式运行主代码进行几次迭代，然后运行`CancelAsync()`函数。这将终止后台工作者。
- en: Threads
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程
- en: 'Threads are essential parts in any modern software. In F#, threads are essentially
    .NET threads with all of the .NET functionality. If you have previous knowledge
    from any other .NET language, the following code will be familiar to you:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是任何现代软件的核心部分。在F#中，线程本质上是.NET线程，具备所有.NET功能。如果你有其他.NET语言的相关知识，下面的代码对你来说应该非常熟悉：
- en: '[PRE113]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: We spawn a thread by passing a delegate to the `Thread` constructor. The thread
    will run the function `runMe`. The new part may be the way exceptions are handled.
    They are handled using pattern matching.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将一个委托传递给`Thread`构造函数来创建一个线程。该线程将运行`runMe`函数。新的部分可能是异常处理的方式。它们是通过模式匹配来处理的。
- en: It's possible to spawn many threads. And they will be executed concurrently.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建很多线程，它们将并发执行。
- en: '[PRE114]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Here, two threads are created and they run concurrently. Sometimes the output
    will be intervened; this is due to the fact that they have no synchronization.
    Spawning threads are quite costly, and will become noticeable if many threads
    are spawned and terminated. Every thread uses some memory, and if the threads
    are short lived, you better use a thread pool to enhance performance.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建了两个线程并且它们并发执行。有时输出会被干扰；这是因为它们没有同步机制。创建线程是相当昂贵的，如果创建和终止的线程很多，这个成本会变得明显。每个线程都占用一定的内存，如果线程的生命周期较短，最好使用线程池来提升性能。
- en: Thread pools
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程池
- en: 'As mentioned in the previous section, spawning threads is quite costly. This
    is because it often involves the operating system itself to handle the task. If
    the threads are short lived, thread pools come to the rescue. A thread pool creates
    and terminates threads depending on the load. When a thread has finished executing
    a task, they sit in a queue waiting for the next task. F# uses the .NET `ThreadPool`
    class. This example will also be familiar to you if you have used the equivalent
    class in C# or any other .NET language:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面所述，创建线程是相当昂贵的。这是因为它通常涉及操作系统本身来处理任务。如果线程的生命周期较短，线程池就能派上用场。线程池会根据负载来创建和终止线程。当线程完成任务时，它们会排队等待下一个任务。F#使用.NET的`ThreadPool`类。如果你曾使用过C#或其他.NET语言中的同类类，这个示例也应该很熟悉：
- en: '[PRE115]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: In the preceding code, we enqueue three tasks to be executed by the thread pool.
    They will all be executed without being enqueued. This is because the thread pool
    will spawn up to the `ThreadPool.GetMaxThreads()` threads, which are usually 1024
    threads. Over that amount, they will be queued.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将三个任务排入队列，由线程池执行。它们将被执行而无需再次排队。这是因为线程池最多会启动`ThreadPool.GetMaxThreads()`个线程，通常为1024个线程。超过这个数量时，它们将被排队。
- en: Asynchronous programming
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步编程
- en: Asynchronous code performs requests that are not completed immediately. That
    means they are doing operations that will be completed sometime in the future
    without blocking the current thread. Instead of waiting for that result to be
    available, multiple requests can be issued and the result will be handled as soon
    as it becomes available. This way of programming is called asynchronous programming.
    The program is not blocking just because of a result that is not yet available.
    Instead, as mentioned, the program will be notified when the result is ready.
    A common application is IO, where the CPU time can be used for something better
    than waiting for the IO operation to complete. There are often a lot of callbacks
    involved in asynchronous programming. Historically, asynchronous programming has
    been done in .NET using the **Asynchronous Programming Model** (**APM**).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 异步代码执行的请求不会立即完成。这意味着它们正在执行一些操作，这些操作将在未来某个时间完成，而不会阻塞当前线程。与其等待结果的可用性，不如发起多个请求，一旦结果可用就处理它。这样的编程方式被称为异步编程。程序不会因为结果尚未可用而被阻塞。相反，如前所述，程序会在结果准备好时收到通知。一个常见的应用场景是IO操作，在这种情况下，CPU时间可以用于做更有意义的事情，而不是等待IO操作完成。异步编程中通常会涉及很多回调。历史上，异步编程在.NET中是通过**异步编程模型**（**APM**）来实现的。
- en: Tip
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: MSDN has a detailed page about APM, that is, [http://msdn.microsoft.com/en-us/library/ms228963.aspx.](http://msdn.microsoft.com/en-us/library/ms228963.aspx.)
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: MSDN有关于APM的详细页面，[http://msdn.microsoft.com/en-us/library/ms228963.aspx.](http://msdn.microsoft.com/en-us/library/ms228963.aspx.)
- en: Without going into a lot of details about the APM and asynchronous callbacks,
    we will simply introduce the asynchronous workflows in F#. This enables us to
    write asynchronous code without the need for explicit callbacks.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在不详细讨论APM和异步回调的情况下，我们将简单介绍F#中的异步工作流。这使我们能够编写异步代码，而无需显式的回调。
- en: The F# asynchronous workflows
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F# 异步工作流
- en: 'To use asynchronous workflows, you simply wrap your code that you want to be
    asynchronous in the `async` block. It''s that simple, but the entire truth is
    not covered yet. There is one more thing. The code inside the `async` block has
    to be asynchronous in itself to make use of the asynchronous workflow:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用异步工作流，你只需将你想要异步执行的代码包裹在`async`块中。就是这么简单，但还没有涵盖全部真相。还有一件事，`async`块中的代码本身必须是异步的，才能利用异步工作流：
- en: '[PRE116]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Here the expression is wrapped inside the `async` block. The expression is set
    up to run asynchronously by `Async.Start`, which means, without blocking the current
    thread. This is especially desirable if the current thread is the GUI thread.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，表达式被包装在 `async` 块中。该表达式通过 `Async.Start` 设置为异步运行，这意味着它不会阻塞当前线程。如果当前线程是 GUI
    线程，这尤其是非常重要的。
- en: Asynchronous binding
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步绑定
- en: When you work with asynchronous code and expressions and want to bind them to
    values, you have to use a modified version of the original `let` keyword, `let!`.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理异步代码和表达式，并且需要将它们绑定到值时，必须使用 `let` 关键字的修改版 `let!`。
- en: This enables the execution to continue after the binding without blocking the
    current thread. It's a way of telling the binding that the value is asynchronous
    and will be used later, when the result is available.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得执行在绑定后可以继续进行，而不会阻塞当前线程。这是一种告知绑定值是异步的，并将在结果可用时稍后使用的方式。
- en: 'Consider the following code:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下代码：
- en: '[PRE117]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: If we don't use the `let!` (let bang) operator here, `myFunction2` will have
    to wait for the result of the asynchronous request. We simply do not need the
    result in response right away, and can better utilize the CPU by running `myFunction2`
    instead of nothing.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这里不使用 `let!`（let bang）操作符，`myFunction2` 就必须等待异步请求的结果。我们其实并不需要立即得到结果，而是可以通过运行
    `myFunction2` 来更好地利用 CPU，而不是做无效的等待。
- en: Examples of using an async workflow
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用异步工作流的示例
- en: 'This example illustrates some of the concepts of asynchronous programming using
    parallel constructs. Here we will download data from Yahoo! finance using an asynchronous
    function in the `WebClient` class, `AsyncDownloadString`. This function takes
    a URL and downloads the content. In this case, the content will be CSV, containing
    the daily OHLC prices from 2010-01-01 until 2013-06-06\. We start by just downloading
    the data in parallel and counting the number of bytes fetched for each stock symbol:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了使用并行构造的异步编程的一些概念。在这里，我们将使用 `WebClient` 类中的异步函数 `AsyncDownloadString`
    从 Yahoo! 财经下载数据。这个函数接受一个 URL 并下载内容。在这个例子中，内容将是 CSV 格式，包含从 2010-01-01 到 2013-06-06
    的每日 OHLC 价格。我们首先通过并行下载数据并统计每个股票符号获取的字节数：
- en: '[PRE118]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Now that we have seen how to download data in parallel and verified that it
    actually works, we will extend the example to do some useful operations on the
    data as well. The code is almost identical to the earlier one, except that we
    added a function, `getMaxPrice`, to parse the CSV and then iterate the sequence
    using pipes. We will then extract the maximum closing price for the entire period
    for each stock. All this is done in parallel, asynchronously:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何并行下载数据，并验证其确实有效，我们将扩展这个例子，对数据执行一些有用的操作。代码几乎与之前的一样，唯一不同的是我们增加了一个函数
    `getMaxPrice`，用于解析 CSV 并通过管道迭代序列。然后我们将提取每只股票在整个期间的最大收盘价。所有这些操作都将并行、异步进行：
- en: '[PRE119]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: We have now looked at two examples, or two versions of the same example. You
    can experiment and extend this example as much as you like to learn more about
    how to work with parallel and asynchronous constructs in F#.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看过两个例子，或者说是同一个例子的两个版本。你可以根据需要实验并扩展这个例子，以便更深入地了解如何在 F# 中使用并行和异步构造。
- en: Parallel programming using TPL
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 TPL 进行并行编程
- en: We have already covered parts of the asynchronous workflow in F# in the previous
    section. In this section, we'll focus on the .NET TPL (Task Parallel Library).
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们已经讲解了 F# 中异步工作流的部分内容。在本节中，我们将重点介绍 .NET 的 TPL（任务并行库）。
- en: Tip
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There are also parallel sequences that you can explore on your own if you are
    interested.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣，还可以探索并行序列。
- en: The TPL is more useful than an asynchronous workflow; if the threads involved
    are going to do CPU work often. In other words, if there is less IO work to be
    done, the TPL is the one to be chosen. The TPL is part of the .NET framework 4,
    and can be used from all the .NET languages.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: TPL 比异步工作流更有用，特别是当涉及的线程需要经常进行 CPU 密集型操作时。换句话说，如果 IO 工作较少，TPL 是更优的选择。TPL 是 .NET
    Framework 4 的一部分，可以从所有 .NET 语言中使用。
- en: The simplest way to program parallel programs is to replace for loops with `Parallel.For`
    and `Parallel.ForEach`, which is found in the `System.Threading` namespace. These
    two functions will enable loops to execute in parallel instead of in a sequence.
    Of course, it's not this simple in reality. For example, it's hard if the current
    iteration depends on another iteration, which is where you have a loop dependence.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 编写并行程序的最简单方法是用`Parallel.For`和`Parallel.ForEach`替换 for 循环，这两个函数位于`System.Threading`命名空间中。这两个函数将使循环并行执行，而不是按顺序执行。当然，现实中并非如此简单。例如，如果当前的迭代依赖于其他迭代，那么这就变得很难，这就是所谓的循环依赖。
- en: MailboxProcessor
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MailboxProcessor
- en: The MailboxProcessor is also called an agent. Agents are constructs to support
    concurrent applications without too many insights into the implementation details.
    They are also more suitable where no shared memory is used, for example, in distributed
    computer systems with many nodes.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: MailboxProcessor 也称为代理。代理是支持并发应用程序的构造，它们无需过多了解实现细节。它们更适用于不使用共享内存的场景，例如在具有多个节点的分布式计算机系统中。
- en: The agent became famous from the Erlang programming language where it is called
    an actor. The concepts of actors have been partially implemented in various libraries
    for other programming languages. One major library is `Akka` for Scala, which
    is now part of the official Scala distribution.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 该代理因 Erlang 编程语言而出名，在该语言中它被称为“actor”（演员）。演员的概念已部分实现于其他编程语言的各种库中。一个主要的库是针对 Scala
    的`Akka`，它现在是官方 Scala 发行版的一部分。
- en: 'We''ll introduce agents by looking at an example which keeps track of a maximum
    value. Every time a message is received, the agent recalculates the maximum value.
    It''s also possible to send a reset message. All communication with agents is
    handled using message passing. Messages are typically discriminated unions. This
    will be clear after we have walked through an example:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过查看一个跟踪最大值的示例来介绍代理。每当接收到一个消息时，代理会重新计算最大值。还可以发送重置消息。与代理的所有通信都是通过消息传递来处理的。消息通常是区分联合类型。通过一个示例演示后，这一点将会更加清晰：
- en: '[PRE120]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: In this example, we make use of modules to illustrate how to structure the program
    when it becomes bigger. First we redefine `MailboxProcessor` to be called `Agent`,
    for simplicity. The module helpers then contain a function to generate a random
    number.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用模块来演示当程序变得更大时，如何结构化程序。首先，我们将`MailboxProcessor`重新定义为`Agent`，以简化代码。然后，模块
    helpers 中包含一个生成随机数的函数。
- en: Finally, the module `MaxAgent` is defined with the `Agent` itself. The `Agent`
    reacts upon received messages using pattern matching. If the message is the reset
    message, the value is reset; otherwise, the agent updates the maximum value and
    waits for one second.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，模块`MaxAgent`定义了`Agent`本身。`Agent`通过模式匹配响应接收到的消息。如果消息是重置消息，则值会被重置；否则，代理会更新最大值并等待一秒钟。
- en: 'The last three lines will create the agent and send it a random value. You
    can execute the last two lines in repetition to send multiple random values and
    update the agent. This will produce an output close to the following:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三行代码将创建代理并向其发送一个随机值。你可以重复执行最后两行代码，以发送多个随机值并更新代理。这将产生接近以下的输出：
- en: '[PRE121]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Let''s send a reset message and see what happens. Do this by using F# Interactive
    as before:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们发送一个重置消息，看看会发生什么。像之前一样，通过使用 F# Interactive 来实现：
- en: '[PRE122]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Now send some updates with random values:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 现在发送一些带有随机值的更新：
- en: '[PRE123]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Agents are powerful constructs that act as state machines. You send messages
    to them and they change state depending on the logic they contain.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是强大的构造，充当状态机的角色。你向它们发送消息，它们根据内部逻辑改变状态。
- en: A brief look at imperative programming
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令式编程简要回顾
- en: In this section, we will look at imperative programming and object orientation.
    It's hard to do object orientation without involving imperative programming. In
    other words, mutable state. Mutable state and pure functional programming is not
    a good combination, in fact pure functional programming forbids mutable state
    totally. To our rescue, F# is not a pure functional programming language, so mutable
    state is allowed. With this knowledge, we can continue and learn about object
    orientation and how it's carried out in F#.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍命令式编程和面向对象编程。要进行面向对象编程，通常离不开命令式编程。换句话说，就是可变状态。可变状态与纯函数式编程并不是一个好组合，事实上，纯函数式编程完全禁止使用可变状态。幸运的是，F#
    并非纯函数式编程语言，因此可变状态是被允许的。有了这些知识，我们可以继续学习面向对象编程以及如何在 F# 中实现它。
- en: Object-oriented programming
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: F# is a multi-paradigm language where object orientation makes up parts of it.
    This makes the language interact seamlessly with the other .NET languages in the
    case of objects. Features that are well known because they are used in almost
    every modern programming language are imperative programming, object orientation,
    storing, and manipulating data. Combine imperative and functional programming;
    F# tried this and has in many ways succeeded. F# objects can have constructors,
    methods, properties (getters and setters), and fields.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: F# 是一种多范式语言，其中面向对象编程占有一部分。这使得该语言在处理对象时能够与其他 .NET 语言无缝互动。几乎所有现代编程语言中常见的特性，如命令式编程、面向对象编程、数据存储和操作，都能在
    F# 中找到。F# 尝试将命令式编程和函数式编程结合起来，并在许多方面取得了成功。F# 中的对象可以拥有构造函数、方法、属性（getter 和 setter）以及字段。
- en: Classes
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类
- en: Classes and objects are the foundation of **object-oriented programming** (**OOP**).
    They are used to model actions, processes, and any conceptual entities in applications.
    Apart from modules, classes are the most useful way in F# to represent and encapsulate
    data and related functionality.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 类和对象是**面向对象编程**（**OOP**）的基础。它们用于建模应用中的动作、过程和任何概念实体。除了模块，类是 F# 中表示和封装数据及相关功能的最有用的方式。
- en: 'Consider a class to represent orders in a trading system. The order will first
    have order-side, order-type, and a price. We''ll continue to extend the functionality
    of this class in this section to explore classes and object-orientation principles:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个类来表示交易系统中的订单。订单首先会有订单方向、订单类型和价格。在本节中，我们将继续扩展该类的功能，以探讨类和面向对象的原则：
- en: '[PRE124]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'We can use the newly-defined type, `order`, and investigate the member variables
    using F# Interactive:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用新定义的类型 `order`，并通过 F# Interactive 调查成员变量：
- en: '[PRE125]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Objects and members
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象和成员
- en: 'We''ll now extend the class `order` to have a function that will enable us
    to toggle the order-side. The order-side has to be mutable, and we need a member
    function that performs the actual work. The function to do this will be called
    `toggleOrderSide` and will use pattern matching for the discriminated union `OrderSide`:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将扩展 `order` 类，增加一个功能，允许我们切换订单方向。订单方向必须是可变的，我们需要一个成员函数来执行实际的工作。执行此操作的函数将被命名为
    `toggleOrderSide`，并使用模式匹配来处理判别联合 `OrderSide`：
- en: '[PRE126]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'As seen previously, we investigate the changes to our class using F# Interactive:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，我们使用 F# Interactive 来研究类的变化：
- en: '[PRE127]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: This may look like a lot of new stuff at once. But first we use the keyword
    mutable, to indicate that the value `S` is mutable. This is needed because we
    want to change its value on an already created object. The opposite is immutable,
    as we talked about in the previous chapter. Pattern matching takes care of the
    actual work, and the `←` operator is used to assign new values to mutable variables.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一次学习很多新东西。但首先我们使用关键字 `mutable` 来指示值 `S` 是可变的。这是因为我们想要修改已创建对象的值。与之相对的是不可变（immutable），正如我们在上一章中讨论过的。模式匹配负责实际操作，`←`
    操作符用于将新值赋给可变变量。
- en: Tip
  id: totrans-517
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Take a look at the MSDN article about values in F# at [http://msdn.microsoft.com/en-us/library/dd233185.aspx](http://msdn.microsoft.com/en-us/library/dd233185.aspx).
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看 MSDN 上关于 F# 中值的文章：[http://msdn.microsoft.com/en-us/library/dd233185.aspx](http://msdn.microsoft.com/en-us/library/dd233185.aspx)。
- en: Methods and properties
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法和属性
- en: Wouldn't it be nice to be able to access the price and order-type fields using
    a better name like T or P? It's always a good tradition to name your objects,
    types, and functions in a clear and concise way. This enables both you and other
    programmers to understand the intention behind the code better.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使用更好的名称（如 T 或 P）访问价格和订单类型字段是不是很好？给你的对象、类型和函数起个清晰简洁的名字始终是个好习惯。这样不仅你自己，而且其他程序员也能更好地理解代码背后的意图。
- en: '[PRE128]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'It''s now possible to access the member values using the properties side and
    type, respectively. Properties are just another name for getters and setters.
    Getters and setters retrieve and change values. You can define members to be read
    only by omitting the setters, as for the `type` property:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以分别通过属性 `side` 和 `type` 访问成员值了。属性只是 getter 和 setter 的另一种叫法。getter 和 setter
    用于获取和修改值。你可以通过省略 setter 来定义只读成员，如 `type` 属性所示：
- en: '[PRE129]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Overloaded operators
  id: totrans-524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重载操作符
- en: 'Overloaded operators can be useful if a specific functionality has to be exposed
    without calling a particular function:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个特定功能需要在不调用特定函数的情况下暴露，重载操作符可能会很有用：
- en: '[PRE130]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Look at the last line in this example; here we define an overloaded operator,
    a unary minus. This operator is defined to toggle the order-side of the order
    object.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个示例中的最后一行；在这里我们定义了一个重载的运算符，即一元减法。该运算符用于切换订单对象的订单方。
- en: 'We can use F# Interactive to investigate this and how it is used in the code
    outside of the order object definition:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 F# Interactive 来调查这个问题，以及它在订单对象定义之外如何在代码中使用：
- en: '[PRE131]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: As you can see, we first create the `order1` object and then we create `order2`
    to be defined as `-order1`. This will call the overloaded operator in the `order`
    class and toggle the order side. Compare the order sides in the last two outputs
    and see for yourself.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们首先创建了 `order1` 对象，然后创建了 `order2`，它被定义为 `-order1`。这将调用 `order` 类中的重载运算符并切换订单方。比较最后两次输出的订单方，自己看看结果。
- en: Using XML documentation
  id: totrans-531
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 XML 文档
- en: XML documentation is useful when you want to autogenerate documentation for
    your code. If you just put the documentation directly in a triple-slash comment,
    the entire content will be a summary. The other possibility is to use specific
    XML tags to specify which type of documentation the specific text belongs to.
    Doing that enables you, as a programmer, to document the code in a more versatile
    way.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: XML 文档在你需要为代码自动生成文档时非常有用。如果你直接将文档放在三斜杠注释中，整个内容将作为摘要。另一种可能性是使用特定的 XML 标签来指定某段文本属于哪种类型的文档。这样做能让你作为程序员以更灵活的方式记录代码。
- en: Useful XML tags
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的 XML 标签
- en: 'The following are some useful XML tags:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些有用的 XML 标签：
- en: '| Tag | Description |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| 标签 | 描述 |'
- en: '| --- | --- |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `summary` | Summary describes code that is commented on |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| `summary` | 摘要描述被注释的代码 |'
- en: '| `Returns` | Specifies what''s returned |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '| `Returns` | 指定返回的内容 |'
- en: '| `Remark` | A remark or something to notice about the code |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| `Remark` | 对代码的备注或需要注意的事项 |'
- en: '| `exception` | Specifies exceptions that may be thrown from the code |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| `exception` | 指定可能从代码中抛出的异常 |'
- en: '| `See also` | Enables you to link your documentation to other sections for
    more details |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '| `See also` | 允许你将文档链接到其他部分以获取更多详细信息 |'
- en: Typical XML documentation
  id: totrans-542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 典型的 XML 文档
- en: 'XML documentation is used by Visual Studio and it''s IntelliSense to provide
    information about the code. Let''s add some XML documentation to a function that
    we have used before and investigate how it affects IntelliSense:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: XML 文档由 Visual Studio 及其 IntelliSense 使用，用于提供有关代码的信息。让我们为之前使用过的一个函数添加一些 XML
    文档，并研究它如何影响 IntelliSense：
- en: '[PRE132]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The final result will look something like the following. Here you can see IntelliSense
    and how it includes the summary at the bottom in the tool tip box:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果将类似于以下内容。你可以看到 IntelliSense 以及它如何在工具提示框的底部包含摘要：
- en: '![Typical XML documentation](img/2_xml_documentation.jpg)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
  zh: '![典型的 XML 文档](img/2_xml_documentation.jpg)'
- en: Summary
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we looked into the F# language and its various features in more
    detail. The objective was to introduce in more detail relevant parts of the language
    to be used later throughout the book. F# is a big language and not all features
    are useful at once. There are many resources to explore on the Internet, and the
    F# 3.0 Specification is one of them. Some of the examples here were quite large
    and contain many of the features and aspects covered.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们更详细地探讨了 F# 语言及其各种特性。目标是更详细地介绍一些在本书中后续会使用到的语言相关部分。F# 是一门庞大的语言，并不是所有特性都需要一次性掌握。互联网上有很多资源可以探索，F#
    3.0 规范就是其中之一。这里的一些示例相当大，包含了许多已涵盖的特性和方面。
- en: You will be well prepared for the next chapter if you have digested the material
    provided here. Next up is financial mathematics and numerical analysis.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经消化了这里提供的材料，你将为下一章做好充分的准备。接下来将介绍金融数学和数值分析。
