["```py\n# Import Libraries\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\n%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom scipy.signal import find_peaks \n```", "```py\n#### Graph Regimes ####\ndef graph_regime_combo(ticker,df,_c,rg,lo,hi,slo,shi,clg,flr,rg_ch,                       ma_st,ma_mt,ma_lt,lt_lo,lt_hi,st_lo,st_hi):\n\n    '''\n    https://www.color-hex.com/color-names.html\n    ticker,df,_c: _c is closing price\n    rg: regime -1/0/1 using floor/ceiling method\n    lo,hi: small, noisy highs/lows\n    slo,shi: swing lows/highs\n    clg,flr: ceiling/floor\n    rg_ch: regime change base\n    ma_st,ma_mt,ma_lt: moving averages ST/MT/LT\n    lt_lo,lt_hi: range breakout High/Low LT \n    st_lo,st_hi: range breakout High/Low ST \n    '''\n    fig = plt.figure(figsize=(20,8))\n    ax1 = plt.subplot2grid((1,1), (0,0))\n    date = df.index\n    close = df[_c]\n    ax1.plot_date(df.index, close,'-', color='k',  label=ticker.upper()) \n    try:\n        if pd.notnull(rg):  \n            base = df[rg_ch]\n            regime = df[rg]\n\n#### removed for brevity: check GitHub repo for full code ####\n\n    for label in ax1.xaxis.get_ticklabels():\n        label.set_rotation(45)\n    ax1.grid(True)\n    ax1.xaxis.label.set_color('k')\n    ax1.yaxis.label.set_color('k')\n    plt.xlabel('Date')\n    plt.ylabel(str.upper(ticker) + ' Price')\n    plt.title(str.upper(ticker))\n    plt.legend()\n#### Graph Regimes Combo #### \n```", "```py\ndef regime_breakout(df,_h,_l,window):\n    hl =  np.where(df[_h] == df[_h].rolling(window).max(),1,\n                                np.where(df[_l] == df[_l].                                    rolling(window).min(), -1,np.nan))\n    roll_hl = pd.Series(index= df.index, data= hl).fillna(method= 'ffill')\n    return roll_hl\n\nticker = '9984.T' # Softbank ticker\nstart= '2016-12-31'\nend = None\ndf = yf.download(tickers= ticker,start= start, end = end,                 interval = \"1d\",group_by = 'column',                 auto_adjust = True, prepost = True, \n                 treads = True, proxy = None)\n\nwindow = 252\ndf['hi_'+str(window)] = df['High'].rolling(window).max()\ndf['lo_'+str(window)] = df['Low'].rolling(window).min()\ndf['bo_'+ str(window)]= regime_breakout(df= df,_h= 'High',_l= 'Low',window= window)\ndf[['Close','hi_'+str(window),'lo_'+str(window),    'bo_'+ str(window)]].plot(secondary_y= ['bo_'+ str(window)], \n        figsize=(20,5), style=['k','g:','r:','b-.'],        title = str.upper(ticker)+' '+str(window)+' days high/low') \n```", "```py\n# CHAPTER 5 Turtle for dummies\n\ndef turtle_trader(df, _h, _l, slow, fast):\n    '''\n    \"    _slow: Long/Short direction\\n\",\n    \"    _fast: trailing stop loss\\n\",\n    '''\n    _slow = regime_breakout(df,_h,_l,window = slow)\n    _fast = regime_breakout(df,_h,_l,window = fast)\n    turtle = pd. Series(index= df.index, \n                        data = np.where(_slow == 1,np.where(_fast == 1,1,0), \n                                np.where(_slow == -1, np.where(_fast ==-1,-1,0),0)))\n    return turtle\nslow = 50\nfast = 20\nohlc = ['Open','High','Low','Close']\n_o,_h,_l,_c = [ohlc[h] for h in range(len(ohlc))]\ndf['bo_'+ str(slow)] = regime_breakout(df,_h,_l,window = slow)\ndf['bo_'+ str(fast)] = regime_breakout(df,_h,_l,window = fast)\ndf['turtle_'+ str(slow)+str(fast)] = turtle_trader(df, _h, _l, slow, fast)\nrg_cols = ['bo_'+str(slow),'bo_'+ str(fast),'turtle_'+ str(slow)+str(fast)]\ndf[['Close','bo_'+str(slow),'bo_'+ str(fast),'turtle_'+ str(slow)+str(fast)] ].plot(\n    secondary_y= rg_cols,figsize=(20,5), style=['k','orange','g:','b-.'],\n                                 title = str.upper(ticker)+' '+str(rg_cols)) \n```", "```py\nma_st = ma_mt = ma_lt = 0\nrg=lo=hi=slo=shi=clg=flr=rg_ch = None\nohlc = ['Open','High','Low','Close']\n_o,_h,_l,_c = [ohlc[h] for h in range(len(ohlc))]\nbo_lt = 200\nbo_st = 50\n\nlt_lo = df[_l].rolling(window= bo_lt).min()\nlt_hi = df[_h].rolling(window= bo_lt).max()\nst_lo = df[_l].rolling(window= bo_st).min()\nst_hi = df[_h].rolling(window= bo_st).max()\ngraph_regime_combo(ticker,df,_c,rg,lo,hi,slo,shi,clg,flr,rg_ch,ma_st,ma_mt,ma_lt,lt_lo,lt_hi,st_lo,st_hi) \n```", "```py\n#### Regime SMA EMA ####\ndef regime_sma(df,_c,st,lt):\n    '''\n    bull +1: sma_st >= sma_lt , bear -1: sma_st <= sma_lt\n    '''\n    sma_lt = df[_c].rolling(lt).mean()\n    sma_st = df[_c].rolling(st).mean()\n    rg_sma = np.sign(sma_st - sma_lt)\n    return rg_sma\n\ndef regime_ema(df,_c,st,lt):\n    '''\n    bull +1: ema_st >= ema_lt , bear -1: ema_st <= ema_lt\n    '''\n    ema_st = df[_c].ewm(span=st,min_periods = st).mean()\n    ema_lt = df[_c].ewm(span=lt,min_periods = lt).mean()\n    rg_ema = np.sign(ema_st - ema_lt)\n    return rg_ema\n\nst = 50\nlt = 200\ndf['sma_' + str(st) + str(lt)] = regime_sma(df, _c='Close', st= st, lt= lt)\ndf['ema_' + str(st) + str(lt)] = regime_ema(df, _c='Close', st= st, lt= lt)\n\nohlc = ['Open','High','Low','Close'] \n_o,_h,_l,_c = [ohlc[h] for h in range(len(ohlc))]\nrgme_cols = ['sma_' + str(st) + str(lt), 'ema_' + str(st) + str(lt),'turtle_'+ str(slow)+str(fast) ]\ndf[['Close','sma_' + str(st) + str(lt), 'ema_' + str(st) + str(lt),'turtle_'+ str(slow)+str(fast)] ].plot(\n    secondary_y= rgme_cols,figsize=(20,8), style=['k','orange','m--','b-.'],\n                                 title = str.upper(ticker)+' '+str(rgme_cols)) \n```", "```py\nrg=lo=hi=slo=shi=clg=flr=rg_ch = None\nlt_lo = lt_hi = st_lo = st_hi = 0\n\nma_st = df[_c].rolling(window=50).mean()\nma_mt = df[_c].rolling(window=200).mean()\nma_lt = df[_c].rolling(window=200).mean()\nohlc = ['Open','High','Low','Close']\n_o,_h,_l,_c = [ohlc[h] for h in range(len(ohlc))]\n\ngraph_regime_combo(ticker,df,_c,rg,lo,hi,slo,shi,clg,flr,rg_ch,ma_st,ma_mt,ma_lt,lt_lo,lt_hi,st_lo,st_hi) \n```", "```py\nmav = [50, 200, 200]\nma_st,ma_mt,ma_lt = [df[_c].rolling(mav[t]).mean() for t in range(len(mav))]\n\nbo = [50, 252]\nst_lo,lt_lo = [df[_l].rolling(bo[t]).min() for t in range(len(bo))]\nst_hi,lt_hi = [df[_h].rolling(bo[t]).max() for t in range(len(bo))]\nohlc = ['Open','High','Low','Close']\n_o,_h,_l,_c = [ohlc[h] for h in range(len(ohlc))]\n\ngraph_regime_combo(ticker,df,_c,rg,lo,hi,slo,shi,clg,flr,rg_ch,ma_st,ma_mt,ma_lt,lt_lo,lt_hi,st_lo,st_hi) \n```", "```py\nrg=lo=hi=slo=shi=clg=flr=rg_ch = None\nlt_lo = lt_hi = st_lo = st_hi = 0\n\nmav = [20, 50, 200]\nma_st,ma_mt,ma_lt = [df[_c].rolling(mav[t]).mean() for t in range(len(mav))]\nohlc = ['Open','High','Low','Close']\n_o,_h,_l,_c = [ohlc[h] for h in range(len(ohlc))]\n\ngraph_regime_combo(ticker,df,_c,rg,lo,hi,slo,shi,clg,flr,rg_ch,ma_st,ma_mt,ma_lt,lt_lo,lt_hi,st_lo,st_hi) \n```", "```py\n# CHAPTER 5 Swing detection\nticker = 'SPY' \n\nstart= '2016-12-31'\nend = None\nraw_data = round(yf.download(tickers= ticker,start= start, end = end,interval = \"1d\",\n                 group_by = 'column',auto_adjust = True, prepost = True, \n                 treads = True, proxy = None),2)\nohlc = ['Open','High','Low','Close']\n_o,_h,_l,_c = [ohlc[h] for h in range(len(ohlc))] \n```", "```py\n#### hilo_alternation(hilo, dist= None, hurdle= None) ####\ndef hilo_alternation(hilo, dist= None, hurdle= None):\n    i=0    \n    while (np.sign(hilo .shift(1)) == np.sign(hilo)).any(): # runs until duplicates are eliminated\n        # removes swing lows > swing highs\n        hilo.loc[(np.sign(hilo.shift(1)) != np.sign(hilo)) & # hilo alternation test \n                 (hilo.shift(1)<0) &  # previous datapoint: high\n                 (np.abs(hilo.shift(1)) < np.abs(hilo) )] = np.nan # high[-1] < low, eliminate low \n\n        hilo.loc[(np.sign(hilo.shift(1)) != np.sign(hilo)) &  # hilo alternation\n                 (hilo.shift(1)>0) &  # previous swing: low\n                 (np.abs(hilo ) < hilo.shift(1))] = np.nan # swing high < swing low[-1]\n\n#### removed for brevity: check GitHub repo for full code ####\n#### hilo_alternation(hilo, dist= None, hurdle= None) ####\n#### historical_swings(df,_o,_h,_l,_c, dist= None, hurdle= None) #### \ndef historical_swings(df,_o,_h,_l,_c, dist= None, hurdle= None):\n\n    reduction = df[[_o,_h,_l,_c]].copy() \n    reduction['avg_px'] = round(reduction[[_h,_l,_c]].mean(axis=1),2)\n    highs = reduction['avg_px'].values\n    lows = - reduction['avg_px'].values\n    reduction_target =  len(reduction) // 100\n\n    n = 0\n    while len(reduction) >= reduction_target: \n        highs_list = find_peaks(highs, distance = 1, width = 0)\n        lows_list = find_peaks(lows, distance = 1, width = 0)\n        hilo = reduction.iloc[lows_list[0]][_l].sub(reduction.iloc[highs_list[0]][_h],fill_value=0)\n\n#### removed for brevity: check GitHub repo for full code ####\n#### historical_swings(df,_o,_h,_l,_c, dist= None, hurdle= None) ####\n\ndf = raw_data.copy()\nohlc = ['Open','High','Low','Close']\n_o,_h,_l,_c = [ohlc[h] for h in range(len(ohlc))]\nrhs = ['Hi1', 'Lo1','Hi2', 'Lo2', 'Hi3', 'Lo3']\nrt_hi,rt_lo,_hi,_lo,shi,slo = [rhs[h] for h in range(len(rhs))]\n\ndf= historical_swings(df,_o,_h,_l,_c,dist= None, hurdle= None)\n\ndf[[_c,rt_hi,rt_lo,_hi,_lo,shi,slo ]].plot(\n    style=['grey','y.', 'c.','r.', 'g.', 'rv', 'g^'],\n    figsize=(20,5),grid=True, title = str.upper(ticker))\ndf[[_c,shi,slo]].plot(style=['grey','rv', 'g^'],\n        figsize=(20,5),grid=True, title = str.upper(ticker)) \n```", "```py\n#### cleanup_latest_swing(df, shi, slo, rt_hi, rt_lo) ####\ndef cleanup_latest_swing(df, shi, slo, rt_hi, rt_lo): \n    '''\n    removes false positives\n    '''\n    # latest swing\n    shi_dt = df.loc[pd.notnull(df[shi]), shi].index[-1]\n    s_hi = df.loc[pd.notnull(df[shi]), shi][-1]\n    slo_dt = df.loc[pd.notnull(df[slo]), slo].index[-1] \n    s_lo = df.loc[pd.notnull(df[slo]), slo][-1] \n    len_shi_dt = len(df[:shi_dt])\n    len_slo_dt = len(df[:slo_dt])\n\n    # Reset false positives to np.nan\n    for i in range(2):\n\n        if (len_shi_dt > len_slo_dt) & ((df.loc[shi_dt:,rt_hi].max()> s_hi) | (s_hi<s_lo)):\n            df.loc[shi_dt, shi] = np.nan\n            len_shi_dt = 0\n        elif (len_slo_dt > len_shi_dt) & ((df.loc[slo_dt:,rt_lo].min()< s_lo)| (s_hi<s_lo)):\n            df.loc[slo_dt, slo] = np.nan \n            len_slo_dt = 0\n        else:\n            pass\n\n    return df\n#### cleanup_latest_swing(df, shi, slo, rt_hi, rt_lo) ####\n\ndf[[_c,shi,slo]].plot(style=['grey','rv', 'g^'],\n        figsize=(20,5),grid=True, title = str.upper(ticker) + ' pre-adjustment')\n\ndf = cleanup_latest_swing(df, shi,slo,rt_hi,rt_lo)\n\ndf[[_c,shi,slo]].plot(style=['grey', 'rv', 'g^'],\n        figsize=(20,5),grid=True, title = str.upper(ticker) + ' post-adjustment') \n```", "```py\n#### latest_swings(df, shi, slo, rt_hi, rt_lo, _h, _l, _c, _vol) ####\ndef latest_swing_variables(df, shi, slo, rt_hi, rt_lo, _h, _l, _c):\n    '''\n    Latest swings dates & values\n    '''\n    shi_dt = df.loc[pd.notnull(df[shi]), shi].index[-1]\n    slo_dt = df.loc[pd.notnull(df[slo]), slo].index[-1]\n    s_hi = df.loc[pd.notnull(df[shi]), shi][-1]\n    s_lo = df.loc[pd.notnull(df[slo]), slo][-1]\n\n    if slo_dt > shi_dt: \n        swg_var = [1,s_lo,slo_dt,rt_lo,shi, df.loc[slo_dt:,_h].max(), df.loc[slo_dt:, _h].idxmax()]         \n    elif shi_dt > slo_dt: \n        swg_var = [-1,s_hi,shi_dt,rt_hi,slo, df.loc[shi_dt:, _l].min(),df.loc[shi_dt:, _l].idxmin()]        \n    else: \n        ud = 0\n    ud, bs, bs_dt, _rt, _swg, hh_ll, hh_ll_dt = [swg_var[h] for h in range(len(swg_var))]   \n\n    return ud, bs, bs_dt, _rt, _swg, hh_ll, hh_ll_dt\n#### latest_swings(df, shi, slo, rt_hi, rt_lo, _h, _l, _c, _vol) ####\n\nud,bs,bs_dt,_rt,_swg,hh_ll,hh_ll_dt = latest_swing_variables(df,shi,slo,rt_hi,rt_lo,_h,_l,_c)\n\nud, bs, bs_dt, _rt, _swg, hh_ll, hh_ll_dt \n```", "```py\n(1,\n 213.43,\n Timestamp('2020-03-23 00:00:00'),\n 'Lo1',\n 'Hi3',\n 452.6,\n Timestamp('2021-09-02 00:00:00')) \n```", "```py\n#### test_distance(ud, bs, hh_ll, vlty, dist_vol, dist_pct) ####\ndef test_distance(ud,bs, hh_ll, dist_vol, dist_pct): \n\n    # priority: 1\\. Vol 2\\. pct 3\\. dflt\n    if (dist_vol > 0):    \n        distance_test = np.sign(abs(hh_ll - bs) - dist_vol)\n    elif (dist_pct > 0):\n        distance_test = np.sign(abs(hh_ll / bs - 1) - dist_pct)\n    else:\n        distance_test = np.sign(dist_pct)\n\n    return int(max(distance_test,0) * ud)\n#### test_distance(ud, bs, hh_ll, vlty, dist_vol, dist_pct) ####\n#### ATR ####\ndef average_true_range(df, _h, _l, _c, n):\n    '''\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:average_true_range_atr\n    '''\n    atr =  (df[_h].combine(df[_c].shift(), max) - df[_l].combine(df[_c].shift(), min)).rolling(window=n).mean()\n    return atr\n\n#### ATR ####\n\ndist_vol = round(average_true_range(df,_h,_l,_c,n=63)[hh_ll_dt] * 2,2)\ndist_pct = 0.05\n_sign = test_distance(ud,bs, hh_ll, dist_vol, dist_pct)\n_sign \n```", "```py\n1 \n```", "```py\n#### retest_swing(df, _sign, _rt, hh_ll_dt, hh_ll, _c, _swg) ####\ndef retest_swing(df, _sign, _rt, hh_ll_dt, hh_ll, _c, _swg):\n    rt_sgmt = df.loc[hh_ll_dt:, _rt] \n\n    if (rt_sgmt.count() > 0) & (_sign != 0): # Retests exist and distance test met    \n        if _sign == 1: # \n            rt_list = [rt_sgmt.idxmax(),rt_sgmt.max(),df.loc[rt_sgmt.idxmax():, _c].cummin()]\n\n        elif _sign == -1:\n            rt_list = [rt_sgmt.idxmin(), rt_sgmt.min(), df.loc[rt_sgmt.idxmin():, _c].cummax()]\n        rt_dt,rt_hurdle, rt_px = [rt_list[h] for h in range(len(rt_list))]\n\n        if str(_c)[0] == 'r':\n            df.loc[rt_dt,'rrt'] = rt_hurdle\n        elif str(_c)[0] != 'r':\n            df.loc[rt_dt,'rt'] = rt_hurdle    \n\n        if (np.sign(rt_px - rt_hurdle) == - np.sign(_sign)).any():\n            df.at[hh_ll_dt, _swg] = hh_ll \n    return df\n#### retest_swing(df, _sign, _rt, hh_ll_dt, hh_ll, _c, _swg) ####\n\ndf = retest_swing(df, _sign, _rt, hh_ll_dt, hh_ll, _c, _swg)\ntry:\n    df['rt '] = df['rt'].fillna(method='ffill')\n    df[bs_dt:][[_c, rt_hi, rt_lo,\n        shi, slo,'rt']].plot(style=['grey', 'c.','y.',\n        'rv', 'g^', 'ko'],figsize=(20,5),grid=True, title = str.upper(ticker))\nexcept:\n    df[bs_dt:][[_c, rt_hi, rt_lo,\n        shi, slo]].plot(style=['grey', 'c.','y.',\n        'rv', 'g^', 'ko'],figsize=(20,5),grid=True, title = str.upper(ticker)) \n```", "```py\n#### retracement_swing(df, _sign, _swg, _c, hh_ll_dt, hh_ll, vlty, retrace_vol, retrace_pct) \ndef retracement_swing(df, _sign, _swg, _c, hh_ll_dt, hh_ll, vlty, retrace_vol, retrace_pct):\n    if _sign == 1: #\n        retracement = df.loc[hh_ll_dt:, _c].min() - hh_ll\n\n#### removed for brevity: check GitHub repo for full code ####\n#### retracement_swing(df, _sign, _swg, _c, hh_ll_dt, hh_ll, vlty, retrace_vol, retrace_pct) ####\n\nvlty = round(average_true_range(df=df, _h= _h, _l= _l, _c= _c , n=63)[hh_ll_dt],2)\ndist_vol = 5 * vlty\ndist_pct = 0.05\n_sign = test_distance(ud,bs, hh_ll, dist_vol, dist_pct)\ndf = retest_swing(df, _sign, _rt, hh_ll_dt, hh_ll, _c, _swg)\nretrace_vol = 2.5 * vlty\nretrace_pct = 0.05\ndf = retracement_swing(df,_sign,_swg,_c,hh_ll_dt,hh_ll, vlty,retrace_vol, retrace_pct)\n\ndf[[_c,_hi,_lo,shi,slo]].plot(\n    style=['grey','r.', 'g.', 'rv', 'g^'],\n    figsize=(20,5),grid=True, title = str.upper(ticker))\n\ndf[[_c,shi,slo]].plot(style=['grey','rv', 'g^'],\n            figsize=(20,5),grid=True, title = str.upper(ticker)) \n```", "```py\n### RELATIVE\ndef relative(df,_o,_h,_l,_c, bm_df, bm_col, ccy_df, ccy_col, dgt, start, end,rebase=True):\n    '''\n    df: df\n    bm_df, bm_col: df benchmark dataframe & column name\n    ccy_df,ccy_col: currency dataframe & column name\n    dgt: rounding decimal\n    start/end: string or offset\n    rebase: boolean rebase to beginning or continuous series\n    '''\n#### removed for brevity: check GitHub repo for full code ####\n### RELATIVE ###\nbm_df = pd.DataFrame()\nbm_col = 'ONEQ'\nccy_col = 'USD'\ndgt= 3\nbm_df[bm_col] = round(yf.download(tickers= bm_col,start= start, end = end,interval = \"1d\",\n                 group_by = 'column',auto_adjust = True, prepost = True, \n                 treads = True, proxy = None)['Close'],2)\nbm_df[ccy_col] = 1\n\ndf = raw_data.copy()\nohlc = ['Open','High','Low','Close']\n_o,_h,_l,_c = [ohlc[h] for h in range(len(ohlc))]\nrhs = ['Hi1', 'Lo1','Hi2', 'Lo2', 'Hi3', 'Lo3']\nrt_hi,rt_lo,_hi,_lo,shi,slo = [rhs[h] for h in range(len(rhs))]\ndf= relative(df,_o,_h,_l,_c, bm_df, bm_col, ccy_df=bm_df, \n            ccy_col=ccy_col, dgt= dgt, start=start, end= end,rebase=True)\n\nfor a in np.arange(0,2):  \n    df = historical_swings(df,_o,_h,_l,_c, dist= None, hurdle= None)\n    df = cleanup_latest_swing(df, shi, slo, rt_hi, rt_lo)\n    ud, bs, bs_dt, _rt, _swg, hh_ll, hh_ll_dt = latest_swing_variables(df, shi, slo,rt_hi,rt_lo,_h, _l,_c)\n    vlty = round(average_true_range(df=df, _h= _h, _l= _l, _c= _c , n=63)[hh_ll_dt],2)\n    dist_vol = 5 * vlty\n    dist_pct = 0.05\n    _sign = test_distance(ud,bs, hh_ll, dist_vol, dist_pct)\n    df = retest_swing(df, _sign, _rt, hh_ll_dt, hh_ll, _c, _swg)\n    retrace_vol = 2.5 * vlty\n    retrace_pct = 0.05\n    df = retracement_swing(df,_sign,_swg,_c,hh_ll_dt,hh_ll, vlty,retrace_vol, retrace_pct)\n    rohlc = ['rOpen','rHigh','rLow','rClose']\n    _o,_h,_l,_c = [rohlc[h] for h in range(len(rohlc)) ]\n    rrhs = ['rH1', 'rL1','rH2', 'rL2', 'rH3', 'rL3']\n    rt_hi,rt_lo,_hi,_lo,shi,slo = [rrhs[h] for h in range(len(rrhs))] \n```", "```py\ndf[['Close','Hi1','Lo1','Hi2','Lo2','Hi3','Lo3']].plot(style=['grey','y.', 'c.','r.', 'g.', 'rv', 'g^'],\n    figsize=(20,5),grid=True, title = str.upper(ticker))\ndf[['Close','Hi3','Lo3']].plot(\n    style=['grey', 'rv', 'g^'],\n    figsize=(20,5),grid=True, title = str.upper(ticker))\n\ndf[['Close','Hi3','Lo3',_c,shi,slo]].plot(\n    style=['grey','rv', 'g^','k:','mv','b^'],\n            figsize=(20,5),grid=True, title = str.upper(ticker)+' vs '+str.upper(bm_col))\nrohlc = ['rOpen','rHigh','rLow','rClose']\n_o,_h,_l,_c = [rohlc[h] for h in range(len(rohlc)) ]\n\ndf[[_c,shi,slo]].plot(\n    style=['k:','mv','b^'],\n            figsize=(20,5),grid=True, title = str.upper(ticker)+' vs '+str.upper(bm_col)) \n```", "```py\n#### regime_floor_ceiling(df, hi,lo,cl, slo, shi,flr,clg,rg,rg_ch,stdev,threshold) ####\ndef regime_floor_ceiling(df, _h,_l,_c,slo, shi,flr,clg,rg,rg_ch,stdev,threshold):\n    # Lists instantiation\n    threshold_test,rg_ch_ix_list,rg_ch_list = [],[], []\n    floor_ix_list, floor_list, ceiling_ix_list, ceiling_list = [],[],[],[]\n\n    ### Range initialisation to 1st swing\n    floor_ix_list.append(df.index[0])\n    ceiling_ix_list.append(df.index[0])\n\n    ### Boolean variables\n    ceiling_found = floor_found = breakdown = breakout = False\n\n    ### Swings lists\n    swing_highs = list(df[pd.notnull(df[shi])][shi])\n    swing_highs_ix = list(df[pd.notnull(df[shi])].index)\n    swing_lows = list(df[pd.notnull(df[slo])][slo])\n    swing_lows_ix = list(df[pd.notnull(df[slo])].index)\n    loop_size = np.maximum(len(swing_highs),len(swing_lows))\n\n    ### Loop through swings\n    for i in range(loop_size): \n\n        ### asymetric swing list: default to last swing if shorter list\n#### removed for brevity: check GitHub repo for full code ####\n\n         ### CLASSIC CEILING DISCOVERY\n#### removed for brevity: check GitHub repo for full code ####\n\n        ### EXCEPTION HANDLING: price penetrates discovery swing\n#### removed for brevity: check GitHub repo for full code ####\n        ### CLASSIC FLOOR DISCOVERY        \n#### removed for brevity: check GitHub repo for full code ####\n\n        ### EXCEPTION HANDLING: price penetrates discovery swing\n#### removed for brevity: check GitHub repo for full code #### \n    ### POPULATE FLOOR,CEILING, RG CHANGE COLUMNS\n#### removed for brevity: check GitHub repo for full code ####\n\n#### regime_floor_ceiling(df, hi,lo,cl, slo, shi,flr,clg,rg,rg_ch,stdev,threshold) ####\nohlc = ['Open','High','Low','Close']\n_o,_h,_l,_c = [ohlc[h] for h in range(len(ohlc))]\nrg_val = ['Hi3','Lo3','flr','clg','rg','rg_ch',1.5]\nslo, shi,flr,clg,rg,rg_ch,threshold = [rg_val[s] for s in range(len(rg_val))]\nstdev = df[_c].rolling(63).std(ddof=0)\ndf = regime_floor_ceiling(df,_h,_l,_c,slo, shi,flr,clg,rg,rg_ch,stdev,threshold)\n\ndf[[_c,'Hi3', 'Lo3','clg','flr','rg_ch','rg']].plot(    style=['grey', 'ro', 'go', 'kv', 'k^','c:','y-.'],     secondary_y= ['rg'],figsize=(20,5),    grid=True, title = str.upper(ticker)) \n```", "```py\nohlc = ['Open','High','Low','Close']\n_o,_h,_l,_c = [ohlc[h] for h in range(len(ohlc))]\nmav = [20, 50, 200]\nma_st,ma_mt,ma_lt = [df[_c].rolling(mav[t]).mean() for t in range(len(mav))]\n\nbo = [50, 252]\nst_lo,lt_lo = [df[_l].rolling(bo[t]).min() for t in range(len(bo))]\nst_hi,lt_hi = [df[_h].rolling(bo[t]).max() for t in range(len(bo))]\n\nrg=lo=hi=slo=shi=clg=flr=rg_ch = None\ngraph_regime_combo(ticker,df,_c,rg,lo,hi,slo,shi,clg,flr,rg_ch,ma_st,ma_mt,ma_lt,lt_lo,lt_hi,st_lo,st_hi)\n\nrg_combo = ['Close','rg','Lo3','Hi3','Lo3','Hi3','clg','flr','rg_ch']\n_c,rg,lo,hi,slo,shi,clg,flr,rg_ch =[rg_combo[r] for r in range(len(rg_combo)) ]\n\ngraph_regime_combo(ticker,df,_c,rg,lo,hi,slo,shi,clg,flr,rg_ch,ma_st,ma_mt,ma_lt,lt_lo,lt_hi,st_lo,st_hi) \n```", "```py\nparams = ['2014-12-31', None, 63, 0.05, 0.05, 1.5, 2]\nstart, end, vlty_n,dist_pct,retrace_pct,threshold,dgt= [params[h] for h in range(len(params))]\n\nrel_var = ['^GSPC','SP500', 'USD']\nbm_ticker, bm_col, ccy_col = [rel_var[h] for h in range(len(rel_var))]\nbm_df = pd.DataFrame()\nbm_df[bm_col] = round(yf.download(tickers= bm_ticker,start= start, end = end,interval = \"1d\",\n                 group_by = 'column',auto_adjust = True, prepost = True, \n                 treads = True, proxy = None)['Close'],dgt)\nbm_df[ccy_col] = 1\n\nticker = 'WFC'\ndf = round(yf.download(tickers= ticker,start= start, end = end,interval = \"1d\",\n                 group_by = 'column',auto_adjust = True, prepost = True, \n                 treads = True, proxy = None),2)\nohlc = ['Open','High','Low','Close']\n_o,_h,_l,_c = [ohlc[h] for h in range(len(ohlc))]\ndf= relative(df=df,_o=_o,_h=_h,_l=_l,_c=_c, bm_df=bm_df, bm_col= bm_col, ccy_df=bm_df, \n            ccy_col=ccy_col, dgt= dgt, start=start, end= end,rebase=True)\n\ndf[['Close','rClose']].plot(figsize=(20,5),style=['k','grey'],\n                           title = str.upper(ticker)+ ' Relative & Absolute') \n```", "```py\nswing_val = ['rg','Lo1','Hi1','Lo3','Hi3','clg','flr','rg_ch']\nrg,rt_lo,rt_hi,slo,shi,clg,flr,rg_ch = [swing_val[s] for s in range(len(swing_val))]\n\nfor a in np.arange(0,2):    \n    df = round(historical_swings(df,_o,_h,_l,_c, dist= None, hurdle= None),2)\n    df = cleanup_latest_swing(df,shi,slo,rt_hi,rt_lo)\n    ud, bs, bs_dt, _rt, _swg, hh_ll, hh_ll_dt = latest_swing_variables(df, \n            shi,slo,rt_hi,rt_lo,_h,_l, _c)\n    vlty = round(average_true_range(df,_h,_l,_c, n= vlty_n)[hh_ll_dt],2)\n    dist_vol = 5 * vlty\n    _sign = test_distance(ud,bs, hh_ll, dist_vol, dist_pct)\n    df = retest_swing(df, _sign, _rt, hh_ll_dt, hh_ll, _c, _swg)\n    retrace_vol = 2.5 * vlty\n    df = retracement_swing(df, _sign, _swg, _c, hh_ll_dt, hh_ll, vlty, retrace_vol, retrace_pct)\n    stdev = df[_c].rolling(vlty_n).std(ddof=0)\n    df = regime_floor_ceiling(df,_h,_l,_c,slo, shi,flr,clg,rg,rg_ch,stdev,threshold)    \n\n    rohlc = ['rOpen','rHigh','rLow','rClose']\n    _o,_h,_l,_c = [rohlc[h] for h in range(len(rohlc)) ]\n    rswing_val = ['rrg','rL1','rH1','rL3','rH3','rclg','rflr','rrg_ch']\n    rg,rt_lo,rt_hi,slo,shi,clg,flr,rg_ch = [rswing_val[s] for s in range(len(rswing_val))] \n```", "```py\nma_st = ma_mt = ma_lt = lt_lo = lt_hi = st_lo = st_hi = 0\n\nrg_combo = ['Close','rg','Lo3','Hi3','Lo3','Hi3','clg','flr','rg_ch']\n_c,rg,lo,hi,slo,shi,clg,flr,rg_ch =[rg_combo[r] for r in range(len(rg_combo)) ]\ngraph_regime_combo(ticker,df,_c,rg,lo,hi,slo,shi,clg,flr,rg_ch,ma_st,ma_mt,ma_lt,lt_lo,lt_hi,st_lo,st_hi)\n\nrrg_combo = ['rClose','rrg','rL3','rH3','rL3','rH3','rclg','rflr','rrg_ch']\n_c,rg,lo,hi,slo,shi,clg,flr,rg_ch =[rrg_combo[r] for r in range(len(rrg_combo)) ]\ngraph_regime_combo(ticker,df,_c,rg,lo,hi,slo,shi,clg,flr,rg_ch,ma_st,ma_mt,ma_lt,lt_lo,lt_hi,st_lo,st_hi) \n```"]