- en: '13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '13'
- en: Looking Ahead
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来
- en: The first generation of quantum algorithms appeared in the 1990s when quantum
    computers existed only as a concept. On the one hand, the absence of actual quantum
    hardware was a huge disadvantage since it made direct experiments impossible;
    on the other hand, it stimulated theoretical research not inhibited by the limitations
    and constraints of the imperfect early quantum computers. Researchers focused
    on devising algorithms that would achieve quadratic or even exponential speedup,
    assuming that powerful, error-free quantum computers would be available one day.
    It was the time when Shor’s prime factorisation algorithm  [[265](Biblography.xhtml#XShor)]
    and Grover’s search algorithm  [[117](Biblography.xhtml#XGrover)] were discovered.
    Incidentally, as the book was about to be released, Peter Shor was named one of
    the four recipients of the 2022 Breakthrough Prize in Fundamental Physics (along
    with C. H. Bennett, G. Brassard, and D. Deutsch) for their foundational work in
    quantum information. Many such algorithms, in turn, relied on basic building blocks
    such as Quantum Phase Estimation and Quantum Fourier Transform  [[278](Biblography.xhtml#XSutor2019)].
    These algorithms played an important role in demonstrating the capabilities of
    universal gate model quantum computers – if only they were available!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 第一代量子算法出现在1990年代，那时量子计算机仅仅是一个概念。一方面，缺乏实际的量子硬件是一个巨大的劣势，因为这使得直接实验变得不可能；另一方面，这也激发了理论研究，而理论研究不受早期量子计算机的不完美限制和约束。研究人员专注于设计可以实现二次甚至指数级加速的算法，假设有一天将会出现强大的、无误差的量子计算机。这正是Shor的素因数分解算法[[265](Biblography.xhtml#XShor)]和Grover的搜索算法[[117](Biblography.xhtml#XGrover)]被发现的时期。顺便提一下，在本书即将发布之际，Peter
    Shor被授予2022年基础物理学突破奖的四位获奖者之一（与C. H. Bennett、G. Brassard和D. Deutsch一起），以表彰他们在量子信息领域的奠基性工作。许多此类算法依赖于基本的构建模块，如量子相位估计和量子傅里叶变换[[278](Biblography.xhtml#XSutor2019)]。这些算法在展示通用门模型量子计算机的能力方面发挥了重要作用——如果它们当时存在的话！
- en: 'A quarter of a century later we are facing a different problem: the development
    of practical quantum computing algorithms and techniques that would allow us to
    extract value from NISQ computers. While quantum computing hardware is improving
    at a breathtaking pace, it is still too far from a state where it can break RSA
    encryption. What are existing quantum computers capable of doing? What is their
    relative strength in comparison with classical computers? In this chapter we look
    at several new, NISQ-friendly algorithms that bring us one step closer to achieving
    the quantum advantage.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 25年后，我们面临了一个不同的问题：开发实用的量子计算算法和技术，使我们能够从NISQ计算机中提取价值。虽然量子计算硬件以惊人的速度在进步，但它仍然远未达到能够破解RSA加密的程度。现有的量子计算机能够做什么？与经典计算机相比，它们的相对优势在哪里？在本章中，我们将探讨几种新的、适用于NISQ的算法，这些算法让我们更接近实现量子优势的目标。
- en: 13.1 Quantum Kernels
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1 量子核方法
- en: We start with the popular classical kernel method and then describe its quantum
    counterpart based on parameterised quantum circuits.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍流行的经典核方法，然后描述基于参数化量子电路的量子版本。
- en: 13.1.1 Classical kernel method
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.1 经典核方法
- en: 'A *kernel method* is the key element of a powerful classical supervised learning
    algorithm: Support Vector Machine (SVM). Unlike a feedforward-neural-network-based
    classifier whose objective is to minimise the classification error, the SVM’s
    objective is to maximise the margin, defined as the distance between a separating
    hyperplane (decision boundary separating samples belonging to different classes)
    and the training samples that are closest to this hyperplane  [[243](Biblography.xhtml#XRaschka2019)].
    The samples that are closest to the separating hyperplane are called *support
    vectors*, thus giving its name to the algorithm.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*核方法*是强大经典监督学习算法的关键元素：支持向量机（SVM）。与目标是最小化分类误差的前馈神经网络分类器不同，SVM的目标是最大化边界，即定义为分隔超平面（分隔属于不同类别的样本的决策边界）与距离该超平面最近的训练样本之间的距离[[243](Biblography.xhtml#XRaschka2019)]。距离分隔超平面最近的样本被称为*支持向量*，因此该算法得名。'
- en: The maximisation of the margins lowers the generalisation error and helps fight
    overfitting. This is a very important property but finding the separating hyperplane
    is not an easy task for non-linearly separable data. Fortunately, the kernel method
    allows us to overcome this difficulty, by creating non-linear combinations of
    the original features and projecting them onto a higher-dimensional space where
    the data samples become linearly separable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 边际最大化降低了泛化误差，并有助于抵抗过拟合。这是一个非常重要的性质，但对于非线性可分的数据，寻找分隔超平面并非易事。幸运的是，核方法允许我们通过创建原始特征的非线性组合，并将其投影到一个高维空间，从而克服这个困难，在该空间中数据样本变得线性可分。
- en: Whereas an SVM with linearly separable data operates on the inner product ![⟨xi,xj⟩](img/file1241.jpg)
    of the training samples, the generalised version to non-linearly separable data
    operates on the kernel function
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 而具有线性可分数据的支持向量机(SVM)操作在训练样本的内积上![⟨xi,xj⟩](img/file1241.jpg)，其广义版本对于非线性可分数据则操作在核函数上
- en: '| ![k(xi,xj) := ϕ(xi)⊤ ϕ(xj), ](img/file1242.jpg) |  |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| ![k(xi,xj) := ϕ(xi)⊤ ϕ(xj), ](img/file1242.jpg) |  |'
- en: 'where *ϕ* : ℝ^N →ℝ^M, with *M* ≫ *N*, is the feature map that projects the
    *N*-dimensional feature x := (*x*[1]*,…,x*[N]) onto the *M*-dimensional feature
    space. The inner product ([13.1.1](#x1-2380001)) would be computationally expensive
    to calculate directly but the kernel function is computationally inexpensive –
    this is known as the *kernel trick*. The kernel function can be seen as a similarity
    function operating on a pair of samples. For example, the radial basis function'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '其中*ϕ* : ℝ^N → ℝ^M，且*M* ≫ *N*，是将*N*维特征x := (*x*[1]*,…,x*[N])投影到*M*维特征空间的特征映射。直接计算内积([13.1.1](#x1-2380001))将计算代价高昂，但核函数计算代价较低——这就是所谓的*核技巧*。核函数可以看作是对一对样本操作的相似性函数。例如，径向基函数'
- en: '| ![ i j ( ∥xi − xj∥2) k(x,x ) = exp − ---2σ2---- , ](img/file1243.jpg) |  |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| ![ i j ( ∥xi − xj∥2) k(x,x ) = exp − ---2σ2---- , ](img/file1243.jpg) |  |'
- en: translates the distance between samples x^i and x^j (defined on [0*,*∞)^N) into
    a similarity score (defined on the interval [0*,*1]).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将样本x^i和x^j之间的距离（定义在[0*,*∞)^N上）转化为相似性分数（定义在区间[0*,*1]上）。
- en: The right choice of kernel function can make the classification task much easier.
    However, some kernels may be hard to compute. This is where quantum computing
    may play an important role by providing efficient quantum circuits to compute
    them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 核函数的选择可以使分类任务变得更加容易。然而，一些核函数可能计算起来比较困难。这时，量子计算可能通过提供高效的量子电路来计算它们，发挥重要作用。
- en: 13.1.2 Quantum kernel method
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.2 量子核方法
- en: 'Wang, Du, Luo, and Ta  [[298](Biblography.xhtml#XWang2021)] have shown a close
    correspondence between classical and quantum kernels. The feature map *ϕ*(⋅) coincides
    with the preparation of a quantum state via a parameterised quantum circuit 𝒰(⋅),
    which maps the input data sample into a high-dimensional Hilbert space described
    by *n* qubits:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 王、杜、罗和塔 [[298](Biblography.xhtml#XWang2021)]展示了经典核和量子核之间的密切对应关系。特征映射*ϕ*(⋅)与通过参数化量子电路𝒰(⋅)准备量子态相吻合，后者将输入数据样本映射到由*n*个量子比特描述的高维希尔伯特空间中：
- en: '| ![ ⊗n ϕ(x) → &#124;ψ(x)⟩ = 𝒰(x) &#124;0⟩ . ](img/file1244.jpg) |  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| ![ ⊗n ϕ(x) → &#124;ψ(x)⟩ = 𝒰(x) &#124;0⟩ . ](img/file1244.jpg) |  |'
- en: 'The kernel function then coincides with applying measurements on the prepared
    quantum states:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，核函数与对准备好的量子态进行测量相吻合：
- en: '| ![ &#124;⟨ ⟩&#124; k(xi,xj) → &#124;ψ (xj)&#124;ψ(xi) &#124;2 , ](img/file1245.jpg)
    |  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| ![ &#124;⟨ ⟩&#124; k(xi,xj) → &#124;ψ (xj)&#124;ψ(xi) &#124;2 , ](img/file1245.jpg)
    |  |'
- en: and allows for more expressive models in comparison with the alternative
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 并且与替代方法相比，能够支持更具表现力的模型
- en: '| ![k (xi,xj) = ϕ(xi)⊤ ϕ(xj) → ⟨ψ(xj)&#124;ψ (xi)⟩. ](img/file1246.jpg) |  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| ![k (xi,xj) = ϕ(xi)⊤ ϕ(xj) → ⟨ψ(xj)&#124;ψ (xi)⟩. ](img/file1246.jpg) |  |'
- en: Huang *et al.*  [[143](Biblography.xhtml#XHuang2021)] argued that even though
    the kernel function ([13.1.2](#x1-2390002)) seems to be more natural, the quantum
    kernel ([13.1.2](#x1-2390002)) can learn arbitrarily deep quantum neural networks
    (deep PQC). This is a strong result, especially in combination with the hierarchy
    of expressive power of parameterised quantum circuits (Chapter [12](Chapter_12.xhtml#x1-22500012),
    Equation ([10](Chapter_12.xhtml#x1-233002r10))).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 黄*等* [[143](Biblography.xhtml#XHuang2021)]认为，尽管核函数 ([13.1.2](#x1-2390002)) 似乎更自然，但量子核 ([13.1.2](#x1-2390002))
    可以学习任意深度的量子神经网络（深度PQC）。这是一个强有力的结果，特别是结合了参数化量子电路（第[12](Chapter_12.xhtml#x1-22500012)章，公式 ([10](Chapter_12.xhtml#x1-233002r10))）的表现力层级。
- en: 'Havlíček *et al.*  [[129](Biblography.xhtml#XHavlicek2019)] described how a
    quantum computer can be used to estimate the kernel. The kernel entries are the
    *fidelities* between different feature vectors (analogous to similarity scores
    in classical kernel methods). Burnham, Cleve, Watrous, and R. de Wolf  [[50](Biblography.xhtml#XBurnham2001)]
    and Cincio, Subaşi, Sornborger, and Coles  [[66](Biblography.xhtml#XCincio2018)]
    investigated various fidelity estimation methods such as quantum fingerprinting
    and machine learning approach (both relying on the application of a CSWAP gate
    implementing the swap test). However, by using the fact that the states in the
    feature space are not arbitrary, the overlap between the quantum states can be
    estimated from the transition probability:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Havlíček *等人* [[129](Biblography.xhtml#XHavlicek2019)]描述了量子计算机如何用于估计核函数。核函数项是不同特征向量之间的*保真度*（类似于经典核方法中的相似度得分）。Burnham、Cleve、Watrous和R.
    de Wolf [[50](Biblography.xhtml#XBurnham2001)]，以及Cincio、Subaşi、Sornborger和Coles
    [[66](Biblography.xhtml#XCincio2018)]研究了各种保真度估计方法，如量子指纹识别和机器学习方法（这两者都依赖于应用CSWAP门实现交换测试）。然而，通过利用特征空间中的状态并非任意的这一事实，量子态之间的重叠可以通过转移概率进行估计：
- en: '| ![&#124;⟨ j i⟩&#124;2 † j i 2 &#124; ψ(x )&#124;ψ(x )&#124; = &#124;⟨0 &#124;𝒰
    (x )𝒰 (x ) &#124;0⟩&#124;, ](img/file1247.jpg) |  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| ![&#124;⟨ j i⟩&#124;2 † j i 2 &#124; ψ(x )&#124;ψ(x )&#124; = &#124;⟨0 &#124;𝒰
    (x )𝒰 (x ) &#124;0⟩&#124;，](img/file1247.jpg) |  |'
- en: where, for brevity, we used the notation ![|0 ⟩](img/file1248.jpg) := ![|0⟩](img/file1249.jpg)^(⊗n).
    The first step is the application of a composition of two consecutive feature
    map circuits (representing the operators 𝒰(x^i) and 𝒰^†(x^j)) to the initial state ![|0⟩](img/file1250.jpg).
    The second step is the measurement of the final state in the computational basis *K*
    times and counting the number *κ* of all-zero strings ![|0⟩](img/file1251.jpg).
    The frequency *κ∕K* of the all-zero string is the estimate of the transition probability
    (the "similarity score").
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，为了简便，我们使用了符号![|0 ⟩](img/file1248.jpg) := ![|0⟩](img/file1249.jpg)^(⊗n)。第一步是将两个连续的特征映射电路（表示操作符𝒰(x^i)和𝒰^†(x^j)）应用于初始态![|0⟩](img/file1250.jpg)。第二步是在计算基下对最终态进行*K*次测量，并计数所有零字符串![|0⟩](img/file1251.jpg)的数量*κ*。所有零字符串的频率*κ∕K*是转移概率（即“相似度得分”）的估计值。
- en: 'The rest of the supervising learning protocol is classical, allowing for the
    natural embedding of quantumly computed kernels into the overall framework: the
    algorithm remains essentially classical with only the classically hard task outsourced
    to the quantum chip.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的监督学习协议是经典的，允许量子计算的核函数自然嵌入到整体框架中：该算法本质上仍然是经典的，只有经典计算中困难的任务被外包给量子芯片。
- en: 13.1.3 Quantum circuits for the feature maps
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.3 特征映射的量子电路
- en: Figure [13.1](#13.1) displays a schematic representation of the feature map
    circuit. In this example, we work with an 8-dimensional dataset with features
    encoded in the rotation angles such that there is a direct mapping of a sample
    x^i := (*x*[1]^i*,…,x*[8]^i) into the vector of adjustable circuit parameters
    𝜃^i := (*𝜃*[1]^i*,…,𝜃*[8]^i). The first section of the circuit implements the
    operator 𝒰(x^i), creating an entangled state due to the layer of fixed two-qubit
    CZ gates, whereas the second section of the circuit implements 𝒰^†(x^j). Here
    we use the fact that
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图[13.1](#13.1)展示了特征映射电路的示意图。在这个示例中，我们处理的是一个8维数据集，其特征通过旋转角度进行编码，因此样本x^i := (*x*[1]^i*,…,x*[8]^i)可以直接映射到可调电路参数向量𝜃^i
    := (*𝜃*[1]^i*,…,𝜃*[8]^i)。电路的第一部分实现了操作符𝒰(x^i)，由于固定的两量子比特CZ门层，它创建了一个纠缠态，而电路的第二部分实现了𝒰^†(x^j)。这里我们使用以下事实：
- en: '![R†X(𝜃) = RX(− 𝜃), R†Y(𝜃) = RY(− 𝜃), CZ† = CZ. ](img/file1252.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![R†X(𝜃) = RX(− 𝜃), R†Y(𝜃) = RY(− 𝜃), CZ† = CZ。](img/file1252.jpg)'
- en: It is easy to see that if the samples x^i and x^j are identical (so that 𝜃^i
    = 𝜃^j), then 𝒰(x^i)𝒰^†(x^j) = ℐ and all *K* measurements will return the all-zero
    string ![|0 ⟩](img/file1253.jpg).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，如果样本x^i和x^j相同（即𝜃^i = 𝜃^j），则𝒰(x^i)𝒰^†(x^j) = ℐ，并且所有*K*次测量都将返回所有零字符串![|0
    ⟩](img/file1253.jpg)。
- en: '![Figure 13.1: Schematic quantum kernel circuit. ](img/file1254.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1：示意量子核电路。](img/file1254.jpg)'
- en: 'Figure 13.1: Schematic quantum kernel circuit.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：示意量子核电路。
- en: The rest of the protocol is classical – the quantum computer is used to assist
    the classifier with the calculation of a kernel function that would not be feasible
    if only classical computational resources were available.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的协议是经典的——量子计算机用于辅助分类器计算核函数，如果仅有经典计算资源，则无法实现该计算。
- en: Let us now apply the quantum kernel method to the Australian Credit Approval
    dataset (introduced in Chapter [8](Chapter_8.xhtml#x1-1620008)) in order to estimate
    the degree of similarity between samples drawn from the same class and samples
    drawn from two different classes. The ACA dataset consists of 690 samples, with 383
    samples labelled as Class 0 and 307 samples labelled as Class 1, so the dataset
    is reasonably well balanced. Each sample consists of 14 features (continuous,
    integer, binary). In Chapter [8](Chapter_8.xhtml#x1-1620008) we built a QNN classifier
    and tested its performance on the ACA dataset, employing the *angle encoding*
    scheme as explained in Section [7.2](Chapter_7.xhtml#x1-1520002). We would like
    to build a feature map that is consistent with the angle encoding scheme and does
    not require the construction of a too deep PQC. In fact, we would like to build
    a feature map using the PQC that is as close as possible to the one shown in Figure [13.1](#13.1).
    The proposed scheme can be embedded into all existing NISQ systems we considered
    earlier in this book. For example, we can use IBM’s Melbourne system shown in
    Figure [13.2](#13.2).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将量子内核方法应用于澳大利亚信用审批数据集（在第[8](Chapter_8.xhtml#x1-1620008)章中介绍），以估计来自同一类别的样本和来自两个不同类别的样本之间的相似度。ACA数据集由690个样本组成，其中383个样本被标记为类别0，307个样本被标记为类别1，因此数据集在类别上是合理平衡的。每个样本由14个特征（连续、整数、二进制）组成。在第[8](Chapter_8.xhtml#x1-1620008)章中，我们构建了一个QNN分类器，并在ACA数据集上测试了其性能，采用了第[7.2](Chapter_7.xhtml#x1-1520002)节中解释的*角度编码*方案。我们希望构建一个与角度编码方案一致的特征映射，并且不需要构建一个过深的PQC。事实上，我们希望使用PQC构建一个尽可能接近图[13.1](#13.1)所示的特征映射。该方案可以嵌入到本书之前讨论的所有现有NISQ系统中。例如，我们可以使用图[13.2](#13.2)所示的IBM墨尔本系统。
- en: '![Figure 13.2: Embedding of the quantum kernel circuit into IBM’s Melbourne
    system. ](img/file1255.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2：量子内核电路嵌入到IBM的墨尔本系统中。](img/file1255.jpg)'
- en: 'Figure 13.2: Embedding of the quantum kernel circuit into IBM’s Melbourne system.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：量子内核电路嵌入到IBM的墨尔本系统中。
- en: We know that 7 quantum registers (shown as shaded qubits connected by the thick
    lines in Figure [13.2](#13.2)) can encode a 14-feature data sample if we follow
    the angle encoding scheme. The corresponding circuit is shown in Figure [13.3](#13.3).
    The linear sequential connectivity between the physical qubits makes the choice
    of the 2-qubit gates straightforward (and, in fact, similar to the one in Figure [13.1](#13.1)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，如果采用角度编码方案，7个量子寄存器（如图[13.2](#13.2)中以粗线连接的阴影量子比特所示）可以编码一个14特征的数据样本。对应的电路如图[13.3](#13.3)所示。物理量子比特之间的线性顺序连接使得选择2量子比特门变得非常直接（实际上，与图[13.1](#13.1)中的相似）。
- en: '![Figure 13.3: Quantum kernel circuit for the ACA dataset. ](img/file1256.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3：ACA数据集的量子内核电路。](img/file1256.jpg)'
- en: 'Figure 13.3: Quantum kernel circuit for the ACA dataset.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3：ACA数据集的量子内核电路。
- en: In the circuit shown in Figure [13.3](#13.3), the angles 𝜃^i and 𝜃^j encode
    the data samples x^i and x^j, which can be drawn either from the same class or
    from two different classes. Running the circuit *K* times and calculating the
    number *κ* of all-zero bitstrings (after measurement) gives us the measure of
    similarity between samples x^i and x^j (estimated as the ratio *κ∕K*). Figure [13.4](#13.4)
    displays the mean values of the transition probabilities (similarity scores) obtained
    using the quantum kernel ([13.1.2](#x1-2390002)) by running the quantum circuit
    on the Qiskit simulator *K* = 10*,*000 times for each pair of data samples. The
    mean values were calculated across all possible pairs of samples from the corresponding
    classes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在图[13.3](#13.3)所示的电路中，角度𝜃^i和𝜃^j分别编码数据样本x^i和x^j，这些样本可以来自同一类别，也可以来自两个不同类别。运行电路*K*次并计算所有全零比特串的数量*κ*（测量后）可以给出样本x^i和x^j之间的相似度度量（估计为比率*κ∕K*）。图[13.4](#13.4)显示了通过在Qiskit模拟器上运行量子电路*K*
    = 10,000次得到的量子内核（[13.1.2](#x1-2390002)）的转移概率（相似度分数）均值。均值是通过计算来自相应类别的所有可能样本对的结果得到的。
- en: '![Figure 13.4: Mean values of the quantum kernel (13.1.2) for the ACA dataset.
    ](img/file1257.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4：ACA数据集的量子内核（13.1.2）的均值。](img/file1257.jpg)'
- en: 'Figure 13.4: Mean values of the quantum kernel ([13.1.2](#x1-2390002)) for
    the ACA dataset.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4：ACA数据集的量子内核（[13.1.2](#x1-2390002)）的均值。
- en: As expected, samples drawn from the same class have, on average, significantly
    larger similarity scores given by the quantum kernel compared with samples drawn
    from two different classes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期，从同一类别中抽取的样本相比于来自两个不同类别的样本，量子核所给出的相似度得分通常显著更大。
- en: Quantum kernels that can be efficiently calculated on quantum computers have
    the potential to improve the performance of hybrid quantum-classical machine learning
    models.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在量子计算机上高效计算的量子核具有提升混合量子-经典机器学习模型性能的潜力。
- en: 13.2 Quantum Generative Adversarial Networks
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2 量子生成对抗网络
- en: 'Generative Adversarial Networks (GANs) are powerful statistical techniques
    to generate (as much as needed) data close enough (in some sense) to given samples.
    They were introduced in  [[114](Biblography.xhtml#XGoodfellow2014)] and originally
    tested on image data. Since then, they have seen wide applications in finance,
    for time series generation  [[301](Biblography.xhtml#Xwiese2021multi), [302](Biblography.xhtml#Xwiese2020quant)],
    tuning of trading models  [[176](Biblography.xhtml#Xkoshiyama2021generative)],
    portfolio management  [[196](Biblography.xhtml#Xlu2022autoencoding)], synthetic
    data generation  [[17](Biblography.xhtml#Xassefa2020generating)], and diverse
    types of fraud detection  [[261](Biblography.xhtml#Xsethia2018data)]. The gist
    of it is to have a generator and a discriminator compete against each other in
    order to improve themselves: the generator improves by becoming better at generating
    good samples (i.e., close to real data) from random noise, whereas the discriminator
    improves by being able to recognise real data from "fake" (namely generated) data.
    Both the generator and the discriminator are usually built as neural networks
    with hyperparameters over which to optimise. Mathematically, given a generator (⋅*,*𝜃^()
    and a discriminator (⋅*,*𝜃^(), where 𝜃 ^(and 𝜃 ^(represent the hyperparameters,
    the problem reads as follows:))))'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 生成对抗网络（GANs）是强大的统计技术，用于生成（按需）足够接近给定样本的数据（在某种意义上）。它们在[[114](Biblography.xhtml#XGoodfellow2014)]中首次提出，并最初在图像数据上进行测试。从那时起，它们在金融领域得到了广泛应用，包括时间序列生成[[301](Biblography.xhtml#Xwiese2021multi),
    [302](Biblography.xhtml#Xwiese2020quant)]，交易模型调优[[176](Biblography.xhtml#Xkoshiyama2021generative)]，投资组合管理[[196](Biblography.xhtml#Xlu2022autoencoding)]，合成数据生成[[17](Biblography.xhtml#Xassefa2020generating)]以及各种类型的欺诈检测[[261](Biblography.xhtml#Xsethia2018data)]。其核心思想是通过生成器和判别器互相竞争，从而提升自身能力：生成器通过变得更擅长从随机噪声中生成接近真实数据的样本（即，好的样本）而提升，而判别器则通过能够识别真实数据和“假数据”（即生成的数据）来提升。生成器和判别器通常都是构建为神经网络，并具有待优化的超参数。数学上，给定一个生成器(⋅*,*𝜃^()和一个判别器(⋅*,*𝜃^()，其中𝜃^(和𝜃^(表示超参数，问题可以表述为如下：
- en: '| ![ { } min max 𝔼x∼ℙdata [log ((x;𝜃 )]+ 𝔼z∼ℙ ) [log (1− ((z;𝜃);𝜃 ))] , 𝜃 𝜃
    (⋅,𝜃 ](img/file1258.jpg) |  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| ![ { } min max 𝔼x∼ℙdata [log ((x;𝜃 )]+ 𝔼z∼ℙ ) [log (1− ((z;𝜃);𝜃 ))] , 𝜃 𝜃
    (⋅,𝜃 ](img/file1258.jpg) |  |'
- en: where x ∼ℙ[data] means some sample x generated from the original dataset, whereas
    z ∼ℙ [refers to sample generated from the generator . We refer the interested
    reader to  [[95](Biblography.xhtml#Xeckerli2021generative)] for an overview of
    the advantages and the pitfalls of GANs in finance. Given this popularity and
    the existence of quantum neural networks (Chapter [8](Chapter_8.xhtml#x1-1620008)),
    it is thus natural to explore the question of whether GANs can be extended to
    the quantum world, and whether there is any advantage in doing so.]
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 x ∼ℙ[data] 表示从原始数据集中生成的某个样本 x，而 z ∼ℙ [表示从生成器生成的样本。我们建议有兴趣的读者参考[[95](Biblography.xhtml#Xeckerli2021generative)]，了解生成对抗网络在金融中的优点和陷阱。鉴于其流行以及量子神经网络的存在（第[8](Chapter_8.xhtml#x1-1620008)章），因此探索生成对抗网络是否可以扩展到量子世界，以及这样做是否存在任何优势，显得十分自然。
- en: 'The main principles of Quantum Generative Adversarial Network (QGAN) – introduced
    simultaneously by Lloyd and Weedbrook  [[192](Biblography.xhtml#Xlloyd2018quantum)]
    and by Dallaire-Demers and Killoran  [[77](Biblography.xhtml#Xdallaire2018quantum)]
    – remain the same, relying on two actors, a generator and a discriminator, competing
    against each other. In  [[192](Biblography.xhtml#Xlloyd2018quantum)], the authors
    translated the classical problem in the language of density matrices (described
    in Section [1.3.1](Chapter_1.xhtml#x1-420001)): Given some data represented by
    a density matrix *σ* (not necessarily describing a pure state) and a generator 
    generating some output density matrix *ρ*, the discriminator is tasked with identifying
    the true data from the fake one. More precisely, it makes a positive operator-valued
    measurement (Section [1.2.3](Chapter_1.xhtml#x1-380003)) with outcomes T (for
    True) or  (for False). The probability that the measurement yields a positive
    answer given the true data is'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 量子生成对抗网络（QGAN）的主要原则——由Lloyd和Weedbrook[[192](Biblography.xhtml#Xlloyd2018quantum)]以及Dallaire-Demers和Killoran[[77](Biblography.xhtml#Xdallaire2018quantum)]同时提出——保持不变，依赖于两个参与者，生成器和判别器，相互竞争。在[[192](Biblography.xhtml#Xlloyd2018quantum)]中，作者将经典问题转化为密度矩阵的语言（在[1.3.1](Chapter_1.xhtml#x1-420001)节中描述）：给定一些由密度矩阵*σ*（不一定描述纯态）表示的数据和生成器生成的输出密度矩阵*ρ*，判别器的任务是从假数据中识别真实数据。更具体地，它通过正算符值测量（见[1.2.3](Chapter_1.xhtml#x1-380003)节）产生结果T（代表真实）或（代表假）。给定真实数据，测量得出正向答案的概率是
- en: '![ℙ(T |σ ) = (Tσ ), ](img/file1259.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![ℙ(T |σ ) = (Tσ ), ](img/file1259.jpg)'
- en: while the probability that it yields a positive answer given generated data
    is
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 给定生成数据的情况下，它得出正向答案的概率是
- en: '![ℙ(T|) = (T ρ). ](img/file1260.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![ℙ(T|) = (T ρ). ](img/file1260.jpg)'
- en: The adversarial game, similarly to the classical case, therefore reads
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对抗游戏，与经典情况类似，因此可表示为
- en: '| ![ { } min max (T ρ)− (Tσ ) . T ](img/file1261.jpg) |  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| ![ { } min max (T ρ)− (Tσ ) . T ](img/file1261.jpg) |  |'
- en: Note that both the set of positive measurement operators T (with 1-norm less
    than one) and the set of density matrices *ρ* are convex, ensuring that the optimisation
    problem ([13.2](#x1-2410002)) admits at least one optimum. However, these two
    sets are infinite dimensional, making the optimisation problem hard to solve.
    Following similar arguments, Dallaire-Demers and Killoran  [[77](Biblography.xhtml#Xdallaire2018quantum)]
    further proposed to model both the generator and the discriminator as variational
    quantum circuits parameterised by some vector of parameters describing, for example,
    the rotation angles of all the gates. A natural question then is whether some
    optimal architecture of variational quantum circuit might exist. While there is
    no clear answer at this stage – as far as we know – recent developments have improved
    our understanding and the power of such circuits.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，正测量算符集T（其1-范数小于1）和密度矩阵集*ρ*是凸集，这确保了优化问题([13.2](#x1-2410002))至少存在一个最优解。然而，这两个集合是无限维的，使得优化问题难以求解。通过类似的论证，Dallaire-Demers和Killoran[[77](Biblography.xhtml#Xdallaire2018quantum)]进一步提出将生成器和判别器建模为由描述旋转角度等参数的参数化变分量子电路。一个自然的问题是是否存在某种最优的变分量子电路架构。尽管目前没有明确答案——据我们所知——近期的发展已改善了我们对这种电路的理解和其能力。
- en: 'Starting from *n* qubits, a quantum generator : ℂ^(2^n) →ℂ^(2^n) takes the
    form of a multi-layer quantum neural network, for example of the following form:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从*n*个量子比特开始，一个量子生成器： ℂ^(2^n) →ℂ^(2^n) 采取多层量子神经网络的形式，例如如下所示：
- en: '| ![ ∏1 := Ul(𝜃l). l=L ](img/file1262.jpg) |  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| ![ ∏1 := Ul(𝜃l). l=L ](img/file1262.jpg) |  |'
- en: 'For each layer *l* ∈{1*,…,L*}, the unitary gate U[l](𝜃[l]) acts on all *n*
    qubits at the same time, and depends on a vector of parameters (or hyperparameters) 𝜃[l].
    In order to avoid (too expensive) high-order qubit gates, entanglement takes the
    form of pairwise controlled unitary gates, and we therefore assume that, for each
    *l* ∈{1*,…,L*}, U[l] is composed of one- or two-qubit gates only. One possible
    (though not the only one) way to parameterise U[l] is with the following principles
    in mind:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一层*l* ∈{1*,…,L*}，单元门U[l](𝜃[l])同时作用于所有*n*个量子比特，并依赖于一组参数（或超参数）𝜃[l]。为了避免（过于昂贵的）高阶量子比特门，纠缠采用成对控制单元门的形式，因此我们假设，对于每个*l*
    ∈{1*,…,L*}，U[l]仅由一比特或二比特门组成。一种可能的（虽然不是唯一的）参数化U[l]的方法是基于以下原则：
- en: any one-qubit unitary gate can be decomposed into a sequence of three rotation
    gates R[Z], R[X] and R[Y], as proved in  [[223](Biblography.xhtml#XNielsen2010), Theorem
    4.1];
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何一个比特单元门都可以分解成三个旋转门R[Z]、R[X]和R[Y]的序列，如在[[223](Biblography.xhtml#XNielsen2010)，定理4.1]中所证明；
- en: following  [[256](Biblography.xhtml#Xschuld2020circuit)], *imprimitive* two-qubit
    gates (i.e., two-qubit gates that map product states to non-product states), together
    with one-qubit gates ensure quantum universality  [[47](Biblography.xhtml#Xbrylinski2002universal)].
    In particular the decomposition R[X](*𝜃*)Q(*ϕ*) is universal  [[47](Biblography.xhtml#Xbrylinski2002universal), Corollary 9.2],
    for *𝜃,ϕ* ∈ [0*,*2*π*), where
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照[[256](Biblography.xhtml#Xschuld2020circuit)]，*非原始*两比特门（即将乘积态映射到非乘积态的两比特门），结合单比特门，确保量子通用性[[47](Biblography.xhtml#Xbrylinski2002universal)]。特别地，分解式R[X](*𝜃*)Q(*ϕ*)是通用的[[47](Biblography.xhtml#Xbrylinski2002universal)，补充定理9.2]，其中*𝜃,
    ϕ* ∈ [0*,*2*π*)，在此
- en: '![ ⌊ ⌋ | 1 0 0 0 | || 0 1 0 0 || Q(ϕ) := | | . |⌈ 0 0 1 0 |⌉ 0 0 0 eiϕ ](img/file1263.jpg)'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![ ⌊ ⌋ | 1 0 0 0 | || 0 1 0 0 || Q(ϕ) := | | . |⌈ 0 0 1 0 |⌉ 0 0 0 eiϕ ](img/file1263.jpg)'
- en: The general form of the *L*-layer neural network is therefore ([13.2](#x1-2410002)),
    where each layer gate U[l](𝜃[l]) takes the form
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*L*层神经网络的一般形式为([13.2](#x1-2410002))，其中每层门U[l](𝜃[l])的形式为
- en: '| ![ {⊗n } Ul(𝜃l) = RX(𝜃ie)Q1+(i mod n)(𝜃iimp) i=1 {( n ) ( n ) ( n ) } ⊗ R
    (𝜃i ) ⊗ R (𝜃i ) ⊗ R (𝜃i ) , i=1 Z Z,l i=1 X X,l i=1 Y Y,l ](img/file1264.jpg)
    |  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| ![ {⊗n } Ul(𝜃l) = RX(𝜃ie)Q1+(i mod n)(𝜃iimp) i=1 {( n ) ( n ) ( n ) } ⊗ R
    (𝜃i ) ⊗ R (𝜃i ) ⊗ R (𝜃i ) , i=1 Z Z,l i=1 X X,l i=1 Y Y,l ](img/file1264.jpg)
    |  |'
- en: where Q^i means that qubit *i* is the control qubit and the gate acts on qubit (*i*
    + 1). Note that 1 + (*i *mod* n*) = 1 + *i* when *i* ∈{1*,…,n*− 1} and is equal
    to 1 when *i* = *n*. The total number of hyperparameters is therefore 5*n* per
    layer, thus 5*nL* in total. The discriminator itself may or may not be of quantum
    nature (following a construction similar to the generator), depending on the problem
    at hand (it is in  [[18](Biblography.xhtml#Xassouel2021quantum)] but not in  [[268](Biblography.xhtml#Xsitu2020quantum)]
    for example), and the nature of the problem – in particular the potential need
    to encode/decode data from quantum to classical (with a high cost) may influence
    this choice.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 其中Q^i表示比特*i*是控制比特，门作用于比特(*i* + 1)。注意，1 + (*i *mod* n*) = 1 + *i* 当 *i* ∈{1*,…,n*−
    1} 时，并且当 *i* = *n* 时等于1。因此，每层的超参数总数为5*n*，总共为5*nL*。判别器本身可能是量子性质的，也可能不是（遵循类似生成器的构造），具体取决于实际问题（例如，它在[[18](Biblography.xhtml#Xassouel2021quantum)]中有，但在[[268](Biblography.xhtml#Xsitu2020quantum)]中没有），并且问题的性质
    – 尤其是可能需要将数据从量子编码/解码为经典（成本较高）可能会影响这一选择。
- en: The finite-dimensional optimisation ([13.2](#x1-2410002)) is usually carried
    out via some gradient descent method; the gradients themselves are computed via
    separate quantum circuits in  [[77](Biblography.xhtml#Xdallaire2018quantum)],
    or rather – more efficiently – using the parameter-shift rule, explained in Section [8.2.3](Chapter_8.xhtml#x1-1670003)
    (see also  [[257](Biblography.xhtml#XSchuld2018)]), which allows for an exact
    computation of the gradient from the original circuit.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有限维优化([13.2](#x1-2410002))通常通过某些梯度下降方法进行；梯度本身是通过在[[77](Biblography.xhtml#Xdallaire2018quantum)]中的独立量子电路计算的，或者更高效地
    – 使用在[8.2.3](Chapter_8.xhtml#x1-1670003)节中解释的参数偏移规则（参见[[257](Biblography.xhtml#XSchuld2018)]），该规则允许通过原始电路精确计算梯度。
- en: 'QGANs are a very new and active research area, and promise to be one where
    NISQ-based algorithms will be particularly fruitful. They are intimately linked
    with developments of QNNs as a whole, and current advances in the field relate
    to the following, which we encourage the reader to follow closely over the next
    few years:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: QGANs是一个非常新的活跃研究领域，预计NISQ基础的算法将在此领域特别有成果。它们与QNNs的整体发展密切相关，当前该领域的进展涉及以下内容，我们鼓励读者在未来几年密切关注：
- en: 'QGAN to generate probability distributions: we refer the interested reader
    to  [[18](Biblography.xhtml#Xassouel2021quantum), [268](Biblography.xhtml#Xsitu2020quantum), [314](Biblography.xhtml#XZoufal2019)]
    for univariate distributions, mostly in the context of finance, and to  [[5](Biblography.xhtml#Xagliardi2022optimal), [312](Biblography.xhtml#Xzhu2021generative)]
    for multivariate distributions;'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QGAN用于生成概率分布：我们建议感兴趣的读者参考[[18](Biblography.xhtml#Xassouel2021quantum)，[268](Biblography.xhtml#Xsitu2020quantum)，[314](Biblography.xhtml#XZoufal2019)]，主要是在金融领域的单变量分布，以及[[5](Biblography.xhtml#Xagliardi2022optimal)，[312](Biblography.xhtml#Xzhu2021generative)]，涉及多变量分布；
- en: 'Quantum Convolutional Neural Networks: In  [[160](Biblography.xhtml#Xkerenidis2019quantum)],
    the authors show how to handle non-linearities in (quantum) deep neural networks;
     [[69](Biblography.xhtml#Xcong2019quantum),  [300](Biblography.xhtml#Xwei2022quantum)]
    explain how reduce the number of required gates (equivalently, the number of rotation
    parameters) in the circuit, and  [[142](Biblography.xhtml#Xhur2022quantum)] highlights
    the importance and sufficiency of two-qubit interactions, more amenable to NISQ
    devices;'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 量子卷积神经网络：在[[160](Biblography.xhtml#Xkerenidis2019quantum)]中，作者展示了如何处理（量子）深度神经网络中的非线性问题；[[69](Biblography.xhtml#Xcong2019quantum)，[300](Biblography.xhtml#Xwei2022quantum)]解释了如何减少电路中所需的门数量（即旋转参数的数量），而[[142](Biblography.xhtml#Xhur2022quantum)]强调了两比特交互的重要性和充分性，更适用于NISQ设备；
- en: 'Quantum Wasserstein GAN: In  [[55](Biblography.xhtml#Xchakrabarti2019quantum)]
    – mimicking recent results in classical Wasserstein GANs  [[13](Biblography.xhtml#Xarjovsky2017wasserstein), [121](Biblography.xhtml#Xgulrajani2017improved)]
    – the authors introduced a Wasserstein semimetric between quantum data, which
    they use to reduce the number of required quantum gates.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 量子Wasserstein GAN：在[[55](Biblography.xhtml#Xchakrabarti2019quantum)]中——模仿经典Wasserstein
    GAN的最新结果[[13](Biblography.xhtml#Xarjovsky2017wasserstein)，[121](Biblography.xhtml#Xgulrajani2017improved)]——作者引入了量子数据之间的Wasserstein半度量，用于减少所需量子门的数量。
- en: 13.3 Bayesian Quantum Circuit
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3 贝叶斯量子电路
- en: Parameterised quantum circuits can be used to construct a quantum state with
    desired properties and to modify it in a controlled way. Measuring the final state
    is then equivalent to drawing a sample from a probability distribution in a form
    of a bitstring. This is the key concept behind the Quantum Circuit Born Machine
    (QCBM) we considered in Chapter [9](Chapter_9.xhtml#x1-1850009). The Bayesian
    Quantum Circuit (BQC) is another quantum generative machine learning model that
    extends the capabilities of QCBM  [[88](Biblography.xhtml#XDu2018)]. Unlike QCBM
    that operates only on *data* qubits encoding the desired probability distribution,
    BQC has additional *ancillary* qubits encoding the *prior* distribution. The BQC
    circuit is shown in Figure [13.5](#13.5).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化量子电路可以用来构造具有期望特性的量子态，并以受控的方式对其进行修改。然后，测量最终的量子态相当于从概率分布中绘制一个比特串样本。这是我们在第[9](Chapter_9.xhtml#x1-1850009)章中考虑的量子电路Born机（QCBM）背后的关键概念。贝叶斯量子电路（BQC）是另一种量子生成式机器学习模型，扩展了QCBM的功能[[88](Biblography.xhtml#XDu2018)]。与仅在*数据*量子比特上操作并编码期望概率分布的QCBM不同，BQC具有额外的*辅助*量子比特，编码*先验*分布。BQC电路如图[13.5](#13.5)所示。
- en: '![Figure 13.5: Schematic representation of BQC. ](img/file1265.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5：BQC的示意图。](img/file1265.jpg)'
- en: 'Figure 13.5: Schematic representation of BQC.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5：BQC的示意图。
- en: The first *m* quantum registers in the circuit are ancillary qubits. After applying
    *K* operator blocks U(*γ*^i)[i=1,…,K], to the initial state ![|0⟩](img/file1266.jpg)^(⊗m),
    we construct the state ![|ψ ⟩](img/file1267.jpg),
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 电路中的前*m*个量子寄存器是辅助量子比特。应用*K*操作符块U(*γ*^i)[i=1,…,K]到初始态![|0⟩](img/file1266.jpg)^(⊗m)之后，我们构造出态![|ψ
    ⟩](img/file1267.jpg)，
- en: '| ![ K &#124;ψ⟩ = ∏ U(γi) &#124;0⟩⊗m , i=1 ](img/file1268.jpg) |  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| ![ K &#124;ψ⟩ = ∏ U(γi) &#124;0⟩⊗m , i=1 ](img/file1268.jpg) |  |'
- en: and measuring it generates a sample from the prior distribution.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 并通过测量该态生成来自先验分布的样本。
- en: The next *n* quantum registers are data qubits. Quantum gates operating on them
    are conditional on the states of the ancillary qubits. Conditionally applying
    *l* × *m* operator blocks to *n* data qubits, we obtain a state that is conditional
    on ![|ψ ⟩](img/file1269.jpg). Measuring it will generate a sample from the conditional
    distribution, which is exactly what is needed to realise a Bayesian model. Bayesian
    modelling allows us to infer a *posterior* distribution over the parameters 𝜃
    of the model given some observed data *D* using Bayes’ theorem  [[57](Biblography.xhtml#XChang2021)],
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的*n*个量子寄存器是数据量子比特。对它们进行的量子门操作依赖于辅助量子比特的状态。条件性地将*l* × *m*个操作符块应用到*n*个数据量子比特后，我们得到一个条件于![|ψ
    ⟩](img/file1269.jpg)的态。测量该态将生成来自条件分布的样本，这正是实现贝叶斯模型所需的。贝叶斯建模允许我们使用贝叶斯定理[[57](Biblography.xhtml#XChang2021)]根据一些观测数据*D*推断模型参数𝜃的*后验*分布。
- en: '| ![ℙ(𝜃&#124;D) = ℙ-(D-&#124;𝜃)ℙ(𝜃) = ∫-ℙ(D-&#124;𝜃-)ℙ-(𝜃)--, ℙ(D ) ℙ(D &#124;𝜃)ℙ(𝜃)d𝜃
    ](img/file1270.jpg) |  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| ![ℙ(𝜃&#124;D) = ℙ-(D-&#124;𝜃)ℙ(𝜃) = ∫-ℙ(D-&#124;𝜃-)ℙ-(𝜃)--, ℙ(D ) ℙ(D &#124;𝜃)ℙ(𝜃)d𝜃
    ](img/file1270.jpg) |  |'
- en: where ℙ(*D*|𝜃) is the likelihood, ℙ(*D*) is the marginal likelihood or evidence,
    and ℙ(𝜃) is the prior. We obtain ℙ(𝜃) by repeatedly measuring the state ![|ψ⟩](img/file1271.jpg)
    given by ([13.3](#x1-242002r3)), ℙ(*D*|𝜃) by repeatedly measuring the final state
    after applying the conditional operators U(*β*), and ℙ(*D*) by repeatedly measuring
    the final state after applying the operators U(*β*) unconditionally.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 其中ℙ(*D*|𝜃)是似然，ℙ(*D*)是边际似然或证据，ℙ(𝜃)是先验。我们通过反复测量由([13.3](#x1-242002r3))给出的状态![|ψ⟩](img/file1271.jpg)得到ℙ(𝜃)，通过反复测量在应用条件算符U(*β*)后的最终状态得到ℙ(*D*|𝜃)，并通过反复测量在无条件应用算符U(*β*)后的最终状态得到ℙ(*D*)。
- en: 'In the case of BQC, the prior is parameterised by the parameters γ := (*γ*¹*,…,γ*^K).
    The posterior can be used to model new unseen data, *D*^∗, using the *posterior*
    *predictive*  [[105](Biblography.xhtml#XFortuin2021)]:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于BQC，先验由参数γ := (*γ*¹*,…,γ*^K)进行参数化。后验可以用来通过*后验* *预测* [[105](Biblography.xhtml#XFortuin2021)]来建模新的未见数据，*D*^∗：
- en: '| ![ ∫ ℙ(D ∗&#124;D) = ℙ (D ∗&#124;𝜃)ℙ(𝜃&#124;D)d𝜃. ](img/file1272.jpg) |  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| ![ ∫ ℙ(D ∗&#124;D) = ℙ (D ∗&#124;𝜃)ℙ(𝜃&#124;D)d𝜃. ](img/file1272.jpg) |  |'
- en: This integral averages predictions of all plausible models weighted by posterior
    probability and is called the *Bayesian model average*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个积分对所有可能模型的预测进行加权平均，权重由后验概率给出，这叫做*贝叶斯模型平均*。
- en: The BQC can be trained by minimising the maximum mean discrepancy cost function
    described in Chapter [9](Chapter_9.xhtml#x1-1850009). In terms of expressive power,
    Du, Hsieh, Liu, and Tao  [[88](Biblography.xhtml#XDu2018)] showed that a better
    expressive power of BQC is obtained in comparison with MPQC from a computational
    complexity perspective.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: BQC可以通过最小化第[9](Chapter_9.xhtml#x1-1850009)章中描述的最大均值差异成本函数进行训练。在表现力方面，Du、Hsieh、Liu和Tao
    [[88](Biblography.xhtml#XDu2018)]展示了与MPQC相比，从计算复杂度角度来看，BQC具有更强的表现力。
- en: Bayesian networks can be used for financial asset price forecasting  [[21](Biblography.xhtml#XBack2019), [56](Biblography.xhtml#XChandra2021)],
    predicting dynamics of limit order book market  [[199](Biblography.xhtml#XMagris2022)],
    predicting corporate bankruptcy  [[52](Biblography.xhtml#XCao2022)], and to model,
    analyse, and understand trading behaviour  [[282](Biblography.xhtml#XTicknor2013)].
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 贝叶斯网络可以用于金融资产价格预测 [[21](Biblography.xhtml#XBack2019)，[56](Biblography.xhtml#XChandra2021)]，预测限价单市场的动态
    [[199](Biblography.xhtml#XMagris2022)]，预测企业破产 [[52](Biblography.xhtml#XCao2022)]，以及建模、分析和理解交易行为
    [[282](Biblography.xhtml#XTicknor2013)]。
- en: The Bayesian Quantum Circuit model extends the capabilities of parameterised
    quantum circuits trained as generative models (QCBM) through the addition of ancillary
    quantum registers encoding the prior distribution. As a result, it achieves greater
    expressive power than MPQC.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 贝叶斯量子电路模型通过增加编码先验分布的辅助量子寄存器，扩展了作为生成模型（QCBM）训练的参数化量子电路的能力。因此，它比MPQC具有更强的表现力。
- en: 13.4 Quantum Semidefinite Programming
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4 量子半正定规划
- en: In Semidefinite Programming (SDP), one optimises a linear function subject to
    the constraint that an affine combination of symmetric matrices is positive semidefinite.
    Such a constraint is non-linear and non-smooth, but convex, so semidefinite programs
    are convex optimisation problems. Semidefinite programming unifies several standard
    problems (e.g., linear and quadratic programming) and finds many applications
    in engineering and combinatorial optimisation  [[292](Biblography.xhtml#XVandenberghe1996)].
    Similarly to finding a quantum counterpart to the classical kernel method, we
    can specify a quantum version of the SDP.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在半正定规划（SDP）中，优化一个线性函数，受限于对称矩阵的仿射组合是正半定的这一约束。这样的约束是非线性和非光滑的，但却是凸的，因此半正定规划是凸优化问题。半正定规划统一了几种标准问题（例如线性规划和二次规划），并在工程和组合优化中找到许多应用
    [[292](Biblography.xhtml#XVandenberghe1996)]。类似于寻找经典核方法的量子对应物，我们可以指定SDP的量子版本。
- en: 13.4.1 Classical semidefinite programming
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.4.1 经典半正定规划
- en: 'The SDP can be generally defined as the following optimisation problem:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: SDP通常可以定义为以下优化问题：
- en: '| ![ max Tr(CX ), subject to Tr(AjX ) ≤ bj, for all j ∈ [[M ]], X∈ℳ+N(ℝ) ](img/file1273.jpg)
    |  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| ![ max Tr(CX ), subject to Tr(AjX ) ≤ bj, for all j ∈ [[M ]], X∈ℳ+N(ℝ) ](img/file1273.jpg)
    |  |'
- en: where [[*M*]] := {1*,…,M*}, ℳ[n]^+(ℝ) denotes the set of positive semidefinite
    matrices of size *N* ×*N*. Here, Hermitian matrices (A[j])[j=1,…,M] and C in ℳ[N](ℝ),
    and (*b*[j])[j∈[[M]]] ∈ℝ^M are the inputs of the problem.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 其中[[*M*]] := {1*,…,M*}，ℳ[n]^+(ℝ)表示大小为*N* × *N*的正半定矩阵集合。这里，厄米矩阵(A[j])[j=1,…,M]和C位于ℳ[N](ℝ)中，(*b*[j])[j∈[[M]]]
    ∈ℝ^M是问题的输入。
- en: SDP can be applied to complex NP-hard optimisation problems  [[112](Biblography.xhtml#XGoemans1997)],
    such as various portfolio optimisation problems. For example, it is typically
    an unrealistic assumption that the distribution of asset returns is known exactly.
    The necessary information may not be complete and estimates are subject to estimation
    errors as well as modelling errors (e.g., an assumption of stationarity of the
    distributions).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: SDP 可应用于复杂的 NP 难优化问题 [[112](Biblography.xhtml#XGoemans1997)]，例如各种投资组合优化问题。例如，通常认为资产收益的分布是已知的，这是一种不现实的假设。所需的信息可能不完整，估计也可能受到估计误差和建模误差的影响（例如，假设分布是平稳的）。
- en: 13.4.2 Maximum risk analysis
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.4.2 最大风险分析
- en: The classical maximum risk analysis problem, assuming there is uncertainty in
    the estimate of the covariance matrix of asset returns, Σ, can be formulated as
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 假设资产收益协方差矩阵 Σ 的估计存在不确定性，经典的最大风险分析问题可以表述为
- en: '| ![ ⊤ L U Σ∈mℳa+x(ℝ)w Σw, subject to Σij ≤ Σij ≤ Σ ij, for all i,j ∈ [[N ]],
    N ](img/file1274.jpg) |  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| ![ ⊤ L U Σ∈mℳa+x(ℝ)w Σw, subject to Σij ≤ Σij ≤ Σ ij, for all i,j ∈ [[N ]],
    N ](img/file1274.jpg) |  |'
- en: 'where w is the fixed vector of weights and Σ is the problem variable. For each
    *i,j* ∈ [[*N*]], the matrices Σ[ij]^L and Σ[ij]^U are fixed constraints in ℳ[N]^+(ℝ).
    The task is to establish the maximum possible portfolio risk for the known asset
    allocation, given uncertainty in the estimate of covariance matrix of asset returns.
    The problem can be expressed as the following SDP  [[229](Biblography.xhtml#XPaini2018)]:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，w 是固定的权重向量，Σ 是问题变量。对于每个 *i,j* ∈ [[*N*]]，矩阵 Σ[ij]^L 和 Σ[ij]^U 是 ℳ[N]^+(ℝ)
    中的固定约束条件。任务是确定已知资产配置下，给定资产收益协方差矩阵估计的不确定性，最大可能的投资组合风险。该问题可以表示为以下的 SDP [[229](Biblography.xhtml#XPaini2018)]：
- en: '| ![ max Tr(w ⊤Σw ) , Σ∈ℳ+N(ℝ) ({ L subject to Tr(− EijΣ) ≤ − Σ ij, for all
    (i,j) ∈ [[N ]]× [[N ]], ( Tr(EijΣ ) ≤ ΣU , ij ](img/file1275.jpg) |  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| ![ max Tr(w ⊤Σw ) , Σ∈ℳ+N(ℝ) ({ L subject to Tr(− EijΣ) ≤ − Σ ij, for all
    (i,j) ∈ [[N ]]× [[N ]], ( Tr(EijΣ ) ≤ ΣU , ij ](img/file1275.jpg) |  |'
- en: where we denote (*E*[ij])[αβ] := *δ*[iα]*δ*[jβ]. The maximum risk analysis problem
    can be expressed in the same form with different risk measures such as VaR or
    Expected Shortfall.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 其中我们表示 (*E*[ij])[αβ] := *δ*[iα]*δ*[jβ]。最大风险分析问题可以用相同的形式表达，只是使用不同的风险度量，如 VaR
    或预期短缺。
- en: 13.4.3 Robust portfolio construction
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.4.3 稳健投资组合构建
- en: The robust portfolio construction problem aims at finding an asset allocation
    method that would achieve the minimum *estimation error* in the suggested asset
    allocation weights. This problem has been addressed in  [[194](Biblography.xhtml#XMLDP2019)]
    using Monte Carlo simulations to determine the most robust asset allocation method
    with respect to small changes in the input covariance matrix for the given portfolio.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 稳健投资组合构建问题旨在找到一种资产配置方法，使得建议的资产配置权重在估计误差最小化方面表现最优。该问题在 [[194](Biblography.xhtml#XMLDP2019)]
    中通过蒙特卡罗模拟方法得以解决，从而确定了对于给定投资组合中输入协方差矩阵的小变化，最稳健的资产配置方法。
- en: In the most general case, it can be formulated as the Min-Max problem
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在最一般的情况下，它可以被表述为最小-最大问题
- en: '| ![min max w ⊤Σw, w∈𝒲 Σ∈𝒮 ](img/file1276.jpg) |  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| ![min max w ⊤Σw, w∈𝒲 Σ∈𝒮 ](img/file1276.jpg) |  |'
- en: with
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: '| 𝒮 | := ![{](img/file1277.jpg)Σ ∈ℳ[N]^+(ℝ) : Σ [ij]^L ≤ Σ [ij] ≤ Σ[ij]^U*,*
    for all *i,j* ∈ [[*N*]]![}](img/file1278.jpg)*,* |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 𝒮 | := ![{](img/file1277.jpg)Σ ∈ℳ[N]^+(ℝ) : Σ [ij]^L ≤ Σ [ij] ≤ Σ[ij]^U*,*
    for all *i,j* ∈ [[*N*]]![}](img/file1278.jpg)*,* |'
- en: '| 𝒲 | := ![{ N ⊤ ⊤ } w ∈ ℝ : 1 w = 1, μ w ≥ Rmin](img/file1279.jpg)*,* |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 𝒲 | := ![{ N ⊤ ⊤ } w ∈ ℝ : 1 w = 1, μ w ≥ Rmin](img/file1279.jpg)*,* |'
- en: where w is the vector of weights, *μ* is the vector of expected asset returns,
    and Σ is the covariance matrix of asset returns.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 w 是权重向量，*μ* 是预期资产收益向量，Σ 是资产收益的协方差矩阵。
- en: 'The following theorem (first proven by von Neumann  [[297](Biblography.xhtml#XvonNeumann28)]
    in 1928) establishes the equivalence of the Min-Max and Max-Min optimisation problems  [[288](Biblography.xhtml#XTuy2004)]:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定理（最早由冯·诺依曼于 1928 年证明 [[297](Biblography.xhtml#XvonNeumann28)]) 确立了最小最大和最大最小优化问题的等价性
    [[288](Biblography.xhtml#XTuy2004)]：
- en: '**Theorem 11** (Minimax Theorem)**.** *Let* 𝒳 ⊂ℝ^n *and* 𝒴 ⊂ℝ^m *be compact*
    *convex sets. If the function* *f* : 𝒳 ×𝒴 →ℝ *is continuous and concave in **x*
    *for fixed **y* *and continuous and convex in **y* *for fixed **x**, then*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**定理 11**（最小最大定理）**.** *设* 𝒳 ⊂ℝ^n *且* 𝒴 ⊂ℝ^m *是紧致的* *凸集。如果函数* *f* : 𝒳 ×𝒴 →ℝ
    *对于固定的**y* 以**x* 为变量是连续的且凹的，并且对于固定的**x*，以**y* 为变量是连续的且凸的，则*'
- en: '![min max f (x, y) = max minf (x, y). y∈𝒴 x∈𝒳 x∈ 𝒳 y∈𝒴 ](img/file1280.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![min max f (x, y) = max minf (x, y). y∈𝒴 x∈𝒳 x∈ 𝒳 y∈𝒴 ](img/file1280.jpg)'
- en: Therefore, in general, the Min-Max robust portfolio construction problem (which
    is convex in w and concave in Σ) is equivalent to the Max-Min problem and can
    be expressed for the constraints above as an SDP in all variables  [[229](Biblography.xhtml#XPaini2018)].
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一般来说，最小-最大鲁棒投资组合构建问题（在 *w* 中是凸的，在 *Σ* 中是凹的）等价于最大-最小问题，并且可以表达为上述约束下的一个 SDP
    形式，涵盖所有变量[[229](Biblography.xhtml#XPaini2018)]。
- en: 13.4.4 Quantum semidefinite programming
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.4.4 量子半定规划
- en: The key idea behind Quantum Semidefinite Programming (QSDP) is based on the
    observation that a normalised positive semidefinite matrix can be naturally represented
    as a quantum state. Operations on quantum states can sometimes be computationally
    cheaper to perform on a quantum computer than classical matrix operations. This
    idea prompted the development of quantum algorithms for SDPs  [[42](Biblography.xhtml#XBrandao2016)].
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 量子半定规划（QSDP）背后的关键思想是基于这样一个观察：一个归一化的正半定矩阵可以自然地表示为量子态。在量子计算机上，量子态的操作有时比经典矩阵操作在计算上更为廉价。这一思想促使了针对
    SDPs 的量子算法的发展[[42](Biblography.xhtml#XBrandao2016)]。
- en: Consider the SDP ([13.4.1](#x1-2440001)) and let *𝜀 >* 0 be small. An algorithm
    is called an *𝜀*-*approximate quantum SDP oracle*  [[290](Biblography.xhtml#XJvA2018)]
    if for all inputs *g* ∈ℝ and *ζ* ∈ (0*,*1), it finds, with success probability
    1 −*ζ*, a vector y ∈ℝ^(M+1) and a real number *z* such that for the density matrix
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 SDP ([13.4.1](#x1-2440001)) 并设 *𝜀 >* 0 为一个小值。如果对于所有输入 *g* ∈ ℝ 和 *ζ* ∈ (0,
    1)，该算法能以成功概率 1 −*ζ* 找到一个向量 y ∈ ℝ^(M+1) 和一个实数 *z*，使得对于密度矩阵
- en: '| ![ ( ) ∑M ρ = ---e(xp--−(---j=1yjAj-+-y0C--)), Tr exp − ∑M y A + y C j=1
    j j 0 ](img/file1281.jpg) |  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| ![ ( ) ∑M ρ = ---e(xp--−(---j=1yjAj-+-y0C--)), Tr exp − ∑M y A + y C j=1
    j j 0 ](img/file1281.jpg) |  |'
- en: we have that *zρ* is an *𝜀*-feasible solution with objective value at least
    *g* − *𝜀*, that is
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到 *zρ* 是一个 *𝜀*-可行解，其目标值至少为 *g* − *𝜀*，即
- en: '| ![( { Tr(z ρAj) ≤ bj + 𝜀, for all j ∈ [[M ]], ( Tr(z ρC) ≥ g − 𝜀, ](img/file1282.jpg)
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| ![( { Tr(z ρAj) ≤ bj + 𝜀, 对所有 j ∈ [[M ]], ( Tr(z ρC) ≥ g − 𝜀, ](img/file1282.jpg)
    |'
- en: or concludes that no such *z* and y exist even if we set *𝜀* = 0.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 或者得出结论，即使我们设定 *𝜀* = 0，也不存在这样的 *z* 和 y。
- en: A general QSDP-solver for sparse matrices was implemented by Brandão and Svore  [[42](Biblography.xhtml#XBrandao2016)]
    using the Arora-Kale framework  [[14](Biblography.xhtml#XArora2016)]. They observed
    that the density matrix *ρ* in ([13.4.4](#x1-2470004)) is in fact a log(*N*)-qubit
    Gibbs state and can be efficiently prepared as a quantum state on a quantum computer.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Brandão 和 Svore 在 Arora-Kale 框架[[14](Biblography.xhtml#XArora2016)]下实现了一个通用的稀疏矩阵
    QSDP 求解器[[42](Biblography.xhtml#XBrandao2016)]。他们观察到，密度矩阵*ρ* 在 ([13.4.4](#x1-2470004))
    中实际上是一个对数(*N*)-量子比特的吉布斯状态，并且可以高效地在量子计算机上准备为量子态。
- en: The reader should already be familiar with the Gibbs state (Gibbs distribution)
    in the form
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 读者应已熟悉吉布斯态（吉布斯分布）形式
- en: '| ![ − βℋ ρ = -e------, Tr(e− βℋ) ](img/file1283.jpg) |  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| ![ − βℋ ρ = -e------, Tr(e− βℋ) ](img/file1283.jpg) |  |'
- en: where ℋ is the problem Hamiltonian and Tr(exp(−*β*ℋ)) is the partition function.
    The Gibbs (Boltzmann) sampling and the Gibbs (Boltzmann) distribution were discussed
    in Chapter [5](Chapter_5.xhtml#x1-960005) (in ([5.4.1](Chapter_5.xhtml#x1-1090001))
    and ([5.4.1](Chapter_5.xhtml#x1-1090001))). The form of the partition function
    in ([13.4.4](#x1-2470004)) should not be confusing. Recall from ([10.1](Chapter_10.xhtml#x1-2030001)),
    that since the Hamiltonian is a Hermitian operator, its spectral decomposition
    yields the representation
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ℋ 是问题哈密顿量，Tr(exp(−*β*ℋ)) 是配分函数。吉布斯（玻尔兹曼）采样和吉布斯（玻尔兹曼）分布在第[5](Chapter_5.xhtml#x1-960005)章讨论过（在
    ([5.4.1](Chapter_5.xhtml#x1-1090001)) 和 ([5.4.1](Chapter_5.xhtml#x1-1090001))
    中）。配分函数的形式在 ([13.4.4](#x1-2470004)) 中不应令人困惑。回顾 ([10.1](Chapter_10.xhtml#x1-2030001))，由于哈密顿量是一个厄米算符，其谱分解产生的表示是
- en: '| ![ ∑ ℋ = Ei &#124;ψi⟩⟨ψi&#124;, i ](img/file1284.jpg) |  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| ![ ∑ ℋ = Ei &#124;ψi⟩⟨ψi&#124;, i ](img/file1284.jpg) |  |'
- en: 'which gives the following expression for the Gibbs state:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该密度矩阵给出了吉布斯态的以下表达式：
- en: '| ![ e−βℋ 1 ∑ ρ = -----= -- e−βEi &#124;ψi⟩⟨ψi&#124;, Z Z i ](img/file1285.jpg)
    |  |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| ![ e−βℋ 1 ∑ ρ = -----= -- e−βEi &#124;ψi⟩⟨ψi&#124;, Z Z i ](img/file1285.jpg)
    |  |'
- en: where the partition function *Z* is given by
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 其中配分函数 *Z* 为
- en: '![ ( ) ∑ Z = Tr e− βℋ = e− βEi. i ](img/file1286.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![ ( ) ∑ Z = Tr e− βℋ = e− βEi. i ](img/file1286.jpg)'
- en: QSDP gives a square-root unconditional speedup over any classical method for
    solving SDPs both in *N* and *M*  [[42](Biblography.xhtml#XBrandao2016)].
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: QSDP 相较于任何经典方法，在求解 SDP 问题上提供了平方根无条件加速，无论是在 *N* 还是 *M* 维度上[[42](Biblography.xhtml#XBrandao2016)]。
- en: Quantum Semidefinite Programming is yet another example where quantum speedup
    can be achieved since operations on quantum states performed on a quantum computer
    are less computationally expensive than the corresponding matrix operations on
    a classical computer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 量子半定规划是另一个可以通过量子加速实现的例子，因为在量子计算机上对量子态进行的运算，比在经典计算机上进行相应的矩阵运算要计算开销小得多。
- en: We would like to finish this chapter (and the book!) with a glance beyond the
    capabilities of the NISQ computers. The last section presents several important
    algorithms which, one day, will become the main building blocks of many quantum
    computing applications.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望以一瞥超越 NISQ 计算机能力的视角来结束本章（以及本书！）。最后一节介绍了几种重要的算法，这些算法有一天将成为许多量子计算应用的主要构建模块。
- en: 13.5 Beyond NISQ
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5 超越 NISQ
- en: In this section, we start with describing the workhorse of many important quantum
    algorithms, the Quantum Fourier Transform (QFT), before moving to its flagship
    application, the Quantum Phase Estimation (QPE), and then discussing the possibility
    of achieving quantum speedup with the Quantum Monte Carlo (QMC) and the Quantum
    Linear Solver (QLS) algorithms.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本节开始介绍许多重要量子算法的核心部分——量子傅里叶变换（QFT），然后转向其旗舰应用——量子相位估计（QPE），最后讨论如何通过量子蒙特卡洛（QMC）和量子线性求解器（QLS）算法实现量子加速的可能性。
- en: 13.5.1 Quantum Fourier Transform
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.5.1 量子傅里叶变换
- en: In the classical setting, the discrete Fourier transform maps a vector x :=
    (*x*[0]*,…,x*[2^n−1]) ∈ℂ^(2^n) to a vector y := (*y*[0]*,…,y*[2^n−1]) ∈ℂ^(2^n)
    , the components of which read
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典设置中，离散傅里叶变换将向量 x := (*x*[0]*,…,x*[2^n−1]) ∈ℂ^(2^n) 映射到向量 y := (*y*[0]*,…,y*[2^n−1])
    ∈ℂ^(2^n)，其分量为
- en: '| ![ n 1 2∑−1 ( 2πijk) n yk = √-n- exp -2n--- xj, for each k = 0,...,2 − 1\.
    2 j=0 ](img/file1287.jpg) |  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| ![ n 1 2∑−1 ( 2πijk) n yk = √-n- exp -2n--- xj, 对每个 k = 0,...,2 − 1\. 2 j=0
    ](img/file1287.jpg) |  |'
- en: Similarly, the quantum Fourier transform is the linear map
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，量子傅里叶变换是线性映射
- en: '| ![ 1 2∑n−1 ( 2πikj ) &#124;k⟩ ↦− → √-n- exp --n--- &#124;j⟩ , 2 j=0 2 ](img/file1288.jpg)
    |  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| ![ 1 2∑n−1 ( 2πikj ) &#124;k⟩ ↦− → √-n- exp --n--- &#124;j⟩ , 2 j=0 2 ](img/file1288.jpg)
    |  |'
- en: and the operator
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 和运算符
- en: '![ 2n−1 ( ) ℱ := √1---∑ exp 2πikj- |j⟩⟨k| q 2n 2n k,j=0 ](img/file1289.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![ 2n−1 ( ) ℱ := √1---∑ exp 2πikj- |j⟩⟨k| q 2n 2n k,j=0 ](img/file1289.jpg)'
- en: represents the Fourier transform matrix which is unitary as qℱqℱ^† = ℐ. In an
    *n*-qubit system with basis (![|0⟩](img/file1290.jpg)*,…,*![|2n − 1⟩](img/file1291.jpg)),
    for a given state ![|j⟩](img/file1292.jpg), we use the binary representation
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 表示傅里叶变换矩阵，它是单位矩阵，因为 qℱqℱ^† = ℐ。在一个 *n* 比特系统中，基态为 (![|0⟩](img/file1290.jpg)*,…,*![|2n
    − 1⟩](img/file1291.jpg))，对于给定的态 ![|j⟩](img/file1292.jpg)，我们使用二进制表示
- en: '| ![j := j-⋅⋅⋅j-, 1 n ](img/file1293.jpg) |  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| ![j := j-⋅⋅⋅j-, 1 n ](img/file1293.jpg) |  |'
- en: with (*j*[1]*,…,j*[n]) ∈{0*,*1}^n so that ![|j⟩](img/file1294.jpg) = ![|j1⋅⋅⋅jn⟩](img/file1295.jpg)
    = ![|j1⟩](img/file1296.jpg)⊗*…*⊗![|jn⟩](img/file1297.jpg). Likewise, the notation
    0*.j*[1]*j*[2]*…j*[n] represents the binary fraction ∑ [i=1]^n2^(−i)*j*[i]. Elementary
    algebra (see  [[223](Biblography.xhtml#XNielsen2010), Section 5.1] for details)
    then yields
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 (*j*[1]*,…,j*[n]) ∈{0*,*1}^n，使得 ![|j⟩](img/file1294.jpg) = ![|j1⋅⋅⋅jn⟩](img/file1295.jpg)
    = ![|j1⟩](img/file1296.jpg)⊗*…*⊗![|jn⟩](img/file1297.jpg)。同样，符号 0*.j*[1]*j*[2]*…j*[n]
    表示二进制小数 ∑ [i=1]^n2^(−i)*j*[i]。基础代数（参见 [[223](Biblography.xhtml#XNielsen2010)，第5.1节]
    了解详细信息）得出
- en: '| ![ --1- ( 2πi0.jn ) ( 2πi0.jn−1jn ) qℱ &#124;j⟩ = √2n- &#124;0⟩+ e &#124;1⟩
    ⊗ &#124;0 ⟩+ e &#124;1⟩ ⊗ ⋅⋅⋅ ( ------ ) ⋅⋅⋅⊗ &#124;0⟩ + e2πi0.j1...jn &#124;1⟩
    . ](img/file1298.jpg) |  |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| ![ --1- ( 2πi0.jn ) ( 2πi0.jn−1jn ) qℱ &#124;j⟩ = √2n- &#124;0⟩+ e &#124;1⟩
    ⊗ &#124;0 ⟩+ e &#124;1⟩ ⊗ ⋅⋅⋅ ( ------ ) ⋅⋅⋅⊗ &#124;0⟩ + e2πi0.j1...jn &#124;1⟩
    . ](img/file1298.jpg) |  |'
- en: 13.5.2 Quantum Phase Estimation
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.5.2 量子相位估计
- en: The goal of QPE is to estimate the unknown phase *φ* ∈ [0*,*1) for a given unitary
    operator 𝒰 with an eigenvector ![|u⟩](img/file1299.jpg) and eigenvalue exp(2*π*i*φ*).
    Consider a register of size *m* and define
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: QPE 的目标是估计给定单位算符 𝒰 的未知相位 *φ* ∈ [0*,*1)，该算符具有特征向量 ![|u⟩](img/file1299.jpg) 和特征值
    exp(2*π*i*φ*)。考虑一个大小为 *m* 的寄存器，并定义
- en: '![ { ---------} b∗ := sup j = 2m 0.j1 ⋅⋅⋅jm . j≤2m φ ](img/file1300.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![ { ---------} b∗ := sup j = 2m 0.j1 ⋅⋅⋅jm . j≤2m φ ](img/file1300.jpg)'
- en: Thus with *b*^∗ = *b*[1]![⋅⋅⋅](img/file1301.jpg)*b*[m], we obtain that 2^(−m)*b*^∗
    = 0*.b*[1]![⋅⋅⋅](img/file1302.jpg)*b*[m] is the best *m*-bit approximation of *φ*
    from below. The QPE procedure uses two registers, with the first containing *m*
    qubits initially in the state ![|0⟩](img/file1303.jpg). Selecting *m* relies on
    the number of digits of accuracy for the estimate of *φ*, and the probability
    with which we wish to obtain a successful phase estimation procedure.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用 *b*^∗ = *b*[1]![⋅⋅⋅](img/file1301.jpg)*b*[m]，我们得到2^(−m)*b*^∗ = 0*.b*[1]![⋅⋅⋅](img/file1302.jpg)*b*[m]是*φ*的最佳*m*-位下界近似。QPE过程使用两个寄存器，第一个包含*m*个量子比特，初始状态为![|0⟩](img/file1303.jpg)。选择*m*依赖于对*φ*的估计精度的位数，以及希望成功进行相位估计过程的概率。
- en: QPE allows us to implement a measurement for any Hermitian operator. Note that
    we always measure individual qubits. If we want to measure a more complex observable,
    we can use a QPE that implements the von Neumann’s measurement scheme  [[212](Biblography.xhtml#XMello2013)].
    The routine prepares an eigenstate of the Hermitian operator in one register and
    stores the corresponding eigenvalue in a second register.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: QPE允许我们对任何厄米算符实施测量。请注意，我们总是测量单个量子比特。如果我们想要测量更复杂的可观察量，可以使用实现冯·诺依曼测量方案的QPE [[212](Biblography.xhtml#XMello2013)]。该例程在一个寄存器中准备厄米算符的特征状态，并在第二个寄存器中存储相应的特征值。
- en: Up to a SWAP transformation, the quantum phase circuit  [[223](Biblography.xhtml#XNielsen2010), Section 5.2]
    gives the output
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 经过SWAP变换后，量子相位电路[[223](Biblography.xhtml#XNielsen2010)，第5.2节]给出了输出
- en: '| ![ 1 ( 2πi0.φm ) ( 2πi0.φm−-1φm- ) &#124;ψ⟩ = √-m-- &#124;0⟩+ e &#124;1⟩
    ⊗ &#124;0⟩+ e &#124;1⟩ ⊗ ⋅⋅⋅ 2 ( ------- ) ⋅⋅⋅⊗ &#124;0⟩+ e2πi0.φ1...φm &#124;1⟩
    , ](img/file1304.jpg) |  |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| ![ 1 ( 2πi0.φm ) ( 2πi0.φm−-1φm- ) &#124;ψ⟩ = √-m-- &#124;0⟩+ e &#124;1⟩
    ⊗ &#124;0⟩+ e &#124;1⟩ ⊗ ⋅⋅⋅ 2 ( ------- ) ⋅⋅⋅⊗ &#124;0⟩+ e2πi0.φ1...φm &#124;1⟩
    , ](img/file1304.jpg) |  |'
- en: which is exactly equal to the QFT for the state ![ m |2 φ⟩](img/file1305.jpg)
    = ![|φ1φ2 ...φm⟩](img/file1306.jpg) as in ([13.5.1](#x1-2490001)), and therefore
    ![|ψ ⟩](img/file1307.jpg) = qℱ![|2m φ⟩](img/file1308.jpg). Since the QFT is a
    unitary transformation, we can inverse the process to retrieve ![ m |2 φ⟩](img/file1309.jpg).
    Algorithm [10](#x1-250008r10) below provides pseudocode for the QPE procedure,
    and we refer the interested reader to  [[223](Biblography.xhtml#XNielsen2010), Chapter
    5.2] for detailed explanations.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 它与状态![ m |2 φ⟩](img/file1305.jpg) = ![|φ1φ2 ...φm⟩](img/file1306.jpg)的QFT完全相等，如([13.5.1](#x1-2490001))所示，因此![|ψ
    ⟩](img/file1307.jpg) = qℱ![|2m φ⟩](img/file1308.jpg)。由于QFT是一个单位变换，我们可以逆向操作以恢复![
    m |2 φ⟩](img/file1309.jpg)。下面的算法[10](#x1-250008r10)提供了QPE过程的伪代码，感兴趣的读者可以参考[[223](Biblography.xhtml#XNielsen2010)，第5.2章]以获取详细的解释。
- en: '![--------------------------------------------------------------------- -Algorithm---10:-Quantum--Phase-Estimation---------------------------
    Input: • Unitary matrix (gate) U with U |u⟩ = e2πiφ |u⟩; • m ancilla qubits initialised
    at |0 ⟩. ⊗m 1: Prepare the initial state with |0⟩ being the m -qubit ancilla register
    and |u⟩ being the n -qubit eigenstate register. 2: Map to 2m− 1 √-1-- ∑ |j⟩ |u
    ⟩ 2m j=0 with Hadamard gates applied to the ancilla register. 3: Map to 2m∑− 1
    2m∑ −1 √-1-- |j⟩Uj |u⟩ = √1-- |j⟩e2πijφ |u ⟩ 2m j=0 2m j=0 with Controlled Uj
    gates applied to the eigenstate register. 4: Compute |φ^⟩ |u⟩ using the inverse
    QFT, where φ^is an m -qubit approximation of φ. 5: Measure to deduceφ^. Result:
    Phase estimate ^φ. ---------------------------------------------------------------------
    ](img/file1310.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![--------------------------------------------------------------------- -算法---10:-量子-相位-估计---------------------------
    输入：• 单位矩阵（门）U，其中U |u⟩ = e2πiφ |u⟩； • m个辅助量子位初始化为|0 ⟩。 ⊗m 1: 准备初始状态，其中|0⟩为m量子比特辅助寄存器，|u⟩为n量子比特特征状态寄存器。
    2: 使用Hadamard门对辅助寄存器进行操作，将其映射到2m− 1 √-1-- ∑ |j⟩ |u ⟩ 2m j=0。 3: 使用控制Uj门将其映射到2m∑−
    1 2m∑ −1 √-1-- |j⟩Uj |u⟩ = √1-- |j⟩e2πijφ |u ⟩ 2m j=0 2m j=0。 4: 使用逆量子傅里叶变换（QFT）计算|φ^⟩
    |u⟩，其中φ^是φ的m量子比特近似值。 5: 测量得到φ^。 结果：相位估计^φ。 ---------------------------------------------------------------------
    ](img/file1310.jpg)'
- en: 13.5.3 Monte Carlo speedup
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.5.3 蒙特卡罗加速
- en: Leveraging on the speedup provided by the Quantum Phase Estimation, Montanaro  [[216](Biblography.xhtml#XMontanaro_QSpeedup)]
    devised a Monte Carlo scheme providing quantum speedup compared to the classical
    one.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 利用量子相位估计提供的加速，Montanaro [[216](Biblography.xhtml#XMontanaro_QSpeedup)] 设计了一种蒙特卡罗方案，相比经典方法提供量子加速。
- en: Classical Monte Carlo
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 经典蒙特卡罗
- en: 'Monte Carlo techniques represent a wide array of methods to simulate statistics
    of random processes. We refer the interested reader to the excellent monograph  [[111](Biblography.xhtml#Xglasserman2004monte)]
    for a full description and analysis. Consider a one-dimensional random variable *X*
    and a function *ϕ* : ℝ → [0*,*1] such that both 𝔭 := 𝔼[*ϕ*(*X*)] and *σ*² := 𝕍[*ϕ*(*X*)]
    are well defined. By the Central Limit Theorem, given an iid collection of random
    variables (*X*[1]*,…,X*[N]) distributed as *X*, then'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '蒙特卡洛技术代表了一系列模拟随机过程统计的广泛方法。我们推荐感兴趣的读者参考出色的专著 [[111](Biblography.xhtml#Xglasserman2004monte)]，以获得完整的描述和分析。考虑一个一维随机变量
    *X* 和一个函数 *ϕ* : ℝ → [0*,*1]，使得 𝔭 := 𝔼[*ϕ*(*X*)] 和 *σ*² := 𝕍[*ϕ*(*X*)] 都是良好定义的。根据中心极限定理，给定一组独立同分布的随机变量
    (*X*[1]*,…,X*[N])，它们的分布与 *X* 相同，则'
- en: '![√ --^𝔭N-−-𝔭- N σ ](img/file1311.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![√ --^𝔭N-−-𝔭- N σ ](img/file1311.jpg)'
- en: converges to a centered Gaussian with unit variance 𝒩(0*,*1) as *N* tends to
    infinity, where 𝔭[N] := ![1- N](img/file1312.jpg) ∑ [i=1]^N*X*[i] is the empirical
    mean. This implies that, for any *𝜀 >* 0, we can estimate
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *N* 趋于无穷时，收敛到具有单位方差的中心高斯分布 𝒩(0*,*1)，其中 𝔭[N] := ![1- N](img/file1312.jpg) ∑
    [i=1]^N*X*[i] 是经验均值。这意味着，对于任意 *𝜀 >* 0，我们可以估计
- en: '![ ( √ --) (||^ || ) 𝜀--N- ℙ 𝔭N − 𝔭 ≤ 𝜀 = ℙ |𝒩 (0,1)| ≤ σ , ](img/file1313.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![ ( √ --) (||^ || ) 𝜀--N- ℙ 𝔭N − 𝔭 ≤ 𝜀 = ℙ |𝒩 (0,1)| ≤ σ , ](img/file1313.jpg)'
- en: so that, for any *z >* 0 and *δ* ∈ (0*,*1), in order to get an estimate of the
    form ℙ![(| | ) |^𝔭N − 𝔭| ≤ z](img/file1314.jpg) = 1 − *δ*, we need *N* = 𝒪(1*∕𝜀*²)
    samples.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于任意 *z >* 0 和 *δ* ∈ (0*,*1)，为了得到形式为 ℙ![(| | ) |^𝔭N − 𝔭| ≤ z](img/file1314.jpg)
    = 1 − *δ* 的估计，我们需要 *N* = 𝒪(1*∕𝜀*²) 个样本。
- en: Quantum Monte Carlo
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 量子蒙特卡洛
- en: Consider now an operator 𝒜 of the form
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个形式为 𝒜 的算子
- en: '![ ⊗n ∑ 𝒜 |0⟩ = αx |ψx⟩ |x⟩, x∈{0,1}k ](img/file1315.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![ ⊗n ∑ 𝒜 |0⟩ = αx |ψx⟩ |x⟩, x∈{0,1}k ](img/file1315.jpg)'
- en: 'for some *k* ≤ *n*, where each ![|ψx⟩](img/file1316.jpg) is a quantum state
    with *n*−*k* qubits and ![|x⟩](img/file1317.jpg) a quantum state with *k* qubits,
    and *α*[x] ∈ℂ is some amplitude, the meaning of which will be made clear below.
    We simply assume that {![|ψx⟩](img/file1318.jpg)}[x∈{0,1}^k] forms an orthogonal
    family and are in fact "garbage qubits", i.e., qubits that are, for example, used
    as controlled to build the solution vector ![|x⟩](img/file1319.jpg) from the data.
    Given the encoded data ![|x⟩](img/file1320.jpg), assume further the existence
    of the operator 𝒲:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某个 *k* ≤ *n*，其中每个 ![|ψx⟩](img/file1316.jpg) 是一个具有 *n*−*k* 量子位的量子态，![|x⟩](img/file1317.jpg)
    是一个具有 *k* 量子位的量子态，*α*[x] ∈ℂ 是某个幅度，其含义将在下文明确。我们假设 {![|ψx⟩](img/file1318.jpg)}[x∈{0,1}^k]
    形成一个正交家族，实际上是“垃圾量子位”，即例如用作受控量子位来根据数据构建解向量 ![|x⟩](img/file1319.jpg)。给定编码数据 ![|x⟩](img/file1320.jpg)，进一步假设存在算子
    𝒲：
- en: '![ ( ∘ -------- ∘ ---- ) 𝒲 |x⟩ |0⟩ = |x⟩ 1− ϕ (x) |0⟩ + ϕ(x) |1⟩ . ](img/file1321.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![ ( ∘ -------- ∘ ---- ) 𝒲 |x⟩ |0⟩ = |x⟩ 1− ϕ (x) |0⟩ + ϕ(x) |1⟩ . ](img/file1321.jpg)'
- en: This can be achieved for example by using the following lemma.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以通过使用以下引理来实现这一点。
- en: '**Lemma 9** (Conditional Rotation. Theorem 3.5 in  [[184](Biblography.xhtml#XLandman2021)])**.**
    *Given a quantum state *![|ψa ⟩](img/file1322.jpg)*, encoding* *a* ∈ [−1*,*−1]
    *in **q* *qubits, there exists a* *quantum circuit performing the unitary mapping*
    ![|ψ ⟩ a](img/file1323.jpg)![|0⟩](img/file1324.jpg)![↦−→](img/file1325.jpg)![|ψ
    ⟩ a](img/file1326.jpg)![(](img/file1327.jpg)*a*![|0⟩](img/file1328.jpg) + ![√
    ------ 1− a2](img/file1329.jpg)![ |1⟩](img/file1330.jpg)![)](img/file1331.jpg)*.*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**引理 9**（条件旋转。定理 3.5 在 [[184](Biblography.xhtml#XLandman2021)])）**。** *给定一个量子态 *![|ψa
    ⟩](img/file1322.jpg)*，编码* *a* ∈ [−1*,*−1] *在**q* *量子位中，存在一个量子电路执行单位映射* ![|ψ ⟩
    a](img/file1323.jpg)![|0⟩](img/file1324.jpg)![↦−→](img/file1325.jpg)![|ψ ⟩ a](img/file1326.jpg)![(](img/file1327.jpg)*a*![|0⟩](img/file1328.jpg)
    + ![√ ------ 1− a2](img/file1329.jpg)![ |1⟩](img/file1330.jpg)![)](img/file1331.jpg)*.*'
- en: 'Consider now the operator ℳ:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑算子 ℳ：
- en: '![ ( ) ( ) ℳ := ℐn− k ⊗ 𝒲 𝒜 ⊗ ℐ , ](img/file1332.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![ ( ) ( ) ℳ := ℐn− k ⊗ 𝒲 𝒜 ⊗ ℐ , ](img/file1332.jpg)'
- en: where ℐ^(n−k) means the identity operator acting on *n* − *k* qubits, so that
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ℐ^(n−k) 表示作用在 *n* − *k* 量子位上的单位算子，因此
- en: '| ![&#124;ψ⟩](img/file1333.jpg) | := ℳ![&#124;0⟩](img/file1334.jpg)^(⊗(n+1))
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| ![&#124;ψ⟩](img/file1333.jpg) | := ℳ![&#124;0⟩](img/file1334.jpg)^(⊗(n+1))
    |'
- en: '|  | = ![(](img/file1335.jpg)ℐ^(n−k) ⊗𝒲![)](img/file1336.jpg)![( ) ∑ ( αx &#124;ψx⟩
    &#124;x⟩) x∈{0,1}k](img/file1337.jpg)![&#124;0⟩](img/file1338.jpg) |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '|  | = ![(](img/file1335.jpg)ℐ^(n−k) ⊗𝒲![)](img/file1336.jpg)![( ) ∑ ( αx &#124;ψx⟩
    &#124;x⟩) x∈{0,1}k](img/file1337.jpg)![&#124;0⟩](img/file1338.jpg) |'
- en: '|  | = ∑ [x∈{0,1}^k]*α*[x]![(](img/file1339.jpg)ℐ^(n−k) ⊗𝒲![)](img/file1340.jpg)![&#124;ψx
    ⟩](img/file1341.jpg)![&#124;x⟩](img/file1342.jpg)![&#124;0⟩](img/file1343.jpg)
    |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '|  | = ∑ [x∈{0,1}^k]*α*[x]![(](img/file1339.jpg)ℐ^(n−k) ⊗𝒲![)](img/file1340.jpg)![&#124;ψx
    ⟩](img/file1341.jpg)![&#124;x⟩](img/file1342.jpg)![&#124;0⟩](img/file1343.jpg)
    |'
- en: '|  | = ∑ [x∈{0,1}^k]*α*[x]![&#124;ψx⟩](img/file1344.jpg)![&#124;x⟩](img/file1345.jpg)![(∘
    -------- ∘ ---- ) 1− ϕ(x) &#124;0⟩ + ϕ(x) &#124;1⟩](img/file1346.jpg) |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '|  | = ∑ [x∈{0,1}^k]*α*[x]![&#124;ψx⟩](img/file1344.jpg)![&#124;x⟩](img/file1345.jpg)![(∘
    -------- ∘ ---- ) 1− ϕ(x) &#124;0⟩ + ϕ(x) &#124;1⟩](img/file1346.jpg) |'
- en: '|  | =: ![&#124;ΨB ⟩](img/file1347.jpg)![&#124;0⟩](img/file1348.jpg) + ![&#124;ΨG
    ⟩](img/file1349.jpg)![&#124;1⟩](img/file1350.jpg)*,* | (13.5.1) |  |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '|  | =: ![&#124;ΨB ⟩](img/file1347.jpg)![&#124;0⟩](img/file1348.jpg) + ![&#124;ΨG
    ⟩](img/file1349.jpg)![&#124;1⟩](img/file1350.jpg)*,* | (13.5.1) |  |'
- en: where ![|Ψ ⟩ B](img/file1351.jpg),
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ![|Ψ ⟩ B](img/file1351.jpg),
- en: '| ![ ∑ ∘ -------- &#124;ΨB ⟩ := αx 1− ϕ (x ) &#124;ψx⟩ &#124;x⟩, x∈ {0,1}k
    ](img/file1352.jpg) |  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| ![ ∑ ∘ -------- &#124;ΨB ⟩ := αx 1− ϕ (x ) &#124;ψx⟩ &#124;x⟩, x∈ {0,1}k
    ](img/file1352.jpg) |  |'
- en: stands for the ‘bad’ state, and ![|ΨG ⟩](img/file1353.jpg),
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 代表“坏”状态，并且 ![|ΨG ⟩](img/file1353.jpg),
- en: '| ![ ∑ ∘ ---- &#124;ΨG ⟩ := αx ϕ(x) &#124;ψx⟩ &#124;x⟩, x∈{0,1}k ](img/file1354.jpg)
    |  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| ![ ∑ ∘ ---- &#124;ΨG ⟩ := αx ϕ(x) &#124;ψx⟩ &#124;x⟩, x∈{0,1}k ](img/file1354.jpg)
    |  |'
- en: stands for the ‘good’ state.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 代表“好”状态。
- en: Consider now the projector 𝒫 := ℐ^n![|1⟩](img/file1355.jpg)⟨1| and measure the
    probability of the last qubit of ![|ψ⟩](img/file1356.jpg) to be in state ![|1⟩](img/file1357.jpg),
    namely
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑投影算符 𝒫 := ℐ^n![|1⟩](img/file1355.jpg)⟨1| 并测量最后一个量子比特 ![|ψ⟩](img/file1356.jpg)处于状态 ![|1⟩](img/file1357.jpg)的概率，即
- en: '| ⟨*ψ*&#124;𝒫^†𝒫![&#124;ψ ⟩](img/file1358.jpg) | = ⟨*ψ*&#124;𝒫![&#124;ψ⟩](img/file1359.jpg)
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| ⟨*ψ*&#124;𝒫^†𝒫![&#124;ψ ⟩](img/file1358.jpg) | = ⟨*ψ*&#124;𝒫![&#124;ψ⟩](img/file1359.jpg)
    |'
- en: '|  | = ![(](img/file1360.jpg)⟨0&#124;⟨Ψ[B]&#124; + ⟨1&#124;⟨Ψ[G]&#124;![)](img/file1361.jpg)𝒫![(](img/file1362.jpg)![&#124;Ψ
    ⟩ B](img/file1363.jpg)![&#124;0⟩](img/file1364.jpg) + ![&#124;Ψ ⟩ G](img/file1365.jpg)![&#124;1⟩](img/file1366.jpg)![)](img/file1367.jpg)
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|  | = ![(](img/file1360.jpg)⟨0&#124;⟨Ψ[B]&#124; + ⟨1&#124;⟨Ψ[G]&#124;![)](img/file1361.jpg)𝒫![(](img/file1362.jpg)![&#124;Ψ
    ⟩ B](img/file1363.jpg)![&#124;0⟩](img/file1364.jpg) + ![&#124;Ψ ⟩ G](img/file1365.jpg)![&#124;1⟩](img/file1366.jpg)![)](img/file1367.jpg)
    |'
- en: '|  | = ![(](img/file1368.jpg)⟨0&#124;⟨Ψ[B]&#124; + ⟨1&#124;⟨Ψ[G]&#124;![)](img/file1369.jpg)![(](img/file1370.jpg)![&#124;ΨB
    ⟩](img/file1371.jpg)![&#124;1⟩](img/file1372.jpg)![ ⟨1&#124;0⟩](img/file1373.jpg)
    + ![&#124;ΨG ⟩](img/file1374.jpg)![&#124;1⟩](img/file1375.jpg)![ ⟨1&#124;1⟩](img/file1376.jpg)![)](img/file1377.jpg)
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '|  | = ![(](img/file1368.jpg)⟨0&#124;⟨Ψ[B]&#124; + ⟨1&#124;⟨Ψ[G]&#124;![)](img/file1369.jpg)![(](img/file1370.jpg)![&#124;ΨB
    ⟩](img/file1371.jpg)![&#124;1⟩](img/file1372.jpg)![ ⟨1&#124;0⟩](img/file1373.jpg)
    + ![&#124;ΨG ⟩](img/file1374.jpg)![&#124;1⟩](img/file1375.jpg)![ ⟨1&#124;1⟩](img/file1376.jpg)![)](img/file1377.jpg)
    |'
- en: '|  | = ![(](img/file1378.jpg)⟨0&#124;⟨Ψ[B]&#124; + ⟨1&#124;⟨Ψ[G]&#124;![)](img/file1379.jpg)![&#124;ΨG
    ⟩](img/file1380.jpg)![ &#124;1⟩](img/file1381.jpg) |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '|  | = ![(](img/file1378.jpg)⟨0&#124;⟨Ψ[B]&#124; + ⟨1&#124;⟨Ψ[G]&#124;![)](img/file1379.jpg)![&#124;ΨG
    ⟩](img/file1380.jpg)![ &#124;1⟩](img/file1381.jpg) |'
- en: '|  | = ⟨0&#124;![⟨ΨB &#124;ΨG ⟩](img/file1382.jpg)![&#124;1⟩](img/file1383.jpg)
    + ⟨1&#124;![⟨ΨG &#124;ΨG ⟩](img/file1384.jpg)![ &#124;1⟩](img/file1385.jpg) |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|  | = ⟨0&#124;![⟨ΨB &#124;ΨG ⟩](img/file1382.jpg)![&#124;1⟩](img/file1383.jpg)
    + ⟨1&#124;![⟨ΨG &#124;ΨG ⟩](img/file1384.jpg)![ &#124;1⟩](img/file1385.jpg) |'
- en: '|  | = ![⟨ΨB &#124;ΨG ⟩](img/file1386.jpg)![ ⟨0&#124;1⟩](img/file1387.jpg)
    + ![⟨ΨG &#124;ΨG ⟩](img/file1388.jpg)![ ⟨1&#124;1⟩](img/file1389.jpg) = &#124;Ψ[G]&#124;²*.*
    |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|  | = ![⟨ΨB &#124;ΨG ⟩](img/file1386.jpg)![ ⟨0&#124;1⟩](img/file1387.jpg)
    + ![⟨ΨG &#124;ΨG ⟩](img/file1388.jpg)![ ⟨1&#124;1⟩](img/file1389.jpg) = &#124;Ψ[G]&#124;²*.*
    |'
- en: Now, since the family {![|ψx⟩](img/file1390.jpg)}[x] is orthogonal, it is easy
    to see from ([13.5.3](#x1-253004r3)) that
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于{![|ψx⟩](img/file1390.jpg)}[x]这一家族是正交的，从 ([13.5.3](#x1-253004r3)) 可以很容易地看出
- en: '| &#124;Ψ[G]&#124;² | = ![⟨ΨG &#124;ΨG ⟩](img/file1391.jpg) |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| &#124;Ψ[G]&#124;² | = ![⟨ΨG &#124;ΨG ⟩](img/file1391.jpg) |'
- en: '|  | = ![( ) ∑ ∘ ---- ( α∗x ϕ(x)⟨x&#124;⟨ψx&#124;) x∈{0,1}k](img/file1392.jpg)![(
    ) ∑ ∘ ---- ( αy ϕ (y) &#124;ψy ⟩ &#124;y⟩) y∈{0,1}k](img/file1393.jpg) |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|  | = ![( ) ∑ ∘ ---- ( α∗x ϕ(x)⟨x&#124;⟨ψx&#124;) x∈{0,1}k](img/file1392.jpg)![(
    ) ∑ ∘ ---- ( αy ϕ (y) &#124;ψy ⟩ &#124;y⟩) y∈{0,1}k](img/file1393.jpg) |'
- en: '|  | = ∑ [x,y∈{0,1}^k]*α*[x]^∗*α* [y]![∘ ---- ϕ (x )](img/file1394.jpg)![∘
    ---- ϕ (y )](img/file1395.jpg)⟨x&#124;![⟨ψx&#124;ψy⟩](img/file1396.jpg)![&#124;y⟩](img/file1397.jpg)
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '|  | = ∑ [x,y∈{0,1}^k]*α*[x]^∗*α* [y]![∘ ---- ϕ (x )](img/file1394.jpg)![∘
    ---- ϕ (y )](img/file1395.jpg)⟨x&#124;![⟨ψx&#124;ψy⟩](img/file1396.jpg)![&#124;y⟩](img/file1397.jpg)
    |'
- en: '|  | = ∑ [x∈{0,1}^k]&#124;*α*[x]&#124;²*ϕ*(x)*,* |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '|  | = ∑ [x∈{0,1}^k]&#124;*α*[x]&#124;²*ϕ*(x)*,* |'
- en: which corresponds precisely to the expectation 𝔼[*ϕ*(*X*)] where the random
    variable *X* is discretised over the set with labels {0*,*1}^k, and where each |*α*[x]|²
    corresponds to the discrete probability of *X* being in x.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这正好对应于期望值 𝔼[*ϕ*(*X*)]，其中随机变量 *X* 在标签为 {0*,*1}^k 的集合上离散化，每个 |*α*[x]|² 对应于 *X*
    处于 x 的离散概率。
- en: In order to retrieve the expectation we are after, we therefore simply need
    to run the circuit corresponding to ℳ, measure the output in the computational
    basis, and determine the probability of observing the state ![|1⟩](img/file1398.jpg).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到我们需要的期望，我们因此只需运行对应于ℳ的电路，测量计算基中的输出，并确定观察到状态的概率![|1⟩](img/file1398.jpg)。
- en: QMC speedup
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: QMC加速
- en: The actual speedup of QMC resides in a subtle application of the *Amplitude*
    *Estimation* theorem and the *Powering Lemma*, which we present now.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: QMC的实际加速来自于对*振幅* *估计*定理和*幂法则*的微妙应用，下面我们将进行介绍。
- en: '**Theorem 12** (Amplitude Estimation. Theorem 12 in  [[43](Biblography.xhtml#Xbrassard2002quantum)])**.**
    *Assume that we have access to a quantum unitary operator *𝒰 *such that* 𝒰![|0⟩](img/file1399.jpg)
    = ![√----- 1 − 𝔭](img/file1400.jpg)![|ΨB ⟩](img/file1401.jpg)![|0⟩](img/file1402.jpg)+![√
    -- 𝔭](img/file1403.jpg)![|ΨG ⟩](img/file1404.jpg)![|1⟩](img/file1405.jpg)*, for
    some states *![|ΨB ⟩](img/file1406.jpg)*,*![|ΨG ⟩](img/file1407.jpg)*. Then,*
    *for any* *N* ∈ℕ*, the amplitude estimation algorithms outputs the estimate* 𝔭
    *such that*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**定理 12**（振幅估计。定理12见[[43](Biblography.xhtml#Xbrassard2002quantum)]）。*假设我们可以访问一个量子幺正操作符*
    𝒰 *，使得* 𝒰![|0⟩](img/file1399.jpg) = ![√----- 1 − 𝔭](img/file1400.jpg)![|ΨB ⟩](img/file1401.jpg)![|0⟩](img/file1402.jpg)+![√
    -- 𝔭](img/file1403.jpg)![|ΨG ⟩](img/file1404.jpg)![|1⟩](img/file1405.jpg)*，对于某些状态*![|ΨB
    ⟩](img/file1406.jpg)*，*![|ΨG ⟩](img/file1407.jpg)*。然后，*对于任意* *N* ∈ℕ*，振幅估计算法输出估计值*
    𝔭 *，使得'
- en: '![ ∘ -------- | | 𝔭(1 − 𝔭) π2 |^𝔭 − 𝔭| ≤ 2π----N-----+ N2- ](img/file1408.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![ ∘ -------- | | 𝔭(1 − 𝔭) π2 |^𝔭 − 𝔭| ≤ 2π----N-----+ N2- ](img/file1408.jpg)'
- en: '*with probability at least* 8*∕π*²*. To achieve this takes exactly **N* *iterations.*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*以至少* 8*∕π*²*的概率。这需要恰好**N* *次迭代。*'
- en: '**Lemma 10** (Powering Lemma. Lemma 6.1 in  [[150](Biblography.xhtml#Xjerrum1986random)])**.**
    *Let *𝔭 *be a quantity* *to estimate and *𝒰 *an algorithm that output* 𝔭 *such
    that* ![||^ || 𝔭 − 𝔭](img/file1409.jpg) ≤ *𝜀* *except* *with probability smaller
    than *1*∕*2*. Then, for any* *δ* ∈ (0*,*1)*, it suffices to* *repeat *𝒰 *about*
    𝒪(log(1*∕δ*)) *times and to take the median to obtain* ![|| || ^𝔭 − 𝔭](img/file1410.jpg)≤
    *𝜀* *with probability at least* 1 − *δ**.*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**引理 10**（幂法则。引理6.1见[[150](Biblography.xhtml#Xjerrum1986random)]）。*设* 𝔭 *为要估计的量，*
    𝒰 *为一个算法，输出* 𝔭 *，使得* ![||^ || 𝔭 − 𝔭](img/file1409.jpg) ≤ *𝜀* *，除非* *以小于* 1*∕2*的概率。然后，对于任意*
    *δ* ∈ (0*,*1)*，只需* *重复 *𝒰 *大约* 𝒪(log(1*∕δ*)) *次，并取中位数，以获得* ![|| || ^𝔭 − 𝔭](img/file1410.jpg)≤
    *𝜀* *，以至少* 1 − *δ**的概率。'
- en: In light of ([13.5.1](#x1-253004r1)), the Amplitude Estimation theorem, combined
    with the Powering Lemma, shows that in order to obtain an estimate of the empirical
    mean
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 根据([13.5.1](#x1-253004r1))，振幅估定理结合幂法则显示，为了获得经验均值的估计
- en: '![ † 2 ⟨ψ|𝒫 𝒫 |ψ ⟩ = |ΨG | ](img/file1411.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![ † 2 ⟨ψ|𝒫 𝒫 |ψ ⟩ = |ΨG | ](img/file1411.jpg)'
- en: with probability at least 1 − *δ* (for any *δ* ∈ (0*,*1)), i.e.,
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以至少1 − *δ*的概率（对于任意*δ* ∈ (0*,*1)），即，
- en: '![ℙ(||^𝔭− 𝔭|| ≤ 𝜀) ≥ 1− δ, ](img/file1412.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![ℙ(||^𝔭− 𝔭|| ≤ 𝜀) ≥ 1− δ, ](img/file1412.jpg)'
- en: it suffices to apply the operators ℳ and 𝒫 about 𝒪(*N* log(1*∕δ*)) times, with
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将操作符ℳ和𝒫应用大约𝒪(*N* log(1*∕δ*))次，其中
- en: '![ -------- ∘ 𝔭(1 − 𝔭) 𝜀 = 2π----------, N ](img/file1413.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![ -------- ∘ 𝔭(1 − 𝔭) 𝜀 = 2π----------, N ](img/file1413.jpg)'
- en: so that, for any fixed *δ* ∈ (0*,*1), the computational cost is of order 𝒪(1*∕𝜀*),
    achieving quadratic speedup compared to classical Monte Carlo.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，对于任意固定的*δ* ∈ (0*,*1)，计算成本的阶数为𝒪(1*∕𝜀*)，相比经典蒙特卡洛方法实现了二次加速。
- en: 13.5.4 Quantum Linear Solver
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.5.4 量子线性求解器
- en: 'Harrow, Hassidim and Lloyd  [[126](Biblography.xhtml#XHHL2009)] devised a quantum
    algorithm to solve linear systems, beating classical computation times. Linear
    systems are ubiquitous in applications, and many aspects of quantitative finance
    rely on being able to solve such (low- or high-dimensional) systems. We highlight
    below two key examples of fundamental importance in finance: solving Partial Differential
    Equations (PDEs) and portfolio optimisation.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Harrow、Hassidim和Lloyd [[126](Biblography.xhtml#XHHL2009)]设计了一种量子算法来求解线性系统，超越了经典计算时间。线性系统在应用中无处不在，许多定量金融的方面依赖于能够求解这样的（低维或高维）系统。我们在下面强调两个在金融中具有基础性重要性的关键示例：求解偏微分方程（PDE）和投资组合优化。
- en: Theoretical aspects
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 理论方面
- en: 'The problem can be stated as follows: given a matrix A ∈ℳ[N](ℂ) and a vector
    b ∈ℂ^N, find the vector x ∈ℂ^N such that'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 问题可以表述为：给定矩阵A ∈ℳ[N](ℂ)和向量b ∈ℂ^N，找到向量x ∈ℂ^N，使得
- en: '| ![Ax = b. ](img/file1414.jpg) |  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| ![Ax = b. ](img/file1414.jpg) |  |'
- en: In order for the algorithm to work, the matrix A needs to be Hermitian. If A
    is not so, we can nevertheless consider the augmented system
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使算法有效，矩阵A需要是厄米矩阵。如果A不是这样，我们仍然可以考虑扩展系统
- en: '![( ) ( ) ( ) (0N,N A ) (0N,1 ) = ( b ) , A † 0N,N x 0N,1 ](img/file1415.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![( ) ( ) ( ) (0N,N A ) (0N,1 ) = ( b ) , A † 0N,N x 0N,1 ](img/file1415.jpg)'
- en: similarly to the Hamiltonian embedding in Section [7.6](Chapter_7.xhtml#x1-1590006).
    We assume from now now that A is indeed Hermitian. The first step of the algorithm
    is to assume that the vector b can be encoded into a quantum state ![|b⟩](img/file1416.jpg)
    and to then rewrite ([13.5.4](#x1-2560004)) as
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于[7.6](Chapter_7.xhtml#x1-1590006)节中的哈密顿嵌入。我们从现在开始假设A确实是厄米的。算法的第一步是假设向量b可以被编码成量子态![|b⟩](img/file1416.jpg)，然后将([13.5.4](#x1-2560004))重写为
- en: '| ![A &#124;x⟩ = &#124;b⟩, ](img/file1417.jpg) |  |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| ![A &#124;x⟩ = &#124;b⟩, ](img/file1417.jpg) |  |'
- en: where we now look for the solution, not as an element of ℂ^N, but as a quantum
    state.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们寻找的解不再是ℂ^N的元素，而是一个量子态。
- en: Since A is Hermitian, it admits the spectral decomposition (Section [1.1.5](Chapter_1.xhtml#x1-280005))
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于A是厄米的，它承认谱分解（见[1.1.5](Chapter_1.xhtml#x1-280005)节）
- en: '![ N− 1 ∑ A = λj |ϕj⟩⟨ϕj|, j=0 ](img/file1418.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![ N− 1 ∑ A = λj |ϕj⟩⟨ϕj|, j=0 ](img/file1418.jpg)'
- en: where *λ*[0]*,…,λ*[N−1] are its (not necessarily distinct) strictly positive
    eigenvalues with corresponding eigenstates ![|ϕ0⟩](img/file1419.jpg)*,…,*![|ϕN
    −1⟩](img/file1420.jpg), and we immediately obtain that its inverse reads
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*λ*[0]*,…,*λ*[N−1]是其（不一定是不同的）严格正的特征值，对应的特征态为![|ϕ0⟩](img/file1419.jpg)*,…,*![|ϕN
    −1⟩](img/file1420.jpg)，我们立即得到其逆的表示为
- en: '![ N−1 A −1 = ∑ 1--|ϕ ⟩ ⟨ϕ |. j=0 λj j j ](img/file1421.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![ N−1 A −1 = ∑ 1--|ϕ ⟩ ⟨ϕ |. j=0 λj j j ](img/file1421.jpg)'
- en: We can also decompose ![|b ⟩](img/file1422.jpg) into the (![|ϕ ⟩ j](img/file1423.jpg))[j=0,…,N−1]
    basis as
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将![|b ⟩](img/file1422.jpg)分解为基态 (![|ϕ ⟩ j](img/file1423.jpg))[j=0,…,N−1]，如下所示：
- en: '![ N−1 |b⟩ = ∑ b |ϕ ⟩ , j=0 i j ](img/file1424.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![ N−1 |b⟩ = ∑ b |ϕ ⟩ , j=0 i j ](img/file1424.jpg)'
- en: and therefore the solution to ([13.5.4](#x1-2560004)) reads
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，([13.5.4](#x1-2560004))的解为
- en: '![ N− 1 |x⟩ = A −1 |b⟩ = ∑ bj-|ϕ ⟩. j=0 λj j ](img/file1425.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![ N− 1 |x⟩ = A −1 |b⟩ = ∑ bj-|ϕ ⟩. j=0 λj j ](img/file1425.jpg)'
- en: The goal of the QLS algorithm is thus to construct such a state, and we summarise
    it as Algorithm [11](#x1-256007r11) below. Note that, since A is Hermitian then,
    for any *t* ∈ℝ, U := exp(iA*t*) is unitary with decomposition
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，QLS算法的目标是构造这样的态，我们在下面总结了算法[11](#x1-256007r11)。请注意，由于A是厄米的，因此对于任何*t* ∈ℝ，U
    := exp(iA*t*)是幺正的，其分解为
- en: '![ N∑− 1 U = eiλjt |ϕj⟩⟨ϕj|. j=0 ](img/file1426.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![ N∑− 1 U = eiλjt |ϕj⟩⟨ϕj|. j=0 ](img/file1426.jpg)'
- en: In total, the QLS algorithm requires *n*[l] + *n*[b] + 1 qubits, where *n*[l]
    is the number of qubits used to encode the *n*[l]-bit binary representation of
    (*λ*[j])[j=0,…,N−1] and *n*[b] is the number of qubits used to convert b into ![|b
    ⟩](img/file1427.jpg) (and also the number of qubits to write the solution state).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，QLS算法需要*n*[l] + *n*[b] + 1个量子比特，其中*n*[l]是用于编码(*λ*[j])[j=0,…,N−1]的*n*[l]位二进制表示的量子比特数，*n*[b]是用于将b转换为![|b
    ⟩](img/file1427.jpg)的量子比特数（也是用于写出解态的量子比特数）。
- en: In terms of computation time, Harrow, Hassidim, and Lloyd showed that the stated
    runtime is of order poly(log(*N*)*,κ*) assuming that A is sparse with condition
    number *κ*, which yields an exponential speedup compared to the classical 𝒪(*N*![√--
    κ](img/file1428.jpg)) runtime.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算时间方面，Harrow、Hassidim和Lloyd证明，假设A是稀疏的且条件数为*κ*，则所述运行时间的阶为poly(log(*N*)*,κ*)，与经典的𝒪(*N*![√--
    κ](img/file1428.jpg))运行时间相比，提供了指数级的加速。
- en: '![--------------------------------------------------------------------- -Algorithm---11:-HHL--Quantum--Linear-Solver--------------------------
    Input: Hermitian matrix A and nl + nb + 1 qubits initialised at ⊗nl ⊗nb |0⟩ |0⟩
    |0⟩. 1: Load the data b into |b⟩ using n qubits (with N = 2nb). b 2: Apply QPE
    with U := exp(iAt), after which the quantum state of the register is N∑ −1 bj
    |λj⟩n |ϕj⟩n |0⟩ . j=0 l b 3: Rotate the ancillary qubit |0⟩ controlled by |λj⟩n
    to obtain l N∑− 1 ( ∘ ------2 ) bj |λj⟩ |ϕj⟩ 1 − C--|0⟩+ C-|1⟩ , j=0 nl nb λ2j
    λj for some normalising constant C (with |C | < minj λj). 4: Apply the inverse
    QPE to obtain N −1 ( ∘ ------- ) ∑ b |0⟩ |ϕ ⟩ 1− C2- |0⟩ + C--|1⟩ . j nl j nb
    λ2j λj j=0 5: Measure the ancillary qubit in the computational basis. If the outcome
    is |1⟩, the register is in the post- measurement state N∑− 1 C bi |0⟩n |ϕj⟩ ,
    j=0 λi l nb which up to a normalisation factor corresponds to the solution. Result:
    Solution |x⟩: N −1 −1 ∑ bj- |x⟩ = A |b ⟩ = λj |ϕj⟩. j=0 ---------------------------------------------------------------------
    ](img/file1429.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![--------------------------------------------------------------------- -算法---11:-HHL--量子--线性--求解器--------------------------
    输入：厄米矩阵 A 和 nl + nb + 1 个量子比特，初始化为 ⊗nl ⊗nb |0⟩ |0⟩ |0⟩。 1: 使用 n 个量子比特将数据 b 加载到
    |b⟩ 中（其中 N = 2nb）。 b 2: 应用量子相位估计（QPE），U := exp(iAt)，之后寄存器的量子态为 N∑ −1 bj |λj⟩n
    |ϕj⟩n |0⟩ . j=0 l b 3: 通过 |λj⟩n 控制的辅助量子比特 |0⟩ 旋转，得到 l N∑− 1 ( ∘ ------2 ) bj |λj⟩
    |ϕj⟩ 1 − C--|0⟩+ C-|1⟩ , j=0 nl nb λ2j λj 对某个归一化常数 C（|C | < minj λj）。 4: 应用逆量子相位估计，得到
    N −1 ( ∘ ------- ) ∑ b |0⟩ |ϕ ⟩ 1− C2- |0⟩ + C--|1⟩ . j nl j nb λ2j λj j=0 5:
    在计算基上测量辅助量子比特。如果结果为 |1⟩，则寄存器处于测量后的状态 N∑− 1 C bi |0⟩n |ϕj⟩ , j=0 λi l nb 该状态与解对应，直到归一化因子。
    结果：解 |x⟩: N −1 −1 ∑ bj- |x⟩ = A |b ⟩ = λj |ϕj⟩。 j=0 ---------------------------------------------------------------------
    ](img/file1429.jpg)'
- en: Solving PDEs
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 求解偏微分方程（PDEs）
- en: One important example is finite-difference schemes for partial differential
    equations; standard tools can be consulted in  [[269](Biblography.xhtml#Xsmith1985numerical)]
    for example, and specific applications to finance can be found in  [[89](Biblography.xhtml#Xduffy2013finite)].
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的例子是有限差分法用于求解偏微分方程；标准工具可以参考 [[269](Biblography.xhtml#Xsmith1985numerical)]，并且在金融领域的具体应用可见于
    [[89](Biblography.xhtml#Xduffy2013finite)]。
- en: 'Consider for example the Black-Scholes parabolic PDE:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑布莱克-斯科尔斯抛物型偏微分方程：
- en: '| ![ σ2- 2 2 ∂tVt + rS ∂SVt + 2 S ∂SSVt = rVt, ](img/file1430.jpg) |  |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| ![ σ2- 2 2 ∂tVt + rS ∂SVt + 2 S ∂SSVt = rVt, ](img/file1430.jpg) |  |'
- en: with boundary condition *V* [T] (*S*) (for instance for a European call option
    with maturity *T >* 0 and strike *K >* 0, we have *V* [T] (*S*) = ![(ST − K )](img/file1431.jpg)[+]
    := max![(ST − K, 0)](img/file1432.jpg)). Before trying to solve it, it is standard
    to simplify it. Let *τ* := *T* − *t* and define *g*[τ](*S*) := *V* [t](*S*), then
    *∂*[t]*V* [t](*S*) = −*∂*[τ]*g*[τ](*S*) and hence
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在边界条件 *V* [T] (*S*) 下（例如，对于到期时间 *T >* 0 和执行价格 *K >* 0 的欧式看涨期权，*V* [T] (*S*)
    = ![(ST − K )](img/file1431.jpg)[+] := max![(ST − K, 0)](img/file1432.jpg)）。在尝试求解之前，通常先进行简化。令
    *τ* := *T* − *t*，并定义 *g*[τ](*S*) := *V* [t](*S*)，则 *∂*[t]*V* [t](*S*) = −*∂*[τ]*g*[τ](*S*)，因此
- en: '![ 2 − ∂ g + rS ∂ g + σ-S2∂2 g = rg , τ τ S τ 2 SS τ τ ](img/file1433.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![ 2 − ∂ g + rS ∂ g + σ-S2∂2 g = rg , τ τ S τ 2 SS τ τ ](img/file1433.jpg)'
- en: with boundary condition *g*[0](*S*). Introduce now *f*[τ](*S*) := e^(rτ)*g*[τ](*S*),
    so that
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在边界条件 *g*[0](*S*) 下。现在引入 *f*[τ](*S*) := e^(rτ)*g*[τ](*S*)，从而
- en: '![ 2 − ∂τfτ + rS ∂Sfτ + σ-S2∂2SSfτ = 0, 2 ](img/file1434.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![ 2 − ∂τfτ + rS ∂Sfτ + σ-S2∂2SSfτ = 0, 2 ](img/file1434.jpg)'
- en: with boundary condition *f*[0](*S*). The transformation *x* := log(*S*) and
    the map *ψ*[τ](*x*) := *f*[τ](*S*) yield, after simplifications,
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在边界条件 *f*[0](*S*) 下。变换 *x* := log(*S*) 和映射 *ψ*[τ](*x*) := *f*[τ](*S*)，经过简化后，
- en: '| ![ ( ) σ2- σ2-2 − ∂τψτ + r − 2 ∂xψτ + 2 ∂xxψ τ = 0, ](img/file1435.jpg) |  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| ![ ( ) σ2- σ2-2 − ∂τψτ + r − 2 ∂xψτ + 2 ∂xxψ τ = 0, ](img/file1435.jpg) |  |'
- en: 'with boundary condition *ψ*[0](*x*). Finally, setting *ϕ*[τ] via *ψ*[τ](*x*)
    =: e^(αx+βτ)*ϕ*[τ](*x*) with'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '在边界条件 *ψ*[0](*x*) 下。最后，通过设定 *ϕ*[τ] 通过 *ψ*[τ](*x*) =: e^(αx+βτ)*ϕ*[τ](*x*)，'
- en: '![ ( 2) ( 2 )2 α := − 12- r − σ-- and β := −-12- r − σ-- , σ 2 2σ 2 ](img/file1436.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![ ( 2) ( 2 )2 α := − 12- r − σ-- 和 β := −-12- r − σ-- , σ 2 2σ 2 ](img/file1436.jpg)'
- en: implies that equation ([13.5.4](#x1-2570004)) becomes the heat equation
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 表明方程 ([13.5.4](#x1-2570004)) 变为热方程
- en: '| ![ σ2-2 ∂τϕτ(x) = 2 ∂xxϕτ(x), ](img/file1437.jpg) |  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| ![ σ2-2 ∂τϕτ(x) = 2 ∂xxϕτ(x), ](img/file1437.jpg) |  |'
- en: for all *x* ∈ℝ with (Dirichlet) boundary condition *ϕ*[0](*x*) = e^(−αx)*ψ*[0](*x*).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有 *x* ∈ℝ，在（狄利克雷）边界条件下，*ϕ*[0](*x*) = e^(−αx)*ψ*[0](*x*)。
- en: We now discretise this PDE using an explicit scheme, where the time derivative
    *∂*[τ] is evaluated by forward difference while the space derivative *∂*[xx] is
    approximated with a central difference scheme (implicit schemes or more general
    *𝜃*-schemes follow a similar logic). We consider ([13.5.4](#x1-2570004)) for *τ
    >* 0 and *x* in some interval [*x*[L]*,x*[U]] ∈ℝ, with (Dirichlet) boundary conditions
    *ϕ*(0*,x*) = *f*(*x*) (payoff at maturity), *ϕ*(*τ,x*[L]) = *f*[L](*τ*), and *ϕ*(*τ,x*[U])
    = *f*[U](*τ*).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用显式方案对该PDE进行离散化，其中时间导数*∂*[τ]通过前向差分法评估，而空间导数*∂*[xx]使用中心差分法进行近似（隐式方案或更一般的*𝜃*-方案遵循类似逻辑）。我们考虑([13.5.4](#x1-2570004))，其中*τ
    >* 0，*x*位于某个区间[*x*[L]*,x*[U]] ∈ℝ内，具有（Dirichlet）边界条件*ϕ*(0*,x*) = *f*(*x*)（到期时的收益），*ϕ*(*τ,x*[L])
    = *f*[L](*τ*)，和*ϕ*(*τ,x*[U]) = *f*[U](*τ*)。
- en: We start by constructing the time-space grid for the approximation scheme. For
    two integers *m* and *n*, we consider a uniform grid, i.e., we split the space
    axis into *m* intervals and the time axis into *n* intervals, and we denote 𝒱
    := {0*,*1*,…,n*} and 𝒲 := {0*,*1*,…,m*}. This means that each point on the grid
    has coordinates (*iδ*[T] *,x*[L] + *jδ*[x]) for *i* ∈𝒱 and *j* ∈𝒲, where
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先构造近似方案的时空网格。对于两个整数*m*和*n*，我们考虑一个均匀网格，即将空间轴分成*m*个区间，将时间轴分成*n*个区间，记𝒱 := {0*,*1*,…,n*}和𝒲
    := {0*,*1*,…,m*}。这意味着网格上的每个点的坐标为(*iδ*[T] *,x*[L] + *jδ*[x])，其中*i* ∈𝒱，*j* ∈𝒲，且
- en: '![ T x − x δT :=-- and δx :=-U-----L. n m ](img/file1438.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![ T x − x δT :=-- 和 δx :=-U-----L. n m ](img/file1438.jpg)'
- en: At each node, we let *ϕ*[i,j] := *ϕ*(*iδ*[T] *,x*[L] + *jδ*[x]) denote the value
    of the function *u*. Note in particular that the boundary conditions imply
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个节点上，我们令*ϕ*[i,j] := *ϕ*(*iδ*[T] *,x*[L] + *jδ*[x])表示函数*u*的值。特别注意，边界条件意味着
- en: '![ϕ0,j = f (xL + jδx), ϕi,0 = fL(iδT), ϕi,m = fU (iδT). ](img/file1439.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![ϕ0,j = f (xL + jδx), ϕi,0 = fL(iδT), ϕi,m = fU (iδT). ](img/file1439.jpg)'
- en: More precisely we consider the following approximations
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，我们考虑以下近似。
- en: '| *∂*[τ]*ϕ*(*τ,x*) | = ![ϕ(τ-+-δT,x)-−-ϕ(τ,x) δT](img/file1440.jpg) + 𝒪![(δ
    ) T](img/file1441.jpg)*,* |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| *∂*[τ]*ϕ*(*τ,x*) | = ![ϕ(τ-+-δT,x)-−-ϕ(τ,x) δT](img/file1440.jpg) + 𝒪![(δ
    ) T](img/file1441.jpg)*,* |'
- en: '| *∂*[xx]*ϕ*(*τ,x*) | = ![ϕ(τ,x + δx)− 2ϕ (τ,x) + ϕ(τ,x− δx) -----------------2----------------
    δx](img/file1442.jpg) + 𝒪![( ) δ2x](img/file1443.jpg)*.* |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| *∂*[xx]*ϕ*(*τ,x*) | = ![ϕ(τ,x + δx)− 2ϕ (τ,x) + ϕ(τ,x− δx) -----------------2----------------
    δx](img/file1442.jpg) + 𝒪![( ) δ2x](img/file1443.jpg)*.* |'
- en: Ignoring the terms in *δ*[T] and *δ*[x]², the heat equation at the node (*iδ*[T]
    *,x*[L] + *jδ*[x]) becomes
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略*δ*[T]和*δ*[x]²中的项时，节点(*iδ*[T] *,x*[L] + *jδ*[x])上的热方程变为
- en: '| ![ϕ − ϕ σ2ϕ − 2ϕ + ϕ ( ) -i+1,j----i,j + 𝒪 (δT ) = ---i,j+1-----i2,j----i,j−1+
    𝒪 δx2 , δT 2 δx ](img/file1444.jpg) |  |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| ![ϕ − ϕ σ2ϕ − 2ϕ + ϕ ( ) -i+1,j----i,j + 𝒪 (δT ) = ---i,j+1-----i2,j----i,j−1+
    𝒪 δx2 , δT 2 δx ](img/file1444.jpg) |  |'
- en: which we can rewrite
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其重写为
- en: '| ![ δ σ2 ( δ ) δ σ2 ϕi+1,j = -T2---ϕi,j+1 + 1− -T2σ2 ϕi,j + -T2---ϕi,j−1,
    δx 2 δx δx 2 ](img/file1445.jpg) |  |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| ![ δ σ2 ( δ ) δ σ2 ϕi+1,j = -T2---ϕi,j+1 + 1− -T2σ2 ϕi,j + -T2---ϕi,j−1,
    δx 2 δx δx 2 ](img/file1445.jpg) |  |'
- en: for all *i* = 0*,…,n*− 1, *j* = 1*,…,m*− 1\. To rewrite this in matrix form,
    introduce for each *i* = 0*,…,n*, [i] ∈ℝ^(m−1), B[i] ∈ℝ^(m−1) and the matrix A
    ∈ℳ[m−1](ℝ) by
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有 *i* = 0*,…,n*− 1，*j* = 1*,…,m*− 1，重写为矩阵形式时，定义每个*i* = 0*,…,n*，[i] ∈ℝ^(m−1)，B[i]
    ∈ℝ^(m−1) 和矩阵A ∈ℳ[m−1](ℝ)为
- en: '| [i] | := ![(ϕ ,...,ϕ ) i,1 i,m−1](img/file1446.jpg)^⊤*,* |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| [i] | := ![(ϕ ,...,ϕ ) i,1 i,m−1](img/file1446.jpg)^⊤*,* |'
- en: '| B[i] | := ![(ϕi,0,0,...,0,ϕi,m)](img/file1447.jpg)^⊤*,* |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| B[i] | := ![(ϕi,0,0,...,0,ϕi,m)](img/file1447.jpg)^⊤*,* |'
- en: '| A | := T[m−1]![( 2 2) 1 − ασ2, ασ-, ασ-- 2 2](img/file1448.jpg)*,* |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| A | := T[m−1]![( 2 2) 1 − ασ2, ασ-, ασ-- 2 2](img/file1448.jpg)*,* |'
- en: where
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: '![α := δT- δ2x ](img/file1449.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![α := δT- δ2x ](img/file1449.jpg)'
- en: and where T[m−1](⋅) denotes the tridiagonal matrix of dimension (*m*− 1) × (*m*−
    1).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 其中T[m−1](⋅)表示维度为(*m*− 1) × (*m*− 1)的三对角矩阵。
- en: The recursion ([13.5.4](#x1-2570004)) thus becomes
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 递推式([13.5.4](#x1-2570004))因此变为
- en: '| ![ 2 i+1= Ai + α-σ-Bi, for each i = 0,...,n − 1, 2 ](img/file1450.jpg) |  |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| ![ 2 i+1= Ai + α-σ-Bi, 对于每个i = 0,...,n − 1, 2 ](img/file1450.jpg) |  |'
- en: with the time boundary condition
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 具有时间边界条件
- en: '![0 = (ϕ0,1,...,ϕ0,m− 1)⊤ = (f (xL + δx),...,f(xL + (m − 1)δx))⊤. ](img/file1451.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![0 = (ϕ0,1,...,ϕ0,m− 1)⊤ = (f (xL + δx),...,f(xL + (m − 1)δx))⊤. ](img/file1451.jpg)'
- en: Leaving the boundary term B[i] aside, the recursion ([13.5.4](#x1-2570004))
    thus is exactly of the form ([13.5.4](#x1-2560004)), and can therefore be tackled
    using the HHL algorithm.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略边界项B[i]，递推式([13.5.4](#x1-2570004))因此完全符合形式([13.5.4](#x1-2560004))，因此可以使用HHL算法来处理。
- en: This is the obvious first step to investigate the use of HHL-type algorithms
    in quantitative finance, and further developments have already been proposed in  [[104](Biblography.xhtml#Xfontanela2021quantum), [108](Biblography.xhtml#Xgarcia2021solving), [188](Biblography.xhtml#Xlinden2022quantum), [310](Biblography.xhtml#Xzhao2022quantum)],
    with or without finance applications in mind.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调查 HHL 类型算法在量化金融中应用的显而易见的第一步，进一步的发展已经在[[104](Biblography.xhtml#Xfontanela2021quantum),
    [108](Biblography.xhtml#Xgarcia2021solving), [188](Biblography.xhtml#Xlinden2022quantum),
    [310](Biblography.xhtml#Xzhao2022quantum)]中提出，无论是否考虑金融应用。
- en: Application to portfolio optimisation
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 应用于投资组合优化
- en: The second immediate application of QLS in finance is for portfolio optimisation.
    Indeed, the standard Markowitz-type problem of the form ([3.3](Chapter_3.xhtml#x1-740003))
    in Section [3.3](Chapter_3.xhtml#x1-740003) is readily formulated (at least for
    weights in {0*,*1}) as a linear problem, the constraints only increasing the dimension
    as Lagrange multipliers. We shall not dive into the details here as this is a
    rather novel development with huge potential but limited results so far, and instead
    refer the reader to  [[306](Biblography.xhtml#Xyalovetzky2021nisq), [187](Biblography.xhtml#Xli2022portfolio)]
    for promising implementations and details.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: QLS 在金融中的第二个直接应用是投资组合优化。事实上，标准的 Markowitz 类型问题（如第[3.3](Chapter_3.xhtml#x1-740003)节中的形式）很容易被表述为线性问题（至少在权重属于{0,1}时），约束条件仅通过拉格朗日乘子增加维度。我们在此不会深入细节，因为这是一个相当新颖的开发，具有巨大的潜力，但迄今为止结果有限，我们建议读者参考[[306](Biblography.xhtml#Xyalovetzky2021nisq),
    [187](Biblography.xhtml#Xli2022portfolio)]以了解有前景的实现和细节。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced several new promising quantum algorithms. First,
    we learned about quantum kernels, which can replace classical kernels in hybrid
    quantum-classical protocols.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了几种有前景的新型量子算法。首先，我们了解了量子核，可以替代混合量子经典协议中的经典核。
- en: Next, we introduced the Bayesian quantum circuit model that expands the concept
    of a Bayesian neural network to parameterised quantum circuits. BQC is a promising
    generative model with larger expressive power than QCBM/MPQC (covered in Chapters [9](Chapter_9.xhtml#x1-1850009)
    and [12](Chapter_12.xhtml#x1-22500012)).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍了贝叶斯量子电路模型，它将贝叶斯神经网络的概念扩展到参数化量子电路。BQC 是一种有前景的生成模型，其表达能力大于 QCBM/MPQC（在第[9](Chapter_9.xhtml#x1-1850009)章和第[12](Chapter_12.xhtml#x1-22500012)章中介绍）。
- en: Then we looked at quantum SDP and its potential to outperform classical SDP.
    This is a topic of active research.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们研究了量子 SDP 及其超越经典 SDP 的潜力。这是一个活跃的研究课题。
- en: Finally, we covered several important quantum algorithms that rely on the existence
    of a quantum computing hardware with characteristics that exceed the capabilities
    of currently available NISQ computers. However, the very presence of these algorithms
    and their potential to achieve quadratic or even exponential speedup provides
    strong motivation for the rapid development of quantum computers.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了几种重要的量子算法，这些算法依赖于具备超越当前可用 NISQ 计算机能力的量子计算硬件的存在。然而，这些算法的存在及其实现二次甚至指数级加速的潜力，提供了推动量子计算机快速发展的强大动力。
- en: This chapter completes the book. Looking ahead, we see a bright future for quantum
    computing. In the update to their quantum computing development roadmap  [[145](Biblography.xhtml#XIBMRoadmap2022)],
    IBM outlined an exciting vision with the goal to build quantum-centric supercomputers.
    The latter will incorporate quantum processors, classical processors, quantum
    communication networks, and classical networks. The immediate deliverables are
    expected to be the 433-qubit *Osprey* processor (expected to be released in 2022)
    and the 1,121-qubit *Condor* processor (expected to be released in 2023). The
    next step will be to develop ways to link processors together into a modular system
    capable of scaling without physical limitations.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成了本书的内容。展望未来，我们看到了量子计算的光明前景。在更新的量子计算发展路线图[[145](Biblography.xhtml#XIBMRoadmap2022)]中，IBM概述了一个激动人心的愿景，目标是构建量子中心的超级计算机。后者将集成量子处理器、经典处理器、量子通信网络和经典网络。预期的近期交付物包括433量子比特的*Osprey*处理器（预计于2022年发布）和1,121量子比特的*Condor*处理器（预计于2023年发布）。下一步将是开发将处理器连接成模块化系统的方法，能够在没有物理限制的情况下进行扩展。
- en: The modular, multi-chip scaling technology is also envisaged by Rigetti. Rigetti
    anticipates the launch of their next generation single-chip 84-qubit quantum computer
    in 2023 and 336-qubit multi-chip processor later in 2023\. The 336-qubit multi-chip
    processor is expected to combine the anticipated improvements of the 84-qubit
    processor with the modular, multi-chip scaling technology of Rigetti’s Aspen-M
    machine. These machines are expected to deliver increased performance across the
    key dimensions of speed, scale, and fidelity  [[246](Biblography.xhtml#XRigettiRoadmap2022)].
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化的多芯片扩展技术同样是Rigetti所设想的。Rigetti预计将在2023年推出下一代单芯片84量子比特量子计算机，并于2023年晚些时候推出336量子比特多芯片处理器。预计336量子比特多芯片处理器将结合84量子比特处理器的预期改进与Rigetti
    Aspen-M机器的模块化、多芯片扩展技术。这些机器预计将在速度、规模和保真度等关键维度上提供更强的性能[[246](Biblography.xhtml#XRigettiRoadmap2022)]。
- en: We also expect to see significant progress in the trapped ion space. IonQ announced
    several major breakthroughs that may have a major impact on the way quantum algorithms
    are designed and run on trapped ion quantum computing hardware. This includes,
    for example, a new family of *n*-qubit gates, such as the *n*-qubit Toffoli gate,
    which flips a select qubit if and only if all the other qubits are in a particular
    state. Unlike standard two-qubit quantum computing gates, the *n*-qubit Toffoli
    gate acts on many qubits at once, leading to more efficient operations  [[146](Biblography.xhtml#XIonQ2022)].
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还预计在捕获离子领域看到显著进展。IonQ宣布了一些重大突破，这些突破可能会对量子算法的设计和在捕获离子量子计算硬件上的运行方式产生重大影响。例如，这包括一种新的*n*量子比特门，像*n*量子比特Toffoli门，当且仅当所有其他量子比特处于特定状态时，才翻转一个选定的量子比特。与标准的双量子比特量子计算门不同，*n*量子比特Toffoli门一次作用于多个量子比特，从而实现更高效的操作[[146](Biblography.xhtml#XIonQ2022)]。
- en: Quantum annealing is going from strength to strength. In a recent white paper  [[39](Biblography.xhtml#XBoothby2021)],
    D-Wave introduced the new *Zephyr* graph with better connectivity than its predecessors,
    *Chimera* and *Pegasus*. Plans are in place for a 7,000-qubit chip based on *Zephyr*,
    scheduled to be available in 2023-2024  [[93](Biblography.xhtml#XDW2022)]. Early
    benchmarks with smaller-scale prototype systems consisting of 500+ qubits have
    demonstrated more compact embedding, lower error rates, improved solution quality,
    and an increased probability of finding optimal solutions  [[210](Biblography.xhtml#XMcGeoch2022)].
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 量子退火技术正日益强大。在最近的白皮书中[[39](Biblography.xhtml#XBoothby2021)]，D-Wave推出了新的*Zephyr*图，相比其前代产品*Chimera*和*Pegasus*，具有更好的连接性。计划在2023-2024年推出基于*Zephyr*的7,000量子比特芯片[[93](Biblography.xhtml#XDW2022)]。早期基于500+量子比特的小规模原型系统的基准测试已展示出更紧凑的嵌入、较低的错误率、改进的解决方案质量，以及更高的找到最优解的概率[[210](Biblography.xhtml#XMcGeoch2022)]。
- en: But, ultimately, it is up to the users to try and test various hardware and
    software solutions on a variety of use cases. We encourage our readers to experiment
    and apply the methods of quantum computing to their own spheres of interest and
    discover new quantum algorithms and applications. This is an exciting journey
    and a great opportunity to participate in the collective effort of achieving quantum
    advantage for the benefits of wider society.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 但归根结底，用户需要在各种用例中尝试和测试不同的硬件和软件解决方案。我们鼓励读者尝试并将量子计算方法应用到自己感兴趣的领域，发现新的量子算法和应用。这是一次激动人心的旅程，也是参与实现量子优势、造福更广泛社会的集体努力的绝佳机会。
