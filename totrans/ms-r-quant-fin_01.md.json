["```py\n#generate the two time series of length 1000\n\nset.seed(20140623)         #fix the random seed\nN <- 1000                  #define length of simulation\nx <- cumsum(rnorm(N))      #simulate a normal random walk\ngamma <- 0.7               #set an initial parameter value\ny <- gamma * x + rnorm(N)  #simulate the cointegrating series\nplot(x, type='l')          #plot the two series\nlines(y,col=\"red\")\n\n```", "```py\n#statistical tests\ninstall.packages('urca');library('urca')\n#ADF test for the simulated individual time series\nsummary(ur.df(x,type=\"none\"))\nsummary(ur.df(y,type=\"none\"))\n\n```", "```py\nz = y - gamma*x\t#take a linear combination of the series\nplot(z,type='l')\n\n```", "```py\nsummary(ur.df(z,type=\"none\"))\n\n```", "```py\n#Estimate the cointegrating relationship\ncoin <- lm(y ~ x -1)           #regression without intercept\ncoin$resid                     #obtain the residuals\nsummary(ur.df(coin$resid))     #ADF test of residuals\n\n```", "```py\ninstall.packages('vars');library('vars')\ninstall.packages('quantmod');library('quantmod')\n\n```", "```py\ngetSymbols('MSFT', from='2004-01-02', to='2014-03-31')\ngetSymbols('SNP', from='2004-01-02', to='2014-03-31')\ngetSymbols('DTB3', src='FRED')\n\n```", "```py\nCl(MSFT)     #closing prices\nOp(MSFT)     #open prices\nHi(MSFT)     #daily highest price\nLo(MSFT)     #daily lowest price\nClCl(MSFT)   #close-to-close daily return\nAd(MSFT)     #daily adjusted closing price\n\n```", "```py\nchartSeries(ClCl(MSFT))  #a plotting example with shortcuts\n\n```", "```py\nDTB3.sub <- DTB3['2004-01-02/2014-03-31']\n\n```", "```py\nMSFT.ret <- diff(log(Ad(MSFT)))\nSNP.ret  <- diff(log(Ad(SNP)))\n\n```", "```py\ndataDaily <- na.omit(merge(SNP.ret,MSFT.ret,DTB3.sub), join='inner')\n\n```", "```py\nSNP.M  <- to.monthly(SNP.ret)$SNP.ret.Close\nMSFT.M <- to.monthly(MSFT.ret)$MSFT.ret.Close\nDTB3.M <- to.monthly(DTB3.sub)$DTB3.sub.Close\n\n```", "```py\nvar1 <- VAR(dataDaily, lag.max=4, ic=\"AIC\")\n\n```", "```py\n>VARselect(dataDaily,lag.max=4)\n\n```", "```py\nsummary(var1)\nvar1\n\n```", "```py\nplot(var1)       #Diagram of fit and residuals for each variables\ncoef(var1)       #concise summary of the estimated variables\nresiduals(var1)  #list of residuals (of the corresponding ~lm)\nfitted(var1)     #list of fitted values\nPhi(var1)        #coefficient matrices of VMA representation\n\n```", "```py\nvar.pred <- predict(var1, n.ahead=10, ci=0.95)\n\n```", "```py\nvar.irf <- irf(var1)\nplot(var.irf)\n\n```", "```py\namat <- diag(3)\namat[2, 1] <- NA\namat[2, 3] <- NA\namat[3, 1] <- NA\n\n```", "```py\nsvar1 <- SVAR(var1, estmethod='direct', Amat = amat)\nirf.svar1 <- irf(svar1)\nplot(irf.svar1)\n\n```", "```py\nlibrary('quantmod')\ngetSymbols('DTB3', src='FRED')\ngetSymbols('DTB6', src='FRED')\nDTB3.sub = DTB3['1984-01-02/2014-03-31']\nDTB6.sub = DTB6['1984-01-02/2014-03-31']\nplot(DTB3.sub)\nlines(DTB6.sub, col='red')\n\n```", "```py\nx1=as.numeric(na.omit(DTB3.sub))\nx2=as.numeric(na.omit(DTB6.sub))\ny = cbind(x1,x2)\ncregr <- lm(x1 ~ x2)\nr = cregr$residuals\n\n```", "```py\ninstall.packages('tseries');library('tseries');\npo.coint <- po.test(y, demean = TRUE, lshort = TRUE)\n\n```", "```py\nyJoTest = ca.jo(y, type = c(\"trace\"), ecdet = c(\"none\"), K = 2)\n\n###################### \n# Johansen-Procedure # \n###################### \n\nTest type: trace statistic , with linear trend \n\nEigenvalues (lambda):\n[1] 0.0160370678 0.0002322808\n\nValues of teststatistic and critical values of test:\n\n test 10pct  5pct  1pct\nr <= 1 |   1.76  6.50  8.18 11.65\nr = 0  | 124.00 15.66 17.95 23.52\n\nEigenvectors, normalised to first column:\n(These are the cointegration relations)\n\n DTB3.l2   DTB6.l2\nDTB3.l2  1.000000  1.000000\nDTB6.l2 -0.994407 -7.867356\nWeights W:\n(This is the loading matrix)\n\n DTB3.l2      DTB6.l2\nDTB3.d -0.037015853 3.079745e-05\nDTB6.d -0.007297126 4.138248e-05\n\n```", "```py\n>yJoRegr = cajorls(dyTest, r=1)\n>yJoRegr\n\n$rlm\n\nCall:\nlm(formula = substitute(form1), data = data.mat)\n\nCoefficients:\n x1.d        x2.d \nect1      -0.0370159  -0.0072971\nconstant  -0.0041984  -0.0016892\nx1.dl1     0.1277872   0.1538121\nx2.dl1     0.0006551  -0.0390444\n\n$beta\n ect1\nx1.l1  1.000000\nx2.l1 -0.994407\n\n```", "```py\ngetSymbols(\"SNP\", from=\"2004-01-01\", to=Sys.Date())\nchartSeries(Cl(SNP))\n\n```", "```py\nret <- dailyReturn(Cl(SNP), type='log')\n\n```", "```py\npar(mfrow=c(2,2))\nacf(ret, main=\"Return ACF\");\npacf(ret, main=\"Return PACF\");\nacf(ret^2, main=\"Squared return ACF\");\npacf(ret^2, main=\"Squared return PACF\")\npar(mfrow=c(1,1))\n\n```", "```py\nm=mean(ret);s=sd(ret);\npar(mfrow=c(1,2))\nhist(ret, nclass=40, freq=FALSE, main='Return histogram');curve(dnorm(x, mean=m,sd=s), from = -0.3, to = 0.2, add=TRUE, col=\"red\")\nplot(density(ret), main='Return empirical distribution');curve(dnorm(x, mean=m,sd=s), from = -0.3, to = 0.2, add=TRUE, col=\"red\")\npar(mfrow=c(1,1))\n\n```", "```py\n> kurtosis(ret)\ndaily.returns \n 12.64959\n\n```", "```py\n# tail zoom\nplot(density(ret), main='Return EDF - upper tail', xlim = c(0.1, 0.2), ylim=c(0,2));\ncurve(dnorm(x, mean=m,sd=s), from = -0.3, to = 0.2, add=TRUE, col=\"red\")\n\n```", "```py\n# density plots on log-scale\nplot(density(ret), xlim=c(-5*s,5*s),log='y', main='Density on log-scale')\ncurve(dnorm(x, mean=m,sd=s), from=-5*s, to=5*s, log=\"y\", add=TRUE, col=\"red\")\n\n# QQ-plot\nqqnorm(ret);qqline(ret);\n\n```", "```py\ninstall.packages('rugarch');library('rugarch')\n\n```", "```py\n#Load Apple data and calculate log-returns\ngetSymbols(\"AAPL\", from=\"2006-01-01\", to=\"2014-03-31\")\nret.aapl <- dailyReturn(Cl(AAPL), type='log')\nchartSeries(ret.aapl)\n\n```", "```py\ngarch11.spec = ugarchspec(variance.model = list(model=\"sGARCH\", garchOrder=c(1,1)), mean.model = list(armaOrder=c(0,0)))\n\n```", "```py\naapl.garch11.fit = ugarchfit(spec=garch11.spec, data=ret.aapl)\n\n```", "```py\n> coef(aapl.garch11.fit)\n mu        omega       alpha1        beta1 \n1.923328e-03 1.027753e-05 8.191681e-02 8.987108e-01\n\n```", "```py\ncoef(msft.garch11.fit)          #estimated coefficients\nvcov(msft.garch11.fit)          #covariance matrix of param estimates\ninfocriteria(msft.garch11.fit)  #common information criteria list\nnewsimpact(msft.garch11.fit)    #calculate news impact curve\nsignbias(msft.garch11.fit)      #Engle - Ng sign bias test\nfitted(msft.garch11.fit)        #obtain the fitted data series\nresiduals(msft.garch11.fit)     #obtain the residuals\nuncvariance(msft.garch11.fit)   #unconditional (long-run) variance\nuncmean(msft.garch11.fit)       #unconditional (long-run) mean\n\n```", "```py\nni.garch11 <- newsimpact(aapl.garch11.fit)\nplot(ni.garch11$zx, ni.garch11$zy, type=\"l\", lwd=2, col=\"blue\", main=\"GARCH(1,1) - News Impact\", ylab=ni.garch11$yexpr, xlab=ni.garch11$xexpr)\n\n```", "```py\n# specify EGARCH(1,1) model with only constant in mean equation\negarch11.spec = ugarchspec(variance.model = list(model=\"eGARCH\", garchOrder=c(1,1)), mean.model = list(armaOrder=c(0,0)))\naapl.egarch11.fit = ugarchfit(spec=egarch11.spec, data=ret.aapl)\n\n> coef(aapl.egarch11.fit)\n mu        omega       alpha1        beta1       gamma1 \n 0.001446685 -0.291271433 -0.092855672  0.961968640  0.176796061\n\n```", "```py\nni.egarch11 <- newsimpact(aapl.egarch11.fit)\nplot(ni.egarch11$zx, ni.egarch11$zy, type=\"l\", lwd=2, col=\"blue\", main=\"EGARCH(1,1) - News Impact\",\nylab=ni.egarch11$yexpr, xlab=ni.egarch11$xexpr)\n\n```", "```py\n# specify TGARCH(1,1) model with only constant in mean equation\ntgarch11.spec = ugarchspec(variance.model = list(model=\"fGARCH\", submodel=\"TGARCH\", garchOrder=c(1,1)), \n mean.model = list(armaOrder=c(0,0)))\naapl.tgarch11.fit = ugarchfit(spec=tgarch11.spec, data=ret.aapl)\n\n> coef(aapl.egarch11.fit)\n mu        omega       alpha1        beta1       gamma1 \n 0.001446685 -0.291271433 -0.092855672  0.961968640  0.176796061\n\n```", "```py\nni.tgarch11 <- newsimpact(aapl.tgarch11.fit)\nplot(ni.tgarch11$zx, ni.tgarch11$zy, type=\"l\", lwd=2, col=\"blue\", main=\"TGARCH(1,1) - News Impact\",\nylab=ni.tgarch11$yexpr, xlab=ni.tgarch11$xexpr)\n\n```", "```py\ngarch11.spec = ugarchspec(variance.model = list(garchOrder=c(1,1)), \n mean.model = list(armaOrder=c(0,0)),\n fixed.pars=list(mu = 0, omega=0.1, alpha1=0.1,\n beta1 = 0.7))\ngarch11.sim = ugarchpath(garch11.spec, n.sim=1000)\n\n```", "```py\naapl.garch11.fit = ugarchfit(spec=garch11.spec, data=ret.aapl, out.sample=20)\naapl.garch11.fcst = ugarchforecast(aapl.garch11.fit, n.ahead=10, n.roll=10)\n\n```", "```py\nplot(aapl.garch11.fcst, which='all')\n\n```"]