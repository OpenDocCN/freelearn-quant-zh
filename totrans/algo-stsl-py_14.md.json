["```py\n# Appendix \n# Data manipulation\nimport pandas as pd\nimport numpy as np\nfrom scipy.signal import *\n# import pathlib\n# Data download\nimport yfinance as yf\n# Data visualisation\n%matplotlib inline\nimport matplotlib.pyplot as plt \n```", "```py\n# CHAPTER 5: Regime Definition \n### RELATIVE\ndef relative(df,_o,_h,_l,_c, bm_df, bm_col, ccy_df, ccy_col, dgt, start, end,rebase=True):\n    #### removed for brevity: check GitHub repo for full code ####\n### RELATIVE ###\ndef lower_upper_OHLC(df,relative = False):\n    if relative==True:\n        rel = 'r'\n    else:\n        rel= ''      \n    if 'Open' in df.columns:\n        ohlc = [rel+'Open',rel+'High',rel+'Low',rel+'Close']       \n    elif 'open' in df.columns:\n        ohlc = [rel+'open',rel+'high',rel+'low',rel+'close']\n\n    try:\n        _o,_h,_l,_c = [ohlc[h] for h in range(len(ohlc))]\n    except:\n        _o=_h=_l=_c= np.nan\n    return _o,_h,_l,_c\n\ndef  regime_args(df,lvl,relative= False):\n    if ('Low' in df.columns) & (relative == False):\n        reg_val = ['Lo1','Hi1','Lo'+str(lvl),'Hi'+str(lvl),'rg','clg','flr','rg_ch']\n    elif ('low' in df.columns) & (relative == False):\n        reg_val = ['lo1','hi1','lo'+str(lvl),'hi'+str(lvl),'rg','clg','flr','rg_ch']\n    elif ('Low' in df.columns) & (relative == True):\n        reg_val = ['rL1','rH1','rL'+str(lvl),'rH'+str(lvl),'rrg','rclg','rflr','rrg_ch']\n    elif ('low' in df.columns) & (relative == True):\n        reg_val = ['rl1','rh1','rl'+str(lvl),'rh'+str(lvl),'rrg','rclg','rflr','rrg_ch']\n\n    try: \n        rt_lo,rt_hi,slo,shi,rg,clg,flr,rg_ch = [reg_val[s] for s in range(len(reg_val))]\n    except:\n        rt_lo=rt_hi=slo=shi=rg=clg=flr=rg_ch= np.nan\n    return rt_lo,rt_hi,slo,shi,rg,clg,flr,rg_ch\n# CHAPTER 5: Regime Definition \n#### regime_breakout(df,_h,_l,window) ####\ndef regime_breakout(df,_h,_l,window):\n    #### removed for brevity: check GitHub repo for full code ####\n#### turtle_trader(df, _h, _l, slow, fast) ####\n#### removed for brevity: check GitHub repo for full code ####\n#### regime_sma(df,_c,st,lt) ####\n#### removed for brevity: check GitHub repo for full code ####\n#### regime_ema(df,_c,st,lt) #### \n```", "```py\n# CHAPTER 5: Regime Definition \n#### hilo_alternation(hilo, dist= None, hurdle= None) ####\ndef hilo_alternation(hilo, dist= None, hurdle= None):\n    i=0    \n    while (np.sign(hilo.shift(1)) == np.sign(hilo)).any(): # runs until duplicates are eliminated\n        #### removed for brevity: check GitHub repo for full code ####\n#### historical_swings(df,_o,_h,_l,_c, dist= None, hurdle= None) #### \ndef historical_swings(df,_o,_h,_l,_c, dist= None, hurdle= None):\n\n    reduction = df[[_o,_h,_l,_c]].copy() \n    reduction['avg_px'] = round(reduction[[_h,_l,_c]].mean(axis=1),2)\n    highs = reduction['avg_px'].values\n    lows = - reduction['avg_px'].values\n    reduction_target =  len(reduction) // 100\n#     print(reduction_target )\n#### removed for brevity: check GitHub repo for full code ####\n#### cleanup_latest_swing(df, shi, slo, rt_hi, rt_lo) ####\ndef cleanup_latest_swing(df, shi, slo, rt_hi, rt_lo): \n    '''\n    removes false positives\n    '''\n    # latest swing\n    shi_dt = df.loc[pd.notnull(df[shi]), shi].index[-1]\n    s_hi = df.loc[pd.notnull(df[shi]), shi][-1]\n    slo_dt = df.loc[pd.notnull(df[slo]), slo].index[-1] \n    s_lo = df.loc[pd.notnull(df[slo]), slo][-1] \n    len_shi_dt = len(df[:shi_dt])\n    len_slo_dt = len(df[:slo_dt])\n\n#### removed for brevity: check GitHub repo for full code ####\n#### latest_swings(df, shi, slo, rt_hi, rt_lo, _h, _l, _c, _vol) ####\ndef latest_swing_variables(df, shi, slo, rt_hi, rt_lo, _h, _l, _c):\n    '''\n    Latest swings dates & values\n    '''\n    shi_dt = df.loc[pd.notnull(df[shi]), shi].index[-1]\n    slo_dt = df.loc[pd.notnull(df[slo]), slo].index[-1]\n    s_hi = df.loc[pd.notnull(df[shi]), shi][-1]\n    s_lo = df.loc[pd.notnull(df[slo]), slo][-1]\n\n    #### removed for brevity: check GitHub repo for full code ####\n#### test_distance(ud, bs, hh_ll, vlty, dist_vol, dist_pct) ####\ndef test_distance(ud,bs, hh_ll, dist_vol, dist_pct): \n\n#### removed for brevity: check GitHub repo for full code ####\n#### ATR ####\ndef average_true_range(df, _h, _l, _c, n):\n    atr =  (df[_h].combine(df[_c].shift(), max) - df[_l].combine(df[_c].shift(), min)).rolling(window=n).mean()\n    return atr\n#### ATR ####\n#### retest_swing(df, _sign, _rt, hh_ll_dt, hh_ll, _c, _swg) ####\ndef retest_swing(df, _sign, _rt, hh_ll_dt, hh_ll, _c, _swg):\n    rt_sgmt = df.loc[hh_ll_dt:, _rt] \n    #### removed for brevity: check GitHub repo for full code ####\n#### retracement_swing(df, _sign, _swg, _c, hh_ll_dt, hh_ll, vlty, retrace_vol, retrace_pct) ####\ndef retracement_swing(df, _sign, _swg, _c, hh_ll_dt, hh_ll, vlty, retrace_vol, retrace_pct):\n    if _sign == 1: #\n        retracement = df.loc[hh_ll_dt:, _c].min() - hh_ll\n#### removed for brevity: check GitHub repo for full code ####\n# CHAPTER 5: Regime Definition \n#### regime_floor_ceiling(df, hi,lo,cl, slo, shi,flr,clg,rg,rg_ch,stdev,threshold) ####\ndef regime_floor_ceiling(df, _h,_l,_c,slo, shi,flr,clg,rg,rg_ch,stdev,threshold):\n#### removed for brevity: check GitHub repo for full code #### \n```", "```py\ndef swings(df,rel = False):\n    _o,_h,_l,_c = lower_upper_OHLC(df,relative= False)\n    if rel == True:\n        df = relative(df=df,_o=_o,_h=_h,_l=_l,_c=_c, bm_df=bm_df, bm_col= bm_col, ccy_df=bm_df, \n                            ccy_col=ccy_col, dgt= dgt, start=start, end= end,rebase=True)\n        _o,_h,_l,_c = lower_upper_OHLC(df,relative= True)    \n        rt_lo,rt_hi,slo,shi,rg,clg,flr,rg_ch = regime_args(df,lvl,relative= True)\n    else :\n        rt_lo,rt_hi,slo,shi,rg,clg,flr,rg_ch = regime_args(df,lvl,relative= False)\n    df= historical_swings(df,_o,_h,_l,_c, dist= None, hurdle= None)\n    df= cleanup_latest_swing(df,shi,slo,rt_hi,rt_lo)\n    ud, bs, bs_dt, _rt, _swg, hh_ll, hh_ll_dt = latest_swing_variables(df, shi,slo,rt_hi,rt_lo,_h,_l, _c)\n    vlty = round(average_true_range(df,_h,_l,_c, n= vlty_n)[hh_ll_dt],dgt)\n    dist_vol = d_vol * vlty\n    _sign = test_distance(ud,bs, hh_ll, dist_vol, dist_pct)\n    df = retest_swing(df, _sign, _rt, hh_ll_dt, hh_ll, _c, _swg)\n    retrace_vol = r_vol * vlty\n    df = retracement_swing(df, _sign, _swg, _c, hh_ll_dt, hh_ll, vlty, retrace_vol, retrace_pct)\n\n    return df\n\ndef regime(df,lvl,rel=False):   \n    _o,_h,_l,_c = lower_upper_OHLC(df,relative= rel)    \n    rt_lo,rt_hi,slo,shi,rg,clg,flr,rg_ch = regime_args(df,lvl,relative= rel)\n    stdev = df[_c].rolling(vlty_n).std(ddof=0)\n    df = regime_floor_ceiling(df,_h,_l,_c,slo, shi,flr,clg,rg,rg_ch,stdev,threshold) \n\n    return df\n# df[rg+'_no_fill'] = df[rg]\n    return df \n```", "```py\n# CHAPTER 5: Regime Definition \n### Graph Regimes ###\ndef graph_regime_combo(ticker,df,_c,rg,lo,hi,slo,shi,clg,flr,rg_ch,\n                       ma_st,ma_mt,ma_lt,lt_lo,lt_hi,st_lo,st_hi):\n\n    '''\n    https://www.color-hex.com/color-names.html\n    ticker,df,_c: _c is closing price\n    rg: regime -1/0/1 using floor/ceiling method\n    lo,hi: small, noisy highs/lows\n    slo,shi: swing lows/highs\n    clg,flr: ceiling/floor\n\n    rg_ch: regime change base\n    ma_st,ma_mt,ma_lt: moving averages ST/MT/LT\n    lt_lo,lt_hi: range breakout High/Low LT \n    st_lo,st_hi: range breakout High/Low ST \n    '''\n#### removed for brevity: check GitHub repo for full code #### \n```", "```py\ndef yf_droplevel(batch_download,ticker):\n    df = batch_download.iloc[:, batch_download.columns.get_level_values(1)==ticker]\n    df.columns = df.columns.droplevel(1)\n    df = df.dropna()\n    return df \n```", "```py\ndef last_row_dictionary(df):    \n    df_cols = list(df.columns)\n    col_dict = {'Symbol':str.upper(ticker),'date':df.index.max().strftime('%Y%m%d')}\n    for i, col_name in enumerate(df_cols):\n        if pd.isnull(df.iloc[-1,i]):\n            try:\n                last_index = df[pd.notnull(df.iloc[:,i])].index[-1]\n                len_last_index = len(df[:last_index]) - 1\n                col_dict.update({col_name + '_dt': last_index.strftime('%Y%m%d')})\n                col_dict.update({col_name : df.iloc[len_last_index,i]})\n            except:\n                col_dict.update({col_name + '_dt':np.nan})\n                col_dict.update({col_name : np.nan})\n        else:\n            col_dict.update({col_name : df.iloc[-1,i]})\n    return col_dict \n```", "```py\nwebsite = 'https://en.wikipedia.org/wiki/List_of_S%26P_500_companies'\nparams = ['2014-12-31', None, 63, 0.05, 0.05, 1.5, 2,5,2.5,3]\nstart,end,vlty_n,dist_pct,retrace_pct,threshold,dgt,d_vol,r_vol,lvl= [params[h] for h in range(len(params))]\nrel_var = ['^GSPC','SP500', 'USD']\nbm_ticker, bm_col, ccy_col = [rel_var[h] for h in range(len(rel_var))]\nwindow = 100\nst= fast = 50\nlt = slow = 200\nbatch_size = 20\nshow_batch = True\nsave_ticker_df = False\nsave_last_row_df = False\nsave_regime_df = False\nweb_df_cols = ['Symbol','Security','GICS Sector','GICS Sub-Industry']\nregime_cols = ['rg','rrg',\n    'smaC'+str(st)+str(lt),'smar'+str(st)+str(lt), 'boHL'+str(slow),\n'borr'+str(slow),'ttH'+str(fast)+'L'+str(slow),'ttr'+str(fast)+'r'+str(slow)]\nswings_cols = ['flr_dt','flr','clg_dt', 'clg', 'rg_ch', \n    'Hi'+str(lvl)+'_dt','Hi'+str(lvl),'Lo'+str(lvl)+'_dt','Lo'+str(lvl),\n      'rflr_dt', 'rflr', 'rclg_dt', 'rclg', 'rrg_ch',\n    'rH'+str(lvl)+'_dt','rH'+str(lvl),'rL'+str(lvl)+'_dt','rL'+str(lvl) ]\nsymbol_cols = ['Symbol','date','Close']\nlast_row_df_cols = symbol_cols+['score']+regime_cols+swings_cols \n```", "```py\nweb_df = pd.read_html(website)[0]\ntickers_list =  list(web_df['Symbol'])\ntickers_list = tickers_list[:]\nprint('tickers_list',len(tickers_list))\nweb_df.head() \n```", "```py\n# Appendix: The Engine Room\n\nbm_df = pd.DataFrame()\nbm_df[bm_col] = round(yf.download(tickers= bm_ticker,start= start, end = end,interval = \"1d\",\n                 group_by = 'column',auto_adjust = True, prepost = True, \n                 treads = True, proxy = None)['Close'],dgt)\nbm_df[ccy_col] = 1\nprint('benchmark',bm_df.tail(1))\n\nregime_df = pd.DataFrame()\nlast_row_df = pd.DataFrame()\nlast_row_list = []\nfailed = []\n\nloop_size = int(len(tickers_list) // batch_size) + 2\nfor t in range(1,loop_size): \n    m = (t - 1) * batch_size\n    n = t * batch_size\n    batch_list = tickers_list[m:n]\n    if show_batch:\n        print(batch_list,m,n)\n\n    try:\n        batch_download = round(yf.download(tickers= batch_list,start= start, end = end, \n                            interval = \"1d\",group_by = 'column',auto_adjust = True, \n                                  prepost = True, treads = True, proxy = None),dgt)        \n\n        for flat, ticker in enumerate(batch_list):\n            df = yf_droplevel(batch_download,ticker)           \n            df = swings(df,rel = False)\n            df = regime(df,lvl = 3,rel = False)\n            df = swings(df,rel = True)\n            df = regime(df,lvl = 3,rel= True)            \n            _o,_h,_l,_c = lower_upper_OHLC(df,relative = False)\n\n            for a in range(2): \n                df['sma'+str(_c)[:1]+str(st)+str(lt)] = regime_sma(df,_c,st,lt)\n                df['bo'+str(_h)[:1]+str(_l)[:1]+ str(slow)] = regime_breakout(df,_h,_l,window)\n                df['tt'+str(_h)[:1]+str(fast)+str(_l)[:1]+ str(slow)] = turtle_trader(df, _h, _l, slow, fast)\n                _o,_h,_l,_c = lower_upper_OHLC(df,relative = True)                \n            try: \n                last_row_list.append(last_row_dictionary(df))\n            except:\n                failed.append(ticker) \n    except:\n        failed.append(ticker)\nlast_row_df = pd.DataFrame.from_dict(last_row_list)\n\nif save_last_row_df:\n    last_row_df.to_csv('last_row_df_'+ str(last_row_df['date'].max())+'.csv', date_format='%Y%m%d')\nprint('failed',failed)\n\nlast_row_df['score']= last_row_df[regime_cols].sum(axis=1)\nregime_df = web_df[web_df_cols].set_index('Symbol').join(\n    last_row_df[last_row_df_cols].set_index('Symbol'), how='inner').sort_values(by='score')\n\nif save_regime_df:\n    regime_df.to_csv('regime_df_'+ str(last_row_df['date'].max())+'.csv', date_format='%Y%m%d') \n```", "```py\ngroupby_cols = ['score'] + regime_cols\nsort_key = ['GICS Sector']\nregime_df.groupby(sort_key)[groupby_cols].mean().sort_values(\n    by= 'score').style.background_gradient(\n    subset= groupby_cols,cmap= 'RdYlGn').format('{:.1g}') \n```", "```py\nsort_key = ['GICS Sub-Industry']\nregime_df.groupby(sort_key)[groupby_cols].mean().sort_values(\n    by= 'score').style.background_gradient(\n    subset= groupby_cols,cmap= 'RdYlGn').format('{:.1g}') \n```", "```py\nsort_key = ['GICS Sector','GICS Sub-Industry']\nregime_df.groupby(sort_key)[groupby_cols].mean().sort_values(\n    by= ['GICS Sector','score']).style.background_gradient(\n    subset= groupby_cols,cmap= 'RdYlGn').format('{:.1g}') \n```", "```py\nbm_ticker= '^GSPC'\nbm_df = pd.DataFrame()\nbm_df[bm_col] = round(yf.download(tickers= bm_ticker,start= start, end = end,interval = \"1d\",\n                 group_by = 'column',auto_adjust = True, prepost = True, \n                 treads = True, proxy = None)['Close'],dgt)\nbm_df[ccy_col] = 1\nticker = 'FMC'\nlvl = 2 # Try different levels to see\n\ndf = round(yf.download(tickers= ticker,start= start, end = end,    interval = \"1d\", group_by = 'column',auto_adjust = True,     prepost = True, treads = True, proxy = None),dgt)\n\ndf = swings(df,rel = False)\ndf = regime(df,lvl = 2,rel = False) # Try different lvl values (1-3) to vary absolute sensitivity\ndf = swings(df,rel = True) # Try different lvl values (1-3) to vary relative sensitivity\ndf = regime(df,lvl = 2,rel= True)\n_o,_h,_l,_c = lower_upper_OHLC(df,relative = False)\n\nfor a in range(2):    \n    df['sma'+str(_c)[:1]+str(st)+str(lt)] = regime_sma(df,_c,st,lt)\n    df['bo'+str(_h)[:1]+str(_l)[:1]+ str(slow)] = regime_breakout(df,_h,_l,window)\n    df['tt'+str(_h)[:1]+str(fast)+str(_l)[:1]+ str(slow)] = turtle_trader(df, _h, _l, slow, fast)\n    _o,_h,_l,_c = lower_upper_OHLC(df,relative = True)\ndf[['Close','rClose']].plot(figsize=(20,5),style=['k','grey'],\n                           title = str.upper(ticker)+ ' Relative &                              Absolute') \n```", "```py\n# CHAPTER 5: Regime Definition \nplot_abs_cols = ['Close','Hi'+str(lvl), 'clg','flr','rg_ch','rg']\n# plot_abs_cols = ['Close','Hi2', 'Lo2','clg','flr','rg_ch','rg']\nplot_abs_style = ['k', 'ro', 'go', 'kv', 'k^','b:','b--']\ny2_abs = ['rg']\nplot_rel_cols = ['rClose','rH'+str(lvl), 'rL'+str(lvl), 'rclg','rflr','rrg_ch','rrg']\n# plot_rel_cols = ['rClose','rH2', 'rL2','rclg','rflr','rrg_ch','rrg']\nplot_rel_style = ['grey', 'ro', 'go', 'kv', 'k^','m:','m--']\ny2_rel = ['rrg']\ndf[plot_abs_cols].plot(secondary_y= y2_abs,figsize=(20,8),\n            title = str.upper(ticker)+ ' Absolute',# grid=True,\n            style=plot_abs_style)\ndf[plot_rel_cols].plot(secondary_y=y2_rel,figsize=(20,8),\n            title = str.upper(ticker)+ ' Relative',# grid=True,\n            style=plot_rel_style)\ndf[plot_rel_cols + plot_abs_cols].plot(secondary_y=y2_rel + y2_abs,    figsize=(20,8), title = str.upper(ticker)+ ' Relative & Absolute',    # grid=True,\n    style=plot_rel_style + plot_abs_style) \n```", "```py\n# CHAPTER 5: Regime Definition \nohlc = ['Open','High','Low','Close']\n_o,_h,_l,_c = [ohlc[h] for h in range(len(ohlc))]\n# ma_st = ma_mt = ma_lt = lt_lo = lt_hi = st_lo = st_hi = 0\nmav = [fast, slow, 200]\nma_st,ma_mt,ma_lt = [df[_c].rolling(mav[t]).mean() for t in range(len(mav))]\nbo = [fast, slow]\nst_lo,lt_lo = [df[_l].rolling(bo[t]).min() for t in range(len(bo))]\nst_hi,lt_hi = [df[_h].rolling(bo[t]).max() for t in range(len(bo))]\nrg_combo = ['Close','rg','Lo3','Hi3','Lo3','Hi3','clg','flr','rg_ch']\n_c,rg,lo,hi,slo,shi,clg,flr,rg_ch =[rg_combo[r] for r in range(len(rg_combo)) ]\ngraph_regime_combo(ticker,df,_c,rg,lo,hi,slo,shi,clg,flr,rg_ch,ma_st,ma_mt,ma_lt,lt_lo,lt_hi,st_lo,st_hi)\nrohlc = ['rOpen','rHigh','rLow','rClose']\n_o,_h,_l,_c = [rohlc[h] for h in range(len(rohlc)) ]\n\nmav = [fast, slow, 200]\nma_st,ma_mt,ma_lt = [df[_c].rolling(mav[t]).mean() for t in range(len(mav))]\nbo = [fast, slow]\nst_lo,lt_lo = [df[_l].rolling(bo[t]).min() for t in range(len(bo))]\nst_hi,lt_hi = [df[_h].rolling(bo[t]).max() for t in range(len(bo))]\nrrg_combo = ['rClose','rrg','rL3','rH3','rL3','rH3','rclg','rflr','rrg_ch']\n_c,rg,lo,hi,slo,shi,clg,flr,rg_ch =[rrg_combo[r] for r in range(len(rrg_combo)) ]\ngraph_regime_combo(ticker,df,_c,rg,lo,hi,slo,shi,clg,flr,rg_ch,ma_st,ma_mt,ma_lt,lt_lo,lt_hi,st_lo,st_hi) \n```"]