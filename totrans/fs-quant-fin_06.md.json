["```py\n/// Calculate the standard deviation\nlet stddev(values:seq<float>) =\n    values\n    |> Seq.fold (fun acc x -> acc + (1.0 / float (Seq.length values)) * (x - (Seq.average values)) ** 2.0) 0.0\n    |> sqrt\n```", "```py\n/// Calculate logarithmic returns\nlet calcDailyReturns(prices:seq<float>) =\n    prices\n    |> Seq.pairwise\n    |> Seq.map (fun (x, y) -> log (x / y))\n```", "```py\n/// Annualized volatility\nlet annualVolatility(returns:seq<float>) =\n    let sd = stddev(calcDailyReturns(returns))\n    let days = Seq.length(returns)\n    sd * sqrt(float days)\n```", "```py\nlet formatLeadingZero(number:int):String =\n    String.Format(\"{0:00}\", number)\n\n/// Helper function to create the Yahoo-finance URL\nlet constructURL(symbol, fromDate:DateTime, toDate:DateTime) =\n    let fm = formatLeadingZero(fromDate.Month-1)\n    let fd = formatLeadingZero(fromDate.Day)\n    let fy = formatLeadingZero(fromDate.Year)\n    let tm = formatLeadingZero(toDate.Month-1)\n    let td = formatLeadingZero(toDate.Day)\n    let ty = formatLeadingZero(toDate.Year)\n    \"http://ichart.finance.yahoo.com/table.csv?s=\" + symbol + \"&d=\" + tm + \"&e=\" + td + \"&f=\" + ty + \"&g=d&a=\" + fm + \"&b=\" + fd + \"&c=\" + fy + \"&ignore=.csv\"\n\n/// Synchronous fetching (just one request)\nlet fetchOne symbol fromDate toDate =\n    let url = constructURL(symbol, fromDate, toDate)\n    let uri = new System.Uri(url)\n    let client = new WebClient()\n    let html = client.DownloadString(uri)\n    html\n\n/// Parse CSV\nlet getPrices stock fromDate toDate =\n    let data = fetchOne stock fromDate toDate\n    data.Trim().Split('\\n')\n    |> Seq.skip 1\n    |> Seq.map (fun s -> s.Split(','))\n    |> Seq.map (fun s -> float s.[4])\n    |> Seq.takeWhile (fun s -> s >= 0.0)\n\n/// Returns a formatted string with volatility for a stock\nlet getAnnualizedVol stock fromStr toStr =\n    let prices = getPrices stock (System.DateTime.Parse fromStr) (System.DateTime.Parse toStr)\n    let vol = Math.Round(annualVolatility(prices) * 100.0, 2)\n    sprintf \"Volatility for %s is %.2f %%\" stock vol \n```", "```py\n> getAnnualizedVol \"MSFT\" \"2013-01-01\" \"2013-08-29\";;\nval it : string = \"Volatility for MSFT is 21.30 %\"\n\n> getAnnualizedVol \"ORCL\" \"2013-01-01\" \"2013-08-29\";;\nval it : string = \"Volatility for ORCL is 20.44 %\"\n\n> getAnnualizedVol \"GOOG\" \"2013-01-01\" \"2013-08-29\";;\nval it : string = \"Volatility for GOOG is 14.80 %\"\n\n> getAnnualizedVol \"EBAY\" \"2013-01-01\" \"2013-08-29\";;\nval it : string = \"Volatility for EBAY is 20.82 %\"\n\n> getAnnualizedVol \"AAPL\" \"2013-01-01\" \"2013-08-29\";;\nval it : string = \"Volatility for AAPL is 25.16 %\"\n\n> getAnnualizedVol \"AMZN\" \"2013-01-01\" \"2013-08-29\";;\nval it : string = \"Volatility for AMZN is 21.10 %\"\n\n> getAnnualizedVol \"^GSPC\" \"2013-01-01\" \"2013-08-29\";;\nval it : string = \"Volatility for ^GSPC is 9.15 %\"\n```", "```py\nopen System\nopen System.Net\n\n/// Calculate the standard deviation\nlet stddev(values:seq<float>) =\n    values\n    |> Seq.fold (fun acc x -> acc + (1.0 / float (Seq.length values)) * (x - (Seq.average values)) ** 2.0) 0.0\n    |> sqrt\n\n/// Calculate logarithmic returns\nlet calcDailyReturns(prices:seq<float>) =\n    prices\n    |> Seq.pairwise\n    |> Seq.map (fun (x, y) -> log (x / y))\n\n/// Annualized volatility\nlet annualVolatility(returns:seq<float>) =\n    let sd = stddev(calcDailyReturns(returns))\n    let days = Seq.length(returns)\n    sd * sqrt(float days)\n\nlet formatLeadingZero(number:int):String =\n    String.Format(\"{0:00}\", number)\n\n/// Helper function to create the Yahoo-finance URL\nlet constructURL(symbol, fromDate:DateTime, toDate:DateTime) =\n    let fm = formatLeadingZero(fromDate.Month-1)\n    let fd = formatLeadingZero(fromDate.Day)\n    let fy = formatLeadingZero(fromDate.Year)\n    let tm = formatLeadingZero(toDate.Month-1)\n    let td = formatLeadingZero(toDate.Day)\n    let ty = formatLeadingZero(toDate.Year)\n    \"http://ichart.finance.yahoo.com/table.csv?s=\" + symbol + \"&d=\" + tm + \"&e=\" + td + \"&f=\" + ty + \"&g=d&a=\" + fm + \"&b=\" + fd + \"&c=\" + fy + \"&ignore=.csv\"\n\n/// Synchronous fetching (just one request)\nlet fetchOne symbol fromDate toDate =\n    let url = constructURL(symbol, fromDate, toDate)\n    let uri = new System.Uri(url)\n    let client = new WebClient()\n    let html = client.DownloadString(uri)\n    html\n\n/// Parse CSV\nlet getPrices stock fromDate toDate =\n    let data = fetchOne stock fromDate toDate\n    data.Trim().Split('\\n')\n    |> Seq.skip 1\n    |> Seq.map (fun s -> s.Split(','))\n    |> Seq.map (fun s -> float s.[4])\n    |> Seq.takeWhile (fun s -> s >= 0.0)\n\n/// Returns a formatted string with volatility for a stock\nlet getAnnualizedVol stock fromStr toStr =\n    let prices = getPrices stock (System.DateTime.Parse fromStr) (System.DateTime.Parse toStr)\n    let vol = Math.Round(annualVolatility(prices) * 100.0, 2)\n    sprintf \"Volatility for %s is %.2f %%\" stock vol\n\ngetAnnualizedVol \"MSFT\" \"2013-01-01\" \"2013-08-29\"\n// val it : string = \"Volatility for MSFT is 21.30 %\"\n\ngetAnnualizedVol \"ORCL\" \"2013-01-01\" \"2013-08-29\"\n// val it : string = \"Volatility for ORCL is 20.44 %\"\n\ngetAnnualizedVol \"GOOG\" \"2013-01-01\" \"2013-08-29\"\n// val it : string = \"Volatility for GOOG is 14.80 %\"\n\ngetAnnualizedVol \"EBAY\" \"2013-01-01\" \"2013-08-29\"\n// val it : string = \"Volatility for EBAY is 20.82 %\"\n\ngetAnnualizedVol \"AAPL\" \"2013-01-01\" \"2013-08-29\"\n// val it : string = \"Volatility for AAPL is 25.16 %\"\n\ngetAnnualizedVol \"AMZN\" \"2013-01-01\" \"2013-08-29\"\n// val it : string = \"Volatility for AMZN is 21.10 %\"\n\ngetAnnualizedVol \"^GSPC\" \"2013-01-01\" \"2013-08-29\"\n// val it : string = \"Volatility for ^GSPC is 9.15 %\"\n```", "```py\n/// Solve for implied volatility\n\nlet pow x n = exp (n * log(x) )\n\ntype PutCallFlag = Put | Call\n\n/// Cumulative distribution function\nlet cnd x =\n    let a1 =  0.31938153\n    let a2 = -0.356563782\n    let a3 =  1.781477937\n    let a4 = -1.821255978\n    let a5 =  1.330274429\n    let pi = 3.141592654\n    let l  = abs(x)\n    let k  = 1.0 / (1.0 + 0.2316419 * l)\n    let w  = (1.0-1.0/sqrt(2.0*pi)*exp(-l*l/2.0)*(a1*k+a2*k*k+a3*(pow k 3.0)+a4*(pow k 4.0)+a5*(pow k 5.0)))\n    if x < 0.0 then 1.0 - w else w\n\n/// Black-Scholes\n// call_put_flag: Call | Put\n// s: stock price\n// x: strike price of option\n// t: time to expiration in years\n// r: risk free interest rate\n// v: volatility\nlet black_scholes call_put_flag s x t r v =\n    let d1=(log(s / x) + (r+v*v*0.5)*t)/(v*sqrt(t))\n    let d2=d1-v*sqrt(t)\n    //let res = ref 0.0\n\n    match call_put_flag with\n    | Put -> x*exp(-r*t)*cnd(-d2)-s*cnd(-d1)\n    | Call -> s*cnd(d1)-x*exp(-r*t)*cnd(d2)    \n/// Bisection solver\nlet rec bisect n N (f:float -> float) (a:float) (b:float) (t:float) : float =\n    if n >= N then -1.0\n    else\n        let c = (a + b) / 2.0\n        if f(c) = 0.0 || (b - a) / 2.0 < t then\n            // Solution found\n            c\n        else\n            if sign(f(c)) = sign(f(a)) then\n                bisect (n + 1) N f c b t\n            else    \n                bisect (n + 1) N f a c t\n\nLet's use it!\n\n/// Calculate implied volatility for an option\nbisect 0 25 (fun x -> (black_scholes Call 58.60 60.0 0.05475 0.0095 x) - 1.2753) 0.0 1.0 0.001\n```", "```py\nlet option_price = black_scholes Call 73.00 75.0 (days_to_years 20) 0.01 0.15\n```", "```py\n> bisect 0 25 (fun x -> (black_scholes Call 73.00 75.0 (days_to_years 20) 0.01 x) - option_price) 0.0 1.0 0.001;;\nval it : float = 0.1494140625\n```", "```py\n/// Assumes 100 shares of stock per option\nlet nr_of_stocks_delta_hedge N =\n    (black_scholes_delta 'c' 58.0 60.0 0.5 0.01 0.3) * 100.0 * (float N)\n\n/// Calculate nr of shares needed to cover 100 call options\nnr_of_stocks_delta_hedge 100\n```", "```py\n> nr_of_stocks_delta_hedge 100;;\nval it : float = 4879.628104\n```", "```py\nopen System.IO\nopen FSharp.Charting\nopen System.Windows.Forms.DataVisualization.Charting\n\nopen MathNet.Numerics\nopen MathNet.Numerics.LinearAlgebra\nopen MathNet.Numerics.LinearAlgebra.Double\nopen MathNet.Numerics.Distributions\n\nlet filePath = @\"smile_data.csv\"\n\n/// Split row on commas\nlet splitCommas (l:string) =\n    l.Split(',')\n\n/// Read a file into a string array\nlet openFile (name : string) =\n    try\n        let content = File.ReadAllLines(name)\n        content |> Array.toList\n    with\n        | :? System.IO.FileNotFoundException as e -> printfn \"Exception! %s \" e.Message; [\"empty\"]\n\n/// Read the data from a CSV file and returns\n/// a tuple of strike price and implied volatility%\nlet readVolatilityData =\n    openFile filePath\n    |> List.map splitCommas\n    |> List.map (fun cols -> (cols.[2], cols.[3]))\n\n/// Calculates moneyness and parses strings into numbers\nlet calcMoneyness spot list =\n    list\n    |> List.map (fun (strike, imp) -> (spot / (float strike), (float imp)))\n```", "```py\nlet list = readVolatilityData\nlet mlist = calcMoneyness 83.2 list\n\n/// Plot values using FSharpChart\nfsi.AddPrinter(fun (ch:FSharp.Charting.ChartTypes.GenericChart) -> ch.ShowChart(); \"FSharpChartingSmile\")    \n```", "```py\nChart.Point(mlist)\n```", "```py\n/// Sample points\n//let xdata = [ 0.0; 1.0; 2.0; 3.0; 4.0 ]\n//let ydata = [ 1.0; 1.4; 1.6; 1.3; 0.9 ]\n\nlet xdata = mlist |> Seq.map (fun (x, _) -> x) |> Seq.toList\nlet ydata = mlist |> Seq.map (fun (_, y) -> y) |> Seq.toList\n\nlet N = xdata.Length\nlet order = 2\n\n/// Generating a Vandermonde row given input v\nlet vandermondeRow v = [for x in [0..order] do yield v ** (float x)]\n\n/// Creating Vandermonde rows for each element in the list\nlet vandermonde = xdata |> Seq.map vandermondeRow |> Seq.toList\n\n/// Create the A Matrix\nlet A = vandermonde |> DenseMatrix.ofRowsList N (order + 1)\nA.Transpose()\n\n/// Create the Y Matrix\nlet createYVector order l = [for x in [0..order] do yield l]\nlet Y = (createYVector order ydata |> DenseMatrix.ofRowsList (order + 1) N).Transpose()\n\n/// Calculate coefficients using least squares\nlet coeffs = (A.Transpose() * A).LU().Solve(A.Transpose() * Y).Column(0)\n\nlet calculate x = (vandermondeRow(x) |> DenseVector.ofList) * coeffs\n\nlet fitxs = [(Seq.min xdata).. 0.01 ..(Seq.max xdata)]\nlet fitys = fitxs |> List.map calculate\nlet fits = [for x in [(Seq.min xdata).. 0.01 ..(Seq.max xdata)] do yield (x, calculate x)]\n```", "```py\nlet chart = Chart.Combine [Chart.Point(mlist); Chart.Line(fits).WithTitle(\"Volatility Smile\")]\n```"]