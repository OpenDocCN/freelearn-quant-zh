- en: Chapter 9. Portfolio Theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Understanding portfolio theory is very important in learning finance. It is
    well known that *don''t put all your eggs in one basket*, that is, it is a great
    idea to diversify away your risk. However, very few know the implied assumption
    behind such a famous idiom. In this chapter, we will discuss various risk measures
    for individual stocks or portfolios, such as Sharpe ratio, Treynor ratio, Sortino
    ratio, how to minimize portfolio risk based on those measures (ratios), how to
    set up an objective function, how to choose an efficient portfolio for a given
    set of stocks, and how to construct an efficient frontier. Our focus is on how
    to apply portfolio theory by using real-world data. For instance, today we have
    $2 million cash and plan to purchase IBM and Walmart stocks. If we have 30% invested
    in the first one and the rest in the second, what is our portfolio risk? What
    is the least risky portfolio that we could form based on those two stocks? How
    about 10 or 500 stocks? In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to portfolio theory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 2-stock portfolio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: N-stock portfolio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Correlation versus diversification effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Producing a return matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating an optimal portfolio based on Sharpe ratio, Treynor ratio, and Sortinor
    ratio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing an efficient frontier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modigliani and Modigliani performance measure (M2 measure)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to portfolio theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The keyword for the portfolio theory is diversification, while the keyword
    for diversification is correlation. In other words, correlation is used to measure
    how closely two stocks or portfolios are moving together. The objective of portfolio
    theory is to allocate our assets optimally with respect to risk and return. Markowitz
    (1952) argues that we should consider only the first two moments of a security''s
    return distribution: mean and variance. For financial markets, several important
    assumptions are made, such as stock markets are inefficient, a typical investor
    is rational, and an arbitrage opportunity would not last long. For the preferences
    between two stocks, for a given risk, a rational investor would prefer stock with
    a higher expected return; for a given return, a rational investor prefers stock
    with a lower risk level. Sometimes, a single period portfolio optimization is
    called *Markowitz Portfolio Optimization*. The input includes a return matrix,
    and a variance and covariance matrix, while the output is an efficient portfolio.
    By connecting numerous efficient portfolios, an efficient frontier is formed.
    Here, we start with the simplest scenario: a two-stock portfolio.'
  prefs: []
  type: TYPE_NORMAL
- en: A 2-stock portfolio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Clearly, a 2-stock portfolio is the simplest one. Let''s assume that the weights
    of those two stocks are *w1* and *w2*. The portfolio returns are given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A 2-stock portfolio](img/B06175_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, *Rp,t*, is the portfolio return at time *t*, *w1* (*w2*) is the weight
    for stock 1 (2), and *R1,t* (*R2,t*) is return at time *t* for stock 1 (2). When
    talking about expected return or mean, we have a quite similar formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A 2-stock portfolio](img/B06175_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, ![A 2-stock portfolio](img/B06175_09_73.jpg) is the mean or expected
    portfolio returns and ![A 2-stock portfolio](img/B06175_09_03.jpg) ![A 2-stock
    portfolio](img/B06175_09_04.jpg) is the mean or expected returns for stock 1 (2).
    The variance of such a 2-stock portfolio is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A 2-stock portfolio](img/B06175_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, ![A 2-stock portfolio](img/B06175_09_06.jpg) is the portfolio variance
    and ![A 2-stock portfolio](img/B06175_09_07.jpg) is the standard deviation for
    stock 1 (2). The definitions of variance and standard for stock 1 are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A 2-stock portfolio](img/B06175_09_08.jpg) ![A 2-stock portfolio](img/B06175_09_09.jpg)
    is the covariance (correlation) between stocks 1 and 2\. They are defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A 2-stock portfolio](img/B06175_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For covariance, if it is positive, then those two stocks usually would move
    together. On the other hand, if it is negative, they would move in the opposite
    way most of times. If the covariance is zero, then they are not related. However,
    if we know that ![A 2-stock portfolio](img/B06175_09_11.jpg) we could not claim
    whether A is strongly correlated with B than C, or the other way around. On the
    other hand, if ![A 2-stock portfolio](img/B06175_09_12.jpg) we would claim that
    A is strongly correlated with B than A. This suggests that correlation is more
    useful than covariance. The range of a correlation is from -1 to 1\. The lower
    the value of correlation, the higher is the effectiveness of the diversification
    effect. When the correlation is -1 (1), it is called perfectively negatively (positively)
    correlated. When two stocks (or portfolios) are perfectively positively correlated
    there is no diversification.
  prefs: []
  type: TYPE_NORMAL
- en: Assume that the volatilities (standard deviations) of two stocks are 0.06 and
    0.24 and they are perfectively negatively correlated. What are two weights in
    order to form a zero-risk portfolio? There exist several methods to find a solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Method 1: we could manually find a solution: plug in given values into Equation
    (3) and set it equal to zero where *x=x1* and *x2=1-x*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A 2-stock portfolio](img/B06175_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After expanding and collecting terms, we would end up with the following general
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A 2-stock portfolio](img/B06175_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For such a general form, we have the following two solutions if the term inside
    the square root is positive, that is, ![A 2-stock portfolio](img/B06175_09_15.jpg):'
  prefs: []
  type: TYPE_NORMAL
- en: '![A 2-stock portfolio](img/B06175_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Based on a set of *a*, *b*, and *c*, we have a solution of x=80%, that is,
    when *w1=0.80* and *w2=0.2*, the preceding 2-stock portfolio will be risk-free.
    Assume that we have an equation of *x2+6x+3=0*, the following Python program offers
    two solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Method 2: For a given pair of standard deviations (or a pair of variances)
    plus a correlation between those two stocks, we generate many weights for stock
    1, such as 0, 0.001, 0.002, 0.003, and the like. Remember that *w2=1-w1*. By applying
    Equation (3), we estimate the variances of this 2-stock portfolio. Our final solution
    will be the pair of *w1* and *w2* achieving the minimum portfolio variance, see
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'First, the result confirms our previous result with *w1=0.8* and *w2=0.2*.
    In the program, we have 1000 pairs of *w1* and *w2*. A small value, called `tiny`,
    is *1/1000=0.001*. The first pair of two weights is 0.1% and 99.9%. A very big
    number is assigned to our solution variable, that is, as an initial value. In
    this program, `portVar=10`. Other big numbers would work perfectly, such as 100\.
    Here is the logic: based on the first pair of *w1* and *w2*, we estimate the portfolio
    variance. If this new portfolio variance is less than `portVar`, we replace `portVar`
    with this new value and record *w1* as well. If the new portfolio variance is
    bigger than `portVar`, we do nothing. Repeat the same procedure until we finish
    the loop. Here is an analogy. Assume that we want to find the tallest person among
    1,000 persons. Assume that we have a variable call `tallestPerson` and its initial
    vale is 0.1 inch. Since every person will be taller than this value, the first
    person''s height will replace this value. If the next person''s height is higher
    than this variable, we replace it. Otherwise, we go to the next one. The procedure
    is repeated until the last person. In terms of efficiency, one small trick is
    to estimate `var1` and `var2` just once.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In finance, it is a convention to use both variance and standard deviation
    to represent risk, since they describe uncertainty. Usually, we use standard deviation
    of returns to represent the volatility. It is a good idea to look at the impact
    of correlation on the efficient frontier. First, let''s learn how to generate
    a set of correlated random numbers. There are two steps involved:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate two random time series, *x1* and *x2*, with a zero-correlation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the following formula:![A 2-stock portfolio](img/B06175_09_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here ρ is the predetermined correlation between those two time series. Now,
    *y1* and *y2* are correlated with a predetermined correlation. The following Python
    program would implement the preceding approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Optimization – minimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before discussing how to generate an optimal portfolio, it is necessary to
    study a few optimization functions. In the following example, we minimize our
    objective function of y:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimization – minimization](img/B06175_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'First, let''s look at the graph of this objective function, see the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The graph is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimization – minimization](img/B06175_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the program more general, two coefficients of `a` and `b` are generated.
    Apparently, since the power of `x` is 2, `y` is minimized only when `x` is 0\.
    The Python code for minimization is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding program, the major function used is called the `scipy.optimize.minimize()`
    function. The first input is our objective function. In this case, it is our y
    function. The second value is our input value, that is, initial value. Since there
    is only one independent variable of `x` for the `y` function, `x0` is a scalar.
    For the third input value, method, we have several choices: `NelderMead`. The
    following table lists 11 choices for the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `NelderMead` | Uses the Simplex algorithm. This algorithm is robust in many
    applications. However, if numerical computation of derivative can be trusted,
    other algorithms using the first and/or second derivatives information might be
    preferred for their better performance in general. |'
  prefs: []
  type: TYPE_TB
- en: '| `Powell` | It is a modification of Powell''s method, which is a conjugate
    direction method. It performs sequential one-dimensional minimizations along each
    vector of the directions set, which is updated at each iteration of the main minimization
    loop. The function need not be differentiable, and no derivatives are taken. |'
  prefs: []
  type: TYPE_TB
- en: '| `CG` | Uses a nonlinear conjugate gradient algorithm by Polak and Ribiere,
    a variant of the Fletcher-Reeves method. Only the first derivatives are used.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `BFGS` | Uses the quasi-Newton method of Broyden, Fletcher, Goldfarb, and
    Shanno (BFGS). It uses the first derivatives only. BFGS has proven good performance
    even for non-smooth optimizations. This method also returns an approximation of
    the Hessian inverse, stored as hess_inv in the OptimizeResult object. |'
  prefs: []
  type: TYPE_TB
- en: '| `NewtonCG` | Uses a Newton-CG algorithm (also known as the truncated Newton
    method). It uses a CG method to compute the search direction. |'
  prefs: []
  type: TYPE_TB
- en: '| `LBFGSB` | Uses the help() function to find more information. |'
  prefs: []
  type: TYPE_TB
- en: '| `TNC` | [ibid] |'
  prefs: []
  type: TYPE_TB
- en: '| `COBYLA` | [ibid] |'
  prefs: []
  type: TYPE_TB
- en: '| `SLSQP` | [ibid] |'
  prefs: []
  type: TYPE_TB
- en: '| `dogleg` | [ibid] |'
  prefs: []
  type: TYPE_TB
- en: '| `trustncg` | [ibid] |'
  prefs: []
  type: TYPE_TB
- en: Table 9.1 Types of solver
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The output shows that the function value is 3.2, and it is achieved by assigning
    `0` to `x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optimization terminated successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimization – minimization](img/B06175_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next example is using the `scipy.optimize.brent()` function on an exponential
    function minimization, see the code followed by the objective function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimization – minimization](img/B06175_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following program tries to minimize the objective function, that is, `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution is `0.799999999528` and the related graph is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimization – minimization](img/B06175_09_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In economics and finance, there is an important concept called utility. One
    of the major reasons to design such a concept is that for many situations, we
    could not quantify certain effects, such as happiness, willingness, risk preference,
    wellness, emotion, and the like. For example, your boss asks you to work extra
    hours on Friday and promises you a bonus. Assume that its value is *x* dollar
    per hour and you are happy with it. If the task is urgent, your boss might ask
    for more hours. Assume that you have to work on Saturday. Do you think the same
    x dollar per hour would make your happy? For most workers the extra bonus should
    be higher than x since they would think that they have sacrificed more now than
    just a Friday evening. Usually, a utility function could be defined as the different
    between benefits and costs. The marginal benefit is a decreasing function of our
    input. It means the extra dollar received is not as valuable of the previous dollar.
    On the other hand, the marginal cost will be an increasing function of your input.
    When you asked to contribute extra work, the appropriate monetary incentive would
    go higher. Here is one utility function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimization – minimization](img/B06175_09_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, *U* is the utility function, *E(R)* is the expected portfolio return
    and we could use its mean to approximate, *A* is the risk-averse coefficient,
    and *σ2* is the variance of the portfolio. When the expected return is higher,
    our utility is higher. The opposite is true: when the risk of our portfolio is
    higher the utility is lower. The key is *A*, which represents the risk-tolerance.
    With the same expected return and risk level, a more risk-reverse investor (a
    higher A) would experience a lower utility. Generally speaking, the objective
    is to balance the benefits (expected returns) with risk (variance).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that we have a set of stocks, such as **International Business Machine**
    (**IBM**), **Walmart** (**WMT**), and **Citi Group** (**C**). Based on the preceding
    utility function, which stock should we choose for different given risk preference?
    The code is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding program, the mean and standard deviation are both annualized.
    The value of 252 represents the number of trading days per year. The time period
    used is from 1/1/2012 to 12/31/2016, that is, a five-year period. The output is
    shown here. Again, the result is for the investor with a risk preference with
    A=1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimization – minimization](img/B06175_09_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Based on the concept of utility, investors prefer stock with the highest utility.
    Thus, we should choose the last stock. In other words, if we have to choose one
    stock as our investment, we should choose City Group. On the other hand, when
    A=10, that is, extremely risk-averse, we have the following utility values for
    those three stocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimization – minimization](img/B06175_09_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The result suggests that such an investor should choose the second stock, that
    is, Walmart as our sole investment. This is consistent with our common sense,
    see their corresponding mean returns and risk levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimization – minimization](img/B06175_09_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding program, a function called `meanVarAnnual()` is generated that
    delivers annualized mean return and annualized volatility. Let's compare the last
    two stocks. The second stock is less risky than the third one at the same time;
    it has a higher risk than the third stock. The mean annual return of the second
    stock decreases by 12%, however, its variance decreases by 63%. The consequence
    is that utility increased.
  prefs: []
  type: TYPE_NORMAL
- en: 'For portfolio optimization, or Markowitz Portfolio Optimization, our input
    datasets include: expected returns, standard deviations, and correlation matrix.
    The output will be an optimal portfolio. By connecting those efficient portfolios,
    an efficient frontier could be constructed. In the rest of this chapter, we use
    historical returns to represent expected returns and use the historical correlation
    in the place of expected correlation.'
  prefs: []
  type: TYPE_NORMAL
- en: Forming an n-stock portfolio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following program generates a return matrix with three stocks plus S&P500:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To show the first and last few lines, we use the `.head()` and `.tail()` functions
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding program, we retrieve S&P500 data first. Then stock data is
    merged with the market index. The major function used is `pandas.merge()`. Please
    pay attention to the meanings of two input parameters: `left_index=True` and `right_index=True`.
    They indicate that those two datasets are merged by their indices. In the program,
    the daily frequency is retrieved. It is quite often that academic researchers
    and professionals prefer monthly frequency. One of the reasons is that monthly
    data has little so-called micro-structure effect compared with daily data. The
    following program uses monthly data. The Python data used is `yanM` `onthly.pkl`,
    [http://canisius.edu/~yany/python/yanMonthly.pkl](http://canisius.edu/~yany/python/yanMonthly.pkl).
    First, we print a list of securities included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To choose a specific security, the index of the dataset is compared with the
    ticker; see the following code for choosing IBM''s monthly price data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following program generates returns first, and then use ticker name as
    its corresponding column name instead of using a generate term, such as `return`.
    The reason is that we intend to choose several stocks and put them together side-by-side,
    that is, arranged by date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we could construct an n-stock return matrix from `yanMonthly.pkl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To randomly choose m stocks from a set of existing available stocks (n of them),
    see the command of `scipy.random.uniform(low=1,high=len(x4),size=n_stocks)`.Since
    `n_stocks` has a value of 10, we choose 10 stocks from `len(x4)`. The output is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In finance, constructing an efficient frontier is always a challenging job.
    This is especially true with real-world data. In this section, we discuss the
    estimation of a variance-covariance matrix and its optimization, finding an optimal
    portfolio, and constructing an efficient frontier with stock data downloaded from
    Yahoo! Finance. When a return matrix is given, we could estimate its variance-covariance
    matrix. For a given set of weights, we could further estimate the portfolio variance.
    The formula to estimate the variance and standard deviation for returns from a
    single stock are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Forming an n-stock portfolio](img/B06175_09_27.jpg)![Forming an n-stock portfolio](img/B06175_09_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, ![Forming an n-stock portfolio](img/B06175_09_29.jpg) is the mean, ![Forming
    an n-stock portfolio](img/B06175_09_30.jpg) is the stock return for period *i*,
    and *n* is the number of returns. For an n-stock portfolio, we have the following
    formula to estimate its portfolio return:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Forming an n-stock portfolio](img/B06175_09_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, ![Forming an n-stock portfolio](img/B06175_09_32.jpg) is the portfolio
    return, ![Forming an n-stock portfolio](img/B06175_09_33.jpg) is the weight for
    stock *i*, and ![Forming an n-stock portfolio](img/B06175_09_30.jpg) is the stock
    i''s return. This is true for the portfolio mean or expected portfolio return,
    see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Forming an n-stock portfolio](img/B06175_09_34.jpg)![Forming an n-stock portfolio](img/B06175_09_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The portfolio variance for an n-stock portfolio is defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Forming an n-stock portfolio](img/B06175_09_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, ![Forming an n-stock portfolio](img/B06175_09_06.jpg) is the portfolio
    variance, *n* is the number of stocks in the portfolio, ![Forming an n-stock portfolio](img/B06175_09_33.jpg)
    is the weight of stock i, and ![Forming an n-stock portfolio](img/B06175_09_38.jpg)
    is the covariance between stocks *i* and *j*. Note that when *i* is the same as
    *j*, ![Forming an n-stock portfolio](img/B06175_09_38.jpg) is the variance, that
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Forming an n-stock portfolio](img/B06175_09_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Understandably, a 2-stock portfolio is just a special case of an n-stock portfolio.
    Again, when the values of the return matrix and the weight vector are given, we
    can estimate their variance-covariance matrix and portfolio variance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The key command used is `ret.T*ret`. `ret.T` is the transpose of a return matrix.
    Since the return matrix is 6 by 2 matrix, its transpose will be a 2 by 6 matrix.
    Thus, the result of a matrix multiplication of *(2*6)* and *(6*2)* will be *(2*2)*.
    The corresponding outputs, such as return matrix, covariance matrix, weights,
    and portfolio variance, are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way to conduct a matrix multiplication is by using the `spcipy.dot()`
    function, see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Constructing an optimal portfolio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In finance, we are dealing with a trade-off between risk and return. One of
    the widely used criteria is Sharpe ratio, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing an optimal portfolio](img/B06175_09_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following program would maximize the Sharpe ratio by changing the weights
    of the stocks in the portfolio. The whole program could be divided into several
    parts. The input area is very simple, just several tickers in addition to the
    beginning and ending dates. Then, we define four functions, convert daily returns
    into annual ones, estimate a portfolio variance, estimate the Sharpe ratio, and
    estimate the last (that is, nth) weight when *n-1* weights are estimated from
    our optimization procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Code for input area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Code for defining a few functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Code for generating a return matrix (annul return):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In step 2, we estimate annual returns from daily returns. For the optimization,
    the most important function is the `scipy.optimize.fmin()` function. The first
    input for this minimization function is our objective function, `negative_sharpe_n_minus_1`.
    Our objective is to maximize a Sharpe Ratio. Since this is a minimization function,
    it is equivalent to minimize a negative Sharpe ratio. Another issue is that we
    need n weights to calculate a Sharpe ratio. However, since the summation of *n*
    weights is 1, we have only n-1 weights as our choice variables. From the following
    output, we know that if we use a naïve equal-weighted strategy, the Sharpe ratio
    is 0.63\. On the other hand, the Sharpe ratio for our optimal portfolio is 0.67:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Constructing an efficient frontier with n stocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Constructing an efficient frontier is always one of the most difficult tasks
    for finance instructors since the task involves matrix manipulation and a constrained
    optimization procedure. One efficient frontier could vividly explain the Markowitz
    Portfolio theory. The following Python program uses five stocks to construct an
    efficient frontier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Code for input area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Code for defining two functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Code for generating a return matrix R:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Code for estimating optimal portfolios for a given return:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Code for plotting the efficient frontier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The key to understanding this program is its objective function under the title
    of *# function 2: objective function*. Our objective is for a given target portfolio
    mean or expected value, we would minimize our portfolio risk. The first part of
    the command line of return `np.sqrt(port_var) + penalty`, is the portfolio variance.
    There is no ambiguity about the first term. Now, let''s turn to the second term
    called penalty, which is defined as the absolute deviation of the portfolio mean
    from our target mean times a big number. This is a quite popular way to define
    our objective function by using an unconstrained optimization procedure. An alternative
    way is to apply an optimization procedure with constraints. The output graph is
    presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing an efficient frontier with n stocks](img/B06175_09_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In one of the previous programs, our objective function is to maximize a Sharpe
    ratio. From the previous chapter, we know that when the portfolio under consideration
    is not all our wealth, Sharpe ratio might not be a good measure. Viewed as a modification
    to the Sharpe ratio, the Treynor ratio is defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing an efficient frontier with n stocks](img/B06175_09_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, the left-hand side is Treynor ratio, ![Constructing an efficient frontier
    with n stocks](img/B06175_09_43.jpg) is the mean portfolio return, ![Constructing
    an efficient frontier with n stocks](img/B06175_09_44.jpg) is the risk-free rate,
    and ![Constructing an efficient frontier with n stocks](img/B06175_09_45.jpg)
    is the portfolio beta. The only modification is that the sigma (total risk) is
    replaced by beta (market risk).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following program, Treynor ratio will be our objective function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing an efficient frontier with n stocks](img/B06175_09_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another argument against using standard deviation in the Sharpe ratio is that
    it considers the deviations in both directions, below and above the mean. Nevertheless,
    we know that investors worry more about the downside risk (deviation below mean
    return). The second issue for the Sharpe ratio is that for the numerator, we compare
    mean returns with a risk-free rate. Nevertheless, for the denominator, the deviations
    are from the mean return instead of the same risk-free rate. To overcome those
    two shortcomings, a so-called **Lower Partial Standard Deviation** (**LPSD**)
    is developed. Assume we have n returns and one **risk-free rate** (**Rf**). Assume
    further that there are m returns that are less than this risk-free rate. We estimate
    LPSP by using only those m returns and it is defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing an efficient frontier with n stocks](img/B06175_09_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following program shows how to estimate LPSD for a given set of returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to Sharpe ratio and Treynor ratio, the Sortino ratio is defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing an efficient frontier with n stocks](img/B06175_09_48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following program would maximize Sortino ratio for a few given stocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the corresponding output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing an efficient frontier with n stocks](img/B06175_09_49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Modigliani and Modigliani (1997) propose another performance measure. Their
    benchmark is a specified market index. Let''s use S&P500 index as an example.
    Assume that our portfolio has a higher risk and a higher return compared with
    the S&P500 market index:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing an efficient frontier with n stocks](img/B06175_09_50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is their two-step approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Form a new portfolio with two weights w for our original portfolio and (1-w)
    for a risk-free investment. The new portfolio would have the risk as the SP500
    market index:![Constructing an efficient frontier with n stocks](img/B06175_09_51.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Actually, the weight of *w* will be given by the following formula:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Constructing an efficient frontier with n stocks](img/B06175_09_52.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Calculate the portfolio mean returns by applying the following formula:![Constructing
    an efficient frontier with n stocks](img/B06175_09_53.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final judgment is whether this new risk-adjusted portfolio is bigger or
    less than S&P500 mean return. The following Python program achieves this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing an efficient frontier with n stocks](img/B06175_09_54.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are different weighting schemes to estimate the portfolio returns. The
    commonly used ones are value-weighed, equal-weighted, and price-weighted. When
    estimating certain indices, the value-weighted is also called market capitalization
    weighted. For example, S&P500 returns are value-weighted and Dow Jones Industrial
    Average is price-weighed. The equal-weighted is the simplest one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing an efficient frontier with n stocks](img/B06175_09_55.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, ![Constructing an efficient frontier with n stocks](img/B06175_09_56.jpg)
    is the portfolio return at time *t*, ![Constructing an efficient frontier with
    n stocks](img/B06175_09_57.jpg) is the stock *i*''s return at time *t*, and *n*
    is the number of stocks in the portfolio. Here is a very simple example, assume
    that we have two stocks in our portfolio. Last year stock A had a return of 20%
    while stock B had a -10%, what is an equal-weighted return based on those two
    values? The answer is 5%. For a value-weighted index, the key is the weight ![Constructing
    an efficient frontier with n stocks](img/B06175_09_33.jpg), see the following
    formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing an efficient frontier with n stocks](img/B06175_09_58.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here *vi* is the value of our investment for ith stock, ![Constructing an efficient
    frontier with n stocks](img/B06175_09_59.jpg) is the total value of our portfolio.
    Assume that we have a 2-stock portfolio. Last year, stock A (B) has a return of
    20% (-10%). If our investment for stocks A and B are 90% versus 10%, what is their
    value-weighted return last year? The answer is *17% (0.9*0.2+0.1*(-0.1))*. For
    a market index, such as S&P5000, *vi* will be the market capitalization of stock
    i and the summation of all 500 stocks'' market capitalizations will be the market
    value of the index portfolio. When estimating the value-weighed market index,
    the small stocks would have little impact since their weights are so tiny. Here
    is a simple example by using `yanMonthly.pkl`, downloadable at [http://canisius.edu/~yany/python/yanMonthly.pkl](http://canisius.edu/~yany/python/yanMonthly.pkl):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing an efficient frontier with n stocks](img/B06175_09_60.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since there are just two stocks, we could manually calculate a few days for
    several weighting schemes. Let''s use the last observation, January 1973, as an
    example and assume that we have 100 shares of IBM and 200 shares of Walmart. The
    equal-weighted monthly return is *-0.08 (0.04-0.2)/2)*. For a value-weighted one,
    we estimate two weights and assume that we use the previous price to estimate
    those weights. The total value is *100*7.04 + 200*0.05= 714*. Thus *w1= 0.9859944
    (704/714)* and *w2=0.0140056*. The value-weighted return is 0.0366, that is, *0.9859944*0.04
    + 0.0140056*(-0.2)*. For a price-weighted portfolio, we have the same format as
    a value-weighted one. The major difference is how to define its weights:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing an efficient frontier with n stocks](img/B06175_09_61.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, ![Constructing an efficient frontier with n stocks](img/B06175_09_62.jpg)
    is the price of *i*th stock. In a sense, a price-weighted portfolio could be viewed
    as we only have one share for each stock in our portfolio for the same 2-stock
    portfolio. Last year, stock A (B) has a return of 20% (-10%). If the price of
    stock A (B) is $10 ($90), then the price-weighted portfolio return would be -7%,
    that is, *0.2*(10/100)-0.1*(90/100)*. It is obvious that stocks with a higher
    unit price command a higher weight. Based on the preceding results for IBM and
    Walmart, the two weights for the price-weighted scheme are *0.9929478*; that is,
    *7.04/(7.04+0.05)* and *0.007052186*. Thus, the price-weighted portfolio return
    in that month is *0.03830747* and *0.9929478*0.04+0.007052186*(-0.2)*.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few twists when estimating portfolio or index returns. The first
    one is whether returns include dividends and other distributions. For example,
    the `CRSP` database has `EWRETD` and `EWRETX`. `EWRETD` is defined as equal-weighed
    market returns based on stock returns including dividend, that is, total return.
    `EWRETX` is defined as equal-weighted market returns without dividends or other
    distributions. Similarly, for value-weighed returns, there exists `VWRETD` and
    `VWRETX`. The second twist is that it is common practice to use previous period's
    market capitalizations as weights instead of the current ones.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please refer to the following articles:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Markowitz, Harry, 1952, Portfolio* *Selection, Journal of Finance 8,77-91*,
    [http://onlinelibrary.wiley.com/doi/10.1111/j.1540-6261.1952.tb01525.x/full](http://onlinelibrary.wiley.com/doi/10.1111/j.1540-6261.1952.tb01525.x/full)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Modigliani, Franco, 1997, Risk-Adjusted Performance, Journal of Portfolio
    Managemen, 45–54*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sharpe, William F., 1994, the Sharpe Ratio, the Journal of Portfolio Management
    21 (1), 49–58*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sharpe, W. F., 1966, Mutual Fund Performance, Journal of Business 39 (S1),
    119–138*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Scipy manual, Mathematical optim**ization: finding minima of functions*, [http://www.scipy-lectures.org/advanced/mathematical_optimization/](http://www.scipy-lectures.org/advanced/mathematical_optimization/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sortino, F.A., Price, L.N.,1994, Performance measurement in a downside risk
    framework, Journal of Investing 3, 50–8*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Treynor, Jack L., 1965, How to Rate Management of Investment Funds, Harvard
    Business Review 43, pp. 63–75*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Appendix A – data case #5 - which industry portfolio do you prefer?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Please go through the following objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the definitions of 49 industries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Learn how to download data from Prof. French's Data Library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understand the utility function, see here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find out which industry is optimal for different types of investors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Learn how to draw an indifference curve (for just one optimal portfolio).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Procedure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Go to *Professor French's Data Library* at:[http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html](http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click `CSV` on the right-hand side of **49 Industry Portfolios**, see the following
    screenshot:![Appendix A – data case #5 - which industry portfolio do you prefer?](img/B06175_09_63.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Estimate returns and variances for both value-weighted and equal-weighed industry
    portfolios.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Estimate the utility function for three types of investors with A=1, 2, and
    4:![Appendix A – data case #5 - which industry portfolio do you prefer?](img/B06175_09_64.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here *U* is the utility function, *E(R)* is the expected portfolio return and
    we could use its mean to approximate, *A* is the risk-averse coefficient, and
    σ2 is the variance of the portfolio.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Choose one result, for example, the optimal value-weighted portfolio for an
    investor who has a value of 1 for A, draw an indifference curve.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comment on your results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From [http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/Data_Library/det_49_ind_port.html](http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/Data_Library/det_49_ind_port.html),
    we could find the definition of those 49 industries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Appendix B – data case #6 - replicate S&P500 monthly returns'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To finish this data case, your school has subscribed to the `CRSP` database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the concepts of equal-weighted and value weighed market index.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a Python program to replicate sp500 monthly returns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comment on your results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Source of data: CRSP'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`sp500monthly.pkl`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`sp500add.pkl`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`stockMonthly.pkl`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the `sp500monthly.pkl`, see the following few observations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'For `sp500add.pkl`, see the following few observations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For the last dataset called `stockMonthly.pkl`, see a few observations from
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the assumption behind *don't put all your eggs in one basket*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the measures of risk?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you measure the co-moment between two stock returns?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why it is argued that correlation is a better measure than covariance when we
    evaluate the co-movements between two stocks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For two stocks A and B, with two pairs of (σA, σB) and (βA,βB), which pair is
    important when comparing their expected returns?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that variance and correlation of historical returns possess the same
    sign?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find some inefficiency with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For a given set of σA, σB, and correlation (ρ), write a Python program to test
    whether we have a solution or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Test the equation of ![Exercises](img/B06175_09_14.jpg)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Exercises](img/B06175_09_65.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What are the differences between covariance and correlation? Write a Python
    program to find out results for a given set of returns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The portfolio risk is defined here. What is the impact of correlation on a portfolio's
    risk?![Exercises](img/B06175_09_66.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For several stocks such as `MSFT`, `IBM`, `WMT`, `^GSPC`, `C`, `A`, and `AA`,
    estimate their variance-covariance and correlation matrices based on the last
    five-year monthly returns data, for example, over the last five years. Which two
    stocks are most strongly correlated?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Based on the latest five-year monthly data and daily data, what are the correlations
    between `IBM` and `WMT`? Are they the same?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a variance-covariance matrix for a market index and several stocks.
    Their tickers are `C`, `MSFT`, `IBM`, `WMT`, `AAPL`, `AF`, `AIG`, `AP`, and `^GSPC`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is correlation constant between stocks over time?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You could pick up a couple of stocks and then estimate correlations among them
    for several five-year windows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Are larger stocks, measured by their market capitalization, more strongly correlated
    among themselves than the correlation of small stocks among themselves?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To form a portfolio, we have the following three stocks to choose from:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to form a 2-stock portfolio with zero portfolio risk?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the weights of those two stocks (to form a risk-free portfolio)?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Stock | Variance | Stock | Variance | Stock | Variance |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| A | 0.0026 | B | 0.0418 | C | 0.0296 |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'The corresponding correlation (coefficient) matrix is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | A | B | C |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| A | 1.0 | -1.0 | 0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| B | -1.0 | 1.0 | 0.7 |'
  prefs: []
  type: TYPE_TB
- en: '| C | 0.0 | 0.7 | 1.0 |'
  prefs: []
  type: TYPE_TB
- en: When calculating variance or standard deviation, usually there are two definitions,
    based on population or based on a sample. The difference is the denominator. If
    based on population, we have the following formula:![Exercises](img/B06175_09_67.jpg)![Exercises](img/B06175_09_68.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If based on a sample, we have the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: Find out whether `scipy.var()` and `spcipy.std()` functions are based on a sample
    or based on population.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a Python program to estimate the expected portfolio returns for 20 stocks
    by using your own weights and the latest 10 year data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For 50 stocks, select at least five years of data. Estimate volatility for each
    stock, their average will be ![Exercises](img/B06175_09_74.jpg). Then form several
    equal-weighted 2-stock portfolios and estimate their volatilities. Their average
    will be our ![Exercises](img/B06175_09_75.jpg). Continue this way and ![Exercises](img/B06175_09_76.jpg)
    will be the average volatility for n-stock equal-weighted portfolios. Draw a graph
    with n, the number of n-stock portfolios, as the x axis and the volatility of
    the n-stock portfolio ![Exercises](img/B06175_09_76.jpg) as the y axis. Comment
    on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find an appropriate definition for industry. Choosing seven stocks from each
    industry, estimate their correlation matrix. Then do the same thing on another
    industry. Comment on your results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a Python program to estimate the optimal portfolio construction by using
    10 stocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the average of correlations for five industries, at least 10 stocks in
    each industry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To estimate the volatility of a portfolio, we have two formulae: for a 2-stock
    portfolio and for an n-stock portfolio. Show that when n equals 2, we expand the
    formula to estimate the volatility of an n-stock portfolio; we end up with the
    same formula for a 2-stock portfolio.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is the following statement correct? Prove or disapprove it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Stock returns are uncorrelated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Downloading one year IBM daily data and estimate its Sharpe ratio by using
    two methods: its definition, and write a `sharpe()` function in Python.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update `yanMonthly.pkl`, [http://canisius.edu/~yany/python/yanMonthly.pkl](http://canisius.edu/~yany/python/yanMonthly.pkl),
    see the following first and last several lines. Note that for stock, `VALUE` is
    monthly stock price, for Fama-French factors, `VALUE` is their factor, that is,
    their monthly portfolio returns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the Markowitz's optimization, only the first two moments are used. Why?
    What are the definitions of the third and fourth moments? What is the impact when
    those two moments are ignored? How do you include them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a Python program to estimate equal-weighed and value-weighted monthly
    returns for 10 stocks from January 2nd, 2012 to December 31st, 2013\. The data
    used is `yanMonthly.pkl`, [http://canisius.edu/~yany/python/yanMonthly.pkl](http://canisius.edu/~yany/python/yanMonthly.pkl).
    For value-weighed returns, the weight is the number of shares invested times the
    price of the previous month.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For this question, assume that your school has subscribed to the **Center for
    Research in Security Prices** (**CRSP**) database. Replicate `VWRETD` and `EWRETD`
    in CRSP. Note that the monthly CRSP dataset should be used. A few observations
    from a dataset called `stockMonthly.pkl` are shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write a Python program to complete Modigliani and Modigliani (1997) performance
    test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For several performance measures such as Sharpe ratio, Treynor ratio, and Sortino
    ratio, see here, the benefits and costs are compared by dividing them:![Exercises](img/B06175_09_69.jpg)![Exercises](img/B06175_09_70.jpg)![Exercises](img/B06175_09_71.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the other hand, the utility function, see the following formula, also balances
    the benefits with the costs by choosing their difference:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Exercises](img/B06175_09_72.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Compare those two approaches. Could we have a more general form to combine those
    two ways?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Estimating the Sharpe ratio, Treynor, and Sortino ratio for the Fama-French
    49 industries. The risk-free rate could be found at [http://finance.yahoo.com/bonds](http://finance.yahoo.com/bonds).
    Alternatively, the risk-free rate from `ffMonthly.pkl`, [http://canisius.edu/~yany/python/ffMonthly.pkl](http://canisius.edu/~yany/python/ffMonthly.pkl),
    could be used. The dataset used is `ff49industries.pkl`, which is downloadable
    at [http://canisius.edu/~yany/python/ff49industries.pkl](http://canisius.edu/~yany/python/ff49industries.pkl).
    A few lines are shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first explained various concepts related to portfolio theory,
    such as covariance and correlation for a pair of stocks and for a portfolio. After
    that, we discussed various risk measures for individual stocks or portfolios,
    such as the Sharpe ratio, Treynor ratio, and Sortino ratio, how to minimize portfolio
    risks based on those measures (ratios), how to set up an objective function, how
    to choose an efficient portfolio for a given set of stocks, and how to construct
    an efficient frontier.
  prefs: []
  type: TYPE_NORMAL
- en: For the next chapter, [Chapter 10](ch10.html "Chapter 10. Options and Futures"),
    *Options and Futures*, we will explain some basic concepts first. Then, we will
    discuss the famous Black-Scholes-Merton options model. In addition, various trading
    strategies involving options will be discussed in detail.
  prefs: []
  type: TYPE_NORMAL
