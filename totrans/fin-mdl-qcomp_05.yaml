- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementation in Quantum Clouds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will dig deeper into the options for executing our algorithms in
    quantum devices or at least solutions that will go beyond the capabilities of
    our classical devices. For the sake of simplicity, most of the algorithms you
    have seen so far used some kind of local simulation to mimic how the outcome would
    look when running on a real quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: When developing our approaches, we have the means to locally simulate the behavior
    of an ideal quantum computer while taking from the mathematical description each
    operation requires. But at the end of the day, the goal is to be able to send
    our work to a quantum device that will leverage the potential of actual quantum
    computing.
  prefs: []
  type: TYPE_NORMAL
- en: Given that owning a quantum computer is something very few privileged people
    will be able to do, we will highlight how cloud access has been an important way
    of leveraging those still experimental resources.
  prefs: []
  type: TYPE_NORMAL
- en: We will also illustrate several examples demonstrating how to utilize cloud
    resources and cloud-hosted quantum devices to execute the previously mentioned
    examples from *Chapters 4*, *5*, and *6*. By doing so, you will not only become
    familiar with the distinct workflow it may entail but also understand the advantages
    of employing these resources when working on the scale that most companies demand
    for their proof-of-concept or innovation projects.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, considering that the cloud operates on a pay-per-use model, we will
    examine the financial implications of utilizing cloud services for our project.
    We will also explore intriguing approaches to initiate quantum projects and implementations
    on cloud-hosted services, even with a limited budget.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapters 8* and *9* will dig deeper into different types of devices and simulators
    we might be using, as well as how to deal with the noise most devices will introduce
    into our abstracted circuits. Finally, [*Chapter 10*](B19146_10.xhtml#_idTextAnchor181)
    will get us into the strategies we can utilize to start using quantum computing
    as an added value asset in our organization and grow with a sensible adoption
    strategy that will not harm our corporation’s finances, nor the pace at which
    the institution may be adopting these disruptive but promising new paradigms as
    part of their business processes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Challenges of accessing the cloud quantum computing platform and implementing
    an algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Major quantum technology providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cost estimation when using a cloud provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges of quantum implementations on cloud platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned previously, most of the examples shown previously leverage
    the fact that quantum computing can be mimicked by our classical resources (using
    simulators). As an example, in [*Chapter 5*](B19146_05.xhtml#_idTextAnchor100),
    we used the following routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We utilized a `qasm_simulator`, an implementation that can execute the operations
    defined in our quantum circuit and provide the expected outcome as dictated by
    the mathematical principles governing quantum computing.
  prefs: []
  type: TYPE_NORMAL
- en: We would like to take this very same circuit to a quantum computer, but it is
    not as easy as purchasing one on Amazon. We can purchase commercially available
    devices, but the price might be too high for most organizations.
  prefs: []
  type: TYPE_NORMAL
- en: D-Wave
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In 2011, D-Wave Systems announced the world’s first commercially available
    quantum computer – a 128-qubit quantum annealing device. They have been able to
    scale their Chimera topology up to 2,000 qubits, and the new architectures have
    surpassed this barrier, with up to 8,000 qubits promised for late 2023/early 2024\.
    Considering that the cost of their initial device reached a seven-zero figure
    ([https://www.engadget.com/2011-05-18-d-wave-one-claims-mantle-of-first-commercial-quantum-computer.html](https://www.engadget.com/2011-05-18-d-wave-one-claims-mantle-of-first-commercial-quantum-computer.html))
    and its chassis reminds us of old mainframe infrastructures, as can be seen in
    *Figure 7**.1*, which requires a data center to put it in, it was clear it was
    not going to be mass-produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – A technician working on a D-Wave Systems machine](img/B19146_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – A technician working on a D-Wave Systems machine
  prefs: []
  type: TYPE_NORMAL
- en: IBM Quantum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Something similar happened to IBM when they started creating their initial
    chips. In 2018, they released their first commercial product, IBM Q System One,
    as shown in *Figure 7**.2*, which is a 20-qubit commercially available quantum
    computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – IBM’s Q System One device](img/B19146_07_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – IBM’s Q System One device
  prefs: []
  type: TYPE_NORMAL
- en: But before this achievement, they were already aware of the needs of many research
    institutions and universities already working in the field of quantum computers.
    They wanted to use an actual device, but they would need to build their own to
    run their experiments.
  prefs: []
  type: TYPE_NORMAL
- en: That is why, in early 2016, IBM decided to connect one of their experimental
    devices to a cloud service so that independent organizations could submit their
    experiments to their first available quantum computer. This milestone gave birth
    to the rich cloud quantum computing ecosystem we know today.
  prefs: []
  type: TYPE_NORMAL
- en: In early 2017, a team at Rigetti Computing was able to program a set of instructions
    into IBM’s device using the pyQuil Python wrapper of the Quil Quantum Instruction
    Set Architecture (*Smith et* *al., 2016*).
  prefs: []
  type: TYPE_NORMAL
- en: Like in many emergent industries, several standards can still be found. IBM
    decided to leverage its own. We have made reference to it in previous chapters.
    Still, **Open Quantum Assembly Language** (**OpenQASM**), which is already on
    its third version, was initially referenced in a publication (*Cross et al., 2017*)
    and the code of IBM’s Quantum Information Software Toolkit (*Qiskit - Anis, Md
    Sajid, et al., 2021*), becoming one of the most mature frameworks for implementing
    quantum programs and communicating with a wide variety of cloud-available devices.
  prefs: []
  type: TYPE_NORMAL
- en: Qiskit can abstract our quantum code from the final device it will run on, but
    given this quite diverse landscape of devices, we might need to remember that
    certain frameworks will fit our needs better, depending on the final hardware
    meant to be used.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most evident examples is when D-Wave Systems’ devices were the ones
    to be used. These are quantum annealing devices. Therefore, gate operations do
    not apply to them yet ([https://techcrunch.com/2021/10/05/d-wave-plans-to-build-a-gate-model-quantum-computer](https://techcrunch.com/2021/10/05/d-wave-plans-to-build-a-gate-model-quantum-computer)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Their devices are freely accessible via their service offering, known as Leap
    (*Figure* *7**.3*; [https://cloud.dwavesys.com/leap/login](https://cloud.dwavesys.com/leap/login)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – D-Wave Systems’ cloud-accessible service, Leap](img/B19146_07_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – D-Wave Systems’ cloud-accessible service, Leap
  prefs: []
  type: TYPE_NORMAL
- en: 'You can simply sign up, and you will be granted monthly time to run your experiments.
    In fact, within the different plans, you can access the Developer Plan (*Figure
    7**.4*), which only requires a GitHub account to be synchronized with D-Wave’s
    Leap service – it provides recurrent usage of their devices for up to 20 minutes
    a month. Considering that the running time of their solver only requires milliseconds,
    it allows for quite a few experiments to be run before you run out of time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – D-Wave’s cloud service usage plans](img/B19146_07_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – D-Wave’s cloud service usage plans
  prefs: []
  type: TYPE_NORMAL
- en: 'Two main options are available when interacting with Leap. The simplest one
    is directly using their cloud-based development environment. By providing the
    URL to an existing GitHub repository where the code will be taken from and committed
    to guarantee it is not lost, an ephemeral browser-accessible IDE will be created
    where your account credentials will be made available. This enables a ready-to-work
    environment for any registered user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – A Leap workspace with an airline example loaded in an example
    IDE](img/B19146_07_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – A Leap workspace with an airline example loaded in an example IDE
  prefs: []
  type: TYPE_NORMAL
- en: This will also ensure that D-Wave’s Ocean Software Development Kit is installed
    and ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you could install the SDK on a local Python setup and log into the
    account by using a Leap-provided token that should be accessible via the Leap
    interface, as shown in *Figure 7**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Leap dashboard, where you can find the token for remote authentication](img/B19146_07_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Leap dashboard, where you can find the token for remote authentication
  prefs: []
  type: TYPE_NORMAL
- en: Ocean SDK’s documentation already provides instructions on how this can be done
    locally so that interaction with the cloud service is done programmatically ([https://docs.ocean.dwavesys.com/en/latest/overview/install.html](https://docs.ocean.dwavesys.com/en/latest/overview/install.html)).
  prefs: []
  type: TYPE_NORMAL
- en: This is how we remotely solved our portfolio optimization in [*Chapter 5*](B19146_05.xhtml#_idTextAnchor100)
    using a non-owned D-Wave device, free of charge.
  prefs: []
  type: TYPE_NORMAL
- en: Like D-Wave, IBM offers free access to some of their devices via their cloud-accessible
    service ([https://quantum-computing.ibm.com/](https://quantum-computing.ibm.com/)).
    You can register using a wide variety of credentials so that if you’re using a
    LinkedIn or GitHub account, you have a simplistic way to access their solutions
    (free or pay-as-you-go).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once registered, a set of services will be shown so that you can choose the
    appropriate one according to your level of expertise. *Figure 7**.7* shows all
    the different services available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – IBM Quantum dashboard showing the different available services](img/B19146_07_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – IBM Quantum dashboard showing the different available services
  prefs: []
  type: TYPE_NORMAL
- en: One of the first things we will realize is that there is also a token option,
    so remote job submission is also available – in this case, using IBM’s Qiskit
    framework. This is often the token that’s referred to when the instructions are
    set to a local setup ([https://github.com/Qiskit/qiskit-ibmq-provider#configure-your-ibm-quantum-credentials](https://github.com/Qiskit/qiskit-ibmq-provider#configure-your-ibm-quantum-credentials)).
  prefs: []
  type: TYPE_NORMAL
- en: 'IBM also provides a tool for creating quantum circuits: Quantum Composer. It’s
    probably the easiest way to start *coding* our first examples. *Figure 7**.8*
    shows how, by dragging and dropping gate figures into Quantum Composer’s central
    console, different plots or even Qiskit and OpenQASM codes are shown. It simplifies
    the transition from the graphical designer to code-based implementations, which
    will be useful when you’re aiming for more complex examples or projects like the
    ones we covered in *Chapters 4* to *6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – IBM’s Quantum Composer graphical interface for starting quantum
    algorithm programming](img/B19146_07_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – IBM’s Quantum Composer graphical interface for starting quantum
    algorithm programming
  prefs: []
  type: TYPE_NORMAL
- en: 'On the top left-hand side of the preceding figure, we can see that it also
    allows us to submit our circuit to a device. We can select the device according
    to the number of qubits we might require and the waiting queue (many people will
    be sending circuits to the same shared device), so we can choose the least busy
    one (*Figure 7**.9*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Circuit submission from Quantum Composer to one of the available
    devices](img/B19146_07_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Circuit submission from Quantum Composer to one of the available
    devices
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the job is sent to the device, the queue will progress, and our results
    will be made available. Within the same console, the set of jobs we have sent
    can be listed, and more information can be requested if we click on the job itself
    (*Figure 7**.10*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Actual results obtained from the ibm_nairobi device](img/B19146_07_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Actual results obtained from the ibm_nairobi device
  prefs: []
  type: TYPE_NORMAL
- en: IBM keeps a list of all the jobs we have submitted; therefore, old results can
    be recovered from the cloud service. A really useful feature is when someone has
    to send a set of examples so that they can be later analyzed. Most of our examples
    will take time to run, not only because they might be variationally trained and
    therefore need to call the device many times, but because the queue for the device
    may increase and take quite some time until our circuit runs on the device (the
    priority in the queue is determined by the number of requests you make in a certain
    time).
  prefs: []
  type: TYPE_NORMAL
- en: Two interesting things we would like to highlight at this point are that if
    we look at the plots in *Figure 7**.10*, the one from the devices shows values
    on states that were not present when we simulated the results (the right-hand
    side plot in *Figure 7**.10*). This is because of the effect of noise and the
    different types of errors that are introduced when running on real devices. We
    will cover this in more detail in *Chapters 8* and *9*. Still, it is interesting
    that we highlight that real devices will not behave like the ideal simulators
    we have been using in some of the examples and will introduce results that are
    not supposed to be there.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting fact is that, if we get to the details of the job we just
    submitted, the circuit we sent and the one that runs are not the same, as can
    be seen in *Figure 7**.11*. Computationally speaking, they are, because the composition
    of *Z* rotations and square root *X* provides the same effect as the Hadamard
    gate, but this is changed because the H operation is unavailable on the device.
    Not all operations performed in the theoretical setup are available on the devices.
    There are even more qubits than the ones we want to use. Therefore, there is always
    a step we cannot omit when moving to the real device; this is called *transpilation*.
  prefs: []
  type: TYPE_NORMAL
- en: Transpilation is the process of adapting our theoretical algorithm to the specific
    gates and topology of a chip that may not perfectly map what we require. This
    process tries to find the best way to map the quantum circuit using some heuristics
    and different optimization levels. By doing this programmatically, we can balance
    the time it takes to fit the algorithm and the depth or the number of operations
    it will be translated into. Simply put, the transpile job will reduce complex
    gates into basic ones to map the hardware architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The more operations we introduce, the more noise the circuit will be subjected
    to, and more inaccurate results may appear in our final reading. That is why this
    step is so important for researchers; they invest so much time in finding better
    ways to improve it. In [*Chapter 9*](B19146_09.xhtml#_idTextAnchor165), we will
    look at some of the latest advances in this process, which is known as *error
    mitigation*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Submitted circuit and the actual circuit that runs on ibm_nairobi](img/B19146_07_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Submitted circuit and the actual circuit that runs on ibm_nairobi
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the options available in IBM’s cloud offering, there’s the option to
    deploy a workspace so that we can work from there without worrying about local
    installations and account settings. The Quantum Lab option (*Figure 7**.12*) allows
    us to deploy a hosted JupyterLab environment that’s already configured with the
    latest Qiskit version and our account loaded so that submitting jobs becomes easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – IBM Quantum Lab workspace creation and available tutorials](img/B19146_07_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – IBM Quantum Lab workspace creation and available tutorials
  prefs: []
  type: TYPE_NORMAL
- en: 'Any of the examples we have previously coded can be easily transferred to this
    workspace, given that Jupyter notebooks can be transferred just by clicking on
    the upload option (up-facing arrow in *Figure 7**.12*). Suppose we click on the
    first **Notebook** option available that says **Python 3** under Qiskit’s logo.
    In that case, a new Jupyter notebook instance will be shown where some common
    libraries and the way we can load our account credentials will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Default cell made available when Qiskit-supporting notebooks
    are created](img/B19146_07_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Default cell made available when Qiskit-supporting notebooks are
    created
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.13* shows the code to load the default provider to access all the
    available backends. They can then be requested:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Freely available device and simulator options within IBM’s
    Quantum Lab](img/B19146_07_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Freely available device and simulator options within IBM’s Quantum
    Lab
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.14* shows the output of the backend function and lists devices
    and simulators. These are classical resources mimicking an available quantum computer,
    so we can choose the backend that best fits our requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: Having covered two of the most popular cloud-based resources for quantum computing,
    you may think that going provider by provider and testing different device types
    may become a nightmare of tokens, configurations, and frameworks to be used.
  prefs: []
  type: TYPE_NORMAL
- en: That is the reason why key players have also started enabling cloud-based quantum
    computing but from a slightly different perspective. AWS and Azure, being the
    cloud providers for the majority of corporations around the globe, aim to make
    it easier to access technology in general. That is the way they primarily joined
    the quantum community – as hubs providing access not only to their actual offering
    but also to third-party providers so that you can access a plethora of options
    via their services.
  prefs: []
  type: TYPE_NORMAL
- en: This is why, in the next two sections, we will concentrate on AWS and Azure
    while showcasing the different options and ways to access those computational
    means so that any quantum developer can make the most out of the existing broad
    offerings.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Braket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon Web Services** (**AWS**) decided to create both a service and a framework
    for quantum computation under the same name.'
  prefs: []
  type: TYPE_NORMAL
- en: The Amazon Braket service, like in previous examples, makes quantum computing
    devices that go beyond the actual offering of AWS available to any user. As far
    as we know, AWS is not working on any hardware device of its own. So, how can
    they offer a quantum computing platform? Well, they partnered with some key niche
    players providing said hardware that decided to give access through a third party
    instead of adding that extra workload of maintaining a customer-accessed platform
    to their business model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anybody with an AWS account can access the Braket service within their account,
    though not all regions currently offer this option, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Amazon Braket shown within the AWS service console, highlighting
    region options](img/B19146_07_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 – Amazon Braket shown within the AWS service console, highlighting
    region options
  prefs: []
  type: TYPE_NORMAL
- en: 'The console resembles the ones we saw previously as it also provides an overview
    of available devices, notebooks that can be run on a workspace created for remote
    development, and a list of jobs that were previously running within the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – Amazon Braket’s main console and available devices](img/B19146_07_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – Amazon Braket’s main console and available devices
  prefs: []
  type: TYPE_NORMAL
- en: One of the key benefits of using AWS Braket instead of independent direct access
    services provided by any quantum hardware company is that it acts as a hub. So,
    by using the same connectivity interface, a customer can directly access a plethora
    of services of many different types.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also provides a set of libraries containing implementations of some canonical
    algorithms that we reviewed in [*Chapter 2*](B19146_02.xhtml#_idTextAnchor032).
    As shown in *Figure 7**.17*, they are provided via Amazon Braket’s Python SDK,
    an open source framework provided by AWS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17 – Amazon Braket’s algorithm library and Berstein Vazirani implementation
    example](img/B19146_07_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.17 – Amazon Braket’s algorithm library and Berstein Vazirani implementation
    example
  prefs: []
  type: TYPE_NORMAL
- en: This framework is more general, given the technologies Amazon Braket is meant
    to support beyond the superconducting chip IBM is focusing on. It makes sense
    that IBM’s framework is mostly thought to help increase device usage. Still, Amazon
    is forced to cover a much wider spectrum within its offering. Here, we can find
    neutral atoms, photonic devices, and trapped-ion services that require different
    ways to interact and impose the computation to be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why this is important, many restrictions associated with the
    process of transpiling the logical circuit initially coded into a specific device
    setup depend on particular aspects of the device. One of the most basic ones is
    qubit connectivity, which forces different translations. This connectivity differs
    from provider to provider (and also backends), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18 – Superconducting chip topology for IBM Washington (below) and
    Rigetti Aspen-M-3 (above)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19146_07_018a.jpg)![Figure 7.18 – Superconducting chip topology for
    IBM Washington (below) and Rigetti Aspen-M-3 (above)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19146_07_018b.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.18 – Superconducting chip topology for IBM Washington (below) and Rigetti
    Aspen-M-3 (above)
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also some differences, such as the native quantum gates that the
    provider will accept. For example, Hadamard gates, which are used for state superposition,
    can hardly be achieved if you don’t combine other actions that can be realized
    in hardware, as shown in *Figure 7**.11*. But it has more profound implications
    when the underlying technology changes. For example, ion-trapped devices can connect
    “many-to-many” qubits arbitrarily (*Figure 7**.19* – connections representation)
    and are better suited for problems that show all-to-all connectivity schemes.
    This is, for example, the case for portfolio optimization, which requires you
    to evaluate the covariance between all potential assets ([*Chapter 5*](B19146_05.xhtml#_idTextAnchor100)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19 – IonQ trapped-ion device topology](img/B19146_07_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.19 – IonQ trapped-ion device topology
  prefs: []
  type: TYPE_NORMAL
- en: Or in the case of neutral atom devices, similar to what happens in D-Wave systems,
    analog coding has to be submitted instead of gate-based algorithms, which requires
    some specific knowledge on how this needs to be done ([https://docs.aws.amazon.com/braket/latest/developerguide/braket-quera-submitting-analog-program-aquila.html](https://docs.aws.amazon.com/braket/latest/developerguide/braket-quera-submitting-analog-program-aquila.html)).
    This is also one of the reasons why Amazon Braket was developed as it allows us
    to extend those specific requirements as new services are enabled within the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Given the usage and maturity of Qiskit within the quantum computing community,
    Amazon also released a plugin so that any Qiskit-encoded routine can be sent to
    Amazon Braket-enabled devices. This helps us interface with some of those devices
    that offer gate-based computation without the need to learn about a third framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following code to install the Amazon provider-enabling plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Qiskit circuits can be sent to Amazon devices. Similar to what we did in the
    case of the IBM-enabled provider in *Figure 7**.14*, we can instantiate Amazon
    Braket as a provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also ask for available devices to be used as backends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is important to pause here. As we mentioned previously, our circuit may need
    to be translated into the specifics of the final device. So, depending on each
    case, certain adaptations may need to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: Also, consider that each device has a different cost scheme, but they will all
    require a billing structure so that the cost of running any example will be charged
    at the end of the billing period.
  prefs: []
  type: TYPE_NORMAL
- en: It is particularly relevant that we pay attention to the pricing of each device
    because, when using variational algorithms, the number of interactions required
    to fit the parameters could increase dramatically, which will directly affect
    the cost of each job.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out how much a specific algorithm could cost on a given device, we
    must be aware of the resources and operations required to run our candidate quantum
    circuit.
  prefs: []
  type: TYPE_NORMAL
- en: 'PennyLane, given its role when dealing with variational algorithms, has a really
    useful resource called a tracker that can keep track of the jobs being sent to
    the device. We could leverage this resource to perform our estimations in combination
    with AWS’s SDK and the PennyLane plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We would proceed as usual and create a circuit, but in this case, using the
    `bracket.local.qubit` device as our target device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call the circuit to perform the operation surrounding it with the
    `qml.Tracker` object, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `qml.Tracker(dev)` as the tracker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from producing the expected result via the tracker, we can request the
    tasks that were sent to the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we perform a gradient calculation, which, for a parameter-shift
    routine, will require executions of the circuit, we will see that this is encapsulated
    within different batch calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Remote devices offer more information to the tracker object, and therefore for
    executions. The computation time is obtained in milliseconds. The bill can then
    be expressed in milliseconds and can be obtained from the `history` field. Of
    course, you must do the final calculations according to the target device and
    its pricing scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Task tracking becomes the key. When translating a task into a device-specific
    execution, the cost schemes will be obtained accordingly. When pushed to the device,
    we can realize the implications of different algorithms and training schemes and
    their associated costs.
  prefs: []
  type: TYPE_NORMAL
- en: Figuring out our cloud costs is one of the most challenging tasks for quantum
    computers and classical resources. That is why Microsoft considered this a core
    part of their service and tried to provide simpler ways so that their users could
    access this billing information at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Azure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft has a wide corporate market size and is well aware of how quantum
    computing technology may disrupt some operational workloads of business users.
    Given their cloud offering, they decided to compete with AWS in a similar setup
    via their Quantum Workspace offering.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, Microsoft decided to also create a framework according to their
    needs, Q#, that follows a similar approach to previous C# and J# proprietary languages
    within the more general .NET framework ([https://learn.microsoft.com/en-us/azure/quantum/overview-what-is-qsharp-and-qdk](https://learn.microsoft.com/en-us/azure/quantum/overview-what-is-qsharp-and-qdk)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable this service, you must create a quantum workspace from an available
    subscription, which is the billing unit Microsoft uses to bill purchased services.
    Quantum Workspace is the service that provides access to the quantum devices that
    you can use, the coding environment, which is once again a notebook-based approach
    (using the omnipresent Jupyter Notebook engine), and additional information on
    quotas, resources, and everything that might be needed to perform your quantum
    circuit executions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20 – The Azure portal and Quantum Workspace creation page](img/B19146_07_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.20 – The Azure portal and Quantum Workspace creation page
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, a Microsoft Azure account provides free credits, different for
    each device, as part of the agreement with those hardware providers. This helps
    users test the different providers before deciding which type of plan they need.
    The plans are pay-per-use, but there are monthly service options. Similar to previous
    options and quantum devices, a notebook service is offered so that you can experiment,
    and a job list is provided so that you can retrieve any past jobs (core services
    are present on the main screen of the service, as shown in *Figure 7**.21*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.21 – Azure’s Quantum Workspace main page with management options
    on the left-hand side menu](img/B19146_07_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.21 – Azure’s Quantum Workspace main page with management options on
    the left-hand side menu
  prefs: []
  type: TYPE_NORMAL
- en: 'The available options show fewer service providers than Amazon’s offering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22 – Available Azure Quantum Workspace service providers](img/B19146_07_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.22 – Available Azure Quantum Workspace service providers
  prefs: []
  type: TYPE_NORMAL
- en: Apart from actual hardware devices, Azure also offers services for optimization
    routines. The user avoids the procedure needed to encode and solve a given problem.
    This is a trend we have seen before in the case of D-Wave’s Hybrid solver or IBM’s
    Qiskit Runtime. The level of abstraction for the user is increased, so they only
    have to worry about the problem to be solved. Quite an interesting trend indeed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Being aware of the maturity of frameworks such as Qiskit instead of forcing
    users to learn about yet another quantum computing framework, Microsoft released
    a Qiskit plugin so that any Qiskit circuit could be sent to enabled devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it has been installed, we need to register our Quantum Workspace as the
    provider from which we want to obtain the backend. This can be done using the
    following code. These lines need to be added to the beginning of any experiment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The backend information is obtained from the main window of Quantum Workspace
    (browser) and is meant to identify the region and subscription it has been deployed
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.23 – Azure Quantum Workspace main window with access information
    highlighted](img/B19146_07_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.23 – Azure Quantum Workspace main window with access information highlighted
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to this, all devices that were seen in *Figure 7**.22* can be invoked
    so that our candidate circuit can be submitted to run on those:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Before running any circuit, it might be relevant to check the cost that running
    the circuit involves. To make it accessible via code, we can use Azure Resource
    Estimator, which only requires the circuit and backend it will be running on to
    assess the potential costs of our execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Microsoft offers a solid view of how they envision their services to be used
    (*Figure 7**.24*), including resource estimation, which will become key information
    for longer-term and cost-efficient usage of quantum resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24 – Quantum development pipeline envisioned by Microsoft](img/B19146_07_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.24 – Quantum development pipeline envisioned by Microsoft
  prefs: []
  type: TYPE_NORMAL
- en: 'This resource estimator, as we saw in the case of Amazon, prevents the user
    from expending substantial amounts of money before any execution is done. More
    examples of how to use Azure resources beyond the algorithm implementation can
    be found in their notebook gallery (*Figure 7**.25*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.25 – Example of available notebooks within each Quantum Workspace](img/B19146_07_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.25 – Example of available notebooks within each Quantum Workspace
  prefs: []
  type: TYPE_NORMAL
- en: Cost estimation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We briefly mentioned resource estimation, but we would like to highlight the
    importance of this ability when aiming for a sustainable adoption strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quantum computing is at an early stage, requiring continuous and complex maintenance
    tasks to provide the best possible service. This is something that classical computing
    resources have mastered for a long time. Due to the limited ecosystem of hardware
    providers and the status of the technology, specifically, when aiming for real
    hardware, we will see costs ramp up significantly, even for the simplest providers.
    That is why resource estimation is such a crucial step in any QC pipeline, particularly
    if the model’s training requires iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.26 – Cost for Quantinuum on Azure (below) and IonQ in AWS (above)](img/B19146_07_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.26 – Cost for Quantinuum on Azure (below) and IonQ in AWS (above)
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we could take the European Call Pricing from [*Chapter 4*](B19146_04.xhtml#_idTextAnchor079)
    and extract its underlying quantum circuit, which we already know is composed
    of a block encoding, the log-normal distribution of the asset, and the block performing
    the function computing the pay-off function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The problem we might face is that, depending on the device we choose, we might
    not be able to understand what the P(X) and F blocks represent in terms of operations,
    as shown in Figure 7.27\. We will need to translate it into a combination of basic
    gates that the device can comprehend, as high-level abstraction blocks typically
    cannot be directly executed on a real device. Consequently, we will also estimate
    the potential cost associated with this translation process, as it is a common
    occurrence.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.27 – European Call Pricing problem circuit showing high-level abstraction
    blocks for the circuit](img/B19146_07_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.27 – European Call Pricing problem circuit showing high-level abstraction
    blocks for the circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Quantinuum device, we could use a combination of rotations, identity,
    CNOT, and Hadamard gates and request the translation of the circuit based on those
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can select the device so that it can perform the estimation on the
    resulting circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this case, a single circuit pass would consume 5.5 Quantinuum credits, which,
    for a standard subscription, would sum up close to $70\. If we consider that the
    amplitude estimation routine could require several iterations over the same circuit,
    we may need a couple of hundred dollars just for an asset pay-off evaluation.
    Of course, then comes the ability to compress this circuit so that fewer operations
    would still render the same state preparation. However, this is mostly the core
    activity of research institutions and is less likely to be something our analysts
    will invest time in.
  prefs: []
  type: TYPE_NORMAL
- en: This is why we must perform some calculations and thoroughly evaluate the expected
    return on investment before we naively submit our training routine to a cloud
    provider that will be happy to serve requests at those prices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The transition from on-premises to cloud-hosted has been a complicated journey
    for many organizations, including the switch to be made from owning the computing
    resources to pay-per-use modalities common today. Quantum computing made its initial
    foray directly into the cloud. Different platforms give access to services and
    providers with efficient costs. Many institutions have facilities to onboard into
    this quantum journey.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum hardware is problem-focused and increases the complexity and decisions
    to be made as you must decide what option, out of the plethora of devices, is
    the most convenient for your problems. Estimators help companies evaluate the
    cost of using this new type of machine, providing them with an efficient way to
    estimate the budget required per study.
  prefs: []
  type: TYPE_NORMAL
- en: No technology has faced such a wide, almost *free-of-charge* offering to learn
    and adapt than quantum computing. Hardware providers enable their latest devices
    in those cloud services and help boost the field for researchers and business
    users. The role of the different communities around the libraries used to manipulate
    such hardware is highly important. It brings an important volume of notebooks
    and tutorials to self-learn quantum computing.
  prefs: []
  type: TYPE_NORMAL
- en: There are already providers offering 2- and 3-qubit desktop systems at competitive
    prices ([https://www.discovermagazine.com/technology/a-desktop-quantum-computer-for-just-usd5-000](https://www.discovermagazine.com/technology/a-desktop-quantum-computer-for-just-usd5-000)),
    but this will mostly remain as an educational resource, given that the cloud is
    where most organizations seem to be locating their infrastructure. It simplifies
    any integration effort to be made by your when self-hosting this type of resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, there are several challenges associated with implementing quantum
    computing on cloud platforms, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessibility**: Quantum computing resources are currently only available
    through specialized cloud providers, which can be difficult for some users to
    access. General cloud providers are already easing this with their early adoption
    of QC hubs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Quantum computing systems require specialized hardware and
    infrastructure, which can be difficult to scale up as demand for quantum computing
    resources increases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interoperability**: Different quantum computing platforms have different
    programming languages and interfaces, making it difficult for developers to work
    with multiple systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Quantum computing systems are vulnerable to certain types of
    attacks, such as quantum hacking, which can expose sensitive information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Noise and errors**: Quantum computers are more susceptible to noise and errors
    than classical computers, making it difficult to obtain accurate results from
    quantum algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost**: Quantum computing resources are still relatively expensive, making
    it difficult for some organizations to afford the necessary hardware and infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In any case, this high-paced technology has just started being useful, and the
    applications that bring competitive advantage will uncover the paths those resources
    will end up adopting.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many providers are already shaping their offerings so that new as-a-service
    paradigms will emerge in the following years.
  prefs: []
  type: TYPE_NORMAL
- en: Oxford Quantum Circuits has already embraced the concept of **Quantum Computing
    as a Service** (**QCaaS**) ([https://www.techradar.com/news/quantum-computing-as-a-service-is-going-mainstream](https://www.techradar.com/news/quantum-computing-as-a-service-is-going-mainstream)),
    whereas other companies like QCentroid are targeting a wider audience by offering
    off-the-shelf solutions tailored to industry-specific applications through their
    **Quantum-as-a-Service** (**QaaS**) platform ([https://marketplace.qcentroid.xyz/](https://marketplace.qcentroid.xyz/)).
  prefs: []
  type: TYPE_NORMAL
- en: When thinking about cloud-accessible resources, one of the most interesting
    cases is the one posed by the variational quantum algorithm, where a constant
    interchange between classical and quantum resources must be sorted out. Given
    the queue times we have seen, we must be aware that any remote training of the
    ansatz will face important delays per iteration if we attempt to train on an actual
    device remotely.
  prefs: []
  type: TYPE_NORMAL
- en: Given the existing benefits that companies derive from classical machine learning
    models, Quantum Computing is likely to be integrated as an auxiliary tool for
    addressing difficult-to-solve problems. Doing so in competent architectures is
    what will require senior roles to step up over the hype in the field and make
    sensible decisions regarding the adoption and long-term strategy. Companies are
    already doing their part to ease the decision process for these early adopters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve that issue, IBM decided to create Qiskit Runtime. Runtimes are routines
    with some well-known algorithms where additional information is sent to the remote
    execution engine, which takes charge of both the classical and the quantum parts.
    It provides closer interaction between two sides of the algorithm, thus rendering
    much more efficient running times. An example workflow can be seen in *Figure
    7**.28*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.28 – Qiskit Runtime as envisioned by IBM for efficient workload
    balancing](img/B19146_07_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.28 – Qiskit Runtime as envisioned by IBM for efficient workload balancing
  prefs: []
  type: TYPE_NORMAL
- en: 'This offering comes with a cost scheme that you need to consider, even though
    a lite option is available with up to 3 hours of free access:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.29 – IBM Qiskit Runtime pricing as of January 2023](img/B19146_07_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.29 – IBM Qiskit Runtime pricing as of January 2023
  prefs: []
  type: TYPE_NORMAL
- en: D-Wave also realized that by combining classical and quantum operations on their
    end, they could extend their portfolio and reduce the time needed to solve certain
    problems that required intermediate classical steps. This is what is hidden behind
    their Hybrid solver – classical routines interacting with a quantum annealer so
    that the combination of both creates a broader range of problems to be solved.
  prefs: []
  type: TYPE_NORMAL
- en: By definition, their solver efficiently solves binary quadratic models but adds
    classical routines. Discrete and constrained models can also be solved by allocating
    quantum and classical resources to each process step ([https://docs.dwavesys.com/docs/latest/doc_leap_hybrid.html](https://docs.dwavesys.com/docs/latest/doc_leap_hybrid.html)).
  prefs: []
  type: TYPE_NORMAL
- en: In all probability, the progression of these remote solvers will eventually
    manifest as a streamlined service, wherein problems are submitted and the service
    provider’s engine determines the optimal combination of resources. If not for
    the advancements that quantum devices can offer in specific problem domains, it
    would be challenging to discern their involvement in the process. Nevertheless,
    this approach will simplify usability and abstraction for business users who are
    primarily focused on finding solutions and may not be as concerned with the technical
    intricacies employed to achieve them.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Cross, A. W., Bishop, L. S., Smolin, J. A., & Gambetta, J. M. (2017). Open
    quantum assembly language. arXiv* *preprint arXiv:1707.03429.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anis MS, Abraham H, AduOffei RA, Agliardi G, Aharoni M, Akhalwaya IY, Aleksandrowicz
    G, Alexander T, Amy M, Anagolum S. (2021). Qiskit: An open-source framework for
    quantum* *computing. Qiskit/qiskit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Smith, R. S., Curtis, M. J., & Zeng, W. J. (2016). A practical quantum instruction
    set architecture. arXiv* *preprint arXiv:1608.03355.*'
  prefs: []
  type: TYPE_NORMAL
