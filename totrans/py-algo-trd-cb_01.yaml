- en: Handling and Manipulating Date, Time, and Time Series Data
  prefs: []
  type: TYPE_NORMAL
- en: Time series data is ubiquitous when it comes to algorithmic trading. So, handling,
    managing, and manipulating time series data is essential to performing algorithmic
    trading successfully. This chapter has various recipes that demonstrate how algorithmic
    trading can be done using the Python standard library and `pandas`, which is a
    Python data analysis library.
  prefs: []
  type: TYPE_NORMAL
- en: For our context, time series data is a series of data consisting of equally
    spaced timestamps and multiple data points describing trading data in that particular
    time frame.
  prefs: []
  type: TYPE_NORMAL
- en: When handling time series data, the first thing you should know is how to read,
    modify, and create Python objects that understand date and time. The Python standard
    library includes the `datetime` module, which provides the `datetime` and `timedelta`
    objects, which can handle everything about the date and time. The first seven
    recipes in this chapter talk about this module. The remainder of this chapter
    talks about handling time series data using the `pandas` library, which is a very
    efficient library for data analysis. The `pandas.DataFrame` class will be used
    in our recipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of the recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating datetime objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating timedelta objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations on datetime objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying datetime objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a datetime to a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a datetime object from a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The datetime object and time zones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a pandas.DataFrame object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DataFrame manipulation—renaming, rearranging, reversing, and slicing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DataFrame manipulation—applying, sorting, iterating, and concatenating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a DataFrame into other formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a DataFrame from other formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following to successfully execute the recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.7+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python package:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas` (`$ pip install pandas`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all the recipes in this chapter, you will need the Jupyter notebook for
    this chapter, found at [https://github.com/PacktPublishing/Python-Algorithmic-Trading-Cookbook/tree/master/Chapter01](https://github.com/PacktPublishing/Python-Algorithmic-Trading-Cookbook/tree/master/Chapter01).
  prefs: []
  type: TYPE_NORMAL
- en: You can also open a new Jupyter notebook and try the hands-on exercises directly
    as they are shown in the recipes. Note that the output for some of these recipes
    might differ for you as they depend on the date, time, and time zone information
    provided at the time.
  prefs: []
  type: TYPE_NORMAL
- en: Creating datetime objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `datetime` module provides a `datetime` class, which can be used to accurately
    capture information relating to timestamps, dates, times, and time zones. In this
    recipe, you will create `datetime` objects in multiple ways and introspect their
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to execute this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary module from the Python standard library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `datetime` object holding the current timestamp using the `now()`
    method and print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output will differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the attributes of `dt1` related to date and time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output would differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `datetime` object holding the timestamp for 1st January 2021::'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the various attributes of `dt2` related to date and time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, you import the `datetime` class from the `datetime` module. In
    *step 2*, you create and print a `datetime` object using the `now()` method and
    assign it to `dt1`. This object holds the current timestamp information.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `datetime` object has the following attributes related to date, time, and
    time zone information:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | `year` | An integer between 0 and 23, both inclusive |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `month` | An integer between 1 and 12, both inclusive |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `day` | An integer between 1 and 31, both inclusive |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `hour` | An integer between 0 and 23, both inclusive |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `minute` | An integer between 0 and 59, both inclusive |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `second` | An integer between 0 and 59, both inclusive |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | `microsecond` | An integer between 0 and 999999, both inclusive |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | `tzinfo` | An object of class `timezone`. (More information on time zones
    in *The datetime object and time zones* recipe). |'
  prefs: []
  type: TYPE_TB
- en: In *step 3*, these attributes are printed for `dt1`. You can see that they hold
    the current timestamp information.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4*, you create and print another `datetime` object. This time you create
    a specific timestamp, which is 1st Jan 2021, midnight. You call the constructor
    itself with the parameters—`year` as `2021`, `month` as `1`, and `day` as `1`.
    The other time related attributes default to `0` and time zone defaults to `None`.
    In *step 5*, you print the attributes of `dt2`. You can see that they hold exactly
    the same values as you had passed to the constructor in *step 4*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the `date()` and `time()` methods of the `datetime` objects to
    extract the date and time information, as instances of `datetime.date` and `datetime.time`
    classes respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `date()` method to extract date from `dt1`. Note the type of the return
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output. Your output may differ::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Use `time()` method to extract date from `dt1`. Note the type of the return
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Use `date()` method to extract date from `dt2`. Note the type of the return
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Use `time()` method to extract date from `dt2`. Note the type of the return
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Creating timedelta objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `datetime` module provides a `timedelta` class, which can be used to represent
    information related to date and time differences. In this recipe, you will create
    `timedelta` objects and perform operations on them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow along with these steps to execute this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary module from the Python standard library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `timedelta` object with a duration of 5 days. Assign it to `td1` and
    print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `timedelta` object with a duration of 4 days. Assign it to `td2` and
    print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `td1` and `td2` and print the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Subtract `td2` from `td1` and print the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiply `td1` with a number (a `float`) :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, you import the `timedelta` class from the `datetime` module. In
    *step 2* you create a `timedelta` object that holds a time difference value of
    `5 days` and assign it to `td1`. You call the constructor to create the object
    with a single attribute, `days`. You pass the value as `5` here. Similarly, in
    *step 3*, you create another `timedelta` object, which holds a time difference
    value of `4 days` and assign it to `td2`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next steps, you perform operations on the `timedelta` objects. In *step
    4*, you add `td1` and `td2`. This returns another `timedelta` object which holds
    a time difference value of `9 days`, which is the sum of the time difference values
    held by `td1` and `td2`. In *step 5*, you subtract `td2` from `td1`. This returns
    another `timedelta` object that holds a time difference value of `1 day`, which
    is the difference of time difference values held by `td1` and `td2`. In *step
    6*, you multiply `td1` with `2.5`, a `float`. This again returns a `timedelta`
    object that holds a time difference value of twelve and a half days.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `timedelta` object can be created using one or more optional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | `weeks` | An integer. Default value is 0. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `days` | An integer. Default value is 0. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `hours` | An integer. Default value is 0. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `minutes` | An integer. Default value is 0. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `seconds` | An integer. Default value is 0. |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `milliseconds` | An integer. Default value is 0. |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | `microseconds` | An integer. Default value is 0. |'
  prefs: []
  type: TYPE_TB
- en: 'In *step 2* and *step 3*, we have used just the `days` argument. You can use
    other arguments as well. Also, these attributes are normalized upon creation.
    This normalization of `timedelta` objects is done to ensure that there is always
    a unique representation for every time difference value which can be held. The
    following code demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `timedelta` object with hours as `23`, minutes as `59`, and seconds
    as `60`. Assign it to `td3` and print it. It will be normalized to a `timedelta`
    object with `days` as `1` (and other date and time-related attributes as `0`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `timedelta` objects have a convenience method, `total_seconds()`. This method
    returns a `float` which represents the total seconds contained in the duration
    held by the `timedelta` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the `total_seconds()` method on `td3`. You get `86400.0` as the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Operations on datetime objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `datetime` and `timedelta` classes support various mathematical operations
    to get dates in the future or the past. Using these operations returns another
    `datetime` object. . In this recipe, you would create `datetime`, `date`, `time`,
    and `timedelta` objects and perform mathematical operations on them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow along with these steps to execute this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary modules from the Python standard library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Fetch today''s date. Assign it to `date_today` and print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Add 5 days to today''s date using a `timedelta` object. Assign it to `date_5days_later`
    and print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Subtract 5 days from today''s date using a `timedelta` object. Assign it to
    `date_5days_ago` and print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare `date_5days_later` with `date_5days_ago` using the `>` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare `date_5days_later` with `date_5days_ago` using the `<` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare `date_5days_later`, `date_today` and `date_5days_ago` together using
    the `>` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Fetch the current timestamp. Assign it to `current_timestamp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Fetch the current time. Assign it to `time_now` and print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Add 5 minutes to the current time using a `timedelta` object. Assign it to
    `time_5minutes_later` and print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Subtract 5 minutes from the current time using a `timedelta` object. Assign
    it to `time_5minutes_ago` and print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare `time_5minutes_later` with `time_5minutes_ago` using the `<` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare `time_5minutes_later` with `time_5minutes_ago` using the `>` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare `time_5minutes_later`, `time_now` and `time_5minutes_ago` together
    using the `>` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, you import `date`, `datetime`, and `timedelta` classes from the
    `datetime` module. In *step 2*, you fetch today's date using the `today()` `classmethod`
    provided by the class `date` and assign it to a new attribute, `date_today`. (A
    `classmethod` allows you to call a method directly on a class without creating
    an instance.) The return object is of type `datetime.date`. In *step 3*, you create
    a date, 5 days ahead of today, by adding a `timedelta` object, holding a duration
    of 5 days, to `date_today`. You assign this to a new attribute, `date_5days_later`.
    Similarly, in *step 4*, you create a date, 5 days ago and assign it to a new attribute
    `date_5days_ago`.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5* and *step 6*, you compare `date_5days_later` and `date_5days_ago`
    using the `>` and `<` operators, respectively. The `>` operator returns `True`
    if the first operand holds a date ahead of that held by operand 2\. Similarly,
    the `<` operator returns `True` if the second operand holds a date ahead of that
    held by operand 1\. In *step 7*, you compare together all three date objects created
    so far. Note the outputs.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 8* to *step 14* perform the same operations as *step 2* to *step 7*,
    but this time on `datetime.time` objects—fetching current time, fetching a time
    5 minutes ahead of the current time, fetching a time 5 minutes before the current
    time and comparing all the `datetime.time` objects which are created. The `timedelta`
    objects cannot be added to `datetime.time` objects directly to get time in the
    past or the future. To overcome this, you can add `timedelta` objects to `datetime`
    objects and then extract time from them using the `time()` method. You do this
    in *step 10* and *step 11*.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The operations shown in this recipe on `date` and `time` objects can similarly
    be performed on `datetime` objects. Besides `+`, `-`, `<` and `>`, you can also
    use the following operators on `datetime`, `date`, and `time` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `>=` | Return `True` only if the first operand holds a `datetime`/`date`/`time`
    ahead or equal to that of the first operand |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | Return `True` only if the first operand holds a `datetime`/`date`/`time`
    before or equal to that of the first operand |'
  prefs: []
  type: TYPE_TB
- en: '| `==` | Return `True` only if the first operand holds a `datetime`/`date`/`time`
    equal to that of the first operand |'
  prefs: []
  type: TYPE_TB
- en: 'This is not an exhaustive list of permissible operators. Refer to the official
    documentation on `datetime` module for more information: [https://docs.python.org/3.8/library/datetime.html](https://docs.python.org/3.8/library/datetime.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying datetime objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, you may want to modify existing `datetime` objects to represent a different
    date and time. This recipe includes code to demonstrate this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to execute this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary modules from the Python standard library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Fetch the current timestamp. Assign it to `dt1` and print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output would differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `datetime` object by replacing the `year`, `month`, and `day`
    attributes of `dt1`. Assign it to `dt2` and print it :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output would differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `datetime` object by specifying all the attributes directly. Assign
    it to `dt3` and print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output would differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare `dt2` and `dt3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We get the following output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, you import the `datetime` class from the `datetime` module. In
    *step 2*, you fetch the current timestamp using the `now()` method of `datetime`
    and assign it to a new attribute, `dt1`. To get a modified timestamp from an existing
    `datetime` object, you can use the `replace()` method. In *step 3*, you create
    a new `datetime` object `dt2`, from `dt1`, by calling the `replace()` method.
    You specify the attributes to be modified, which are `year`, `month`, and `day`.
    The remaining attributes remain as it is, which are an `hour`, `minute`, `second`,
    `microsecond`, and `timezone`. You can confirm this by comparing the outputs of
    *step 2* and *step 3*. In *step 4*, you create another `datetime` object, `dt3`.
    This time you call the `datetime` constructor directly. You pass all the attributes
    to the constructor such that the timestamp created is the same as `dt2`. In *step
    5*, you confirm that `dt2` and `dt3` hold exactly the same timestamp by using
    the `==` operator, which returns `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a datetime object to a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe demonstrates the conversion of the `datetime` objects into strings
    which finds application in printing and logging. Also, this is helpful while sending
    timestamps as JSON data over web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary modules from the Python standard library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Fetch the current timestamp along with time zone information. Assign it to
    `now` and print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Cast `now` to a string and print it::'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert `now` to a string with a specific date-time format using `strftime()`
    and print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *step 1*, you import the `datetime` class from the `datetime` module. In
    *step 2*, you fetch the current timestamp with time zone and assign it to a new
    attribute, `now`. The `now()` method of `datetime` fetches the current timestamp,
    but without time zone information. Such objects are called time zone-native `datetime`
    objects. The `astimezone()` method adds time zone information from the system
    local time on this time zone-naive object, essentially converting it to a time
    zone-aware object. (More information in *The datetime object and time zones* recipe).
    In *step 3*, you cast `now` to a string object and print it. Observe that the
    output date format is fixed and may not be of your choice. The datetime module
    has a `strftime()` method which can convert the object to a string in a specific
    format as required. In *step 4*, you convert `now` to a string in the format `DD-MM-YYYY
    HH:MM:SS +Z`. The directives used in *step 4* are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Directive** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `%d` | The day of the month as a zero-padded decimal number |'
  prefs: []
  type: TYPE_TB
- en: '| `%m` | The month as a zero-padded decimal number |'
  prefs: []
  type: TYPE_TB
- en: '| `%Y` | The year with the century as a decimal number |'
  prefs: []
  type: TYPE_TB
- en: '| `%H` | The hour (24-hour clock) as a zero-padded decimal number |'
  prefs: []
  type: TYPE_TB
- en: '| `%M` | The minute as a zero-padded decimal number |'
  prefs: []
  type: TYPE_TB
- en: '| `%S` | The second as a zero-padded decimal number |'
  prefs: []
  type: TYPE_TB
- en: '| `%Z` | The time zone name (empty string if the object is naive) |'
  prefs: []
  type: TYPE_TB
- en: A complete list of the directives that can be given to `.strptime()` can be
    found at [https://docs.python.org/3.7/library/datetime.html#strftime-and-strptime-behavior](https://docs.python.org/3.7/library/datetime.html#strftime-and-strptime-behavior).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a datetime object from a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe demonstrates the conversion of well-formatted strings into `datetime`
    objects. This finds application in reading timestamps from a file. Also, this
    is helpful while receiving timestamps as JSON data over web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary modules from the Python standard library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a string representation of timestamp with date, time, and time zone.
    Assign it to `now_str`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert `now_str` to `now`, a `datetime.datetime` object. Print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm that now is of the `datetime` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, you import the `datetime` class from the `datetime` module. In
    *step 2*, you create a string holding a valid timestamp and assign it to a new
    attribute, `now_str`. The `datetime` module has a `strptime()` method which can
    convert a string holding a valid timestamp in a specific format to a `datetime`
    object. In *step 3*, you convert `now_str`, a string in the format `DD-MM-YYYY
    HH:MM:SS +Z`, to `now`. In *step 4*, you confirm that `now` is indeed an object
    of the `datetime` type. The directives used in *step 3* are the same as those
    described in the *Converting a datetime object to a string* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When reading a string into a `datetime` object, the entire string should be
    consumed with appropriate directives. Consuming a string partially will throw
    an exception, as shown in the following code snippet. The error message shows
    what data was not converted and can be used to fix the directives provided to
    the `strptime()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to convert `now_str` to a `datetime` object using `strptime()` method.
    Pass a string with directives for only the date part of the string. Note the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The datetime object and time zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of `datetime` objects—time zone-naive and time zone-aware.
    Time zone-naive objects do not hold time zone information and timezone-aware objects
    hold time zone information. This recipe demonstrates multiple time zone related
    operations on `datetime` objects: creating time zone-naive and time zone-aware
    objects, adding time zone information to time zone-aware objects, removing time
    zone information from time zone-naive objects, and comparing time zone-aware and
    time zone-naive objects.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary modules from the Python standard library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a time zone-naive `datetime` object. Assign it to `now_tz_naive` and
    print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the time zone information of `now_tz_naive`. Note the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a time zone-aware `datetime` object. Assign it to `now_tz_aware` and
    print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the time zone information of `now_tz_aware`. Note the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new timestamp by adding time zone information to `now_tz_naive` from
    `now_tz_aware`. Assign it to `new_tz_aware` and print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the timezone information of `new_tz_aware` using the `tzinfo` attribute.
    Note the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new timestamp by removing timezone information from `new_tz_aware`.
    Assign it to `new_tz_naive` and print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the timezone information of `new_tz_naive` using the `tzinfo` attribute.
    Note the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, you import the `datetime` class from the `datetime` module. In
    *step 2*, you create a time zone-naive `datetime` object using the `now()` method
    and assign it to a new attribute `now_tz_naive`. In *step 3*, you print the time
    zone information held by `now_tz_naive` using the `tzinfo` attribute. Observe
    that the output is `None` as this is a time zone-naive object.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4*, you create a time zone-aware `datetime` object using the `now()`
    and `astimezone()` methods and assign it to a new attribute `now_tz_aware`. In
    *step 5*, you print the time zone information held by `now_tz_aware` using the
    `tzinfo` attribute. Observe that the output is `IST` and not `None`; as this is
    a time zone-aware object.
  prefs: []
  type: TYPE_NORMAL
- en: In `step 6`, you create a new `datetime` object by adding time zone information
    to `now_tz_naive`. The time zone information is taken from `now_tz_aware`. You
    do this using the `replace()` method (Refer to *Modifying datetime objects* recipe for
    more information). You assign this to a new variable, `new_tz_aware`. In *step
    7*, you print the time zone information held by `new_tz_aware`. Observe it is
    the same output as in *step 5* as you have taken time zone information from `now_tz_aware`.
    Similarly, in *step 8* and *step 9*, you create a new `datetime` object, `new_tz_naive`,
    but this time you remove the time zone information.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use comparison operators only between time zone-naive or time zone-aware
    `datetime` objects. You cannot compare a time zone-naive `datetime` object with
    a time zone-aware `datetime` object. Doing so will throw an exception. This is
    demonstrated in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare 2 timezone-naive objects, `new_tz_naive` and `now_tz_naive`. Note the
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare 2-time zone-aware objects, `new_tz_aware`, and `now_tz_aware`. Note
    the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare a time zone-aware object and a time zone-naive object, `new_tz_aware`,
    and `now_tz_naive`. Note the error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Creating a pandas.DataFrame object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are done with handling date and time, let's move on to handling
    time series data. The `pandas` library has a `pandas.DataFrame` class, which is
    useful for handling and manipulating such data. This recipe starts by creating
    these objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary modules from the Python standard library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a sample time-series data as a list of dictionary objects. Assign it
    to `time_series` data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `DataFrame` from `time_series_data`. Assign it to `df` and print
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the list of columns in `df`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `DataFrame` object again using the `time_series_data`. This time,
    specify the columns in the order you want:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, you import the `datetime` class from the `datetime` module and
    the `pandas` package. In *step 2*, you create a time-series data, which is typically
    returned by 3rd party APIs for historical data. This data is a list of dictionaries,
    and each dictionary has the same set of keys—`date`, `open`, `high`, `low`, `close`,
    and `volume`. Observe that the value for the `date` key is a `datetime` object
    and for the other keys are `float` objects.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, you create a pandas `DataFrame` object by directly calling the
    constructor with `time_series_data` as an argument and assign the return data
    to `df`. The keys of the dictionaries become the column names of `df` and values
    become the data. In *step 4*, you fetch the columns of `df` as a list using the
    `columns` attribute and the `tolist()` method. You can verify that the column
    names are the same as the keys of the dictionaries in `time_series_data`.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, you create a `DataFrame` with the columns in a specific order by
    passing a `columns` argument to the constructor with the required order as a list
    of strings.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a `DataFrame` object is created, an index is assigned to it automatically,
    which is an address for all the rows. The leftmost column in the preceding example
    is the index column. By default, the index starts from `0`. A custom index can
    be set by passing an `index` argument to the `DataFrame` constructor with the
    required indices as an iterator. This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new DataFrame object from `time_series_data`, with a custom index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Note the index in the output starts from `10` and goes up to `19`. The default
    index values would have ranged from `0` to `9`.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame manipulation—renaming, rearranging, reversing, and slicing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After creating a `DataFrame` object, you can perform various operations on it.
    This recipe covers the following operations on `DataFrame` objects. Renaming a
    column, rearranging columns, reversing the `DataFrame`, and slicing the `DataFrame`
    to extract a row, column, and a subset of data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the `df` object is available in your Python namespace. Refer to *Creating
    a pandas.DataFrame object* recipe of this chapter to set up this object.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rename the `date` column to `timestamp` for `df`. Print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `DataFrame` object by rearranging the columns in `df`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `DataFrame` object by reversing the rows in `df`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Extract the `close` column from `df`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Extract the first row from `df`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Extract a *2 × 2* matrix with the first two rows and first two columns only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Renaming**: In *step 1*, you rename the `date` column to `timestamp` using
    the `rename()` method of pandas `DataFrame`. You pass the `columns` argument as
    a dictionary with the existing names to be replaced as keys and their new names
    as the corresponding values. You also pass the `inplace` argument as `True` so
    that `df` is modified directly. If it is not passed, the default value is `False`,
    meaning a new `DataFrame` would be created instead of modifying `df`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rearranging**: In *step 2*, you use the `reindex()` method to create a new
    `DataFrame` from `df` by rearranging its columns. You pass the `columns` argument
    with a list of column names as strings in the required order.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Revering**: In *step 3*, you create a new `DataFrame` from `df` with its
    rows reversed by using the indexing operator in a special way `- [::-1]`. This
    is similar to the way we reverse regular Python lists.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Slicing**: In *step 4*, you extract the column `close` by using the indexing
    operator on `df`. You pass the column name, `close`, as the index here. The return
    data is a `pandas.Series` object. You can use the `iloc` property on DataFrame
    objects to extract a row, a column, or a subset DataFrame object. In *step 5*,
    you extract the first-row using `iloc` with `0` as the index. The return data
    is a `pandas.Series` object In *step 6*, you extract a 2x2 subset from df using
    `iloc` with `(:2, :2)` as the index. This implies all data in rows until index
    2 (which are 0 and 1) and columns until index 2 (which again are 0 and 1) would
    be extracted. The return data is a `pandas.DataFrame` object.'
  prefs: []
  type: TYPE_NORMAL
- en: For all the operations shown in this recipe where a new `DataFrame` object is
    returned, the original `DataFrame` object remains unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `.iloc()` property can also be used to extract a column from a `DataFrame`.
    This is shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract the 4th column from `df`. Observe the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Note that this output and the output of *step 4* are identical.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame manipulation—applying, sorting, iterating, and concatenating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding to the previous recipe, this recipe demonstrates more operations that
    can be performed on `DataFrame` objects: applying a function to all elements in
    a column, sorting based on a column, iterating over the rows, and concatenating
    multiple `DataFrame` objects vertically and horizontally.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have followed the previous recipe before trying out this recipe.
    Ensure you have `df` in your Python namespace from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the necessary modules
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the values in the timestamp column of `df` with a different date and
    time format `DD-MM-YYYY HH:MM:SS`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `DataFrame` object by sorting the `close` column in ascending
    order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `DataFrame` object by sorting the `open` column in descending
    order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate over `df` to find the average of `open`, `close`, `high`, and `low` values
    for each row:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate column-wise over all the values of the first row of `df`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a sample time-series data as a list of dictionary objects. Assign it
    to `df_new`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new DataFrame by concatenating `df` and `df_new` vertically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, you import the `pandas` package.
  prefs: []
  type: TYPE_NORMAL
- en: '**Applying**: In *step 2*, you modify all the values in the `timestamp` column
    of `df` by using the `apply` method. This method takes a function as an input
    to be applied. You pass a lambda function here which expects a `datetime` object
    as a single input, and converts it to a string in the required format using `strftime()`.
    (Refer to *Converting a datetime object to a string* recipe for more details on
    `strftime()`). The `apply` method is called on the `timestamp` column of `df`,
    which is a `pandas.Series` object. The lambda function is applied to each value
    in the column. This call returns a new `pandas.Series` object, which you assign
    back to the `timestamp` column of `df`. Note, after this, the `timestamp` column
    of `df` holds timestamps as string objects, and not `datetime` objects as earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sorting**: In *step 3*, you create a new `DataFrame` object by sorting the
    `close` column of `df` in ascending order. You use the `sort_values()` method
    to perform the sorting. Similarly, in *step 4*, you create a new `DataFrame` object
    by sorting the `open` column of `df` in descending order.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterating**: In *step 5*, you iterate over df using the `iterrows()` method
    to find and print the average of `open`, `close`, `high`, and `low` values for
    each row. The `iterrows()` method iterates over each row as an (`index, pandas.Series`)
    pair. In *step 6*, you iterate over all the values of the first row of `df` using
    `df.iloc[0]`. You get the `timestamp`, `open`, `high`, `low`, `close`, and `volume`
    column values for the first row as the output.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Concatenation**: In *step 6*, you create a new `DataFrame` similar to the
    one created in *step 2* of *Creating a pandas.DataFrame object* recipe, and assign
    it to `df_new`. You use the `pandas.concat()` function to create a new `DataFrame`
    by vertically concatenating `dt` and `df_new`. This implies that a new `DataFrame`
    would be created with the rows of `df_new` appended below the rows of `df`. You
    pass a list containing `df` and `df_new` as an argument to the `pandas.concat()`
    function. Also, to create a fresh index starting from `0`, you use the `reset_index()`
    method with the argument drop passed as `True`. If you don''t use `reset_index()`,
    the indices of the concatenated `DataFrame` would look something like this—`0,
    1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4`. (Refer to *Creating a pandas.DataFrame
    object* recipe to know more about the `DataFrame` index.)'
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also use the `pandas.concat()` function to concatenate two `DataFrame`
    objects together horizontally, which is column-wise by, passing the `axis` argument a
    value of `1` to the `pandas.concat()` method. This is shown in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `random` module from the Python standard library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a DataFrame object with a single column, `open`, and random values.
    Assign it to `df1` and print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another `DataFrame` object with a single column, `close`, and random
    values. Assign it to `df2` and print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `DataFrame` by concatenating `df1` and `df2` horizontally
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output. Your output may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Converting a DataFrame into other formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe demonstrates the conversion of `DataFrame` objects into other formats,
    such as `.csv` files, `json` objects, and `pickle` objects. Conversion into a `.csv`
    file makes it easier to further work on the data using a spreadsheet application.
    The `json` format is useful for transmitting `DataFrame` objects over web APIs.
    The `pickle` format is useful for transmitting `DataFrame` objects created in
    one Python session to another Python session over sockets without having to recreate
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the object `df` is available in your Python namespace. Refer to *Creating
    a pandas.DataFrame object* recipe of this chapter to set up this object.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert and save `df` as a CSV file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert `df` to a JSON string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Pickle `df` to a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, you use the `to_csv()` method to save `df` as a `.csv` file. You
    pass `dataframe.csv`, a file path where the `.csv` file should be generated, as
    the first argument and index as `False` as the second argument. Passing index
    as `False` prevents the index from being dumped to the `.csv` file. If you want
    to save the `DataFrame` along with its index, you can pass the index as `True`
    to the `to_csv()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, you use the `to_json()` method to convert `df` into a JSON string.
    You do not pass any additional arguments to the `to_json()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, you use the `to_pickle()` method to pickle (serialize) the object.
    Again you do not pass any additional arguments to the `to_pickle()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods `to_csv()`, `to_json()`, and `to_pickle()` can take more optional
    arguments than the ones shown in this recipe. Refer to the official docs for complete
    information on these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`to_csv()`: [https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_csv.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_csv.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`to_json()`: [https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_json.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_json.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`to_pickle()`: [https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_pickle.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_pickle.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a DataFrame from other formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will create `DataFrame` objects from other formats, such
    as `.csv` files, `.json` strings, and `pickle` files. A `.csv` file created using
    a spreadsheet application, valid JSON data received over web APIs, or valid pickle
    objects received over sockets can all be processed further using Python by converting
    them to `DataFrame` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading pickled data received from untrusted sources can be unsafe. Please
    use `read_pickle()` with caution. You can find more details here: [https://docs.python.org/3/library/pickle.html](https://docs.python.org/3/library/pickle.html).
    If you are using this function on the pickle file created in the previous recipe,
    it is perfectly safe to use `read_pickle()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have followed the previous recipe before starting this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a DataFrame object by reading a CSV file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a DataFrame object by reading a JSON string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `DataFrame` object by unpickling the `df.pickle` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, you use the `pandas.read_csv()` function to create a DataFrame
    object from a `.csv` file. You pass `dataframe.csv`, the file path from where
    the `.csv` file should be read, as an argument. Recall, you have created `dataframe.csv`
    in *step 1* of the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, you use the `pandas.read_json()` function to create a `DataFrame`
    object from a valid JSON string. You pass the JSON string from the output of *step
    2* in the previous recipe as an argument to this function.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, you use the `pandas.read_pickle()` method to create a `DataFrame`
    object from a `pickle` file. You pass `df.pickle`, the file path from where the
    pickle file should be read, as an argument to this function. Recall, what you
    created `df.pickle` in *step 3* of the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: If you have followed the previous recipe, the outputs for all the three steps
    would all be the same `DataFrame` object. And this would be identical to `df`
    from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The methods `read_csv()`, `read_json()`, and `read_pickle()` can take more optional
    arguments than the ones shown in this recipe. Refer to the official docs for complete
    information on these methods.
  prefs: []
  type: TYPE_NORMAL
- en: '`read_csv()`: [https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html#pandas.read_csv](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html#pandas.read_csv)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`read_json()`: [https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_json.html#pandas.read_json](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_json.html#pandas.read_json)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`read_pickle()`: [https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_pickle.html#pandas.read_pickle](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_pickle.html#pandas.read_pickle)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
