- en: '10'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variational Quantum Eigensolver
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameterised quantum circuits can find many possible applications outside
    the quantum machine learning use cases considered in the previous chapters. They
    can be used to solve problems as diverse as portfolio optimisationÂ  Â [[168](Biblography.xhtml#XKolotouros2021)]
    and protein foldingÂ Â [[248](Biblography.xhtml#XRobert2019)]. However, one aspect
    remains the same regardless of the specifics of the particular algorithm: the
    construction of a quantum state with desired characteristics through an optimal
    PQC configuration (ansatz) and an optimal set of adjustable PQC parameters. This,
    in turn, is done through the minimisation of some cost function â€“ it can be a
    classification error in the case of a QNN-based classifier or a distance between
    two distributions in the case of QCBM.'
  prefs: []
  type: TYPE_NORMAL
- en: The Variational Quantum Eigensolver (VQE) is a PQC-based algorithm that aims
    to find the smallest eigenvalue (the lowest energy) of a problem Hamiltonian.
    As we know from ChapterÂ [3](Chapter_3.xhtml#x1-630003), the objective functions
    of many NP-hard combinatorial optimisation problems can be encoded in the Hamiltonians
    of quantum systems â€“ thus finding the ground state of the Hamiltonian gives us
    the minimum of the objective function. The VQE was originally proposed inÂ Â [[231](Biblography.xhtml#XPeruzzo2014)]
    and quickly became one of the most popular tools for experimenting with the wide
    range of optimisation problems solvable on NISQ devicesÂ Â [[153](Biblography.xhtml#XKandala2017),Â [215](Biblography.xhtml#XMoll2018)].
    The variational part of the algorithm refers to the systematic search for the
    best possible approximation of the ground state by trying various PQC ansÃ¤tze
    and configurations of adjustable PQC parameters â€“ the variational approach.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1 The Variational Approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us start with recollecting the details of training discriminative (QNN)
    and generative (QCBM) models. In both cases our task was to find an optimal configuration
    of PQC parameters (e.g., rotation angles of adjustable one-qubit gates) such that
    the resulting quantum state had the desired properties: we could either sample
    from the encoded probability distribution (generative model) or obtain a class
    label for the given sample (discriminative model). The process of finding an optimal
    configuration of PQC parameters is called *learning* when we are dealing with
    QML use cases. This learning can be done either in a differentiable or in a non-differentiable
    way, but it always consists of the minimisation of some cost function through
    varying the adjustable circuit parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: What if the cost function we want to minimise is encoded in the problem Hamiltonian
    and the task is formulated as finding its ground state? In ChapterÂ [3](Chapter_3.xhtml#x1-630003),
    we saw how this problem can be solved on a quantum annealer. But it is also possible
    to find the lowest energy state of a quantum system (or at least a good approximation)
    using a gate model quantum computer within the PQC framework.
  prefs: []
  type: TYPE_NORMAL
- en: The characteristic equation for the HamiltonianÂ â„‹ reads
  prefs: []
  type: TYPE_NORMAL
- en: '| ![â„‹ &#124;ÏˆiâŸ© = Ei &#124;ÏˆiâŸ©, ](img/file840.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'where ![|ÏˆiâŸ©](img/file841.jpg) is an eigenstate associated with the eigenvalue
    *E*[i]. The objective is to find the smallest eigenvalue *E*[0] (the lowest energy)
    ofÂ â„‹ corresponding to the ground state (the lowest energy state) ![|Ïˆ0 âŸ©](img/file842.jpg).
    This would be a straightforward task if the latter was known since the eigenvalue
    (energy) ofÂ â„‹ is simply the expectation ofÂ â„‹:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![âŸ¨Ïˆi&#124;â„‹ &#124;ÏˆiâŸ© = âŸ¨Ïˆi&#124;Ei &#124;ÏˆiâŸ© = Ei âŸ¨Ïˆi&#124;ÏˆiâŸ© = Ei. ](img/file843.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: We will explain below how this expectation is calculated on a quantum computer.
    However, in most cases the ground state is not known. In fact, the task is to
    find the ground state that encodes the solution to the optimisation problem by
    searching for the state that minimises the expectation value ofÂ â„‹. What we can
    do is to construct a progressively better approximation of the ground state, yielding
    a tighter and tighter upper bound for the ground state energyÂ *E*[0].
  prefs: []
  type: TYPE_NORMAL
- en: The variational approach is motivated by the spectral theorem introduced in
    ChapterÂ [1](Chapter_1.xhtml#x1-220001), which allows us to expand the Hermitian
    HamiltonianÂ â„‹ as
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ âˆ‘ â„‹ = Ei &#124;ÏˆiâŸ©âŸ¨Ïˆi&#124;. i ](img/file844.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: Assume that we constructed a stateÂ ![|ÏˆâŸ©](img/file845.jpg), which is an approximation
    of the true ground state ![|Ïˆ0 âŸ©](img/file846.jpg). As we know from ChapterÂ [1](Chapter_1.xhtml#x1-220001),
    the expectation value ofÂ â„‹ in state ![|Ïˆ âŸ©](img/file847.jpg) is âŸ¨*Ïˆ*|â„‹![|ÏˆâŸ©](img/file848.jpg).
    SubstitutingÂ â„‹ given byÂ ([10.1](#x1-2030001)) into this, we obtain, by linearity,
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ( ) âˆ‘ âŸ¨Ïˆ&#124;â„‹ &#124;ÏˆâŸ© = âŸ¨Ïˆ&#124; Ei &#124;ÏˆiâŸ©âŸ¨Ïˆi&#124; &#124;ÏˆâŸ© âˆ‘ i
    âˆ‘ = Ei âŸ¨Ïˆ&#124;ÏˆiâŸ©âŸ¨Ïˆi&#124;Ïˆ âŸ© = Ei&#124;âŸ¨Ïˆ,ÏˆiâŸ©&#124;2 . i i ](img/file849.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: ExpressionÂ ([10.1](#x1-2030001)) shows that the expectation ofÂ â„‹ on any stateÂ ![|ÏˆâŸ©](img/file850.jpg)
    can be expressed as a linear combination of the eigenvalues ofÂ â„‹ with all weights
    greater than or equal to zero, since |![âŸ¨Ïˆ, Ïˆ âŸ© i](img/file851.jpg)|Â² â‰¥ 0 for
    eachÂ *i*. Therefore, we obtain
  prefs: []
  type: TYPE_NORMAL
- en: '| ![âŸ¨Ïˆ&#124;â„‹ &#124;Ïˆ âŸ© â‰¥ E0, ](img/file852.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: sinceÂ *E*[0] is the smallest eigenvalue of â„‹ and all coefficients (weights)
    in the linear combinationÂ ([10.1](#x1-2030001)) are non-negative.
  prefs: []
  type: TYPE_NORMAL
- en: The role of PQC is to produce the candidate stateÂ ![|Ïˆ âŸ©](img/file853.jpg).
    The *variational* part of the algorithm consists of iterative improvements of
    the candidate state (iterative updates of the adjustable parameters). This is
    something that can be done as a classical part of the hybrid quantum-classical
    protocol. The quantum part of the algorithm consists of running the PQC and then
    measuring â„‹ on the constructed quantum state in order to obtain the expectation
    value of â„‹.
  prefs: []
  type: TYPE_NORMAL
- en: The variational approach allows us to solve hard optimisation problems encoded
    in the Hamiltonian on the digital gate model quantum computer â€“ an alternative
    to adiabatic quantum computing since not all optimisation problems can be efficiently
    formulated in a QUBO format.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2 Calculating Expectations on a Quantum Computer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The key element of the VQE algorithm is the calculation of the expectation value.
    We now show how this can be performed on a quantum computer. We start with the
    one-qubit case and then generalise the proposed approach to the two-qubit and
    multi-qubit cases.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.1 The one-qubit case
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider the simplest case of a one-qubit system. Since any 2 Ã— 2 unitary and
    Hermitian matrix can always be decomposed into a sum of the Pauli matrices X,
    Y, Z and an identity matrix I (more on this in SectionÂ [10.2.3](#x1-2070003)),
    we can represent any one-qubit Hamiltonian as
  prefs: []
  type: TYPE_NORMAL
- en: '| ![â„‹ = aX + bY+ cZ + dI, ](img/file854.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: where *a*, *b*, *c*, and *d* are some real coefficients. For a given stateÂ ![|Ïˆ
    âŸ©](img/file855.jpg), the expectation value of the HamiltonianÂ ([10.2.1](#x1-2050001))
    is given by
  prefs: []
  type: TYPE_NORMAL
- en: '| ![âŸ¨â„‹ âŸ© â‰¡ âŸ¨Ïˆ &#124;â„‹ &#124;Ïˆ âŸ© = a âŸ¨Ïˆ&#124;X &#124;Ïˆ âŸ©+ bâŸ¨Ïˆ &#124;Y &#124;ÏˆâŸ©
    + câŸ¨Ïˆ&#124;Z &#124;Ïˆ âŸ©+ dâŸ¨Ïˆ &#124;I &#124;ÏˆâŸ© . ](img/file856.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: The expectation value of â„‹ is computed by adding the expectation values of all
    its terms, which means that we can compute the expectation values of the Pauli
    terms independently and then sum them up to obtain ![âŸ¨â„‹ âŸ©](img/file857.jpg). We
    can do it by first constructing the state ![|Ïˆ âŸ©](img/file858.jpg) with the help
    of a PQC and then by performing measurement in the computational basis. The cycle
    of constructing the state and performing measurement should be repeated a sufficient
    number of times in order to obtain accurate statistics. Let us go through the
    terms of the HamiltonianÂ ([10.2.1](#x1-2050001)) one by one to see how it can
    be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the last term, which is the identity operatorÂ I multiplied by
    the coefficientÂ *d*. This is a trivial case and we do not even need to run a quantum
    circuit to compute its expectation value, since the expectation value ofÂ I is
    1:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![âŸ¨Ïˆ&#124;I &#124;ÏˆâŸ© = âŸ¨Ïˆ &#124;Ïˆ âŸ© = 1, ](img/file859.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: so that this term will contributeÂ *d* to ![âŸ¨â„‹ âŸ©](img/file860.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: We move now to the next term, *c*Z. The measurement is performed in the computational
    basis, which is the *z*-basis. In this basis, ![|ÏˆâŸ©](img/file861.jpg) can be represented
    as a superposition of the basis states ![|0âŸ©](img/file862.jpg) and ![|1âŸ©](img/file863.jpg)
    as
  prefs: []
  type: TYPE_NORMAL
- en: '| ![&#124;Ïˆ âŸ© = Î±z &#124;0âŸ©+ Î²z &#124;1âŸ©, ](img/file864.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: with *Î±*[z]*,Î²*[z] âˆˆâ„‚. The expectation âŸ¨*Ïˆ*|Z![|ÏˆâŸ©](img/file865.jpg) is then
    calculated as
  prefs: []
  type: TYPE_NORMAL
- en: '| âŸ¨*Ïˆ*&#124;Z![&#124;Ïˆ âŸ©](img/file866.jpg) | = &#124;*Î±*[z]&#124;Â² âŸ¨0&#124;Z![&#124;0âŸ©](img/file867.jpg)
    + *Î±* [z]^âˆ—*Î²* [z] âŸ¨0&#124;Z![&#124;1âŸ©](img/file868.jpg) + *Î±*[z]*Î²*[z]^âˆ—âŸ¨1&#124;Z![&#124;0âŸ©](img/file869.jpg)
    + &#124;*Î²* [z]&#124;Â² âŸ¨1&#124;Z![&#124;1âŸ©](img/file870.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = &#124;*Î±*[z]&#124;Â²![âŸ¨0&#124;0âŸ©](img/file871.jpg)âˆ’ *Î±* [z]^âˆ—*Î²* [z]![âŸ¨0&#124;1âŸ©](img/file872.jpg)
    + *Î±*[z]*Î²*[z]^âˆ—![âŸ¨1&#124;0âŸ©](img/file873.jpg)âˆ’&#124;*Î²* [z]&#124;Â²![âŸ¨1&#124;1âŸ©](img/file874.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | = &#124;*Î±*[z]&#124;Â² âˆ’&#124;*Î²* [z]&#124;Â²*,* |'
  prefs: []
  type: TYPE_TB
- en: using the definition of the Z-gate (ChapterÂ [6](Chapter_6.xhtml#x1-1190006))
    and orthogonality of the basis states.
  prefs: []
  type: TYPE_NORMAL
- en: By definition, |*Î±*[z]|Â² and |*Î²*[z]|Â² are the probabilities that after the
    *z*-basis measurement, the quantum stateÂ ![|Ïˆ âŸ©](img/file875.jpg) will become
    ![|0âŸ©](img/file876.jpg) or ![|1âŸ©](img/file877.jpg) respectively. In order to find
    that value, we should run the quantum circuit (to construct stateÂ ![|ÏˆâŸ©](img/file878.jpg))
    and then perform measurementÂ *N* times. The probability of finding a qubit in
    stateÂ ![|0âŸ©](img/file879.jpg) is then estimated as *n*[0]*âˆ•N*, where *n*[0] is
    the number of stateÂ ![|0âŸ©](img/file880.jpg) measurements. Similarly, the probability
    of finding a qubit in state ![|1âŸ©](img/file881.jpg) can be estimated as *n*[1]*âˆ•N*,
    where *n*[1] is the number of state ![|1âŸ©](img/file882.jpg) measurements.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the contribution of the Z-term to ![âŸ¨â„‹ âŸ©](img/file883.jpg) is given
    by
  prefs: []
  type: TYPE_NORMAL
- en: '| ![câŸ¨Ïˆ&#124;Z &#124;ÏˆâŸ© = cn0 âˆ’-n1-. N ](img/file884.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: Now we can move to the first two terms on the right side ofÂ ([10.2.1](#x1-2050001)).
    Recall thatÂ ![|0âŸ©](img/file885.jpg) andÂ ![|1âŸ©](img/file886.jpg) are the eigenstates
    ofÂ Z with corresponding eigenvalues +1 and âˆ’1, namely
  prefs: []
  type: TYPE_NORMAL
- en: '| ![Z &#124;0âŸ© = &#124;0âŸ© and Z &#124;1âŸ© = âˆ’ &#124;1âŸ©. ](img/file887.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: Furthermore, the eigenstates ofÂ X are
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ &#124;0âŸ©+ &#124;1âŸ© &#124;0âŸ©âˆ’ &#124;1âŸ© &#124;+ âŸ© = --âˆš----- and &#124;âˆ’
    âŸ© =---âˆš----, 2 2 ](img/file888.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: and the eigenstates ofÂ Y are
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ &#124;0âŸ©+ i &#124;1âŸ© &#124;0âŸ©âˆ’ i &#124;1âŸ© &#124;RâŸ© = ---âˆš----- and &#124;LâŸ©
    = ---âˆš-----. 2 2 ](img/file889.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: Their corresponding eigenvalues also are +1 and âˆ’1, so that
  prefs: []
  type: TYPE_NORMAL
- en: '| ![X &#124;+ âŸ© = &#124;+ âŸ©, X &#124;âˆ’ âŸ© = âˆ’ &#124;âˆ’ âŸ©, Y &#124;R âŸ© = &#124;RâŸ©
    , Y &#124;LâŸ© = âˆ’ &#124;LâŸ©. ](img/file890.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'Therefore, the quantum stateÂ ![|Ïˆ âŸ©](img/file891.jpg) can also be decomposed
    into the superposition of the basis states {![|R âŸ©](img/file892.jpg)*,*![|LâŸ©](img/file893.jpg)}
    (*y*-basis) and {![|+âŸ©](img/file894.jpg)*,*![|âˆ’ âŸ©](img/file895.jpg)} (*x*-basis):'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![&#124;Ïˆ âŸ© = Î±x &#124;+âŸ© + Î²x &#124;âˆ’ âŸ© = Î±y &#124;RâŸ©+ Î²y &#124;LâŸ©. ](img/file896.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: If we can perform measurement in the *x*-basis and the *y*-basis, the expectations
    âŸ¨*Ïˆ*|X![|ÏˆâŸ©](img/file897.jpg) and âŸ¨*Ïˆ*|Y![|Ïˆ âŸ©](img/file898.jpg) can be calculated
    in exactly the same way as the expectation âŸ¨*Ïˆ*|Z![|ÏˆâŸ©](img/file899.jpg), namely
  prefs: []
  type: TYPE_NORMAL
- en: '| ![a âŸ¨Ïˆ&#124;X &#124;Ïˆ âŸ© = a n+-âˆ’-nâˆ’-, bâŸ¨Ïˆ&#124;Y &#124;Ïˆ âŸ© = b nR-âˆ’-nL. N
    N ](img/file900.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: Here, *n*[+] andÂ *n*[âˆ’] are the numbers of measurements in the *x*-basis that
    correspond, respectively, to the ![|+ âŸ©](img/file901.jpg) and ![|âˆ’ âŸ©](img/file902.jpg)
    outcomes, andÂ *n*[R] andÂ *n*[L] are the numbers of measurements in the *y*-basis
    that correspond, respectively, to ![|RâŸ©](img/file903.jpg) and ![|L âŸ©](img/file904.jpg)
    outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: However, it may be the case that we can only perform measurement in the *z*-basis.
    In this case, we need to apply some additional gates toÂ ![|ÏˆâŸ©](img/file905.jpg)
    before the measurement, such that the probability of measuringÂ ![|0âŸ©](img/file906.jpg)
    in the *z*-basis is the same as the probability of measuringÂ ![|+ âŸ©](img/file907.jpg)
    in the *x*-basis if we are calculating âŸ¨*Ïˆ*|X![|ÏˆâŸ©](img/file908.jpg), or the probability
    of measuringÂ ![|0âŸ©](img/file909.jpg) in the *z*-basis is the same as the probability
    of measuringÂ ![|RâŸ©](img/file910.jpg) in the *y*-basis if we are calculating âŸ¨*Ïˆ*|Y![|ÏˆâŸ©](img/file911.jpg).
    Denoting these gatesÂ H andÂ G, we have
  prefs: []
  type: TYPE_NORMAL
- en: '| ![H &#124;ÏˆâŸ© = H(Î±x &#124;+ âŸ©+ Î²x &#124;âˆ’ âŸ©) = Î±x &#124;0âŸ© + Î²x &#124;1âŸ©,
    ](img/file912.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: with H![|+ âŸ©](img/file913.jpg) = ![|0âŸ©](img/file914.jpg) and H![|âˆ’ âŸ©](img/file915.jpg)
    = ![|1âŸ©](img/file916.jpg) and
  prefs: []
  type: TYPE_NORMAL
- en: '| ![G &#124;ÏˆâŸ© = G(Î±y &#124;RâŸ© + Î²y &#124;LâŸ©) = Î±y &#124;0âŸ©+ Î²y &#124;1âŸ©, ](img/file917.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: with G![|R âŸ©](img/file918.jpg) = ![|0 âŸ©](img/file919.jpg) and G![|L âŸ©](img/file920.jpg)
    = ![|1âŸ©](img/file921.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: The operatorsÂ H (which is simply the Hadamard operator) andÂ G admit the matrix
    representations
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ âŒŠ âŒ‹ âŒŠ âŒ‹ -1- 1 1 -1- 1 âˆ’ i H = âˆš2--âŒˆ âŒ‰ and G = âˆš2-âŒˆ âŒ‰ . 1 âˆ’ 1 1 i ](img/file922.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: 10.2.2 The two-qubit case
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What if the problem Hamiltonian has terms involving more than a single qubit?
    Consider a Hamiltonian with terms consisting of tensor products of Pauli matrices
    such as XâŠ—Y, YâŠ—Z, etc. The general approach remains the same: the expectation
    value of the Hamiltonian consists of the sum of expectation values of all its
    terms. Thus, we need to know how to calculate the expectation value of the product
    of Pauli matrices. Without loss of generality, consider the XâŠ—Y term â€“ as the
    very same logic applies to all other Pauli tensor products.'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that XâŠ—Y is the tensor product of the two Pauli operatorsÂ X andÂ Y, each
    acting on their own qubits, not a sequential application of gatesÂ X andÂ Y to the
    same qubit. Indeed, given for two unitary operatorsÂ U[1] andÂ U[2], the tensor
    product U[1] âŠ—U[2] acts on the state of a two-qubit system as
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ ( ) ( ) (U1 âŠ— U2) &#124;Ïˆ1âŸ© âŠ— &#124;Ïˆ2 âŸ© = U1 &#124;Ïˆ1âŸ© âŠ— U2 &#124;Ïˆ2
    âŸ© . ](img/file923.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: We immediately see fromÂ ([10.2.2](#x1-2060002)) that the tensor product of eigenvectors
    ofÂ X andÂ Y is an eigenvector ofÂ XâŠ—Y. Indeed, if U![|ÏˆU âŸ©](img/file924.jpg) = *E*[U]![|ÏˆUâŸ©](img/file925.jpg)
    with *E*[U] âˆˆâ„‚, for U âˆˆ{X*,*Y}, then
  prefs: []
  type: TYPE_NORMAL
- en: '![(XâŠ— Y) |ÏˆXâŸ©âŠ— |ÏˆYâŸ© = X |ÏˆXâŸ©âŠ— Y |ÏˆY âŸ© = EX |ÏˆXâŸ©âŠ— EY |ÏˆYâŸ© = EXEY |ÏˆX âŸ©âŠ— |ÏˆY
    âŸ©. ](img/file926.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We also remember that all eigenvectors of Pauli operators have eigenvalues equal
    to either +1 or âˆ’1 (as detailed inÂ ([10.2.1](#x1-2050001)) andÂ ([10.2.1](#x1-2050001))).
    Now, for the XâŠ—Y Pauli term, the eigenvectors with eigenvalueÂ +1 are
  prefs: []
  type: TYPE_NORMAL
- en: '![|+ âŸ©âŠ— |RâŸ© = |+R âŸ© and |âˆ’ âŸ© âŠ— |LâŸ© = |âˆ’ LâŸ©, ](img/file927.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and the eigenvectors with eigenvalueÂ âˆ’1 are
  prefs: []
  type: TYPE_NORMAL
- en: '![|+ âŸ©âŠ— |LâŸ© = |+L âŸ© and |âˆ’ âŸ©âŠ— |R âŸ© = |âˆ’ RâŸ©, ](img/file928.jpg)'
  prefs: []
  type: TYPE_IMG
- en: which follow directly from the computations
  prefs: []
  type: TYPE_NORMAL
- en: '| ![(XâŠ— Y) &#124;+R âŸ© = (XâŠ— Y) &#124;+âŸ©âŠ— &#124;R âŸ© = X &#124;+âŸ© âŠ— Y &#124;R
    âŸ© = &#124;+ âŸ©âŠ— &#124;RâŸ© = &#124;+R âŸ©, (XâŠ— Y) &#124;+L âŸ© = (XâŠ— Y) &#124;+ âŸ©âŠ— &#124;LâŸ©
    = X &#124;+ âŸ©âŠ— Y &#124;LâŸ© = &#124;+ âŸ©âŠ— (âˆ’ &#124;LâŸ©) = âˆ’ &#124;+L âŸ©, (XâŠ— Y) &#124;âˆ’
    RâŸ© = (XâŠ— Y) &#124;âˆ’ âŸ©âŠ— &#124;R âŸ© = X &#124;âˆ’ âŸ© âŠ— Y &#124;R âŸ© = (âˆ’ &#124;âˆ’ âŸ©)âŠ—
    &#124;R âŸ© = âˆ’ &#124;âˆ’ RâŸ© , (XâŠ— Y) &#124;âˆ’ LâŸ© = (XâŠ— Y) &#124;âˆ’ âŸ©âŠ— &#124;LâŸ© = X
    &#124;âˆ’ âŸ©âŠ— Y &#124;LâŸ© = (âˆ’ &#124;âˆ’ âŸ©) âŠ— (âˆ’ &#124;L âŸ©) = &#124;âˆ’ LâŸ©. ](img/file929.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: 'Let us write down the representation of a quantum state of the two-qubit system
    ![|Ïˆ âŸ©](img/file930.jpg) = ![|Ïˆ1âŸ©](img/file931.jpg)âŠ—![|Ïˆ2 âŸ©](img/file932.jpg)
    in the basis of XâŠ—Y eigenvectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![&#124;ÏˆâŸ© = &#124;Ïˆ1âŸ©âŠ— &#124;Ïˆ2âŸ© = (Î±x &#124;+ âŸ©+ Î²x &#124;âˆ’ âŸ©)âŠ— (Î±y &#124;R
    âŸ©+ Î²y &#124;LâŸ©) = Î±xÎ±y &#124;+R âŸ©+ Î±xÎ²y &#124;+L âŸ©+ Î²xÎ±y &#124;âˆ’ R âŸ©+ Î²xÎ²y &#124;âˆ’
    L âŸ©, ](img/file933.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'with (*Î±*[x]*,Î²*[x]*,Î±*[y]*,Î²*[y]) âˆˆâ„‚â´. We want to apply an operator allowing
    us to perform measurements in the *z*-basis such that the probability amplitudes
    of the corresponding states remain the same. It is easy to see that this operator
    is a tensor product of theÂ H andÂ G gates:'
  prefs: []
  type: TYPE_NORMAL
- en: '| (HâŠ—G)![&#124;ÏˆâŸ©](img/file934.jpg) | = (HâŠ—G)![(Î±x Î±y &#124;+R âŸ© + Î±xÎ²y &#124;+L
    âŸ©+ Î²xÎ±y &#124;âˆ’ RâŸ© + Î²xÎ²y &#124;âˆ’ LâŸ©)](img/file935.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = *Î±*[x]*Î±*[y](HâŠ—G)![&#124;+ âŸ©](img/file936.jpg)âŠ—![&#124;R âŸ©](img/file937.jpg)
    + *Î±*[x]*Î²*[y](HâŠ—G)![&#124;+ âŸ©](img/file938.jpg)âŠ—![&#124;L âŸ©](img/file939.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | + *Î²*[x]*Î±*[y](HâŠ—G)![&#124;âˆ’ âŸ©](img/file940.jpg)âŠ—![&#124;RâŸ©](img/file941.jpg)
    + *Î²*[x]*Î²*[y](HâŠ—G)![&#124;âˆ’ âŸ©](img/file942.jpg)âŠ—![&#124;LâŸ©](img/file943.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | = *Î±*[x]*Î±*[y](H![&#124;+ âŸ©](img/file944.jpg)âŠ—G![&#124;RâŸ©](img/file945.jpg))
    + *Î±*[x]*Î²*[y](H![&#124;+ âŸ©](img/file946.jpg)âŠ—G![&#124;L âŸ©](img/file947.jpg))
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | + *Î²*[x]*Î±*[y](H![&#124;âˆ’ âŸ©](img/file948.jpg)âŠ—G![&#124;RâŸ©](img/file949.jpg))
    + *Î²*[x]*Î²*[y](H![&#124;âˆ’ âŸ©](img/file950.jpg)âŠ—G![&#124;LâŸ©](img/file951.jpg)) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = *Î±*[x]*Î±*[y](![&#124;0âŸ©](img/file952.jpg)âŠ—![&#124;0âŸ©](img/file953.jpg))
    + *Î±*[x]*Î²*[y](![&#124;0âŸ©](img/file954.jpg)âŠ—![&#124;1âŸ©](img/file955.jpg)) + *Î²*[x]*Î±*[y](![&#124;1âŸ©](img/file956.jpg)âŠ—![&#124;0âŸ©](img/file957.jpg))
    + *Î²*[x]*Î²*[y](![&#124;1âŸ©](img/file958.jpg)âŠ—![&#124;1âŸ©](img/file959.jpg)) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = *Î±*[x]*Î±*[y]![&#124;00âŸ©](img/file960.jpg) + *Î±*[x]*Î²*[y]![&#124;01âŸ©](img/file961.jpg)
    + *Î²*[x]*Î±*[y]![&#124;10âŸ©](img/file962.jpg) + *Î²*[x]*Î²*[y]![&#124;11âŸ©](img/file963.jpg)*.*
    |'
  prefs: []
  type: TYPE_TB
- en: 'The eigenvalues ofÂ ZâŠ—Z corresponding to the eigenstates {![|00âŸ©](img/file964.jpg)*,*![|01
    âŸ©](img/file965.jpg)*,*![|10âŸ©](img/file966.jpg)*,*![|11âŸ©](img/file967.jpg)} are
    the same as the eigenvalues ofÂ XâŠ—Y corresponding to the eigenstates {![|+R âŸ©](img/file968.jpg)*,*![|+L
    âŸ©](img/file969.jpg)*,*![|âˆ’ RâŸ©](img/file970.jpg)*,*![|âˆ’ LâŸ©](img/file971.jpg)}:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![(ZâŠ— Z) &#124;00âŸ© = (ZâŠ— Z ) &#124;0âŸ©âŠ— &#124;0âŸ© = Z &#124;0âŸ©âŠ— Z &#124;0âŸ©
    = &#124;0âŸ©âŠ— &#124;0âŸ© = &#124;00âŸ© , (ZâŠ— Z) &#124;01âŸ© = (ZâŠ— Z ) &#124;0âŸ©âŠ— &#124;1âŸ©
    = Z &#124;0âŸ©âŠ— Z &#124;1âŸ© = &#124;0âŸ©âŠ— (âˆ’ &#124;1âŸ©) = âˆ’ &#124;01âŸ©, (ZâŠ— Z) &#124;10âŸ©
    = (ZâŠ— Z ) &#124;1âŸ©âŠ— &#124;0âŸ© = Z &#124;1âŸ©âŠ— Z &#124;0âŸ© = (âˆ’ &#124;1âŸ©) âŠ— &#124;0âŸ©
    = âˆ’ &#124;10âŸ©, (ZâŠ— Z) &#124;11âŸ© = (ZâŠ— Z ) &#124;1âŸ©âŠ— &#124;1âŸ© = Z &#124;1âŸ©âŠ— Z &#124;1âŸ©
    = (âˆ’ &#124;1âŸ©) âŠ— (âˆ’ &#124;1âŸ©) = &#124;11âŸ©. ](img/file972.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: Therefore, the expectation âŸ¨*Ï•*|ZâŠ—Z![|Ï•âŸ©](img/file973.jpg), with
  prefs: []
  type: TYPE_NORMAL
- en: '| ![&#124;Ï•âŸ© = Î±xÎ±y &#124;00âŸ© + Î±xÎ²y &#124;01 âŸ©+ Î²xÎ±y &#124;10âŸ©+ Î²xÎ²y &#124;11
    âŸ©, ](img/file974.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: in the *z*-basis is given by
  prefs: []
  type: TYPE_NORMAL
- en: '| ![&#124;Î± Î± &#124;2 âˆ’ &#124;Î± Î² &#124;2 âˆ’ &#124;Î² Î± &#124;2 + &#124;Î² Î² &#124;2\.
    x y x y x y x y ](img/file975.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: The values of the probabilities |*Î±*[x]*Î±*[y]|Â², |*Î±*[x]*Î²*[y]|Â², |*Î²*[x]*Î±*[y]|Â²,
    and |*Î²*[x]*Î²*[y]|Â² can be found using quantum computers in exactly the same way
    we found probabilities in the one-qubit case. By counting the numbersÂ *n*[ij]
    of outcomes ![|ijâŸ©](img/file976.jpg) (for *i,j* âˆˆ{0*,*1}, with âˆ‘ [i,jâˆˆ{0,1}]*n*[ij]
    = *N*), the expectation value ofÂ XâŠ—Y is given by
  prefs: []
  type: TYPE_NORMAL
- en: '| ![âŸ¨X âŠ— YâŸ© = n00 âˆ’-n01-âˆ’-n10 +-n11\. N ](img/file977.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 10.2.3 The multi-qubit case
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is straightforward to scale this approach to more complex Pauli products
    and larger Hamiltonians since any Hamiltonian may be written as
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ âˆ‘ i i âˆ‘ ij i j â„‹ = hÎ± ÏƒÎ± + hÎ±Î²Ïƒ Î±ÏƒÎ² + ... iÎ± ijÎ±Î² ](img/file978.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: for real *h*, where the superscripts *i,j,â€¦* identify the subsystem (qubit)
    on which the operator acts, and the subscripts *Î±,Î²,â€¦* identify the Pauli operator.
    For example, *i* = 1, *Î±* = *x*, and *Ïƒ*[x]Â¹ = X acting on qubit 1\. No assumption
    about the dimension or structure of the Hermitian Hamiltonian is needed for this
    expansion to be validÂ Â [[231](Biblography.xhtml#XPeruzzo2014)].
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already used the linearity of quantum observables that allows us to
    calculate the expectation of the Hamiltonian as a sum of expectations of the individual
    terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ âˆ‘ iâŸ¨ iâŸ© âˆ‘ ij âŸ¨ i jâŸ© âŸ¨â„‹âŸ© = h Î± ÏƒÎ± + hÎ±Î² ÏƒÎ±ÏƒÎ² + ... iÎ± ijÎ±Î² ](img/file979.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: As long as we consider Hamiltonians that can be written as a polynomial number
    of terms with respect to the system size, the evaluation of ![âŸ¨â„‹âŸ©](img/file980.jpg)
    is reduced to the sum of a polynomial number of expectation values of simple Pauli
    operators for some quantum stateÂ ![|Ïˆ âŸ©](img/file981.jpg), multiplied by some
    real constants. As we have seen above, a quantum computer can efficiently evaluate
    the expectation value of a tensor product of an arbitrary number of simple Pauli
    operatorsÂ Â [[227](Biblography.xhtml#XOrtiz2001)].
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computers can be used to efficiently calculate expectation values of
    Hamiltonians consisting of tensor products of Pauli operators. Any Hamiltonian
    may be represented as a sum of tensor products of Pauli operators (X, Y, Z, and
    I gates).
  prefs: []
  type: TYPE_NORMAL
- en: 10.3 Constructing the PQC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The question of how to construct a high-quality candidate state used to calculate
    expectations is of fundamental importance. Unless we have some prior knowledge
    about the ground state and where to search for it in the Hilbert space of the
    *n*-qubit system, the first task would be to generate a range of candidate states
    that will cover the whole Hilbert space without being heavily concentrated in
    any one region. Let us see how this can be done for the single-qubit and multi-qubit
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.1 One-qubit ansatz
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We return to the Bloch sphere that visualises the possible states of a one-qubit
    system. FigureÂ [10.1](#10.1) shows how the qubit state can change from its initial
    state ![|0âŸ©](img/file982.jpg) to the intermediate state ![|ÏˆiâŸ©](img/file983.jpg)
    and then to the final state ![|ÏˆfâŸ©](img/file984.jpg) through a rotation around
    the *y*-axis followed by a rotation around the *z*-axis.
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 10.1: Bloch sphere: visualisation of one-qubit rotations. ](img/file985.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 10.1: Bloch sphere: visualisation of one-qubit rotations.'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to reach any point on the Bloch sphere starting fromÂ ![|0âŸ©](img/file986.jpg)
    with just two rotations around any two orthogonal axes. The corresponding circuit
    is shown in FigureÂ [10.2](#10.2).
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 10.2: PQC for a one-qubit system. ](img/file987.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 10.2: PQC for a one-qubit system.'
  prefs: []
  type: TYPE_NORMAL
- en: The PQC shown in FigureÂ [10.2](#10.2) is everything we need in the one-qubit
    case if we only have theÂ Z andÂ I terms in the problem Hamiltonian. If we want
    to calculate the expectation value of theÂ X term, we have to add anÂ H gate to
    the circuit as shown in FigureÂ [10.3](#10.3).
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 10.3: PQC with H gate to calculate âŸ¨XâŸ©. ](img/file989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 10.3: PQC with H gate to calculate ![âŸ¨XâŸ©](img/file988.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if we want to calculate the expectation value of theÂ Y term, we
    have to add aÂ G gate to the circuit as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 10.4: PQC with G gate to calculate âŸ¨YâŸ©. ](img/file991.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 10.4: PQC with G gate to calculate ![âŸ¨YâŸ©](img/file990.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.2 Multi-qubit ansatz
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We now look at the multi-qubit case, and assume that the optimisation problem
    is encoded in the two-qubit Hamiltonian
  prefs: []
  type: TYPE_NORMAL
- en: '| ![â„‹ = aX âŠ— Y+ bY âŠ— Z+ cZ âŠ— X, ](img/file992.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'for some coefficients *a,b,c* âˆˆâ„. As we know, the expectation value of the
    HamiltonianÂ ([10.3.2](#x1-2100002)) is given by the sum of expectation values
    of individual terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![âŸ¨â„‹ âŸ© â‰¡ âŸ¨Ïˆ &#124;â„‹ &#124;ÏˆâŸ© = aâŸ¨Ïˆ &#124;X âŠ— Y &#124;Ïˆ âŸ©+ bâŸ¨Ïˆ &#124;YâŠ— Z
    &#124;Ïˆ âŸ©+ câŸ¨Ïˆ &#124;ZâŠ— X &#124;ÏˆâŸ©. ](img/file993.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'We need to calculate all these expectations for the same quantum stateÂ ![|ÏˆâŸ©](img/file994.jpg).
    To do so, we need to construct a quantum circuit with sufficiently flexible adjustable
    gates to support a wide range of possible candidate states. Since the problem
    Hamiltonian operates on two-qubit states, the PQC that constructs the candidate
    states may look like the one shown in FigureÂ [10.5](#10.5):'
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 10.5: PQC for the construction of candidate states. ](img/file995.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 10.5: PQC for the construction of candidate states.'
  prefs: []
  type: TYPE_NORMAL
- en: In the PQC shown in FigureÂ [10.5](#10.5), the parameters (rotation angles)Â *ğœƒ*[1]
    andÂ *ğœƒ*[2] uniquely specify state ![|Ïˆ1âŸ©](img/file996.jpg) of the first qubit,
    and the parametersÂ *ğœƒ*[3] andÂ *ğœƒ*[4] uniquely specify state ![|Ïˆ2âŸ©](img/file997.jpg)
    of the second qubit. The full quantum circuit for the calculation of the expectation
    value ![âŸ¨X âŠ— YâŸ©](img/file998.jpg) is shown in FigureÂ [10.6](#10.6), where the
    gatesÂ H (first quantum register) andÂ G (second quantum register) form the change
    of basis layer before the measurement in the computational basis. FiguresÂ [10.7](#10.7)
    andÂ [10.8](#10.8) display the PQCs for the calculation of ![âŸ¨Y âŠ— ZâŸ©](img/file999.jpg)
    and ![âŸ¨Z âŠ— XâŸ©](img/file1000.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 10.6: PQC for the calculation of the âŸ¨X âŠ— YâŸ© term. ](img/file1002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 10.6: PQC for the calculation of the ![âŸ¨X âŠ— YâŸ©](img/file1001.jpg) term.'
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 10.7: PQC for the calculation of the âŸ¨Y âŠ— ZâŸ© term. ](img/file1004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 10.7: PQC for the calculation of the ![âŸ¨Y âŠ— ZâŸ©](img/file1003.jpg) term.'
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 10.8: PQC for the calculation of the âŸ¨Z âŠ— XâŸ© term. ](img/file1006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 10.8: PQC for the calculation of the ![âŸ¨Z âŠ— XâŸ©](img/file1005.jpg) term.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the state construction circuits shown in FiguresÂ [10.6](#10.6)-[10.8](#10.8)
    consist of one-qubit gates and do not contain two-qubit gates that would create
    entanglement. Adding two-qubit gates, such as CNOT and CPHASE, would help explore
    a wider range of possible quantum states and should be done as a matter of course
    as we know from the previous chapters. However, our task here is to illustrate
    the general principle and compare the results obtained by running the PQC with
    the calculations done "by hand", as we shall see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 10.4 Running the PQC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now run some numerical experiments for the optimisation problem encoded in
    the HamiltonianÂ ([10.3.2](#x1-2100002)) and compare the obtained results with
    direct calculations to better understand the mechanics of the algorithm and to
    build intuition.
  prefs: []
  type: TYPE_NORMAL
- en: 10.4.1 Experimenting with the two-qubit ansatz
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In line with the variational approach and taking into account the PQC architecture
    specified in FigureÂ [10.5](#10.5), we need to build the candidate states controlled
    by the four adjustable parametersÂ *ğœƒ*[1], *ğœƒ*[2], *ğœƒ*[3], andÂ *ğœƒ*[4]. In ChaptersÂ [8](Chapter_8.xhtml#x1-1620008)
    andÂ [9](Chapter_9.xhtml#x1-1850009), we considered two possible approaches to
    train the PQC: differentiable and non-differentiable learning. Both methods have
    their strong and weak points and can be used to find an optimal set of adjustable
    parameters for the PQC of arbitrary size. However, the PQC shown in FigureÂ [10.5](#10.5)
    is only two-layer deep and two-quantum register wide â€“ it is perfectly feasible
    in this case to apply the brute force method.'
  prefs: []
  type: TYPE_NORMAL
- en: The brute force method consists of discretising the range of possible values
    of the rotation angles with the elementary step (increment) kept reasonably small.
    The parametersÂ *ğœƒ*[1] andÂ *ğœƒ*[3] are rotation angles around the *y*-axis and are
    defined on the interval [0*,Ï€*], which we discretise as
  prefs: []
  type: TYPE_NORMAL
- en: '| ![{ } (2k +-1-)Ï€ , 2m k=0,...,mâˆ’1 ](img/file1007.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: for some integerÂ *m*. Similarly, *ğœƒ*[2] andÂ *ğœƒ*[4] are rotation angles around
    the *z*-axis defined on [0*,*2*Ï€*], with range
  prefs: []
  type: TYPE_NORMAL
- en: '| ![{ (2k + 1)Ï€} --------- . 2m k=0,...,2mâˆ’ 1 ](img/file1008.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: In both cases the increment is *Ï€âˆ•m*. Taking, for example, *m* = 8 is a sensible
    compromise between speed and accuracy. What is more, once the optimal configuration
    of adjustable parameters is found, we can run an additional, more granular search
    in the vicinity of the candidate optimal configuration in order to further improve
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm looks as follows. For the given configuration of R[Y] and R[Z]
    rotation angles drawn from the setsÂ ([10.4.1](#x1-2120001)) andÂ ([10.4.1](#x1-2120001)),
    we execute 100,000 runs of PQCs specified in FiguresÂ [10.6](#10.6), [10.7](#10.7),
    andÂ [10.8](#10.8) on the Qiskit quantum simulator. This gives us the expectation
    values of XâŠ—Y, YâŠ—Z, and ZâŠ—X for the quantum state ![|Ïˆ âŸ©](img/file1009.jpg) =
    ![|Ïˆ1âŸ©](img/file1010.jpg)âŠ—![|Ïˆ2 âŸ©](img/file1011.jpg), where
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( ğœƒ ) ( ğœƒ ) |Ïˆ1âŸ© = cos -1 |0âŸ©+ eiğœƒ2 sin -1 |1âŸ© 2 2 ](img/file1012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( ) ( ) ğœƒ3 iğœƒ4 ğœƒ3 |Ïˆ2âŸ© = cos 2 |0âŸ© + e sin 2 |1âŸ©. ](img/file1013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We select the state ![|Ïˆ âˆ—âŸ©](img/file1014.jpg) with the smallest value of ![âŸ¨â„‹
    âŸ©](img/file1015.jpg) given byÂ ([10.3.2](#x1-2100002)), and denote the corresponding
    rotation angles *ğœƒ*[1]^âˆ—*,â€¦,ğœƒ*[4]^âˆ—. After that, we perform a more refined search
    in the neighbourhood of ![|Ïˆ âˆ—âŸ©](img/file1016.jpg). The new set values of the
    rotation angles are now
  prefs: []
  type: TYPE_NORMAL
- en: '| ![{ } ğœƒâˆ—i + (k-âˆ’-4)Ï€- , i = 1,...,4, 4m k=0,...,m ](img/file1017.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: with increment *Ï€âˆ•*(4*m*). Again, we select the quantum state ![ â€² |Ïˆ âŸ©](img/file1018.jpg)
    with the smallest value ofÂ ![âŸ¨â„‹ âŸ©](img/file1019.jpg) and denote the corresponding
    rotation angles *ğœƒ*â€²[1]*,â€¦,ğœƒ*â€²[4].
  prefs: []
  type: TYPE_NORMAL
- en: 'With *m* = 8, *a* = 4, *b* = 3, *c* = 2, we obtain the results in TableÂ [10.1](#table10.1):'
  prefs: []
  type: TYPE_NORMAL
- en: '| 1st search: | ğœƒ[1]^âˆ— = 1.7671 | ğœƒ[2]^âˆ— = 3.0434 | ğœƒ[3]^âˆ— = 1.7671 | ğœƒ[4]^âˆ—
    = 1.4726 | ![TableÂ 10.1: Optimal configurations of adjustable PQC parameters that
    minimise the expectation value of the Hamiltonian. ](img/file1020.jpg)[min] =
    âˆ’3.93 |'
  prefs: []
  type: TYPE_TB
- en: '| 2nd search: | ğœƒâ€²[1] = 1.5708 | ğœƒâ€²[2] = 3.1416 | ğœƒâ€²[3] = 1.5708 | ğœƒâ€²[4] =
    1.5708 | ![TableÂ 10.1: Optimal configurations of adjustable PQC parameters that
    minimise the expectation value of the Hamiltonian. ](img/file1020.jpg)[min] =
    âˆ’4.00 |'
  prefs: []
  type: TYPE_TB
- en: 'TableÂ 10.1: Optimal configurations of adjustable PQC parameters that minimise
    the expectation value of the Hamiltonian.'
  prefs: []
  type: TYPE_NORMAL
- en: In TableÂ [10.1](#table10.1), the values of ![âŸ¨â„‹ âŸ©](img/file1021.jpg) are in
    the units of coefficients *a*, *b*, and *c*, and the values of rotation angles
    are in radians. Note that 3*.*1416 = *Ï€* and 1*.*5708 = *Ï€âˆ•*2\. Therefore, the
    optimal configuration of rotation angles that minimises ![âŸ¨â„‹ âŸ©](img/file1022.jpg)
    is
  prefs: []
  type: TYPE_NORMAL
- en: '![ğœƒâ€²1 = ğœƒâ€²3 = ğœƒâ€²4 = Ï€ and ğœƒâ€²2 = Ï€. 2 ](img/file1023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The corresponding quantum states are
  prefs: []
  type: TYPE_NORMAL
- en: '![|Ïˆ âŸ© = âˆš1--|0âŸ© âˆ’ âˆš1--|1âŸ©, |Ïˆ âŸ© = âˆš1--|0âŸ© + âˆši--|1âŸ©, 1 2 2 2 2 2 ](img/file1024.jpg)![
    1 i 1 i |ÏˆâŸ© = |Ïˆ1âŸ©âŠ— |Ïˆ2 âŸ© =--|00âŸ©+ -|01âŸ©âˆ’ -|10âŸ©âˆ’ --|11âŸ©. 2 2 2 2 ](img/file1025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 10.4.2 Analysis of the obtained results
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Do the obtained results make sense? Since the problem size is small and the
    circuit is not too deep, we can verify the results by direct manual calculations.
    First, we visualise the statesÂ ![|Ïˆ1âŸ©](img/file1026.jpg) andÂ ![|Ïˆ2 âŸ©](img/file1027.jpg).
    FigureÂ [10.4.2](#x1-2130002) shows their positions on the Bloch sphere. StateÂ ![|Ïˆ
    âŸ© 1](img/file1028.jpg) is the black dot at the intersection of the *x*-axis and
    the equator. We get toÂ ![|Ïˆ1 âŸ©](img/file1029.jpg) from stateÂ ![|0âŸ©](img/file1030.jpg)
    by performing a *Ï€âˆ•*2 radian rotation around the *y*-axis and then a *Ï€* radian
    rotation around the *z*-axis. StateÂ ![|Ïˆ2 âŸ©](img/file1031.jpg) is the gray dot
    at the intersection of the *y*-axis and the equator, which is reached fromÂ ![|0âŸ©](img/file1032.jpg)
    by performing a *Ï€âˆ•*2 radian rotation around the *y*-axis and then a *Ï€âˆ•*2 radian
    rotation around the *z*-axis.
  prefs: []
  type: TYPE_NORMAL
- en: '![FigureÂ 10.9: Visualisation of states |Ïˆ1âŸ© (black dot) and |Ïˆ2âŸ© (grey dot).
    ](img/file1035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FigureÂ 10.9: Visualisation of states ![|Ïˆ1âŸ©](img/file1033.jpg) (black dot)
    and ![|Ïˆ2âŸ©](img/file1034.jpg) (grey dot).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the expectation ![âŸ¨XâŠ— YâŸ©](img/file1036.jpg). The operatorÂ X acts onÂ ![|Ïˆ1âŸ©](img/file1037.jpg),
    which is one of its eigenstates in the *x*-basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ -1- -1- |Ïˆ1âŸ© = âˆš2-|0âŸ©âˆ’ âˆš2--|1âŸ© = |âˆ’ âŸ©, ](img/file1038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'andÂ Y acts onÂ ![|Ïˆ2âŸ©](img/file1039.jpg), which is also one of its eigenstates
    in the *y*-basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![|Ïˆ âŸ© = âˆš1-|0âŸ©+ âˆš-i-|1âŸ© = |R âŸ©. 2 2 2 ](img/file1040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We then perform measurements in the computational basis (*z*-basis). Before
    measurement, the Hadamard operatorÂ H will transform ![|Ïˆ1âŸ©](img/file1041.jpg)
    = ![|âˆ’ âŸ©](img/file1042.jpg) intoÂ ![|1âŸ©](img/file1043.jpg), which is a basis state
    in the *z*-basis. Similarly, the operatorÂ G will transform ![|Ïˆ2âŸ©](img/file1044.jpg)
    = ![|R âŸ©](img/file1045.jpg) intoÂ ![|0âŸ©](img/file1046.jpg), which is also a basis
    state in the *z*-basis.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, measurement in the *z*-basis will give us the stateÂ ![|1âŸ©](img/file1047.jpg)âŠ—![|0âŸ©](img/file1048.jpg)
    = ![|10âŸ©](img/file1049.jpg) with probability one. If we performÂ *N* measurements,
    we will obtain the state ![|10âŸ©](img/file1050.jpg) *N* times and the corresponding
    expectation value ![âŸ¨X âŠ— YâŸ©](img/file1051.jpg) will be
  prefs: []
  type: TYPE_NORMAL
- en: '![âŸ¨X âŠ— YâŸ© = n00 âˆ’-n01-âˆ’-n10 +-n11= 0âˆ’-0-âˆ’-N-+-0-= âˆ’ 1\. N N ](img/file1052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The value of the coefficientÂ *a* in front of the XâŠ—Y term was set equal toÂ 4\.
    Therefore, the contribution of the first term to the expectation value of the
    HamiltonianÂ ([10.3.2](#x1-2100002)) isÂ âˆ’4.
  prefs: []
  type: TYPE_NORMAL
- en: The expectations ![âŸ¨YâŠ— ZâŸ©](img/file1053.jpg) and ![âŸ¨Z âŠ— XâŸ©](img/file1054.jpg)
    are equally straightforward to calculate. Let us start withÂ ![âŸ¨Y âŠ— ZâŸ©](img/file1055.jpg).
    The operatorÂ Y acts on the first qubit in the stateÂ ![|Ïˆ1âŸ©](img/file1056.jpg).
    Since we measure the resulting state in the *z*-basis, we need to applyÂ G before
    measurement. The operatorÂ G transformsÂ ![|Ïˆ1 âŸ©](img/file1057.jpg) into the state
  prefs: []
  type: TYPE_NORMAL
- en: '![1+--i 1-âˆ’-i 2 |0âŸ©+ 2 |1âŸ©. ](img/file1058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Measurement in the *z*-basis will result inÂ ![|0âŸ©](img/file1059.jpg) andÂ ![|1âŸ©](img/file1060.jpg)
    with equal probabilityÂ 1*âˆ•*2.
  prefs: []
  type: TYPE_NORMAL
- en: The operatorÂ Z acts on the second qubit in state ![|Ïˆ2âŸ©](img/file1061.jpg).
    Since we measure the operatorÂ Z in the *z*-basis, we do not need to apply any
    gates. MeasuringÂ ![|Ïˆ2âŸ©](img/file1062.jpg) in the *z*-basis will also result in
    obtainingÂ ![|0âŸ©](img/file1063.jpg) andÂ ![|1âŸ©](img/file1064.jpg) with equal probabilityÂ 1*âˆ•*2\.
    Therefore, we are equally likely to measure all four basis states (![|00âŸ©](img/file1065.jpg),
    ![|01âŸ©](img/file1066.jpg), ![|10âŸ©](img/file1067.jpg), and ![|11 âŸ©](img/file1068.jpg))
    with probabilityÂ 1*âˆ•*4, and, asÂ *N* tends to infinity, the expectation value of
    ![âŸ¨Y âŠ— ZâŸ©](img/file1069.jpg) in our experiment should converge to
  prefs: []
  type: TYPE_NORMAL
- en: '![ n00 âˆ’-n01-âˆ’-n10 +-n11 14N-âˆ’--14N-âˆ’-14N--+-14N-- âŸ¨Y âŠ— ZâŸ© = N = N = 0\. ](img/file1070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are left now with ![âŸ¨Z âŠ— XâŸ©](img/file1071.jpg). The operatorÂ Z acts onÂ ![|Ïˆ1âŸ©](img/file1072.jpg).
    The measurement is done in the *z*-basis, so no transformation is needed. The
    measurement will result in obtaining the states ![|0âŸ©](img/file1073.jpg) and ![|1âŸ©](img/file1074.jpg)
    with equal probabilityÂ 1*âˆ•*2\. The operatorÂ X acts on the second qubit in the
    stateÂ ![|Ïˆ2âŸ©](img/file1075.jpg). The measurement is performed in the *z*-basis,
    so we need to apply the Hadamard gateÂ H before measurement. Applying theÂ H gate
    toÂ ![|Ïˆ2âŸ©](img/file1076.jpg) transforms it into
  prefs: []
  type: TYPE_NORMAL
- en: '![1+ i 1 âˆ’ i -----|0âŸ©+ -----|1âŸ©, 2 2 ](img/file1077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'with measurement in the *z*-basis producing outcomes ![|0âŸ©](img/file1078.jpg)
    and ![|1âŸ©](img/file1079.jpg) with probabilityÂ 1*âˆ•*2\. Thus, we find ourselves
    in the same situation as with ![âŸ¨Y âŠ— ZâŸ©](img/file1080.jpg): all basis states are
    equally likely. AsÂ *N* tends to infinity, the expectation value of ![âŸ¨Z âŠ— XâŸ©](img/file1081.jpg)
    should also converge to'
  prefs: []
  type: TYPE_NORMAL
- en: '![ n00 âˆ’-n01-âˆ’-n10 +-n11 14N-âˆ’--14N-âˆ’-14N--+-14N-- âŸ¨Z âŠ— XâŸ© = N = N = 0\. ](img/file1082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is exactly what we observed in our numerical experiment. The total contribution
    of all three terms of the HamiltonianÂ â„‹ given byÂ ([10.3.2](#x1-2100002)) with
    *a* = 4, *b* = 3, and *c* = 2 is equal to âˆ’4\. The XâŠ—Y term has the largest coefficient,
    therefore it makes sense that the ground state ofÂ â„‹ is the one that minimises
    the expectation value ![âŸ¨XâŠ— YâŸ©](img/file1083.jpg) (with expectation values ![âŸ¨Y
    âŠ— ZâŸ©](img/file1084.jpg) and ![âŸ¨ZâŠ— XâŸ©](img/file1085.jpg) being zero).
  prefs: []
  type: TYPE_NORMAL
- en: PQC can be used to construct the candidate states for the VQE algorithm. The
    selection and improvement of the candidate states is performed classically. This
    makes VQE a perfect example of a hybrid quantum-classical algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 10.5 Discrete Portfolio Optimisation with VQE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In ChapterÂ [3](Chapter_3.xhtml#x1-630003), we investigated quantum annealing
    for NP-hard discrete portfolio optimisation problems. The same type of QUBO problems
    can be solved on gate model quantum computers with the help of a hybrid VQE algorithm.
    The QUBO formulation of the discrete portfolio optimisation problem consists of
    minimising the cost functionÂ ([3.3.1](Chapter_3.xhtml#x1-750001)):'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ Nâˆ‘ âˆ‘N âˆ‘N L(q) = aiqi + bijqiqj, i=1 i=1j=i+1 ](img/file1086.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: 'where q := (*q*[1]*,â€¦,q*[N]) is a vector of binary decision variables indicating
    which (equally weighted) assets are selected (from the universe of *N* investable
    assets): *q*[i] = 1 means that assetÂ *i* is selected and *q*[i] = 0 means that
    asset *i* is not selected. The task is to find a configuration ofÂ q that minimisesÂ *L*(q).'
  prefs: []
  type: TYPE_NORMAL
- en: For each *i,j* = 1*,â€¦N*, the coefficients *a*[i], *a*[j], and *b*[ij] reflect,
    respectively, the individual and joint attractiveness of assetsÂ *i* andÂ *j*. For
    example, assets with larger expected returns and lower volatilities would be assigned
    large negative values ofÂ *a*. Similarly, pairs of assets with low positive or
    even negative correlation would be assigned negative values ofÂ *b* to reward diversification.
    Assets with lower expected returns, higher volatility, and strongly positively
    correlated with other assets would be penalised with positive values ofÂ *a* andÂ *b*.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum annealers solve QUBO problems in their Ising model formulation where
    binary decision variables q := (*q*[1]*,â€¦,q*[N]) are translated into spin variables
    s := (*s*[1]*,â€¦,s*[N]) taking values {+1*,*âˆ’1} through the transformation *s*[i]
    = 2*q*[i] âˆ’ 1\. We analyse the simplest case of an investable universe consisting
    of just two assets. In this case, the QUBO cost function reads
  prefs: []
  type: TYPE_NORMAL
- en: '| ![L(q) = a1q1 + a2q2 + b12q1q2, ](img/file1087.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: or, in the Ising model formulation,
  prefs: []
  type: TYPE_NORMAL
- en: '| ![L (s) = g1s1 + g2s2 + J12s1s2 + const, ](img/file1088.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ 1 1 1 1 1 g1 = -a1 + -b12, g2 = -a2 + -b12, J12 = -b12\. 2 4 2 4 4 ](img/file1089.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: The constant term inÂ ([10.5](#x1-2140005)) does not depend on the decision variablesÂ *s*[1]
    andÂ *s*[2] and can hence be ignored. The cost function we want to minimise thus
    becomes
  prefs: []
  type: TYPE_NORMAL
- en: '| ![L(s) = g1s1 + g2s2 + J12s1s2\. ](img/file1090.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: As we know from ChapterÂ [2](Chapter_2.xhtml#x1-480002), transition from the
    classical to the quantum mechanical description of the system consists of replacing
    variables corresponding to physical observables by their respective operators.
    In the case of the QUBO problem in its Ising model formulation, it means replacing
    classical spin variables with the corresponding Pauli operators *Ïƒ*[x], *Ïƒ*[y],
    and *Ïƒ*[z], which are represented in the quantum circuit by, respectively, the
    quantum gates X, Y, and Z.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we remember from ChapterÂ [3](Chapter_3.xhtml#x1-630003), the Ising cost
    functionÂ ([10.5](#x1-2140005)) corresponds to the following *final* Hamiltonian
    that encodes the same optimisation problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ 1 2 1 2 â„‹F = g1Ïƒ z + g2Ïƒz + J12ÏƒzÏƒz. ](img/file1091.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: Here, the classical spin variablesÂ *s*[1] andÂ *s*[2] are replaced by theÂ *Ïƒ*[z]
    operators, andÂ *Ïƒ*[z]Â¹ is theÂ Z gate acting on qubitÂ 1 whileÂ *Ïƒ*[z]Â² is theÂ Z
    gate acting on qubitÂ 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the mapping between the binary QUBO decision variables *q*, classical
    spin variables *s*, and the eigenstates of Z is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![q = 0 â†’ s = âˆ’ 1 â†’ &#124;1âŸ© since Z &#124;1âŸ© = âˆ’ &#124;1âŸ©, ](img/file1092.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '| ![q = 1 â†’ s = +1 â†’ &#124;0âŸ© since Z &#124;0âŸ© = &#124;0âŸ©. ](img/file1093.jpg)
    |  |'
  prefs: []
  type: TYPE_TB
- en: We now solve the QUBO problemÂ ([10.5](#x1-2140005)) with
  prefs: []
  type: TYPE_NORMAL
- en: '| ![a1 = âˆ’ 2, a2 = 3, b12 = âˆ’ 2, ](img/file1094.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: using both the classical method (in this case a simple exhaustive search given
    that the solution space consists of just four possible solutions) and the VQE
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The classical exhaustive search results are straightforward to obtain via direct
    calculations and are summarised in TableÂ [10.2](#x1-214002r2) with the optimal
    solution q^âˆ— = (1*,*0): assetÂ 1 is selected, while assetÂ 2 is not.'
  prefs: []
  type: TYPE_NORMAL
- en: '| q[1] | q[2] | L(q) |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | -2 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | -1 |'
  prefs: []
  type: TYPE_TB
- en: 'TableÂ 10.2: Classical exhaustive search results.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The VQE calculations are as follows. We first rewrite the HamiltonianÂ ([10.5](#x1-2140005))
    in the quantum gate form:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![â„‹F = g1Z1 + g2Z2 + J12Z1 âŠ— Z2, ](img/file1095.jpg) |  |'
  prefs: []
  type: TYPE_TB
- en: where ZÂ¹ is theÂ Z gate acting on qubitÂ 1, ZÂ² is theÂ Z gate acting on qubitÂ 2,
    andÂ ZÂ¹ âŠ—ZÂ² is the tensor product of theÂ Z gates acting on qubitsÂ 1 andÂ 2 respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to calculate the expectation values ![âŸ¨ZâŸ©](img/file1096.jpg)
    and ![âŸ¨Z âŠ— ZâŸ©](img/file1097.jpg). As we know, Z is a PHASE gate that flips the
    phase of a qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Z |0âŸ© = |0âŸ©, Z |1âŸ© = âˆ’ |1âŸ©. ](img/file1098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Therefore, we have
  prefs: []
  type: TYPE_NORMAL
- en: '| ![ âŸ¨0&#124;Z1 &#124;0âŸ© = +1, âŸ¨1&#124;Z1 &#124;1âŸ© = âˆ’ 1, âŸ¨0&#124;Z2 &#124;0âŸ©
    = +1, âŸ¨1&#124;Z2 &#124;1âŸ© = âˆ’ 1, âŸ¨00&#124;Z1 âŠ— Z2 &#124;00âŸ© = +1, âŸ¨01&#124;Z1
    âŠ— Z2 &#124;01 âŸ© = âˆ’ 1, âŸ¨10&#124;Z1 âŠ— Z2 &#124;10âŸ© = âˆ’ 1, âŸ¨11&#124;Z1 âŠ— Z2 &#124;11
    âŸ© = +1\. ](img/file1099.jpg) |'
  prefs: []
  type: TYPE_TB
- en: 'Here we calculated the expectation values of operators Z and ZâŠ—Z analytically
    but we would obtain exactly the same values if we were to calculate them using
    a quantum computer as described in SectionÂ [10.2](#x1-2040002). Now we need to
    calculate the values of the coefficientsÂ *g*[1], *g*[2], andÂ *J*[12] using the
    transformationÂ ([10.5](#x1-2140005)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![g1 = âˆ’ 1.5, g2 = 1, J12 = âˆ’ 0.5\. ](img/file1100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The expectation values ofÂ â„‹[F] in states ![|00âŸ©](img/file1101.jpg), ![|01âŸ©](img/file1102.jpg),
    ![|10âŸ©](img/file1103.jpg), ![|11âŸ©](img/file1104.jpg) can then be calculated as
  prefs: []
  type: TYPE_NORMAL
- en: '| ![&#124;00âŸ©](img/file1105.jpg) : | ![âŸ¨â„‹âŸ©](img/file1106.jpg) = *g*[1] â‹… (+1)
    + *g*[2] â‹… (+1) + *J*[12] â‹… (+1) = âˆ’1*,* |'
  prefs: []
  type: TYPE_TB
- en: '| ![&#124;01âŸ©](img/file1107.jpg) : | ![âŸ¨â„‹âŸ©](img/file1108.jpg) = *g*[1] â‹… (+1)
    + *g*[2] â‹… (âˆ’1) + *J*[12] â‹… (âˆ’1) = âˆ’2*,* |'
  prefs: []
  type: TYPE_TB
- en: '| ![&#124;10âŸ©](img/file1109.jpg) : | ![âŸ¨â„‹âŸ©](img/file1110.jpg) = *g*[1] â‹… (âˆ’1)
    + *g*[2] â‹… (+1) + *J*[12] â‹… (âˆ’1) = 3*,* |'
  prefs: []
  type: TYPE_TB
- en: '| ![&#124;11âŸ©](img/file1111.jpg) : | ![âŸ¨â„‹âŸ©](img/file1112.jpg) = *g*[1] â‹… (âˆ’1)
    + *g*[2] â‹… (âˆ’1) + *J*[12] â‹… (+1) = 0*.* |'
  prefs: []
  type: TYPE_TB
- en: The best solution found using VQE is therefore ![|01âŸ©](img/file1113.jpg) = ![|0âŸ©](img/file1114.jpg)âŠ—![|1âŸ©](img/file1115.jpg),
    i.e., assetÂ 1 is selected while assetÂ 2 is not, which is the same as the best
    solution found by exhaustive search.
  prefs: []
  type: TYPE_NORMAL
- en: A VQE is a viable tool for solving finance-related NP-hard optimisation problems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we introduced the Variational Quantum Eigensolver algorithm,
    a powerful QML model based on the variational approach that allows us to solve
    hard optimisation problems. We learned how to calculate expectation values using
    a quantum computer and how to construct a PQC, creating the candidate quantum
    states.
  prefs: []
  type: TYPE_NORMAL
- en: We also experimented with running the VQE model on a sample problem encoded
    in a two-qubit Hamiltonian and analysed and verified the results by performing
    manual calculations. Finally, we demonstrated the applicability of the VQE to
    finance-related optimisation problems, in particular to a stylised example of
    a discrete portfolio optimisation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce the Quantum Approximate Optimisation
    Algorithm, another example of a hybrid quantum-classical approach to solving hard
    optimisation problems.
  prefs: []
  type: TYPE_NORMAL
- en: Join our bookâ€™s Discord space
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Join our Discord community to meet like-minded people and learn alongside more
    than 2000 members at: [https://packt.link/quantum](https://packt.link/quantum)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
