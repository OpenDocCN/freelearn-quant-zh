["```py\n\nimport json\ndata = None\nwith open(\"binance-data.json\", \"r\") as jsonfile:\n    data = json.load(jsonfile)\n```", "```py\n\nimport numpy as np\nreturns = data['mu']\ncovar = data['sigma']\nassets = []\ncosts = []\nfor row in data['assets']:\n    assets.append(row[\"Asset\"])\n    costs.append(float(row[\"Open\"]))\n# Half the money\nbudget = np.sum(costs)/0.5\n```", "```py\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nsns.barplot(y=returns, x = assets)\nplt.show()\n```", "```py\n\nf, ax = plt.subplots(figsize=(10, 8))\nsns.heatmap(covar, mask=np.zeros_like(covar, dtype=bool), annot=True,\n            square=True, ax=ax, xticklabels=assets, yticklabels=assets)\nplt.title(\"Covariance between Equities\")\nplt.show()\n```", "```py\n\nimport cvxpy as cp\n# Our solution variable\nx_val = cp.Variable(len(returns), boolean=True)\ntheta = cp.Parameter(nonneg=True)\nret = np.array(returns)@x_val\nrisk = cp.quad_form(x_val, covar)\ne_costs = np.array(costs)@x_val\n# Constraints\ncons = [cp.sum(x_val) >= 0, cp.sum(e_costs) <= budget, x_val >= 0]\n# Objective function\nobj = cp.Minimize(- ret + theta*risk)\n# Problem\nprob = cp.Problem(obj, cons)\n```", "```py\n\ntheta.value = 0.03 # This is related to the risk penalty lagrangian\nprob.solve(solver='ECOS_BB')\nfor i, val in enumerate(np.round(x_val.value,1)):\n    if val == 1:\n        print(f\"Asset {assets[i]} was selected\")\n    else:\n        print(f\"Asset {assets[i]} was not selected\")\n```", "```py\n\nimport json\nimport numpy as np\ndata = None\nwith open(\"binance-data.json\", \"r\") as jsonfile:\n    data = json.load(jsonfile)\nreturns = data['mu']\ncovar = data['sigma']\n```", "```py\n\nassets = []\ncosts = []\nfor row in data['assets']:\n    assets.append(row[\"Asset\"])\n    costs.append(float(row[\"Open\"]))\n# Half the money\nbudget = np.sum(costs)/0.5\n```", "```py\n\nfrom pyqubo import Array, Placeholder, Constraint\nnum_assets = len(assets)\nx = Array.create('x', shape=num_assets, vartype='BINARY')\n# Profit generated by each asset individually\nH_linear_profit = 0.0\nfor i in range(num_assets):\n    H_linear_profit += Constraint(\n        returns[i] * x[i], label='profit({})'.format(i)\n    )\n# Risk obtained from the covariance matrix\nH_quadratic = 0.0\nfor i in range(num_assets):\n    for j in range(i + 1, num_assets):\n        H_quadratic += Constraint(\n            covar[i][j] * x[i] * x[j], label='risk({}, {})'.format(i, j)\n        )\n# Constraint (budget)\nH_linear_budget = 0.0\nfor i in range(num_assets):\n    H_linear_budget += Constraint(costs[i]*x[i], label='slot({})'.format(i))\n# Final shape of the problem\ntheta1 = Placeholder('theta1')\ntheta2 = Placeholder('theta2')\nH = - H_linear_profit + theta1 * H_quadratic + theta2 * (H_linear_budget - budget)**2\nmodel = H.compile()\n```", "```py\n\n# Set the Lagrange multipliers\ntheta1=0.5\ntheta2=0.3\nfeed_dict = {'theta1': theta1, 'theta2' : theta2}\n# Transform to QUBO.\nqubo, offset = model.to_qubo(feed_dict=feed_dict)\nqubo\n{('x[4]', 'x[0]'): -8.656820265502894e-06,\n ('x[0]', 'x[0]'): -0.003196217986409817,\n ('x[3]', 'x[1]'): 0.00019183405443636594,\n…\n ('x[1]', 'x[1]'): 9.405658442868104e-05,\n ('x[2]', 'x[1]'): 0.00014597087707179864,\n ('x[1]', 'x[0]'): 0.00023358187881969354,\n ('x[2]', 'x[0]'): 0.0006994880363473856}\n```", "```py\n\nfrom dwave.system.samplers import DWaveSampler\nfrom dwave.system.composites import FixedEmbeddingComposite\nimport minorminer\nimport dimod\n# Instanciate Sampler\ndwave_sampler = DWaveSampler()\n```", "```py\n\n# Construct a problem\nbqm = dimod.BinaryQuadraticModel(qubo, dimod.BINARY)\n# Get the edge list\ntarget_edgelist = dwave_sampler.edgelist\n# And source edge list on the BQM quadratic model\nsource_edgelist = list(bqm.quadratic)\n# Find the embeding\nembedding = minorminer.find_embedding(source_edgelist, target_edgelist)\nsampler = FixedEmbeddingComposite(dwave_sampler, embedding)\n```", "```py\n\nta = 10 # microseconds\nnum_reads = 10\nresponse = sampler.sample_qubo(qubo, num_reads=num_reads, annealing_time=ta)\nresponse.first\nSample(sample={'x[0]': 1, 'x[1]': 0, 'x[2]': 1, 'x[3]': 0, 'x[4]': 0}, energy=-0.005097396148791738, num_occurrences=10, chain_break_fraction=0.0)\n```", "```py\n\nfrom qiskit_finance.applications.optimization import PortfolioOptimization\nq = 0.5  # set risk factor\nbudget = len(assets) // 2  # set budget\nportfolio = PortfolioOptimization(\n    expected_returns=returns, covariances=covar, risk_factor=q, budget=budget\n)\nqp = portfolio.to_quadratic_program()\n```", "```py\n\nfrom qiskit_optimization.converters import QuadraticProgramToQubo\nfrom qiskit_optimization.algorithms import MinimumEigenOptimizer\nfrom qiskit.algorithms import NumPyMinimumEigensolver\ndef index_to_selection(i, num_assets):\n…\ndef print_result(result):\n…\nexact_mes = NumPyMinimumEigensolver()\nexact_eigensolver = MinimumEigenOptimizer(exact_mes)\nresult = exact_eigensolver.solve(qp)\nprint_result(result)\nOptimal: selection [1\\. 0\\. 1\\. 0\\. 0.], value -0.0011\n----------------- Full result ---------------------\nselection  value    probability\n---------------------------------------------------\n[1 0 1 0 0]  -0.0011  1.0000\n[1 1 1 1 1]  9.0971    0.0000\n[0 1 1 1 1]  4.0459    0.0000\n[1 0 0 0 0]  1.0102    0.0000\n[0 1 0 0 0]  1.0108    0.0000\n[1 1 0 0 0]  0.0010    0.0000\n[0 0 1 0 0]  1.0087    0.0000\n[0 1 1 0 0]  -0.0005  0.0000\n[1 1 1 0 0]  1.0102    0.0000\n[0 0 0 1 0]  1.0122    0.0000\n[1 0 0 1 0]  0.0024    0.0000\n[0 1 0 1 0]  0.0031    0.0000\n[1 1 0 1 0]  1.0138    0.0000\n```", "```py\n\nfrom qiskit.algorithms import QAOA\nfrom qiskit.algorithms.optimizers import COBYLA\nlayers = 2\ncobyla = COBYLA()\ncobyla.set_options(maxiter=500)\nqaoa_mes = QAOA(optimizer=cobyla, reps=layers, quantum_instance=quantum_instance)\nqaoa = MinimumEigenOptimizer(qaoa_mes)\nresult = qaoa.solve(qp)\nOptimal: selection [1\\. 0\\. 1\\. 0\\. 0.], value -0.0011\n----------------- Full result ---------------------\nselection  value    probability\n---------------------------------------------------\n[0 0 0 1 1]  0.0048    0.0783\n[0 1 0 1 0]  0.0031    0.0777\n[0 1 0 0 1]  0.0031    0.0777\n[1 0 0 1 0]  0.0024    0.0775\n[1 0 0 0 1]  0.0021    0.0773\n[0 0 1 1 0]  0.0009    0.0770\n[1 1 0 0 0]  0.0010    0.0770\n[0 0 1 0 1]  0.0009    0.0770\n[0 1 1 0 0]  -0.0005    0.0765\n[1 0 1 0 0]  -0.0011    0.0763\n…\n```", "```py\n\nfrom qiskit.algorithms import QAOA\nlayers = 5\nqaoa_mes = QAOA(optimizer=cobyla, reps=layers, quantum_instance=quantum_instance)\nqaoa = MinimumEigenOptimizer(qaoa_mes)\nresult = qaoa.solve(qp)\nOptimal: selection [1\\. 0\\. 1\\. 0\\. 0.], value -0.0011\n----------------- Full result ---------------------\nselection  value    probability\n---------------------------------------------------\n[0 0 0 1 1]  0.0048    0.0666\n[0 1 0 1 0]  0.0031    0.0663\n[0 1 0 0 1]  0.0031    0.0661\n[1 0 0 1 0]  0.0024    0.0659\n[1 0 0 0 1]  0.0021    0.0659\n[0 0 1 1 0]  0.0009    0.0656\n[0 0 1 0 1]  0.0009    0.0654\n[1 1 0 0 0]  0.0010    0.0654\n[0 1 1 0 0]  -0.0005    0.0651\n[1 0 1 0 0]  -0.0011    0.0647\n…\n```", "```py\n\nfrom qiskit.circuit.library import TwoLocal\nansatz = TwoLocal(num_assets, \"ry\", \"cz\", reps=3, entanglement=\"full\")\nansatz.decompose().draw('mpl', fold=150)\n```", "```py\n\nfrom qiskit import Aer\nfrom qiskit.algorithms import VQE\nfrom qiskit.algorithms.optimizers import COBYLA\nfrom qiskit.utils import QuantumInstance\nfrom qiskit.utils import algorithm_globals\nalgorithm_globals.random_seed = 1234\nbackend = Aer.get_backend(\"statevector_simulator\")\ncobyla = COBYLA()\ncobyla.set_options(maxiter=500)\nquantum_instance = QuantumInstance(backend=backend, seed_simulator=1234, seed_transpiler=1234)\nvqe_mes = VQE(ansatz, optimizer=cobyla, quantum_instance=quantum_instance)\nvqe = MinimumEigenOptimizer(vqe_mes)\nresult = vqe.solve(qp)\n```", "```py\n\nprint_result(result)\nOptimal: selection [1\\. 0\\. 1\\. 0\\. 0.], value -0.0011\n----------------- Full result ---------------------\nselection  value    probability\n---------------------------------------------------\n[1 1 0 0 0]  0.0010    0.3613\n[1 0 0 1 0]  0.0024    0.3463\n[0 0 1 1 0]  0.0009    0.1285\n…\n[1 0 1 0 0]  -0.0011    0.0000\n```", "```py\n\nansatz = TwoLocal(num_assets, \"ry\", \"cz\", reps=6, entanglement=\"full\")\nvqe_mes = VQE(ansatz, optimizer=cobyla, quantum_instance=quantum_instance)\nvqe = MinimumEigenOptimizer(vqe_mes)\nresult = vqe.solve(qp)\nOptimal: selection [1\\. 0\\. 1\\. 0\\. 0.], value -0.0011\n----------------- Full result ---------------------\nselection  value    probability\n---------------------------------------------------\n[0 1 0 0 1]  0.0031    0.6130\n[1 0 1 0 0]  -0.0011    0.2030\n[0 1 0 1 0]  0.0031    0.0528\n[0 1 1 0 0]  -0.0005    0.0435\n[1 0 0 1 0]  0.0024    0.0314\n…\n```", "```py\n\nfrom qiskit import QuantumCircuit\nfrom qiskit import Aer, execute\nfrom qiskit.visualization import plot_histogram\nqc = QuantumCircuit(num_assets,num_assets)\n# VQE Two Local ansatz\nqc.compose(ansatz, inplace=True)\n# Measures\nfor i in range(0, num_assets):\n    qc.measure(i, i)\npqc = qc.bind_parameters(best_parameters)\n# Number of shots to the circuit\nnshots = 10\n# execute the quantum circuit\nbackend = Aer.get_backend('qasm_simulator') # the device to run on\nresult = execute(pqc, backend, shots=nshots).result()\nWe could then collect the results and check the outcome.\ncounts  = result.get_counts(pqc)\nplot_histogram(counts)\n```"]