- en: Chapter 12. Monte Carlo Simulation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 蒙特卡洛模拟
- en: 'Monte Carlo Simulation is an extremely useful tool in finance. For example,
    because we can simulate stock price by drawing random numbers from a lognormal
    distribution, the famous **Black-Scholes-Merton option** model can be replicated.
    From [Chapter 9](ch09.html "Chapter 9. Portfolio Theory"), *Portfolio Theory*,
    we have learnt that by adding more stocks into a portfolio, the firm specific
    risk could be reduced or eliminated. Via simulation, we can see the diversification
    effect much clearly since we can randomly select 50 stocks from 5,000 stocks repeatedly.
    For capital budgeting, we can simulate over several dozen variables with uncertain
    future values. For those cases, simulation can be applied to generate many possible
    future outcomes, events, and various types of combinations. In this chapter, the
    following topics will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛模拟是金融领域中非常有用的工具。例如，因为我们可以通过从对数正态分布中抽取随机数来模拟股票价格，所以著名的**布莱克-斯科尔斯-梅顿期权**模型可以被复制。在[第9章](ch09.html
    "第9章. 投资组合理论")，*投资组合理论*中，我们学习到，通过向投资组合中添加更多股票，企业特定风险可以被减少或消除。通过模拟，我们可以更清晰地看到多样化效应，因为我们可以反复从5000只股票中随机选择50只股票。对于资本预算，我们可以模拟几十个具有不确定未来值的变量。对于这些情况，可以通过模拟生成许多可能的未来结果、事件以及各种类型的组合。在本章中，将涵盖以下主题：
- en: Generating random numbers drawn from a normal, uniform, and Poisson distributions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从正态分布、均匀分布和泊松分布中生成随机数
- en: Estimating π value by using Monte Carlo simulation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用蒙特卡洛模拟估算π值
- en: Simulate stock price movement with a lognormal distribution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对数正态分布模拟股票价格变动
- en: Constructing efficient portfolios and an efficient frontier
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建高效投资组合与有效前沿
- en: Replicating the Black-Scholes-Merton option model by simulation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过模拟复制布莱克-斯科尔斯-梅顿期权模型
- en: Pricing several exotic options, such as lookback options with floating strikes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定价一些复杂期权，例如带浮动行权价格的回顾期权
- en: Bootstrapping with/without replacements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自助法（有/无放回）
- en: Long term expected return forecast
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长期预期回报预测
- en: Efficiency, Quasi Monte Carlo simulation, and Sobol sequence
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效率、准蒙特卡洛模拟与Sobol序列
- en: Importance of Monte Carlo Simulation
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蒙特卡洛模拟的重要性
- en: '**Monte Carlo Simulation**, or simulation, plays a quite important role in
    finance with many applications. Assume that we intend to estimate **Net Present
    Value** (**NPV**) of a project. There are many uncertainties in the future, such
    as borrowing cost, price of our final products, raw materials, and so on. For
    just a few variables, we still could manage the task easily. However, if we face
    two dozen variables with uncertain future values, it is a headache to find a solution.
    Fortunately, Monte Carlo Simulation can be applied here. In [Chapter 10](ch10.html
    "Chapter 10. Options and Futures"), *Options and Futures*, we have learnt that
    the logic behind the Black-Scholes-Merton option models is the normality assumption
    for stock returns. Because of this, their closed-firm solution could be replicated
    by simulation. Another example is to randomly choose 50 stocks from 4,500 available
    stocks. Unlike vanilla options, such as the Black-Scholes-Merton model, there
    are no closed-form solutions for exotic options. Fortunately, we can use simulation
    to price some of them.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**蒙特卡洛模拟**，或称模拟，在金融领域发挥着非常重要的作用，具有广泛的应用。假设我们打算估算一个项目的**净现值**（**NPV**）。未来存在许多不确定性，例如借款成本、最终产品价格、原材料等。对于少数几个变量，我们仍然能够轻松处理。然而，如果面对二十多个具有不确定未来值的变量，寻找解决方案就会成为一个难题。幸运的是，这时可以应用蒙特卡洛模拟。在[第10章](ch10.html
    "第10章. 期权与期货")，*期权与期货*中，我们了解到，布莱克-斯科尔斯-梅顿期权模型背后的逻辑是股票回报的正态性假设。正因为如此，它们的封闭形式解可以通过模拟来复制。另一个例子是从4500只可用股票中随机选择50只。与传统期权（如布莱克-斯科尔斯-梅顿模型）不同，复杂期权没有封闭形式解。幸运的是，我们可以使用模拟来为其中一些期权定价。'
- en: Generating random numbers from a standard normal distribution
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从标准正态分布生成随机数
- en: 'Normal distributions play a central role in finance. A major reason is that
    many finance theories, such as option theory and their related applications, are
    based on the assumption that stock returns follow a normal distribution. The second
    reason is that if our econometric models are well designed, the error terms from
    the models should follow a zero-mean normal distribution. It is a common task
    that we need to generate n random numbers from a standard normal distribution.
    For this purpose, we have the following three lines of code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正态分布在金融中起着核心作用。一个主要原因是，许多金融理论（如期权理论及其相关应用）假设股票收益服从正态分布。第二个原因是，如果我们的计量经济学模型设计得当，那么模型中的误差项应该服从零均值的正态分布。生成标准正态分布中的
    n 个随机数是一个常见任务。为此，我们有以下三行代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The basic random numbers in SciPy/NumPy are created by Mersenne Twister PRNG
    in the `numpy.random` function. The random numbers for distributions in `numpy.random`
    are in cython/pyrex and are pretty fast. There is no chance that readers would
    get the same `10` random numbers shown here. We will explain how to generate the
    same set of random numbers pretty soon. Alternatively, we can use the following
    code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy/NumPy 中的基本随机数是通过 `numpy.random` 函数中的梅森旋转算法（Mersenne Twister PRNG）生成的。`numpy.random`
    中的分布随机数是用 Cython/Pyrex 编写的，运行速度非常快。读者不可能得到与此处相同的`10`个随机数。我们很快会解释如何生成相同的一组随机数。或者，我们可以使用以下代码：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This program is equivalent to the following one:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序等价于以下程序：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first input is for mean, the second input is for standard deviation, and
    the last one is for the number of random numbers, that is, the size of our desired
    dataset. Comparing the previous two programs, obviously the default settings for
    mean and standard deviations are `0` and `1`. We can use the `help()` function
    to find out the names of those three input variables. To save space, only the
    first few lines are shown here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个输入是均值，第二个输入是标准差，最后一个输入是随机数的个数，也就是我们期望数据集的大小。对比前两个程序，显然均值和标准差的默认设置是`0`和`1`。我们可以使用
    `help()` 函数来查看这三个输入变量的名称。为了节省空间，这里仅显示前几行：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Drawing random samples from a normal distribution
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从正态分布中抽取随机样本
- en: 'The probability density function of the normal distribution, first derived
    by De Moivre and 200 years later by both Gauss and Laplace independently, is often
    called the bell curve because of its characteristic shape; refer to the following
    graph:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正态分布的概率密度函数最早由德·莫伊夫（De Moivre）推导出来，200年后由高斯（Gauss）和拉普拉斯（Laplace）独立推导完成，通常称为钟形曲线，因为它的特征形状；参见下图：
- en: '![Drawing random samples from a normal distribution](img/B06175_12_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![从正态分布中抽取随机样本](img/B06175_12_01.jpg)'
- en: 'The density function for a standard normal distribution is given here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 标准正态分布的密度函数如下所示：
- en: '![Drawing random samples from a normal distribution](img/B06175_12_17.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![从正态分布中抽取随机样本](img/B06175_12_17.jpg)'
- en: 'Here, *f(x)* is the density function for a standard normal distribution, *x*
    is an input value, *e* is the exponential function, and *π* is *3.1415926*. Here
    is the code to generate the preceding bell curve:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*f(x)* 是标准正态分布的密度函数，*x* 是输入值，*e* 是指数函数，*π* 是 *3.1415926*。以下是生成上述钟形曲线的代码：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Generating random numbers with a seed
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用种子生成随机数
- en: 'Quite often, users want to produce the same set of random numbers repeatedly.
    For example, when a professor is explaining how to estimate the mean, standard
    deviation, skewness, and kurtosis of a set of random numbers, it is a good idea
    that students could generate exactly the same values as their instructor. Another
    example would be that when we are debugging our Python program to simulate a stock''s
    movements, we might prefer to have the same intermediate results. For such cases,
    we use the `scipy.random.seed()` function as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，用户希望能够反复生成相同的一组随机数。例如，当教授在讲解如何估计一组随机数的均值、标准差、偏度和峰度时，学生能够生成与教授完全相同的数值是非常有帮助的。另一个例子是，当我们在调试
    Python 程序以模拟股票走势时，我们可能更希望得到相同的中间结果。对于这种情况，我们可以使用`scipy.random.seed()`函数，如下所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, `12345` is a seed. The value of the seed is not important. The key is
    that the same seed leads to the same set of random values. The formula for a more
    general normal distribution is shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`12345`是种子。种子的值并不重要，关键是相同的种子会产生相同的随机数值。更一般的正态分布公式如下：
- en: '![Generating random numbers with a seed](img/B06175_12_18.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![使用种子生成随机数](img/B06175_12_18.jpg)'
- en: Here, *f(x)* is the density function for a normal distribution, *x* is an input
    value, *e* is the exponential function, μ is the mean, σ is the standard deviation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*f(x)*是正态分布的密度函数，*x*是输入值，*e*是指数函数，μ是均值，σ是标准差。
- en: Random numbers from a normal distribution
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正态分布的随机数
- en: 'To generate *n* random numbers from a normal distribution, we have the following
    code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要从正态分布中生成*n*个随机数，我们有以下代码：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The difference between this program and the previous one is that the mean is
    `0.05` instead of `0`, while the standard deviation is `0.1` instead of `1`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序与前一个程序的区别在于，均值是`0.05`而不是`0`，而标准差是`0.1`而不是`1`。
- en: Histogram for a normal distribution
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正态分布的直方图
- en: 'A histogram is used intensively in the process of analyzing the properties
    of datasets. To generate a histogram for a set of random values drawn from a normal
    distribution with specified mean and standard deviation, we have the following
    code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析数据集属性的过程中，直方图被广泛使用。为了为从具有指定均值和标准差的正态分布中抽取的一组随机值生成直方图，我们有以下代码：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The resultant graph is presented as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图形如下所示：
- en: '![Histogram for a normal distribution](img/B06175_12_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![正态分布的直方图](img/B06175_12_02.jpg)'
- en: Graphical presentation of a lognormal distribution
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对数正态分布的图形展示
- en: 'When stock returns follow a normal distribution, then its prices should follow
    a lognormal distribution. The definition of a lognormal distribution is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当股票回报率遵循正态分布时，其价格应当遵循对数正态分布。对数正态分布的定义如下：
- en: '![Graphical presentation of a lognormal distribution](img/B06175_12_19.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![对数正态分布的图形展示](img/B06175_12_19.jpg)'
- en: 'Here, *f(x;μ,σ)* is the density of a lognormal distribution, `ln()` is the
    natural log function. The following code shows three different lognormal distributions
    with three pairs of parameters, such as (0, 0.25), (0, 0.5), and (0, 1.0). The
    first parameter is for mean (μ), while the second one is for standard deviation,
    see the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*f(x;μ,σ)*是对数正态分布的密度，`ln()`是自然对数函数。以下代码展示了三个不同的对数正态分布，分别使用了三组参数，如(0, 0.25)、(0,
    0.5)和(0, 1.0)。第一个参数是均值(μ)，第二个参数是标准差，见以下代码：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The graph is shown here. Obviously, unlike a density of a normal distribution,
    the density function of a lognormal distribution is not symmetric:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了图形。显然，与正态分布的密度不同，对数正态分布的密度函数是非对称的：
- en: '![Graphical presentation of a lognormal distribution](img/B06175_12_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![对数正态分布的图形展示](img/B06175_12_03.jpg)'
- en: Generating random numbers from a uniform distribution
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从均匀分布中生成随机数
- en: 'When randomly choosing m stocks from *n* available stocks, we can draw a set
    of random numbers from a uniform distribution. To generate 10 random numbers between
    1 and 100 from a uniform distribution, we have the following code. To guarantee
    for the same set of numbers, the `seed()` function is used:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当从*n*个可用的股票中随机选择m只股票时，我们可以从均匀分布中抽取一组随机数。为了从均匀分布中生成10个介于1和100之间的随机数，我们有以下代码。为了保证相同的数值集合，使用了`seed()`函数：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Again, low, high, and size are the three input names. The first one specifies
    the minimum, the second one specifies the high end, while the size gives the number
    of the random numbers we intend to generate. The first five numbers are shown
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，low、high和size是三个输入名称。第一个指定最小值，第二个指定最大值，而size指定我们打算生成的随机数的数量。前五个数字如下所示：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next program randomly roll a dice with a value from 1, 2, and up to 6:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个程序随机掷一个骰子，结果为1、2、3、4、5或6：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the previous program, the `random.seed()` function is applied. Thus, any
    reader should get the same results shown by the last line.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个程序中，应用了`random.seed()`函数。因此，任何读者都应得到最后一行显示的相同结果。
- en: Using simulation to estimate the pi value
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟估算π值
- en: 'It is a good exercise to estimate π value by simulation. Let''s draw a square
    with 2R as its side. If putting the largest circle inside the square, its radius
    will be R, described by the following equation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过模拟估算π值是一个很好的练习。我们来画一个边长为2R的正方形。如果在正方形内部放置一个最大的圆形，那么其半径将是R，表示为以下方程：
- en: '![Using simulation to estimate the pi value](img/B06175_12_20.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![使用模拟估算π值](img/B06175_12_20.jpg)'
- en: 'On the other hand, the square is the product of its sides:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，正方形的面积是其边长的平方：
- en: '![Using simulation to estimate the pi value](img/B06175_12_21.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![使用模拟估算π值](img/B06175_12_21.jpg)'
- en: 'Dividing *Equation (4)* by *Equation (5)*, we have the following result:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将*方程 (4)* 除以*方程 (5)*，我们得到以下结果：
- en: '![Using simulation to estimate the pi value](img/B06175_12_22.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![使用仿真估算π值](img/B06175_12_22.jpg)'
- en: 'Reorganize it; we end up with the following equation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重新组织后，我们得到以下方程：
- en: '![Using simulation to estimate the pi value](img/B06175_12_23.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![使用仿真估算π值](img/B06175_12_23.jpg)'
- en: In other words, the value of π will be *4* Scircle/Square*. When running the
    simulation, we generate *n* pairs of *x* and *y* from a uniform distribution with
    a range of zero and 0.5\. Then we estimate a distance that is the square root
    of the summation of the squared *x* and *y*, that is, ![Using simulation to estimate
    the pi value](img/B06175_12_41.jpg).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，π的值将是*4* Scircle/Square*。在运行仿真时，我们从一个均匀分布中生成*n*对*x*和*y*，范围为0到0.5。然后我们估算一个距离，该距离是*x*和*y*的平方和的平方根，即！[使用仿真估算π值](img/B06175_12_41.jpg)。
- en: 'Obviously, when *d* is less than 0.5 (value of R), it will fall into the circle.
    We can imagine throwing a dart that falls into the circle. The value of the pi
    will take the following form:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当*d*小于0.5（R值）时，它会落入圆内。我们可以想象扔一个飞镖，飞镖落入圆内时，π的值将呈现以下形式：
- en: '![Using simulation to estimate the pi value](img/B06175_12_24.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![使用仿真估算π值](img/B06175_12_24.jpg)'
- en: 'The following graph illustrates these random points within a circle and within
    a square:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了这些随机点在圆内和方形内的分布：
- en: '![Using simulation to estimate the pi value](img/B06175_12_04.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![使用仿真估算π值](img/B06175_12_04.jpg)'
- en: 'The Python program to estimate the value of pi is presented as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 估算π值的Python程序如下所示：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The estimated pi value would change whenever we run the previous code, as shown
    in the following code, and the accuracy of its estimation depends on the number
    of trials, that is, *n*:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行前面的代码时，估算的π值会发生变化，如下所示，且其估算的准确性取决于试验次数，即*n*：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Generating random numbers from a Poisson distribution
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从泊松分布生成随机数
- en: 'To investigate the impact of private information, Easley, Kiefer, O''Hara,
    and Paperman (1996) designed a **Probability of informed** (**PIN**) trading measure
    that is derived based on the daily number of buyer-initiated trades and the number
    of seller-initiated trades. The fundamental aspect of their model is to assume
    that order arrivals follow a Poisson distribution. The following code shows how
    to generate *n* random numbers from a Poisson distribution:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了研究私人信息的影响，Easley、Kiefer、O'Hara和Paperman（1996年）设计了一个**信息化交易概率**（**PIN**）度量方法，基于买方发起交易的每日数量和卖方发起交易的数量推导而来。他们模型的基本假设是，订单到达遵循泊松分布。以下代码展示了如何从泊松分布中生成*n*个随机数：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The graph is shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该图如下所示：
- en: '![Generating random numbers from a Poisson distribution](img/B06175_12_05.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![从泊松分布生成随机数](img/B06175_12_05.jpg)'
- en: Selecting m stocks randomly from n given stocks
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从n个给定股票中随机选择m只股票
- en: 'Based on the preceding program, we could easily choose 20 stocks from 500 available
    securities. This is an important step if we intend to investigate the impact of
    the number of randomly selected stocks on the portfolio volatility, as shown in
    the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面的程序，我们可以轻松地从500只可用证券中选择20只股票。如果我们打算研究随机选择股票数量对投资组合波动性的影响，这将是一个重要的步骤，如下所示的代码所示：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding program, we select 20 numbers from 500 numbers. Since we have
    to choose integers, we might end up with less than 20 values, that is, some integers
    appear more than once after we convert real numbers into integers. One solution
    is to pick more than we need. Then choose the first 20 integers. An alternative
    is to use the `randrange()` and `randint()` functions. In the next program, we
    choose *n* stocks from all available stocks. First, we download a dataset from
    [http://canisius.edu/~yany/python/yanMonthly.pkl](http://canisius.edu/~yany/python/yanMonthly.pkl).
    Assume that the dataset is located under `C:/temp/`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们从500个数字中选择20个数字。由于我们必须选择整数，可能最终会得到少于20个值，也就是说，一些整数在将实数转换为整数后可能会出现重复。一种解决方法是选择更多的数字，然后取前20个整数。另一种方法是使用`randrange()`和`randint()`函数。在下一个程序中，我们从所有可用的股票中选择*n*只股票。首先，我们从[http://canisius.edu/~yany/python/yanMonthly.pkl](http://canisius.edu/~yany/python/yanMonthly.pkl)下载数据集。假设数据集位于`C:/temp/`目录下：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding program, we remove non-stock data items. These non-stock items
    are a part of data items. First, we load a dataset called `yanMonthly.pickle`
    that includes over 200 stocks, gold price, GDP, unemployment rate, **Small Minus
    Big** (**SMB**), **High Minus Low** (**HML**), risk-free rate, price rate, market
    excess rate, and Russell indices.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们移除了非股票数据项。这些非股票项是数据项的一部分。首先，我们加载一个名为`yanMonthly.pickle`的数据集，其中包括200多只股票、黄金价格、GDP、失业率、**小盘减大盘**（**SMB**）、**高估减低估**（**HML**）、无风险利率、价格率、市场超额收益率以及罗素指数。
- en: 'One type of output formats from pandas is with a `.pkl` `.png`. Since `x.index`
    would present all indices for each observation, we need to use the `unique()`
    function to select all unique IDs. Since we only consider stocks to form our portfolio,
    we have to move all market indices and other non-stock securities, such as HML
    and `US_DEBT`. Because all stock market indices start with a carat (^), we use
    less than ZZZZ to remove them. For other IDs that are between A and Z, we have
    to remove them one after another. For this purpose, we use the `.remove()` function
    available for a list variable. The final output is shown as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: pandas的一种输出格式是`.pkl`和`.png`。由于`x.index`会呈现每个观测值的所有索引，我们需要使用`unique()`函数来选择所有唯一的ID。因为我们只考虑股票来构建我们的投资组合，所以我们必须移除所有市场指数和其他非股票证券，如HML和`US_DEBT`。因为所有股票市场指数都以插入符号（^）开头，所以我们使用小于ZZZZ的方式来移除它们。对于其他在A和Z之间的ID，我们必须逐个移除它们。为此，我们使用`.remove()`函数，该函数适用于列表变量。最终输出如下：
- en: '![Selecting m stocks randomly from n given stocks](img/B06175_12_06.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![从n个给定股票中随机选择m个股票](img/B06175_12_06.jpg)'
- en: With/without replacements
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有/没有替换
- en: Assume that we have the historical data, such as price and return, for a stock.
    Obviously, we could estimate their mean, standard deviation, and other related
    statistics. What are their expected annual mean and risk next year? The simplest,
    maybe naïve way is to use the historical mean and standard deviation. A better
    way is to construct the distribution of annual return and risk. This means that
    we have to find a way to use historical data more effectively to predict the future.
    In such cases, we could apply the bootstrapping methodology. For example, for
    one stock, we have its last 20-year monthly returns, that is, 240 observations.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们拥有一只股票的历史数据，如价格和回报。显然，我们可以估计它们的均值、标准差和其他相关统计数据。那么，明年的预期年均值和风险是多少呢？最简单的，可能也是天真的方法是使用历史均值和标准差。更好的方法是构建年回报和风险的分布。这意味着我们必须找到一种方法，利用历史数据更有效地预测未来。在这种情况下，我们可以应用自助法（bootstrapping）方法。例如，对于一只股票，我们拥有过去20年的月度回报数据，即240个观测值。
- en: 'To estimate next year''s 12 monthly returns, we need to construct a return
    distribution. First, we choose 12 returns randomly from the historical return
    set without replacements and estimate their mean and standard deviations. We repeat
    this procedure 5,000 times. The final output will be our return-standard distribution.
    Based on such a distribution, we can estimate other properties as well. Similarly,
    we can do so with replacements. One of the useful functions present in NumPy is
    called `numpy.random.permutation()`. Assume that we have 10 numbers from one to
    10 (inclusive of one and 10). We can call the `numpy.random.permutation()` function
    to reshuffle them as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了估计明年12个月的回报，我们需要构建回报分布。首先，我们从历史回报集中随机选择12个回报（不放回），并估计它们的均值和标准差。我们重复这个过程5000次。最终输出将是我们的回报-标准差分布。基于这个分布，我们也可以估计其他属性。同样地，我们也可以在有替换的情况下进行。NumPy中一个有用的函数是`numpy.random.permutation()`。假设我们有从1到10的10个数字（包含1和10）。我们可以调用`numpy.random.permutation()`函数来重新洗牌，如下所示：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of this code is shown as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出如下所示：
- en: '![With/without replacements](img/B06175_12_07.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![有/没有替换](img/B06175_12_07.jpg)'
- en: 'Based on the `numpy.random.permutation()` function, we can define a function
    with three input variables: data, number of observations we plan to choose from
    the data randomly, and whether we choose to bootstrap with or without replacement,
    as shown in the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`numpy.random.permutation()`函数，我们可以定义一个函数，输入三个变量：数据、我们计划从数据中随机选择的观测值数量，以及是否选择有或没有替换的自助法，如下代码所示：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The constraint specified in the previous program is that the number of given
    observations should be larger than the number of random returns we plan to pick
    up. This is true for the bootstrapping without the replacement method. For the
    bootstrapping with the replacement method, we could relax this constraint; refer
    to the related exercise.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的程序中指定的约束条件是，给定的观察次数应大于我们计划选择的随机回报次数。这对于无替换的自助法是成立的。对于有替换的自助法，我们可以放宽这个约束；请参考相关习题。
- en: Distribution of annual returns
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 年度回报分布
- en: 'It is a good application to estimate annualized return distribution and represent
    it as a graph. To make our exercise more meaningful, we download Microsoft''s
    daily price data. Then, we estimate its daily returns and convert them into annual
    ones. Based on those annual returns, we generate its distribution by applying
    bootstrapping with replacements 5,000 times, as shown in the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 估算年化回报分布并将其表示为图形是一个很好的应用。为了使我们的练习更有意义，我们下载了微软的每日价格数据。然后，我们估算了其每日回报，并将其转换为年回报。基于这些年回报，我们通过应用带替换的自助法进行5,000次模拟，从而生成其分布，如下代码所示：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The corresponding graph is shown as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的图表如下所示：
- en: '![Distribution of annual returns](img/B06175_12_08.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![年度回报分布](img/B06175_12_08.jpg)'
- en: Simulation of stock price movements
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 股票价格波动模拟
- en: 'We mentioned in the previous sections that in finance, returns are assumed
    to follow a normal distribution, whereas prices follow a lognormal distribution.
    The stock price at time *t+1* is a function of the stock price at *t*, mean, standard
    deviation, and the time interval, as shown in the following formula:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的章节中提到，在金融领域，回报假定服从正态分布，而价格则服从对数正态分布。股票在时间 *t+1* 的价格是时间 *t* 股票价格、均值、标准差和时间间隔的函数，如下公式所示：
- en: '![Simulation of stock price movements](img/B06175_12_25.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![股票价格波动模拟](img/B06175_12_25.jpg)'
- en: 'In this formula, *St + 1* is the stock price at *t+1*, *ˆ μ* is the expected
    stock return, *t _* is the time interval (*T t n_=* ), *T* is the time (in years),
    *n* is the number of steps, *ε* is the distribution term with a zero mean, and
    *σ* is the volatility of the underlying stock. With a simple manipulation, equation
    (4) can lead to the following equation that we will use in our programs:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在此公式中，*St + 1* 是时间 *t+1* 的股票价格，*ˆ μ* 是预期股票回报，*t_* 是时间间隔（*T t n_=* ），*T* 是时间（以年为单位），*n*
    是步数，*ε* 是均值为零的分布项，*σ* 是标的股票的波动率。通过简单的操作，方程（4）可以推导出以下我们将在程序中使用的方程：
- en: '![Simulation of stock price movements](img/B06175_12_26.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![股票价格波动模拟](img/B06175_12_26.jpg)'
- en: 'In a risk-neutral work, no investors require compensation for bearing risk.
    In other words, in such a world, the expected return on any security (investment)
    is the risk-free rate. Thus, in a risk-neutral world, the previous equation becomes
    the following equation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个风险中性世界中，投资者不要求承担风险的补偿。换句话说，在这样的世界里，任何证券（投资）的预期回报率都是无风险利率。因此，在风险中性世界中，前面的方程式变为以下方程式：
- en: '![Simulation of stock price movements](img/B06175_12_27.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![股票价格波动模拟](img/B06175_12_27.jpg)'
- en: 'If you want to learn more about the risk-neutral probability, refer to *Options,
    Futures and Other Derivatives, 7th edition, John Hull, Pearson, 2009*. The Python
    code to simulate a stock''s movement (path) is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于风险中性概率的内容，请参考*《期权、期货及其他衍生品》第七版，约翰·赫尔，皮尔森，2009年*。模拟股票价格运动（路径）的Python代码如下：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To make our graph more readable, we deliberately choose just five simulations.
    Since the `scipy.random.seed()` function is applied, you can replicate the following
    graph by running the previous code. The graph is shown here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的图表更具可读性，我们故意只选择了五次模拟。由于应用了`scipy.random.seed()`函数，你可以通过运行之前的代码来复制以下图表。图表如下所示：
- en: '![Simulation of stock price movements](img/B06175_12_09.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![股票价格波动模拟](img/B06175_12_09.jpg)'
- en: Graphical presentation of stock prices at options' maturity dates
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 期权到期日股票价格的图形展示
- en: 'Up to now, we have discussed that options are really path-independent, which
    means the option prices depend on terminal values. Thus, before pricing such an
    option, we need to know the terminal stock prices. To extend the previous program,
    we have the following code to estimate the terminal stock prices for a given set
    of values: `S0` (initial stock price), `n_simulation` (number of terminal prices),
    `T` (maturity date in years), `n_steps` (number of steps), `mu` (expected annual
    stock returns), and `sigma` (volatility):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了期权实际上是路径无关的，这意味着期权价格取决于终值。因此，在定价此类期权之前，我们需要知道终期股票价格。为了扩展之前的程序，我们有以下代码来估算一组给定值的终期股票价格：`S0`（初始股票价格），`n_simulation`（终期价格的数量），`T`（到期日，按年计算），`n_steps`（步骤数），`mu`（预期年股票回报率），`sigma`（波动率）：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The histogram of our simulated terminal prices is shown as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模拟的终期价格的直方图如下所示：
- en: '![Graphical presentation of stock prices at options'' maturity dates](img/B06175_12_10.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![期权到期日股票价格的图示](img/B06175_12_10.jpg)'
- en: 'As we mentioned in [Chapter 9](ch09.html "Chapter 9. Portfolio Theory"), *Portfolio
    Theory*, in order to generate two correlated random number time series, there
    are two step involved: generate two random time series *x1* and *x2* with a zero-correlation;
    and then apply the following formulae:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第9章](ch09.html "第9章. 投资组合理论")中提到的，*投资组合理论*，为了生成两个相关的随机时间序列，需要进行两个步骤：生成两个零相关的随机时间序列*x1*和*x2*；然后应用以下公式：
- en: '![Graphical presentation of stock prices at options'' maturity dates](img/B06175_12_33.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![期权到期日股票价格的图示](img/B06175_12_33.jpg)'
- en: 'Here, ρ is the predetermined correlation between those two time series. Now,
    `y1` and `y2` are correlated with a predetermined correlation. The following Python
    program will implement the preceding approach:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，ρ是这两个时间序列之间的预定相关性。现在，`y1`和`y2`与预定的相关性相关。以下Python程序将实现上述方法：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Replicating a Black-Scholes-Merton call using simulation
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟复制布莱克-斯科尔斯-默顿看涨期权
- en: 'After knowing the terminal prices, we can estimate the payoff for a call if
    the exercise price is given. The mean of those discounted payoffs using the risk-free
    rate as our discount rate will be our call price. The following code helps us
    estimate the call price:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在知道终期价格后，如果给定行权价格，我们可以估算看涨期权的支付。使用无风险利率作为贴现率计算的这些贴现支付的均值将是我们的看涨期权价格。以下代码帮助我们估算看涨期权价格：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The estimated call price is $2.748\. The same logic applies to pricing a put
    option.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 估算的看涨期权价格为$2.748。相同的逻辑适用于定价看跌期权。
- en: 'Exotic option #1 – using the Monte Carlo Simulation to price average'
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '异型期权 #1 – 使用蒙特卡洛模拟来定价平均值'
- en: 'Up to now, we have discussed European and American options in [Chapter 9](ch09.html
    "Chapter 9. Portfolio Theory"), *Portfolio Theory*. The Black- Scholes-Merton
    Option Model, which is also called a vanilla option. One of the characters is
    path independent. On the other hand, exotic options are more complex since they
    might have several triggers relating to the determination of their payoffs. For
    example, a refinery is worried about the oil, its major raw material, and price
    movement in the next three months. They plan to hedge the potential price jumps
    in crude oil. The company could buy a call option. However, since the firm consumes
    a huge amount of crude oil every day, naturally it cares more about the average
    price instead of just the terminal price on which a vanilla call option depends.
    For such cases, average options will be more effective. Average options are a
    type of Asian options. For an average option, its payoff is determined by the
    average underlying prices over some preset period of time. There are two types
    of averages: arithmetic average and geometric average. The payoff function of
    an Asian call (average price) is given as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在[第9章](ch09.html "第9章. 投资组合理论")中已经讨论了欧式期权和美式期权，*投资组合理论*。布莱克-斯科尔斯-默顿期权模型，也叫做普通期权。其特征之一是路径无关。另一方面，异型期权更复杂，因为它们可能有多个触发因素与其支付的确定相关。例如，一家炼油厂担心未来三个月内原油价格的波动。它们计划对潜在的原油价格跳跃进行对冲。公司可以购买看涨期权。然而，由于公司每天消耗大量的原油，自然更关心的是平均价格，而不仅仅是普通看涨期权所依赖的终期价格。对于这种情况，平均期权会更有效。平均期权是一种亚洲期权。对于平均期权，其支付是由一段预设时间内的基础价格的平均值决定的。平均值有两种类型：算术平均和几何平均。亚洲看涨期权（平均价格）的支付函数如下所示：
- en: '![Exotic option #1 – using the Monte Carlo Simulation to price average](img/B06175_12_29.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![另类期权 #1 – 使用蒙特卡罗模拟法定价平均价格](img/B06175_12_29.jpg)'
- en: 'The payoff function of an Asian put (average price) is given here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出了亚洲看跌期权（平均价格）的支付函数：
- en: '![Exotic option #1 – using the Monte Carlo Simulation to price average](img/B06175_12_30.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![另类期权 #1 – 使用蒙特卡罗模拟法定价平均价格](img/B06175_12_30.jpg)'
- en: 'Asian options are one of the basic forms of exotic options. Another advantage
    of Asian options is that their costs are cheaper compared to European and American
    vanilla options since the variation of an average will be much smaller than a
    terminal price. The following Python program is for an Asian option with an arithmetic
    average price:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 亚洲期权是另类期权的一种基本形式。亚洲期权的另一个优势是，与欧洲和美式普通期权相比，它们的成本更低，因为平均值的波动要比终值的波动小得多。下面的Python程序是针对具有算术平均价格的亚洲期权的：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Based on the preceding result, the call premium for this average price call
    is $1.70.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述结果，这个平均价格看涨期权的权利金为$1.70。
- en: 'Exotic option #2 – pricing barrier options using the Monte Carlo Simulation'
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '另类期权 #2 – 使用蒙特卡罗模拟法定价障碍期权'
- en: 'Unlike the Black-Scholes-Merton option model''s call and put options, which
    are path-independent, a barrier option is path-dependent. A barrier option is
    similar in many ways to an ordinary option except a trigger exists. An `in` option
    starts its life worthless unless the underlying stock reaches a predetermined
    knock-in barrier. On the contrary, an `out` barrier option starts its life active
    and turns useless when a knock-out barrier price is breached. In addition, if
    a barrier option expires inactive, it may be worthless, or there may be a cash
    rebate paid out as a fraction of the premium. The four types of barrier options
    are given as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与黑-肖尔斯-莫顿期权模型中的看涨和看跌期权不同，后者是路径无关的，障碍期权则是路径相关的。障碍期权在许多方面与普通期权类似，但存在触发条件。`敲入`期权的生命周期从无价值开始，除非标的股票达到预定的敲入障碍。而相反，`敲出`障碍期权从一开始就有效，只有在价格突破敲出障碍时才会变得无效。此外，如果障碍期权到期时没有激活，它可能变得一文不值，或者可能支付一部分权利金作为现金返还。四种障碍期权如下所示：
- en: '**Up-and-out**: In this barrier option, the price starts from down a barrier
    level. If it reaches the barrier, it is knocked out.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向上敲出期权**：在这种障碍期权中，价格从较低的障碍水平开始。如果它达到障碍，则被“敲出”。'
- en: '**Down-and-out**: In this barrier option, the price starts from higher a barrier.
    If it reaches the barrier, it is knocked out.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跌破障碍期权**：在这种障碍期权中，价格从一个较高的障碍开始。如果价格达到障碍，则被“敲出”。'
- en: '**Up-and-in**: In this barrier option, the price starts down a barrier and
    has to reach the barrier to be activated.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向上敲入期权**：在这种障碍期权中，价格从较低的障碍开始，必须达到该障碍才能激活。'
- en: '**Down-and-in**: In this barrier option, the price starts higher a barrier
    and has to reach the barrier to be activated.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向下敲入期权**：在这种障碍期权中，价格从较高的障碍开始，必须达到该障碍才能激活。'
- en: 'The next Python program is for an up-and-out barrier option with a European
    call:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的Python程序用于一个向上敲出障碍期权，类型为欧洲看涨期权：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The basic design is that we simulate the stock movement *n* times, such as
    100 times. For each simulation, we have 100 steps. Whenever the stock price reaches
    the barrier, the payoff will be zero. Otherwise, the payoff will be a vanilla
    European call. The final value will be the summation of all call prices that are
    not knocked out, divided by the number of simulations, as shown in the following
    code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 基本设计是我们模拟股票价格波动*n*次，例如模拟100次。对于每次模拟，我们有100个步骤。每当股票价格达到障碍时，支付将为零。否则，支付将为一种普通的欧洲看涨期权。最终价值将是所有未被敲出的看涨期权价格的总和，再除以模拟次数，如下所示的代码：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Based on the preceding result, we know that the call price for this up and out-call
    is $0.94.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述结果，我们知道这个向上敲出看涨期权的价格为$0.94。
- en: Liking two methods for VaR using simulation
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 喜欢使用模拟法计算VaR的两种方法
- en: 'In the previous chapter, [Chapter 11](ch11.html "Chapter 11. Value at Risk"),
    *Value at Risk*, we learnt that we could apply two methods to estimate a VaR for
    an individual stock or for a portfolio: it depends on the normality assumption
    and based on the ranking of historical returns. Monte Carlo Simulation could link
    those two methods, see the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章，[第11章](ch11.html "第11章：风险价值")，*风险价值*中，我们学习了可以使用两种方法来估算个股或投资组合的VaR：这取决于正态性假设和基于历史回报排序的方法。蒙特卡罗模拟法能够将这两种方法结合起来，见下述代码：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Monte Carlo Simulation offers a result of $386,113 compared with $385,270 based
    on the formula for a $1 million of portfolio value today.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛模拟的结果为$386,113，而基于公式计算的结果为$385,270（假设投资组合当前价值为100万美元）。
- en: Capital budgeting with Monte Carlo Simulation
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蒙特卡洛模拟进行资本预算
- en: 'As we mentioned at the beginning of this chapter, we can use Monte Carlo Simulation
    to capital budgeting when the number of variables has many different values. Our
    objective is to estimate the NPV for a given budget by discounting all of its
    future free cash flow:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头提到的，当变量的数量有许多不同的值时，我们可以使用蒙特卡洛模拟来进行资本预算。我们的目标是通过对所有未来自由现金流进行折现，来估算给定预算的净现值（NPV）：
- en: '![Capital budgeting with Monte Carlo Simulation](img/B06175_12_31.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![使用蒙特卡洛模拟进行资本预算](img/B06175_12_31.jpg)'
- en: 'Here, *NPV* is the Net Present Value of one proposal, *FCF0* will be the free
    cash flow at time zero, *FCFt* will be free cash flow at the end of year *I*,
    *R* is the discount rate. The formula to calculate free cash flows at the end
    of year *t* is given here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*NPV* 是某一提案的净现值，*FCF0* 将是零时点的自由现金流，*FCFt* 将是第 *I* 年末的自由现金流，*R* 是折现率。计算第 *t*
    年末自由现金流的公式如下：
- en: '![Capital budgeting with Monte Carlo Simulation](img/B06175_12_32.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![使用蒙特卡洛模拟进行资本预算](img/B06175_12_32.jpg)'
- en: 'Here, *FCTt* is Free Cash Flow at year *t*, *Dt* is depreciation of year *t*,
    *CaptExt* is the net capital expenditure at year *t*, *NWC* is for Net working
    capital, which is the current asset minus current liability, Δ means change. Let''s
    look at a simple one. Assume that the company buys one price of long term equivalent
    with a total cost of 0.5 million with a life of five years:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*FCTt* 是第 *t* 年的自由现金流，*Dt* 是第 *t* 年的折旧，*CaptExt* 是第 *t* 年的净资本支出，*NWC* 是净营运资金，即流动资产减去流动负债，Δ表示变化。让我们看一个简单的例子。假设公司购买一项长期等效资产，总成本为50万美元，使用年限为五年：
- en: '| Items | 0 | 1 | 2 | 3 | 4 | 5 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 项目 | 0 | 1 | 2 | 3 | 4 | 5 |'
- en: '| Price | 0 | 28 | 28 | 28 | 28 | 28 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 价格 | 0 | 28 | 28 | 28 | 28 | 28 |'
- en: '| Unit | 0 | 100000 | 100000 | 100000 | 100000 | 100000 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 单位 | 0 | 100000 | 100000 | 100000 | 100000 | 100000 |'
- en: '| Sales | 0 | 2800000 | 2800000 | 2800000 | 2800000 | 2800000 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 销售 | 0 | 2800000 | 2800000 | 2800000 | 2800000 | 2800000 |'
- en: '| Cost of goods sold | 0 | 840000 | 840000 | 840000 | 840000 | 840000 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 销售成本 | 0 | 840000 | 840000 | 840000 | 840000 | 840000 |'
- en: '| Other costs | 0 | 100000 | 100000 | 100000 | 100000 | 100000 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 其他成本 | 0 | 100000 | 100000 | 100000 | 100000 | 100000 |'
- en: '| Selling, general and adm | 15000 | 15000 | 15000 | 15000 | 15000 | 15000
    |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 销售、一般管理和行政费用 | 15000 | 15000 | 15000 | 15000 | 15000 | 15000 |'
- en: '| R&D | 20000 |   |   |   |   |   |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 研发费用 | 20000 |   |   |   |   |   |'
- en: '| Depreciation |   | 1000000 | 1000000 | 1000000 | 1000000 | 1000000 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 折旧 |   | 1000000 | 1000000 | 1000000 | 1000000 | 1000000 |'
- en: '| EBIT | -35000 | 845000 | 845000 | 845000 | 845000 | 845000 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 息税前利润（EBIT） | -35000 | 845000 | 845000 | 845000 | 845000 | 845000 |'
- en: '| Tax 35% | -12250 | 295750 | 295750 | 295750 | 295750 | 295750 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 税率 35% | -12250 | 295750 | 295750 | 295750 | 295750 | 295750 |'
- en: '| NI | -47250 | 1140750 | 1140750 | 1140750 | 1140750 | 1140750 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 净收入（NI） | -47250 | 1140750 | 1140750 | 1140750 | 1140750 | 1140750 |'
- en: '| Add depreciation | -47250 | 2140750 | 2140750 | 2140750 | 2140750 | 2140750
    |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 加上折旧 | -47250 | 2140750 | 2140750 | 2140750 | 2140750 | 2140750 |'
- en: Table 12.1 Cash flows every year
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表 12.1 每年的现金流
- en: 'We have the following equivalent code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下等效代码：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The NPV of this project is $1,848,477\. Since it is positive, we should accept
    that the proposal if our criterion is based on the NPV rule. Now, let''s add some
    uncertainty. Assume that we have three uncertainties: price, unit of products
    expected to sell, and discount rates, see the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的净现值（NPV）为$1,848,477。由于它是正值，如果我们的标准是基于 NPV 规则，那么我们应当接受该提案。现在，让我们加入一些不确定性。假设我们有三个不确定因素：价格、预计销售的产品单位数以及折现率，请参见以下代码：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The histogram of the NPV distribution is shown here:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: NPV 分布的直方图如下所示：
- en: '![Capital budgeting with Monte Carlo Simulation](img/B06175_12_11.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![使用蒙特卡洛模拟进行资本预算](img/B06175_12_11.jpg)'
- en: Python SimPy module
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python SimPy 模块
- en: 'SimPy is a process-based discrete-event simulation framework based on standard
    Python. Its event dispatcher is based on Python''s generators and can also be
    used for asynchronous networking or to implement multi-agent systems (with both
    simulated and real communication). Processes in SimPy are simple Python generator
    functions and are used to model active components such as customers, vehicles,
    or agents. SimPy also provides various types of shared resources to model limited
    capacity congestion points (such as servers, checkout counters, and tunnels).
    From version 3.1, it will also provide monitoring capabilities to aid in gathering
    statistics about resources and processes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: SimPy 是一个基于标准 Python 的基于过程的离散事件仿真框架。它的事件调度器基于 Python 的生成器，也可以用于异步网络通信或实现多智能体系统（包括模拟和真实通信）。SimPy
    中的进程是简单的 Python 生成器函数，用于建模活跃的组件，如顾客、车辆或代理。SimPy 还提供了各种类型的共享资源，用于建模有限容量的拥堵点（如服务器、结账柜台和隧道）。从
    3.1 版本开始，它还将提供监控功能，帮助收集有关资源和进程的统计数据：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Comparison between two social policies – basic income and basic job
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两种社会政策的比较——基本收入与基本工作
- en: This example is borrowed from Stucchhio (2013). Over the development of the
    past several decades, the wealth of each nation is continuously commutative. This
    is especially true for the developed countries. One of the basic arguments supporting
    equity is that each citizen should have their basic standard of living. Based
    on this argument, many countries offer huge benefits to their citizens, such as
    universal healthcare, free education, and the like. One policy suggestion is basic
    income, under which each citizen receives a basic income annually with no strings
    attached. For example, if we assume that the basic hourly rate is $7.50, 40 hours
    per week and 50 weeks per year, then the basic income should be $15,000\. Zhong
    (2017) reports that India is considering fighting poverty with a universal basic
    income plan. The obvious advantage is that the administration cost will be quite
    small. In addition, it is less likely that corruption would eat the lions share
    of government release funds for the poor. In 2017, Finland launched a pilot project,
    and local authorities in Canada and the Netherlands have also announced experiments.
    In 2016, voters in Switzerland rejected a minimum income proposal.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子借鉴自 Stucchhio（2013）。在过去几十年的发展中，各国的财富持续积累，尤其是在发达国家中尤为明显。支持公平的基本论点之一是每个公民都应拥有基本的生活标准。基于这一论点，许多国家为其公民提供了大量福利，例如普及医疗、免费教育等。一项政策建议是基本收入，即每个公民每年都会获得一笔无附加条件的基本收入。例如，如果我们假设基本时薪为
    7.50 美元，每周工作 40 小时，每年工作 50 周，那么基本收入应该为 15,000 美元。Zhong（2017）报告称，印度正在考虑通过普遍基本收入计划来对抗贫困。显而易见的优势是行政成本会相当低。此外，腐败侵占政府为穷人发放的资金的可能性也较小。2017
    年，芬兰启动了一个试点项目，加拿大和荷兰的地方当局也宣布了相关实验。2016 年，瑞士选民拒绝了一项最低收入提案。
- en: 'One alternative is a so-called basic job in which the government guarantees
    a low-paid job to anyone who cannot find a decent one. Each of these methods has
    its advantages and disadvantages. Based on a set of assumptions, such as hourly
    pay, number of working hours per week, number of working weeks per year, population,
    workforce, and the like, Stucchhio (2013) compares the cost and benefits of these
    two proposals. Several uncertainties exist; see the list in the following table:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代方案是所谓的基本工作，在这种工作中，政府保证为无法找到体面工作的人提供一份低薪工作。这些方法各有优缺点。基于一组假设，如时薪、每周工作小时数、每年工作周数、人口、劳动力等，Stucchhio（2013）比较了这两种提案的成本和收益。存在若干不确定性；请参阅下表中的列表：
- en: '| Policy | Command | Description |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 政策 | 命令 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Basic income** | `unitAdmCost = norm(250,75)` | Administration cost for
    each person |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| **基本收入** | `unitAdmCost = norm(250,75)` | 每个人的行政费用 |'
- en: '| `binom(nNonWorkers,tiny).rvs()` | A random number from a binomial distribution
    |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `binom(nNonWorkers,tiny).rvs()` | 从二项分布中随机生成一个数字 |'
- en: '| `nonWorkerMultiplier = uniform(-0.10, 0.15).rvs()` | Multiplier for none
    workers |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `nonWorkerMultiplier = uniform(-0.10, 0.15).rvs()` | 非劳动者的乘数 |'
- en: '| **Basic job** | `unitAdmCost4disabled= norm(500,150).rvs()` | Administration
    cost for each disabled adult |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| **基本工作** | `unitAdmCost4disabled= norm(500,150).rvs()` | 每个残疾成年人所需的行政费用 |'
- en: '| `unitAdmCost4worker = norm(5000, 1500).rvs()` | Administration cost for each
    worker |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `unitAdmCost4worker = norm(5000, 1500).rvs()` | 每个工人的行政费用 |'
- en: '| `nonWorkerMultiplier = uniform(-0.20, 0.25).rvs()` | Multiplier for none
    workers |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `nonWorkerMultiplier = uniform(-0.20, 0.25).rvs()` | 非工作者的乘数 |'
- en: '| `hourlyProductivity = uniform(0.0,hourlyPay).rvs()` | Hourly productivity
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `hourlyProductivity = uniform(0.0,hourlyPay).rvs()` | 每小时生产力 |'
- en: 'Table 12.2: Costs and benefits of the two proposals'
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表12.2：两种提案的成本与收益
- en: 'The program uses three distributions: normal, uniform, and binomial. The `uniform(a,b).rvs()`
    command generates a random number uniformly distributed between *a* and *b*. The
    `norm(mean,std).rvs()` command generates a random number generated from a normal
    distribution with specified mean and standard deviation. The `binom(n,k).rvs()`
    command generates a random number from a binomial distribution with a pair of
    input values of `n` and `k`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用三种分布：正态分布、均匀分布和二项分布。`uniform(a,b).rvs()`命令生成一个在*a*和*b*之间均匀分布的随机数。`norm(mean,std).rvs()`命令生成一个来自具有指定均值和标准差的正态分布的随机数。`binom(n,k).rvs()`命令生成一个来自二项分布的随机数，输入值为`n`和`k`：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Stucchhio''s Python program, with a few minor modifications, is shown here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Stucchhio的Python程序，经过少许修改，显示如下：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Based on the graph shown here, he concludes that the cost of basic job proposal
    is lower than the basic income proposal. To save space, we will not elaborate
    on the program. For more detailed explanation and related assumption, please read
    the blog posted by Stucchhio (2013):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这里展示的图表，他得出结论，基本工作提案的成本低于基本收入提案。为了节省篇幅，我们不再详细阐述该程序。更多详细解释及相关假设，请参阅Stucchhio（2013）发布的博客：
- en: '![Comparison between two social policies – basic income and basic job](img/B06175_12_12.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![两种社会政策比较 – 基本收入与基本工作](img/B06175_12_12.jpg)'
- en: Finding an efficient frontier based on two stocks by using simulation
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过模拟找到基于两只股票的有效前沿
- en: 'The following program aims at generating an efficient frontier based on two
    stocks with known means, standard deviations, and correlation. We have just six
    input values: two means, two standard deviations, the correlation (ρ), and the
    number of simulations. To generate the correlated *y1* and *y2* time series, we
    generate the uncorrelated *x1* and *x2* series first. Then, we apply the following
    formulae:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序旨在基于已知均值、标准差和相关性的两只股票生成有效前沿。我们只有六个输入值：两个均值，两个标准差，相关性（ρ）和模拟次数。为了生成相关的* y1
    *和* y2 *时间序列，我们首先生成不相关的* x1 *和* x2 *序列。然后，我们应用以下公式：
- en: '![Finding an efficient frontier based on two stocks by using simulation](img/B06175_12_33.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![通过模拟找到基于两只股票的有效前沿](img/B06175_12_33.jpg)'
- en: Another important issue is how to construct an objective function to minimize.
    Our objective function is the standard deviation of the portfolio in addition
    to a penalty that is defined as the scaled absolute deviation from our target
    portfolio mean.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的问题是如何构造一个目标函数来最小化。我们的目标函数是投资组合的标准差，外加一个惩罚项，该惩罚项定义为与目标投资组合均值的绝对偏差的缩放。
- en: 'In other words, we minimize both the risk of the portfolio and the deviation
    of our portfolio return from our target return, as shown in the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们最小化投资组合的风险以及投资组合回报与目标回报之间的偏差，代码如下所示：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is shown here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Finding an efficient frontier based on two stocks by using simulation](img/B06175_12_13.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![通过模拟找到基于两只股票的有效前沿](img/B06175_12_13.jpg)'
- en: Constructing an efficient frontier with n stocks
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建带有n只股票的有效前沿
- en: 'When the number of stocks, *n*, increases, the correlation between each pair
    of stocks increases dramatically. For *n* stocks, we have *n*(n-1)/2* correlations.
    For example, if *n* is 10, we have 45 correlations. Because of this, it is not
    a good idea to manually input those values. Instead, we generate means, standard
    deviations, and correlations by drawing random numbers from several uniform distributions.
    To produce correlated returns, first we generate *n* uncorrelated stock return
    time series and then apply Cholesky decomposition as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当股票数量* n *增加时，每对股票之间的相关性会显著增加。对于* n *只股票，我们有 *n*(n-1)/2* 个相关性。例如，如果* n *是10，则我们有45个相关性。由于这个原因，手动输入这些值并不是一个好主意。相反，我们通过从多个均匀分布中抽取随机数来生成均值、标准差和相关性。为了产生相关的回报，首先我们生成*
    n *个不相关的股票回报时间序列，然后应用Cholesky分解，具体如下：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The graph is shown here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图表如下所示：
- en: '![Constructing an efficient frontier with n stocks](img/B06175_12_14.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![构建带有n只股票的有效前沿](img/B06175_12_14.jpg)'
- en: 'It is difficult to simulate an n-stock portfolio when n is a huge number. The
    reason is that it is time consuming to generate a variance-covariance matrix,
    see the number of covariances (correlations) here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当 n 是一个很大的数字时，模拟一个 n 股票组合是困难的。原因在于生成方差-协方差矩阵非常耗时，请看这里的协方差（相关性）数量：
- en: '![Constructing an efficient frontier with n stocks](img/B06175_12_34.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![构建包含 n 只股票的有效前沿](img/B06175_12_34.jpg)'
- en: 'Assume that we have 500 stocks in our portfolio. Then we have to estimate 124,750
    pairs of correlations. To simplify this calculation, we could apply CAPM, see
    the following formula:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的投资组合中有 500 只股票。那么我们需要估算 124,750 对相关性。为了简化这个计算，我们可以应用资本资产定价模型（CAPM），见下式：
- en: '![Constructing an efficient frontier with n stocks](img/B06175_12_35.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![构建包含 n 只股票的有效前沿](img/B06175_12_35.jpg)'
- en: 'Here *R*[*i,t*] is the return for stock *i* at time *t*, *α[*i*]*, and *β[i]*
    are the intercept and slope for stock *i*, *R*[*M,t*] is the a market index return
    at time *t*, *e*[*i*], *t*, is the error term at time *t*. Since the total risk
    of individual stock has two components: systematic risk and firm specific risk.
    Thus, the variance of stock *i* is associated with the market index in the following
    way:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 *R*[*i,t*] 是股票 *i* 在时间 *t* 的收益，*α[*i*]* 和 *β[i]* 分别是股票 *i* 的截距和斜率，*R*[*M,t*]
    是市场指数在时间 *t* 的收益，*e*[*i*], *t* 是时间 *t* 的误差项。由于单只股票的总风险包含两个成分：系统性风险和公司特定风险。因此，股票
    *i* 的方差与市场指数的关系如下所示：
- en: '![Constructing an efficient frontier with n stocks](img/B06175_12_36.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![构建包含 n 只股票的有效前沿](img/B06175_12_36.jpg)'
- en: 'The covariance between stocks *i* and *j* is given here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 股票 *i* 和 *j* 之间的协方差如下所示：
- en: '![Constructing an efficient frontier with n stocks](img/B06175_12_37.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![构建包含 n 只股票的有效前沿](img/B06175_12_37.jpg)'
- en: 'Because of this, we can reduce our estimation from 124,750 to just 1,000\.
    Estimate 500 βs first. Then we apply the preceding formula to estimate the covariance.
    Similarly, the formula to estimate the correlation between stock *i* and *j* is
    given here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将估算从 124,750 减少到仅 1,000。首先估算 500 个 β 值。然后我们应用之前的公式来估算协方差。类似地，估算股票 *i*
    和 *j* 之间的相关性的公式如下：
- en: '![Constructing an efficient frontier with n stocks](img/B06175_12_38.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![构建包含 n 只股票的有效前沿](img/B06175_12_38.jpg)'
- en: Long-term return forecasting
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长期收益预测
- en: 'Many researchers and practitioners argue that a long-term return forecast would
    be overestimated if it is based on the arithmetic mean of the past returns and
    underestimated based on a geometric mean. Using 80 years'' historical returns
    to forecast the next 25-year future return, Jacquier, Kane, and Marcus (2003)
    suggest the following weighted scheme:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 许多研究人员和实践者认为，如果基于过去收益的算术平均数来进行长期收益预测，会导致过高的估计；而如果基于几何平均数，则会导致过低的估计。Jacquier、Kane
    和 Marcus（2003）建议使用以下加权方案，利用 80 年的历史收益来预测未来 25 年的收益：
- en: '![Long-term return forecasting](img/B06175_12_39.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![长期收益预测](img/B06175_12_39.jpg)'
- en: 'The following program reflects the preceding equation:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序反映了上述方程：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is shown here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下所示：
- en: '![Long-term return forecasting](img/B06175_12_15.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![长期收益预测](img/B06175_12_15.jpg)'
- en: Efficiency, Quasi-Monte Carlo, and Sobol sequences
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 效率、拟蒙特卡洛法和 Sobol 序列
- en: 'When applying the Monte Carlo simulation to solve various finance-related problems,
    a set of random numbers is generated. When the accuracy is very high, we have
    to draw a huge amount of such random numbers. For example, when pricing options,
    we use very small intervals or a large number of steps to increase the accuracy
    of our solutions. Thus, the efficiency of our Monte Carlo simulation would be
    a vital issue in terms of computational time and costs. This is especially true
    if several thousand options are to be priced. One way to increase the efficiency
    is to apply a better algorithm, that is, optimize our codes. Another way is to
    use some special types of random numbers that are more evenly distributed. This
    is called Quasi-Monte Carlo Simulation. A typical example is a so-called Sobol
    sequence. Sobol sequences belong to the so-called low-discrepancy sequences, which
    satisfy the properties of random numbers, but are distributed more evenly:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用蒙特卡洛模拟来解决各种金融相关问题时，会生成一组随机数。当精度要求非常高时，我们必须生成大量的随机数。例如，在定价期权时，我们使用非常小的间隔或大量的步长来提高解决方案的精度。因此，蒙特卡洛模拟的效率在计算时间和成本方面至关重要。如果需要定价几千个期权，这一点尤其重要。一种提高效率的方法是应用更好的算法，即优化我们的代码。另一种方法是使用一些分布更均匀的特殊类型的随机数，这被称为准蒙特卡洛模拟。一个典型的例子是所谓的Sobol序列。Sobol序列属于低差异序列，满足随机数的属性，但分布更加均匀：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The related graph is shown on the left panel:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 相关图表显示在左侧面板：
- en: '![Efficiency, Quasi-Monte Carlo, and Sobol sequences](img/B06175_12_16.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![效率、准蒙特卡洛、和Sobol序列](img/B06175_12_16.jpg)'
- en: 'On the other hand, if we use the Sobol sequence, the distribution of those
    random numbers would be more even; see the preceding right panel. The related
    code is shown here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们使用Sobol序列，这些随机数的分布会更加均匀；请参见前面的右侧面板。相关代码如下：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For a similar example, but with more complex Python codes, see [http://betatim.github.io/posts/quasi-random-numbers/](http://betatim.github.io/posts/quasi-random-numbers/).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个类似的例子，但使用更复杂的Python代码，请参见 [http://betatim.github.io/posts/quasi-random-numbers/](http://betatim.github.io/posts/quasi-random-numbers/).
- en: 'Appendix A – data case #8 - Monte Carlo Simulation and blackjack'
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录A – 数据案例#8 - 蒙特卡洛模拟与二十一点
- en: Blackjack is a two-player game, with a dealer and a player. Here, we assume
    that you are the player.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 二十一点是一种双人游戏，包括发牌员和玩家。这里，我们假设你是玩家。
- en: 'Rule #1: Cards 2 to 10 have their face value, while Jack, Quenn, and King are
    worth 10 points, and Ace is worth either 1 or 11 points (player''s choice).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 规则#1：2到10的牌按面值计分，而杰克、皇后和国王的点数为10，A的点数为1或11（由玩家选择）。
- en: 'Terminology:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 术语：
- en: '**Blackjack**: One A plus any card worth 10 points'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二十一点**：一张A牌加任何一张值10点的牌'
- en: '**Lose**: The player''s bet is taken by the dealer'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输**：玩家的赌注被发牌员收走'
- en: '**Win**: The player wins as much as he bets'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**胜**：玩家赢得与赌注相等的金额'
- en: '**Blackjack (natural)**: The player wins 1.5 times the bet'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二十一点（自然牌）**：玩家赢得1.5倍赌注'
- en: '**Push**: The player keeps his bet, neither winning nor losing money'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平局**：玩家保持赌注，既不赢也不输'
- en: '**Step 1**: The dealer draws two cards, one face up, while the player draws
    two cards (face up)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤1**：发牌员抽两张牌，一张面朝上，而玩家抽两张牌（面朝上）'
- en: '**Step 2**: The player could draw the third card'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤2**：玩家可以抽第三张牌'
- en: '**Win or lose**: If the sum of your cards is less than 21 and is bigger than
    the dealer''s, you win. Take a look at [http://www.pagat.com/banking/ blackjack.html](http://www.pagat.com/banking/%20blackjack.html)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**胜或负**：如果你的牌的点数少于21且大于发牌员的点数，你获胜。查看 [http://www.pagat.com/banking/ blackjack.html](http://www.pagat.com/banking/%20blackjack.html)'
- en: References
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Please refer to the following articles:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下文章：
- en: '*Bruno, Giuseppe*, *Monte Carlo Simulation for Pricing European and American
    Basket* *option*, *Bank of Italy*, [https://www.r-project.org/conferences/ useR-2010/abstracts/Bruno.pdf](https://www.r-project.org/conferences/%20useR-2010/abstracts/Bruno.pdf)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*布鲁诺，朱塞佩*，*蒙特卡洛模拟在定价欧洲和美式篮子* *期权中的应用*，*意大利银行*，[https://www.r-project.org/conferences/
    useR-2010/abstracts/Bruno.pdf](https://www.r-project.org/conferences/%20useR-2010/abstracts/Bruno.pdf)'
- en: '*Easley, D., Kiefer, N.M., O''Hara, M., Paperman, J.B., 1996*, *Liquidity,
    information, and infrequently traded stocks*, *Journal of Finance 51, 1405–1436*,
    [http://www.defaultrisk.com/pa_liqty_03.htm](http://www.defaultrisk.com/pa_liqty_03.htm)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Easley, D., Kiefer, N.M., O''Hara, M., Paperman, J.B., 1996*，*流动性、信息和不常交易的股票*，*《金融学杂志》51卷，1405–1436*，[http://www.defaultrisk.com/pa_liqty_03.htm](http://www.defaultrisk.com/pa_liqty_03.htm)'
- en: '*Jacquier, Eric, Alex Kane, and Alan J. Marcus,2003*, *Geometric or Arithmetic
    Me**an: A Reconsideration*, [https://www2.bc.edu/alan-marcus/papers/FAJ_2003.
    pdf](https://www2.bc.edu/alan-marcus/papers/FAJ_2003.%20pdf)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Jacquier, Eric, Alex Kane, and Alan J. Marcus, 2003*, *几何平均数与算术平均数：一种重新考虑*,
    [https://www2.bc.edu/alan-marcus/papers/FAJ_2003.pdf](https://www2.bc.edu/alan-marcus/papers/FAJ_2003.pdf)'
- en: '*Stucchio, Chris, 2013, Modelling a Basic Income with Python and M**onte Carlo
    Simulation*, [https://www.chrisstucchio.com/blog/2013/basic_income_ vs_basic_job.html](https://www.chrisstucchio.com/blog/2013/basic_income_%20vs_basic_job.html)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Stucchio, Chris, 2013, 使用Python和蒙特卡罗模拟模型构建基本收入*, [https://www.chrisstucchio.com/blog/2013/basic_income_vs_basic_job.html](https://www.chrisstucchio.com/blog/2013/basic_income_vs_basic_job.html)'
- en: '*Zhong, Raymond, 2017, India Considers Fighting Poverty With a Universal Basic
    Income**, Wall Street Journal*, [http://blogs.wsj.com/ indiarealtime/2017/01/31/india-considers-fighting-poverty-witha-
    universal-basic-income/](http://blogs.wsj.com/%20indiarealtime/2017/01/31/india-considers-fighting-poverty-witha-%20universal-basic-income/)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Zhong, Raymond, 2017, 印度考虑通过普遍基本收入来对抗贫困**, 《华尔街日报》*, [http://blogs.wsj.com/indiarealtime/2017/01/31/india-considers-fighting-poverty-witha-universal-basic-income/](http://blogs.wsj.com/indiarealtime/2017/01/31/india-considers-fighting-poverty-witha-universal-basic-income/)'
- en: Exercises
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '[http://finance.yahoo.com](http://finance.yahoo.com)), download the last five
    years of price data for a few companies, such as IBM, WMT, and C (City Group).
    Test whether their daily returns follow a normal distribution.'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[http://finance.yahoo.com](http://finance.yahoo.com)，下载一些公司（如IBM、WMT和C（花旗集团））过去五年的价格数据。测试它们的每日回报是否符合正态分布。'
- en: Write a Python program to use the `scipy.permutation()` function to select 12
    monthly returns randomly from the past five-year data without replacement. To
    test the program, you can use Citigroup and the time period from January 2, 2012
    to December 31, 2016 from Yahoo! Finance.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Python程序，使用`scipy.permutation()`函数，从过去五年的数据中随机选择12个月的回报，不放回。为了测试该程序，你可以使用花旗集团的数据，时间范围为2012年1月2日到2016年12月31日，数据来源于Yahoo!
    Finance。
- en: Write a Python program to run bootstrapping with *n* given returns. For each
    time, we select *m* returns where *m>n*.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Python程序，使用给定的*n*个回报进行自助法抽样。每次选择*m*个回报，其中*m>n*。
- en: To convert random numbers from a uniform distribution to a normal distribution,
    we have the following formula:![Exercises](img/B06175_12_40.jpg)
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将均匀分布的随机数转换为正态分布，我们有以下公式：![Exercises](img/B06175_12_40.jpg)
- en: Based on the formula, generate 5,000 normally distributed random numbers; estimate
    their mean, standard deviation, and test it.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据公式，生成5,000个正态分布的随机数；估算它们的均值、标准差，并进行测试。
- en: Assume that the current stock price is $10.25, the mean value in the past five
    years is $9.35, and the standard deviation is 4.24\. Write a Python program to
    generate 1,000 future prices.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设当前股票价格为$10.25，过去五年的均值为$9.35，标准差为4.24。编写一个Python程序，生成1,000个未来的股票价格。
- en: 'Download the price data for 10 stocks over the last 10 years. Form an equal-weighted
    portfolio and conduct a Shapiro-Wilk test on its portfolio daily returns:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载过去10年内10只股票的价格数据。构建一个等权重投资组合，并对该组合的每日回报进行Shapiro-Wilk检验：
- en: '| Company name | Ticker | Dell company | DELL |'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 公司名称 | 股票代码 | 戴尔公司 | DELL |'
- en: '| --- | --- | --- | --- |'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| International Business Machine | IBM | General Electric | GE |'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 国际商业机器公司 | IBM | 通用电气 | GE |'
- en: '| Microsoft | MSFT | Google | GOOG |'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 微软 | MSFT | 谷歌 | GOOG |'
- en: '| Family Dollar Stores | FDO | Apple | AAPL |'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| Family Dollar Stores | FDO | Apple | AAPL |'
- en: '| Wal-Mart Stores | WMT | eBay | EBAY |'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| Wal-Mart Stores | WMT | eBay | EBAY |'
- en: '| McDonald''s | MCD |   |   |'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 麦当劳 | MCD |   |   |'
- en: Go to Yahoo! Finance to find out today's IBM price and then download its historical-prices
    information to estimate its mean and standard deviation for the past five years.
    Generate predictions for one-year daily prices in the future.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往Yahoo! Finance查找今天的IBM股票价格，然后下载其历史价格信息，估算过去五年的均值和标准差。生成未来一年每日价格的预测。
- en: For 20 tickers, download and save their daily price as 20 different CSV files.
    Write a Python program to randomly select five stocks and estimate their equal-weighted
    portfolio returns and risk.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于20个股票代码，下载并保存它们的每日价格为20个不同的CSV文件。编写一个Python程序，随机选择五只股票，估算它们的等权重投资组合回报和风险。
- en: Repeat the previous program, but save it as one file instead of 20 separate
    CSV files.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复前一个程序，但将其保存为一个文件，而不是20个单独的CSV文件。
- en: Tip
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Generate an extra variable called ticker.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成一个额外的变量，称为ticker。
- en: There are 30 students in a class. Write a program to select seven of them randomly.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 班级里有30名学生。编写一个程序，从中随机选择七个学生。
- en: Test the time difference between retrieving `ffMonthly.pkl`, `ffDaily.pkl`,
    or `ffMonthly.csv`, `ffDaily.csv` and conduct some tests.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试提取`ffMonthly.pkl`、`ffDaily.pkl`或`ffMonthly.csv`、`ffDaily.csv`的时间差，并进行一些测试。
- en: Usually we observe the negative relationship between the portfolio's volatility
    and the number of stocks in the portfolio. Write a program to show the relationship
    between the variance of a portfolio and the number of stock in it.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常我们观察到投资组合的波动率与投资组合中股票数量之间存在负相关关系。编写一个程序，显示投资组合方差与其中股票数量之间的关系。
- en: 'What is the probability for picking up 1, 2, 3, and 4 from 10 balls marked
    from 1 to 10? Use two methods: a. Use the formula. b. Write a program to generate
    a set of five random numbers.'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从标记为1到10的10个球中，抽取1、2、3和4的概率是多少？使用两种方法：a. 使用公式。b. 编写一个程序生成五个随机数。
- en: Write a program to generate 176 million sets of combinations in terms of the
    Mega Millions game. What is the chance to win (1, 2, 3, 4, 5) and (1)?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序生成176百万组Mega Millions游戏的组合。赢得（1、2、3、4、5）和（1）的机会是多少？
- en: For the Powerball games, we choose five white balls from 59 white balls numbered
    from 1 to 59 and one red ball from 39 red balls numbered from 1 to 39\. Write
    a program to choose those six balls randomly.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Powerball游戏，我们从59个标有1到59的白球中选择5个白球，并从39个标有1到39的红球中选择1个红球。编写一个程序随机选择这六个球。
- en: Retrieving seven stocks from 20 stocks, what is the probability of choosing
    the first seven stocks? Use simulation to prove your result.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从20只股票中选择7只，选择前七只股票的概率是多少？使用模拟来证明你的结果。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we discussed several types of distribution: normal, standard
    normal, lognormal, and Poisson. Since the assumption that stocks follow a lognormal
    distribution and returns follow a normal distribution is the cornerstone for option
    theory, the Monte Carlo simulation is used to price European options. Under certain
    scenarios, Asian options might be more effective in terms of hedging. Exotic options
    are more complex than the vanilla options since the former have no closed-form
    solution, while the latter could be priced by the Black-Scholes-Merton option
    model. One way to price these exotic options is to use the Monte Carlo simulation.
    The Python programs to price an Asian option and lookback options were also discussed.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了几种类型的分布：正态分布、标准正态分布、对数正态分布和泊松分布。由于假设股票遵循对数正态分布且回报遵循正态分布是期权理论的基石，因此蒙特卡洛模拟被用于定价欧式期权。在某些情况下，亚洲期权可能在对冲方面更为有效。奇异期权比标准期权更为复杂，因为前者没有封闭解，而后者可以通过Black-Scholes-Merton期权模型定价。定价这些奇异期权的一种方法是使用蒙特卡洛模拟。我们还讨论了定价亚洲期权和回溯期权的Python程序。
