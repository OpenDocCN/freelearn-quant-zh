["```py\n%matplotlib inline\nfrom zipline import run_algorithm \nfrom zipline.api import order_target_percent, symbol, set_commission\nfrom zipline.finance.commission import PerTrade\nimport pandas as pd\nimport pyfolio as pf\nimport warnings\nwarnings.filterwarnings('ignore')\ndef initialize(context): \n    context.stock = symbol('AAPL')\n    context.rolling_window = 90\n    set_commission(PerTrade(cost=5)) \ndef handle_data(context, data): \n    price_hist = data.history(context.stock, \"close\", \n                              context.rolling_window, \"1d\")\n    order_target_percent(context.stock, 1.0 if price_hist[-1] > price_hist.mean() else 0.0) \ndef analyze(context, perf): \n    returns, positions, transactions = \\\n    pf.utils.extract_rets_pos_txn_from_zipline(perf) \n    pf.create_returns_tear_sheet(returns, \n                                 benchmark_rets = None)\n\nstart_date = pd.to_datetime('2000-1-1', utc=True)\nend_date = pd.to_datetime('2018-1-1', utc=True)\n\nresults = run_algorithm(start = start_date, end = end_date, \n                        initialize = initialize, \n                        analyze = analyze, \n                        handle_data = handle_data, \n                        capital_base = 10000, \n                        data_frequency = 'daily', \n                        bundle ='quandl')\n```", "```py\n%matplotlib inline\nfrom zipline import run_algorithm \nfrom zipline.api import order_target_percent, symbol, set_commission\nfrom zipline.finance.commission import PerTrade\nimport pandas as pd\nimport pyfolio as pf\nimport warnings\nwarnings.filterwarnings('ignore')\ndef initialize(context): \n    context.stock = symbol('AAPL')\n    context.rolling_window = 90 \n    set_commission(PerTrade(cost=5))     \ndef handle_data(context, data): \n    price_hist = data.history(context.stock, \"close\", \n                              context.rolling_window, \"1d\")\n\n    rolling_mean_short_term = \\\n    price_hist.rolling(window=45, center=False).mean()\n    rolling_mean_long_term = \\\n    price_hist.rolling(window=90, center=False).mean()\n\n    if rolling_mean_short_term[-1] > rolling_mean_long_term[-1]:\n        order_target_percent(context.stock, 1.0)     \n    elif rolling_mean_short_term[-1] < rolling_mean_long_term[-1]:\n        order_target_percent(context.stock, 0.0)     \ndef analyze(context, perf): \n    returns, positions, transactions = \\\n    pf.utils.extract_rets_pos_txn_from_zipline(perf) \n    pf.create_returns_tear_sheet(returns, \n                                 benchmark_rets = None)\n\nstart_date = pd.to_datetime('2000-1-1', utc=True)\nend_date = pd.to_datetime('2018-1-1', utc=True)\n\nresults = run_algorithm(start = start_date, end = end_date, \n                        initialize = initialize, \n                        analyze = analyze, \n                        handle_data = handle_data, \n                        capital_base = 10000, \n                        data_frequency = 'daily', \n                        bundle ='quandl')\n```", "```py\n%matplotlib inline\nfrom zipline import run_algorithm \nfrom zipline.api import order_target_percent, symbol, set_commission\nfrom zipline.finance.commission import PerTrade\nimport pandas as pd\nimport pyfolio as pf\nimport warnings\nwarnings.filterwarnings('ignore')\ndef initialize(context): \n    context.stock = symbol('AAPL')\n    context.rolling_window = 90\n    set_commission(PerTrade(cost=5))     \ndef handle_data(context, data): \n    price_hist = data.history(context.stock, \"close\", \n                              context.rolling_window, \"1d\")\n\n    rolling_mean_short_term = \\\n    price_hist.ewm(span=5, adjust=True,\n                   ignore_na=True).mean()\n    rolling_mean_long_term = \\\n    price_hist.ewm(span=30, adjust=True, \n                   ignore_na=True).mean()\n\n    if rolling_mean_short_term[-1] > rolling_mean_long_term[-1]:\n        order_target_percent(context.stock, 1.0)     \n    elif rolling_mean_short_term[-1] < rolling_mean_long_term[-1]:\n        order_target_percent(context.stock, 0.0)     \ndef analyze(context, perf): \n    returns, positions, transactions = \\\n    pf.utils.extract_rets_pos_txn_from_zipline(perf) \n    pf.create_returns_tear_sheet(returns, \n                                 benchmark_rets = None)\n\nstart_date = pd.to_datetime('2000-1-1', utc=True)\nend_date = pd.to_datetime('2018-1-1', utc=True)\n\nresults = run_algorithm(start = start_date, end = end_date,\n                        initialize = initialize, \n                        analyze = analyze, \n                        handle_data = handle_data, \n                        capital_base = 10000, \n                        data_frequency = 'daily', \n                        bundle ='quandl')\n```", "```py\npip install stockstats\n```", "```py\n%matplotlib inline\nfrom zipline import run_algorithm \nfrom zipline.api import order_target_percent, symbol, set_commission\nfrom zipline.finance.commission import PerTrade\nimport pandas as pd\nimport pyfolio as pf\nfrom stockstats import StockDataFrame as sdf\nimport warnings\nwarnings.filterwarnings('ignore')\ndef initialize(context): \n    context.stock = symbol('AAPL')\n    context.rolling_window = 20\n    set_commission(PerTrade(cost=5))     \ndef handle_data(context, data): \n    price_hist = data.history(context.stock, \n                              [\"open\", \"high\", \n                               \"low\",\"close\"], \n                              context.rolling_window, \"1d\")\n\n    stock=sdf.retype(price_hist)   \n    rsi = stock.get('rsi_12')\n\n    if rsi[-1] > 90:\n        order_target_percent(context.stock, 0.0)     \n    elif rsi[-1] < 10:\n        order_target_percent(context.stock, 1.0)   \n\ndef analyze(context, perf): \n    returns, positions, transactions = \\\n    pf.utils.extract_rets_pos_txn_from_zipline(perf) \n    pf.create_returns_tear_sheet(returns, \n                                 benchmark_rets = None)\n\nstart_date = pd.to_datetime('2015-1-1', utc=True)\nend_date = pd.to_datetime('2018-1-1', utc=True)\n\nresults = run_algorithm(start = start_date, end = end_date,\n                        initialize = initialize, \n                        analyze = analyze, \n                        handle_data = handle_data, \n                        capital_base = 10000, \n                        data_frequency = 'daily', \n                        bundle ='quandl')\n```", "```py\n%matplotlib inline\nfrom zipline import run_algorithm \nfrom zipline.api import order_target_percent, symbol, set_commission\nfrom zipline.finance.commission import PerTrade\nimport pandas as pd\nimport pyfolio as pf\nfrom stockstats import StockDataFrame as sdf\nimport warnings\nwarnings.filterwarnings('ignore')\ndef initialize(context): \n    context.stock = symbol('AAPL')\n    context.rolling_window = 20\n    set_commission(PerTrade(cost=5))     \ndef handle_data(context, data): \n    price_hist = data.history(context.stock, \n                              [\"open\",\"high\", \n                               \"low\",\"close\"], \n                              context.rolling_window, \"1d\")\n\n    stock=sdf.retype(price_hist)   \n    signal = stock['macds']\n    macd   = stock['macd'] \n\n    if macd[-1] > signal[-1] and macd[-2] <= signal[-2]:\n        order_target_percent(context.stock, 1.0)     \n    elif macd[-1] < signal[-1] and macd[-2] >= signal[-2]:\n        order_target_percent(context.stock, 0.0)   \n\ndef analyze(context, perf): \n    returns, positions, transactions = \\\n    pf.utils.extract_rets_pos_txn_from_zipline(perf) \n    pf.create_returns_tear_sheet(returns, \n                                 benchmark_rets = None)\n\nstart_date = pd.to_datetime('2015-1-1', utc=True)\nend_date = pd.to_datetime('2018-1-1', utc=True)\n\nresults = run_algorithm(start = start_date, end = end_date, \n                        initialize = initialize, \n                        analyze = analyze, \n                        handle_data = handle_data, \n                        capital_base = 10000, \n                        data_frequency = 'daily', \n                        bundle ='quandl')\n```", "```py\n%matplotlib inline\nfrom zipline import run_algorithm \nfrom zipline.api import order_target_percent, symbol, set_commission\nfrom zipline.finance.commission import PerTrade\nimport pandas as pd\nimport pyfolio as pf\nfrom stockstats import StockDataFrame as sdf\nimport warnings\nwarnings.filterwarnings('ignore')\ndef initialize(context): \n    context.stock = symbol('MSFT')\n    context.rolling_window = 20\n    set_commission(PerTrade(cost=5))     \ndef handle_data(context, data): \n    price_hist = data.history(context.stock, \n                              [\"open\", \"high\", \n                               \"low\",\"close\"], \n                              context.rolling_window, \"1d\")\n\n    stock=sdf.retype(price_hist)   \n    rsi = stock.get('rsi_12')\n\n    signal = stock['macds']\n    macd   = stock['macd'] \n\n    if rsi[-1] < 50 and macd[-1] > signal[-1] and macd[-2] <= signal[-2]:\n        order_target_percent(context.stock, 1.0)     \n    elif rsi[-1] > 50 and macd[-1] < signal[-1] and macd[-2] >= signal[-2]:\n        order_target_percent(context.stock, 0.0)   \n\ndef analyze(context, perf): \n    returns, positions, transactions = \\\n    pf.utils.extract_rets_pos_txn_from_zipline(perf) \n    pf.create_returns_tear_sheet(returns, \n                                 benchmark_rets = None)\n\nstart_date = pd.to_datetime('2015-1-1', utc=True)\nend_date = pd.to_datetime('2018-1-1', utc=True)\n\nresults = run_algorithm(start = start_date, end = end_date, \n                        initialize = initialize, \n                        analyze = analyze, \n                        handle_data = handle_data, \n                        capital_base = 10000, \n                        data_frequency = 'daily', \n                        bundle ='quandl')\n```", "```py\n%matplotlib inline\nfrom zipline import run_algorithm \nfrom zipline.api import order_target_percent, symbol, set_commission\nfrom zipline.finance.commission import PerTrade\nimport pandas as pd\nimport pyfolio as pf\nfrom stockstats import StockDataFrame as sdf\nimport warnings\nwarnings.filterwarnings('ignore')\ndef initialize(context): \n    context.stock = symbol('MSFT')\n    context.rolling_window = 20\n    set_commission(PerTrade(cost=5))     \ndef handle_data(context, data): \n    price_hist = data.history(context.stock, \n                              [\"open\",\"high\", \n                               \"low\",\"close\"], \n                              context.rolling_window, \"1d\")\n\n    stock=sdf.retype(price_hist)   \n    trix = stock.get('trix')\n\n    if trix[-1] > 0 and trix[-2] < 0:\n        order_target_percent(context.stock, 0.0)     \n    elif trix[-1] < 0 and trix[-2] > 0:\n        order_target_percent(context.stock, 1.0)   \n\ndef analyze(context, perf): \n    returns, positions, transactions = \\\n    pf.utils.extract_rets_pos_txn_from_zipline(perf) \n    pf.create_returns_tear_sheet(returns, \n                                 benchmark_rets = None)\n\nstart_date = pd.to_datetime('2015-1-1', utc=True)\nend_date = pd.to_datetime('2018-1-1', utc=True)\n\nresults = run_algorithm(start = start_date, end = end_date, \n                        initialize = initialize, \n                        analyze = analyze, \n                        handle_data = handle_data, \n                        capital_base = 10000, \n                        data_frequency = 'daily', \n                        bundle ='quandl')\n```", "```py\n%matplotlib inline\nfrom zipline import run_algorithm \nfrom zipline.api import order_target_percent, symbol, set_commission\nfrom zipline.finance.commission import PerTrade\nimport pandas as pd\nimport pyfolio as pf\nfrom stockstats import StockDataFrame as sdf\nimport warnings\nwarnings.filterwarnings('ignore')\ndef initialize(context): \n    context.stock = symbol('MSFT')\n    context.rolling_window = 20\n    set_commission(PerTrade(cost=5))     \ndef handle_data(context, data): \n    price_hist = data.history(context.stock, \n                              [\"open\", \"high\",\n                               \"low\",\"close\"], \n                              context.rolling_window, \"1d\")\n\n    stock=sdf.retype(price_hist)   \n    wr = stock.get('wr_6')\n\n    if wr[-1] < 10:\n        order_target_percent(context.stock, 0.0)     \n    elif wr[-1] > 90:\n        order_target_percent(context.stock, 1.0)   \n\ndef analyze(context, perf): \n    returns, positions, transactions = \\\n    pf.utils.extract_rets_pos_txn_from_zipline(perf) \n    pf.create_returns_tear_sheet(returns, \n                                 benchmark_rets = None)\n\nstart_date = pd.to_datetime('2015-1-1', utc=True)\nend_date = pd.to_datetime('2018-1-1', utc=True)\n\nresults = run_algorithm(start = start_date, end = end_date, \n                        initialize = initialize, \n                        analyze = analyze, \n                        handle_data = handle_data, \n                        capital_base = 10000, \n                        data_frequency = 'daily', \n                        bundle ='quandl')\n```", "```py\n%matplotlib inline\nfrom zipline import run_algorithm \nfrom zipline.api import order_target_percent, symbol, set_commission\nfrom zipline.finance.commission import PerTrade\nimport pandas as pd\nimport pyfolio as pf\nimport warnings\nwarnings.filterwarnings('ignore')\ndef initialize(context): \n    context.stock = symbol('DG')\n    context.rolling_window = 20 \n    set_commission(PerTrade(cost=5))     \ndef handle_data(context, data): \n    price_hist = data.history(context.stock, \"close\", \n                              context.rolling_window, \"1d\")\n\n    middle_base_line = price_hist.mean()\n    std_line =  price_hist.std()\n    lower_band = middle_base_line - 2 * std_line\n    upper_band = middle_base_line + 2 * std_line\n\n    if price_hist[-1] < lower_band:\n        order_target_percent(context.stock, 1.0)     \n    elif price_hist[-1] > upper_band:\n        order_target_percent(context.stock, 0.0)     \ndef analyze(context, perf): \n    returns, positions, transactions = \\\n    pf.utils.extract_rets_pos_txn_from_zipline(perf) \n    pf.create_returns_tear_sheet(returns, \n                                 benchmark_rets = None)\n\nstart_date = pd.to_datetime('2000-1-1', utc=True)\nend_date = pd.to_datetime('2018-1-1', utc=True)\n\nresults = run_algorithm(start = start_date, end = end_date, \n                        initialize = initialize, \n                        analyze = analyze, \n                        handle_data = handle_data, \n                        capital_base = 10000, \n                        data_frequency = 'daily', \n                        bundle ='quandl')\n```", "```py\n%matplotlib inline\nfrom zipline import run_algorithm \nfrom zipline.api import order_target_percent, symbol, set_commission\nfrom zipline.finance.commission import PerTrade\nimport pandas as pd\nimport pyfolio as pf\nimport numpy as np\nimport statsmodels.api as sm\nfrom statsmodels.tsa.stattools import coint\nimport warnings\nwarnings.filterwarnings('ignore')\ndef initialize(context): \n    context.stock_x = symbol('PEP')\n    context.stock_y = symbol('KO')\n    context.rolling_window = 500\n    set_commission(PerTrade(cost=5))       \n    context.i = 0\n\ndef handle_data(context, data):   \n    context.i += 1\n    if context.i < context.rolling_window:\n        return\n\n    try:\n        x_price = data.history(context.stock_x, \"close\", \n                               context.rolling_window,\"1d\")\n        x = np.log(x_price)\n\n        y_price = data.history(context.stock_y, \"close\", \n                               context.rolling_window,\"1d\")\n        y = np.log(y_price)\n        _, p_value, _  = coint(x, y)\n        if p_value < .9:\n            return\n\n        slope, intercept = sm.OLS(y, sm.add_constant(x, prepend=True)).fit().params\n\n        spread = y - (slope * x + intercept)\n        zscore = (\\\n        spread[-1] - spread.mean()) / spread.std()    \n\n        if -1 < zscore < 1:\n            return\n        side = np.copysign(0.5, zscore)\n        order_target_percent(context.stock_y, \n                             -side * 100 / y_price[-1])\n        order_target_percent(context.stock_x,  \n                             side * slope*100/x_price[-1])\n    except:\n        pass\ndef analyze(context, perf): \n    returns, positions, transactions = \\\n    pf.utils.extract_rets_pos_txn_from_zipline(perf) \n    pf.create_returns_tear_sheet(returns, \n                                 benchmark_rets = None)\n\nstart_date = pd.to_datetime('2015-1-1', utc=True)\nend_date = pd.to_datetime('2018-01-01', utc=True)\n\nresults = run_algorithm(start = start_date, end = end_date, \n                        initialize = initialize, \n                        analyze = analyze, \n                        handle_data = handle_data, \n                        capital_base = 10000, \n                        data_frequency = 'daily', \n                        bundle ='quandl')\n```", "```py\n%matplotlib inline\nfrom zipline import run_algorithm \nfrom zipline.api import order_target_percent, symbol, set_commission, schedule_function, date_rules, time_rules\nfrom zipline.finance.commission import PerTrade\nimport pandas as pd\nimport pyfolio as pf\nfrom scipy.optimize import minimize\nimport numpy as np\nimport warnings\nwarnings.filterwarnings('ignore')\ndef initialize(context): \n    context.stocks = [symbol('DIS'), symbol('WMT'), \n                      symbol('DOW'), symbol('CRM'), \n                      symbol('NKE'), symbol('HD'), \n                      symbol('V'), symbol('MSFT'),\n                      symbol('MMM'), symbol('CSCO'),\n                      symbol('KO'), symbol('AAPL'),\n                      symbol('HON'), symbol('JNJ'),\n                      symbol('TRV'), symbol('PG'),\n                      symbol('CVX'), symbol('VZ'),\n                      symbol('CAT'), symbol('BA'),\n                      symbol('AMGN'), symbol('IBM'),\n                      symbol('AXP'), symbol('JPM'),\n                      symbol('WBA'), symbol('MCD'),\n                      symbol('MRK'), symbol('GS'),\n                      symbol('UNH'), symbol('INTC')]\n    context.rolling_window = 200\n    set_commission(PerTrade(cost=5))\n    schedule_function(handle_data, \n                      date_rules.month_end(), \n                      time_rules.market_open(hours=1))\n\ndef minimum_vol_obj(wo, cov):\n    w = wo.reshape(-1, 1)\n    sig_p = np.sqrt(np.matmul(w.T, \n                              np.matmul(cov, w)))[0, 0]\n    return sig_p\ndef handle_data(context, data): \n    n_stocks = len(context.stocks)\n    prices = None\n\n    for i in range(n_stocks):\n        price_history = \\\n        data.history(context.stocks[i], \"close\", \n                     context.rolling_window, \"1d\")\n\n        price = np.array(price_history)\n        if prices is None:\n            prices = price\n        else:\n            prices = np.c_[prices, price]\n\n    rets = prices[1:,:]/prices[0:-1, :]-1.0\n    mu = np.mean(rets, axis=0)\n    cov = np.cov(rets.T)    \n\n    w0 = np.ones(n_stocks) / n_stocks\n\n    cons = ({'type': 'eq', \n             'fun': lambda w: np.sum(w) - 1.0}, \n            {'type': 'ineq', 'fun': lambda w: w})\n    TOL = 1e-12    \n    res = minimize(minimum_vol_obj, w0, args=cov, \n                   method='SLSQP', constraints=cons, \n                   tol=TOL, options={'disp': False})\n\n    if not res.success:\n        return;\n\n    w = res.x\n\n    for i in range(n_stocks):\n        order_target_percent(context.stocks[i], w[i])    \ndef analyze(context, perf): \n    returns, positions, transactions = \\\n    pf.utils.extract_rets_pos_txn_from_zipline(perf) \n    pf.create_returns_tear_sheet(returns, \n                                 benchmark_rets = None)\n\nstart_date = pd.to_datetime('2010-1-1', utc=True)\nend_date = pd.to_datetime('2018-1-1', utc=True)\n\nresults = run_algorithm(start = start_date, end = end_date, \n                        initialize = initialize, \n                        analyze = analyze, \n                        capital_base = 10000, \n                        data_frequency = 'daily'\n                        bundle ='quandl')\n```", "```py\npip install PyPortfolioOpt\n%matplotlib inline\nfrom zipline import run_algorithm \nfrom zipline.api import order_target_percent, symbols, set_commission, schedule_function, date_rules, time_rules\nfrom zipline.finance.commission import PerTrade\nimport pandas as pd\nimport pyfolio as pf\nimport numpy as np\nfrom pypfopt.efficient_frontier import EfficientFrontier\nfrom pypfopt import risk_models\nfrom pypfopt import expected_returns\nimport warnings\nwarnings.filterwarnings('ignore')\ndef initialize(context): \n    context.stocks = \\\n    symbols('DIS','WMT','DOW','CRM','NKE','HD','V','MSFT',\n            'MMM','CSCO','KO','AAPL','HON','JNJ','TRV',\n            'PG','CVX','VZ','CAT','BA','AMGN','IBM','AXP',\n            'JPM','WBA','MCD','MRK','GS','UNH','INTC')\n    context.rolling_window = 252\n    set_commission(PerTrade(cost=5))\n    schedule_function(handle_data, date_rules.month_end(), \n                      time_rules.market_open(hours=1))\n\ndef handle_data(context, data): \n    prices_history = data.history(context.stocks, \"close\", \n                                  context.rolling_window, \n                                  \"1d\")\n    avg_returns = \\\n    expected_returns.mean_historical_return(prices_history)\n    cov_mat = risk_models.sample_cov(prices_history)\n    efficient_frontier = EfficientFrontier(avg_returns, \n                                           cov_mat)\n    weights = efficient_frontier.max_sharpe()\n    cleaned_weights = efficient_frontier.clean_weights()\n\n    for stock in context.stocks:\n        order_target_percent(stock, cleaned_weights[stock])\ndef analyze(context, perf): \n    returns, positions, transactions = \\\n    pf.utils.extract_rets_pos_txn_from_zipline(perf) \n    pf.create_returns_tear_sheet(returns, \n                                 benchmark_rets = None)\n\nstart_date = pd.to_datetime('2010-1-1', utc=True)\nend_date = pd.to_datetime('2018-1-1', utc=True)\n\nresults = run_algorithm(start = start_date, end = end_date, \n                        initialize = initialize, \n                        analyze = analyze, \n                        capital_base = 10000, \n                        data_frequency = 'daily', \n                        bundle ='quandl')\n```", "```py\n%matplotlib inline\nfrom zipline import run_algorithm \nfrom zipline.api import order_target_percent, symbol, set_commission\nfrom zipline.finance.commission import PerTrade\nimport pandas as pd\nimport pyfolio as pf\nimport pmdarima as pm\nimport warnings\nwarnings.filterwarnings('ignore')\ndef initialize(context): \n    context.stock = symbol('AAPL')\n    context.rolling_window = 90\n    set_commission(PerTrade(cost=5)) \ndef handle_data(context, data): \n    price_hist = data.history(context.stock, \"close\", \n                              context.rolling_window, \"1d\")\n    try:\n        model = pm.auto_arima(price_hist, seasonal=True)\n        forecasts = model.predict(7)      \n        order_target_percent(context.stock, 1.0 if price_hist[-1] < forecasts[-1] else 0.0) \n    except:\n        pass\ndef analyze(context, perf): \n    returns, positions, transactions = \\\n    pf.utils.extract_rets_pos_txn_from_zipline(perf) \n    pf.create_returns_tear_sheet(returns, \n                                 benchmark_rets = None)\n\nstart_date = pd.to_datetime('2017-1-1', utc=True)\nend_date = pd.to_datetime('2018-1-1', utc=True)\n\nresults = run_algorithm(start = start_date, end = end_date, \n                        initialize = initialize, \n                        analyze = analyze, \n                        handle_data = handle_data, \n                        capital_base = 10000, \n                        data_frequency = 'daily', \n                        bundle ='quandl')\n```", "```py\n%matplotlib inline\nfrom zipline import run_algorithm \nfrom zipline.api import order_target_percent, symbol, set_commission\nfrom zipline.finance.commission import PerTrade\nimport pandas as pd\nimport pyfolio as pf\nfrom fbprophet import Prophet\nimport logging\nlogging.getLogger('fbprophet').setLevel(logging.WARNING)\nimport warnings\nwarnings.filterwarnings('ignore')\ndef initialize(context): \n    context.stock = symbol('AAPL')\n    context.rolling_window = 90\n    set_commission(PerTrade(cost=5)) \ndef handle_data(context, data): \n    price_hist = data.history(context.stock, \"close\", \n                              context.rolling_window, \"1d\")\n\n    price_df = pd.DataFrame({'y' : price_hist}).rename_axis('ds').reset_index()\n    price_df['ds'] = price_df['ds'].dt.tz_convert(None)\n\n    model = Prophet()\n    model.fit(price_df)\n    df_forecast = model.make_future_dataframe(periods=7, \n                                              freq='D')\n    df_forecast = model.predict(df_forecast)\n\n    last_price=price_hist[-1]\n    forecast_lower=df_forecast['yhat_lower'].iloc[-1]\n    forecast_upper=df_forecast['yhat_upper'].iloc[-1]\n\n    if last_price < forecast_lower:\n        order_target_percent(context.stock, 1.0) \n    elif last_price > forecast_upper:\n        order_target_percent(context.stock, 0.0) \ndef analyze(context, perf): \n    returns, positions, transactions = \\\n    pf.utils.extract_rets_pos_txn_from_zipline(perf) \n    pf.create_returns_tear_sheet(returns, \n                                 benchmark_rets = None)\n\nstart_date = pd.to_datetime('2017-1-1', utc=True)\nend_date = pd.to_datetime('2018-1-1', utc=True)\n\nresults = run_algorithm(start = start_date, end = end_date, \n                        initialize = initialize, \n                        analyze = analyze, \n                        handle_data = handle_data, \n                        capital_base = 10000, \n                        data_frequency = 'daily', \n                        bundle ='quandl')\n```"]