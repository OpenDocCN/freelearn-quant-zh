- en: Chapter 6. Exploring Volatility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about volatility and using numerical methods
    in F# to explore the properties of options. We'll solve for the intrinsic volatility,
    called implied volatility, in the Black-Scholes model using the code from the
    previous chapter and extending it with numerical methods covered in [Chapter 3](ch03.html
    "Chapter 3. Financial Mathematics and Numerical Analysis"), *Financial Mathematics
    and Numerical Analysis*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: Actual volatility and implied volatility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using F# to calculate actual volatility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving for implied volatility in Black-Scholes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using numerical methods for options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delta hedging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Briefly about volatility arbitrage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to volatility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter we looked at the basics behind Black-Scholes for European
    options. We'll continue to explore options in this chapter and look at volatility
    and how to use F# to help us out. Volatility measures changes in price as annualized
    standard deviation, which is the rate at which the price of a financial instrument
    fluctuates up or down. Higher volatility means larger dispersion and lower volatility
    means, of course, smaller dispersion. Volatility relates to variance and variance
    equals the square of the standard deviation, as covered previously.
  prefs: []
  type: TYPE_NORMAL
- en: Black-Scholes assumes normal distributed movements in stock prices, which is
    not really the case in reality according to observations. In real life, the distribution
    is more fat-tailed, which means that negative price movements tend to be larger
    when they occur, but positive movements are more common, and smaller on average.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to volatility](img/4623OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: Courtesy of Yahoo! Finance. Shows S&P 500 Index with low volatility
    (9.5 % annualized) and Apple with high volatility (31 % annualized)'
  prefs: []
  type: TYPE_NORMAL
- en: Actual volatility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actual volatility is the current observed volatility over a specific period
    of time, typically the last month or year. Actual volatility uses the current
    market price and several previous observations. In simple terms, it is the standard
    deviation of the logarithmic returns of a series of today's and existing price
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Implied volatility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implied volatility is the volatility encapsulated in option prices. If we use
    Black-Scholes, we need to provide several inputs: stock price, strike price, risk
    free interest rate, volatility, and time to expiration. This will output a theoretical
    price for that option in terms of the assumptions made. We can use Black-Scholes
    backwards to get the implied volatility. That means we can extract the volatility
    from the market price of that option if it''s traded on an exchange as a fair
    market price. Doing so requires us to use a numerical method for root solving,
    which has been covered in the chapter about numerical analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: Implied volatility using current prices will solve for implied volatility in
    the Black-Scholes model using a bisection solver, which we will study in a later
    section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring volatility in F#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at a sample program in F# that will cover some aspects of volatility
    and how to calculate the volatility from real market data. We''ll look at some
    tech stocks from NASDAQ and calculate the annualized volatility for each of them.
    First, we need to define a function to do the calculations. Annualized volatility
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring volatility in F#](img/4623OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Where **P** is the time period in years, ![Exploring volatility in F#](img/4623OS_06_03.jpg)
    is the annualized volatility, and ![Exploring volatility in F#](img/4623OS_06_04.jpg)
    is the standard deviation during the time period **P**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we use **P** as ![Exploring volatility in F#](img/4623OS_06_05.jpg), this
    means we can rewrite the formula as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring volatility in F#](img/4623OS_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We start by using the function to calculate the standard deviation as mentioned
    in [Chapter 3](ch03.html "Chapter 3. Financial Mathematics and Numerical Analysis"),
    *Financial Mathematics and Numerical Analysis*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then we need a function to calculate the logarithmic returns. This is done using
    the `Seq.pairwise` function, since we need a window of size 2\. This is the same
    as using the `Seq.windowed` function with a size of 2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, we have our function to calculate annualized volatility
    from the return series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This function uses the mathematical equation described previously, with the
    number of days squared and multiplied by the standard deviation for the return
    series. This can be interpreted as a scaling factor.
  prefs: []
  type: TYPE_NORMAL
- en: 'These functions are the main building blocks we need to proceed with. The next
    step is to reuse the functionality to obtain prices from Yahoo! Finance, slightly
    modified to use the preceding functions. Next, we introduce two helper functions.
    The first is to format a number as a string with a leading zero if the number
    is smaller than ten. The second function is to help us construct the URL needed
    to request data from Yahoo! Finance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try it out with a few stocks from NASDAQ using F# Interactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding code can be summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Symbol | Name | Annualized volatility |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| MSFT | Microsoft Corp. | 21.30 percent |'
  prefs: []
  type: TYPE_TB
- en: '| ORCL | Oracle | 20.44 percent |'
  prefs: []
  type: TYPE_TB
- en: '| GOOG | Google Inc. | 14.80 percent |'
  prefs: []
  type: TYPE_TB
- en: '| EBAY | eBay | 20.82 percent |'
  prefs: []
  type: TYPE_TB
- en: '| AAPL | Apple Computer | 25.16 percent |'
  prefs: []
  type: TYPE_TB
- en: '| AMZN | Amazon | 21.10 percent |'
  prefs: []
  type: TYPE_TB
- en: '| ^GSPC | S&P 500 | 9.15 percent |'
  prefs: []
  type: TYPE_TB
- en: From the preceding table, we can see and compare annualized volatility for the
    selected stocks and the S&P 500 index. It's clear from the data which one has
    the highest respectability and the lowest volatility. AAPL and ^GSPC are compared
    in *Figure 1* in the introduction of this chapter. Sometimes, volatility can tell
    you something about the risk involved in investing in that particular instrument.
    But keep in mind that this data is historical and will not interpret the future
    price movements of an instrument.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Following is the code listing for the entire program used earlier. You can
    modify the parameters to the Yahoo! Finance web service that returns CSV data.
    The parameters are a, b, c for the `from-date` parameter and d, e, f for the `to-date`
    parameter together with the symbol of the stock, see the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| s | Stock symbol | MSFT |'
  prefs: []
  type: TYPE_TB
- en: '| d | To month of year | 07 |'
  prefs: []
  type: TYPE_TB
- en: '| e | To day of month | 29 |'
  prefs: []
  type: TYPE_TB
- en: '| f | To year | 2013 |'
  prefs: []
  type: TYPE_TB
- en: '| a | From month of year | 00 |'
  prefs: []
  type: TYPE_TB
- en: '| b | To day of month | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| c | To year | 2013 |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s have a look at an example where we downloaded data from Yahoo! for a
    couple of stocks listed on NASDAQ as well as the S&P500 index. We''ll look at
    a timespan from January 01, 2013 to August 2, 2013:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this section we looked at actual volatility for some instruments using data
    from Yahoo! Finance. In the next section we'll look into implied volatility and
    how to extract that information from the Black-Scholes formula.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about implied volatility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we'll use the bisection method introduced in [Chapter 3](ch03.html "Chapter 3. Financial
    Mathematics and Numerical Analysis"), *Financial Mathematics and Numerical Analysis*.
    This is a numerical method for finding roots. The implied volatility is the root
    where the function value is zero for the Black-Scholes function for different
    input parameters. The volatility of an underlying instrument is the input to Black-Scholes
    which gives the same price as the current price of the option.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vega** tells us about the sensitivity in the option price for the changes
    in the volatility of the underlying asset. Look at Yahoo! Finance and find the
    option data. Take that option data into the following solve function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Learning about implied volatility](img/4623OS_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: The VIX-index for the S&P500 index options from 2000-01-01 to 2013-11-01'
  prefs: []
  type: TYPE_NORMAL
- en: The VIX-index, as seen in the preceding screenshot, is an index which combines
    the implied volatility of S&P 500 index options. This can be interpreted as an
    indication of future volatility.
  prefs: []
  type: TYPE_NORMAL
- en: Solving for implied volatility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next we'll use a method for solving for implied volatility for European options.
    This can be done by numerically solving for the root using the bisection method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to understand why we use the bisection solver to find the root of
    the Black-Scholes equation, we need some tools. First we recapture the definition
    of the call and put price as a function of the estimated volatility and a set
    of parameters (denoted):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving for implied volatility](img/4623OS_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To extract the implied volatility, we need an inverse function of the Black-Scholes
    formula. Unfortunately, there is no analytical inverse of that function. Instead,
    we can say that the Black-Scholes formula, with the implied volatility minus the
    current market price of that option, has a call option in this case of zero. Following
    ![Solving for implied volatility](img/4623OS_06_09.jpg) is the current market
    price for the call option studied in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving for implied volatility](img/4623OS_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This enables us to use a numerical root solver to find the implied volatility.
    Following is an implementation of the bisection solver in F#. We'll also use the
    earlier Black-Scholes implementation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding code will result in an implied volatility of 0.3408203125,
    approximately 34.1 percent volatility. Note that we have to subtract for the current
    market price of the option (`1.2753`) as well, because we are solving for roots.
    The last three inputs are the start and stop values, `0.0` and `1.0` means 0 percent
    and 100 percent respectively in terms of volatility. The stepping size is set
    to be 0.001, which is 0.1 percent. A simple way to test whether the values are
    correct is to first use the Black-Scholes formula using an actual volatility to
    get a theoretical price for that option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have a call option with a strike of $75.00, stock price of
    $73.00, 20 days to maturity (approximately 0.05475 years), a volatility of 15
    percent, and a fixed rate of 0.01 percent; this will result in an option price
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use this price to see if the bisection method works and solve for
    the implied volatility. In this case we can expect an implied volatility to be
    exactly the same as the volatility we put into the Black-Scholes formula; that
    is 15 percent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Delta hedging using Black-Scholes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A delta neutral portfolio is constructed by an option and the underlying instrument.
    The portfolio will, in theory, be immune against small changes in the underlying
    price. When talking about delta hedging, the hedge ratio of a derivative is used
    to define the amount of underlying price needed for each option. Delta hedging
    is the trading strategy that maintains a delta neutral portfolio for small changes
    in the underlying price.
  prefs: []
  type: TYPE_NORMAL
- en: 'Briefly, let''s look at how to do this in practice. Suppose we have N derivatives.
    This needs to be hedged to protect against price movements. We then need to buy
    the underlying stock to create the hedge. The whole procedure can be described
    in three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: N derivatives need to be delta hedged
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Buy underlying stock to protect derivatives
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rebalance hedge position on a regular basis
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To determine how many stocks we need, we use the delta of the option, Δ. This
    tells us how much the option price changes for a change in price of the underlying
    price. The portfolio uses ![Delta hedging using Black-Scholes](img/Image1673.jpg)
    shares to be delta neutral; often there are 100 shares for each options contract.
  prefs: []
  type: TYPE_NORMAL
- en: The price of the underlying stock is constantly fluctuating, which leads to
    changes in the option prices. This means we also have to rebalance our portfolio.
    This is due to the time value of options and the change in the underlying price.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use F# to calculate the number of stocks we need for a particular option
    to delta hedge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If we evaluate the last row, we'll obtain the number of shares needed to create
    a delta neutral hedge with 100 calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The answer is approximately 4880 shares needed to hedge the call options.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the volatility smile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The volatility smile is a phenomenon frequently observed in the markets. This
    phenomenon is mostly explained by the assumptions made in the Black-Scholes formula.
    Black-Scholes assumes constant volatility throughout the life of an option. If
    the Black-Scholes formula was corrected for this behavior, by taking into account
    the nature of volatility being non-constant, we would end up with a flat volatility
    surface.
  prefs: []
  type: TYPE_NORMAL
- en: Further, the volatility smile describes the volatility for a certain price of
    the option relative to the strike price of the same. The volatility surface is
    often referring to a three-dimensional graph of the volatility smile, where time
    to maturity and moneyness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moneyness is the ratio between the spot price of the underlying asset, S, and
    the strike price of the option, K:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the volatility smile](img/4623OS_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we'll look at how to use F# to provide a graph for us where the volatility
    smile is computed from parametric regression from real market data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following data is from Ericsson B options, from the OMX exchange in Sweden:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the volatility smile](img/4623OS_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Volatility smile for a warrant'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following screenshot, the smile comes from the different
    implied volatility for the strike prices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the volatility smile](img/4623OS_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Volatility smile as points from market data'
  prefs: []
  type: TYPE_NORMAL
- en: We can use polynomial regression to estimate the volatility smile from the points
    in the graph. This method was introduced in [Chapter 3](ch03.html "Chapter 3. Financial
    Mathematics and Numerical Analysis"), *Financial Mathematics and Numerical Analysis*;
    we'll build on the code from there. The polynomial will be of order two, which
    means a second degree polynomial, that will describe the expected volatility smile
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an application that will produce the plot in *Figure 5* using
    Math.NET and FSharpChart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our data in a tuple, we''ll use the spot price of the underlying
    price, which was 83.2 at the time the data was collected. The mlist is the list
    of the converted tuples with moneyness calculated for each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to reproduce the previous plot, you can run the following line
    in F# Interactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to calculate the regression coefficients and use these to
    calculate the points for our curve. Then we will use a combined plot with the
    points and the fitted curve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the code line to produce the combined plot with a title. The result
    will look as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![Exploring the volatility smile](img/4623OS_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Volatility smile with polynomial regression curve'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked into using F# for investigating different aspects
    of volatility. Volatility is an interesting dimension of finance where you quickly
    dive into complex theories and models. Here it's very much helpful to have a powerful
    tool such as F# and F# Interactive. We've just scratched the surface of options
    and volatility in this chapter. There is a lot more to cover, but that's outside
    the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the content here will be used in the trading system that we will develop
    in the following chapters of this book. In the next chapter, we''ll begin to look
    at the first pragmatic building blocks of our trading system: orders and order
    types. We''ll also cover some aspects of pre-trade risk and how F# can help us
    model these.'
  prefs: []
  type: TYPE_NORMAL
