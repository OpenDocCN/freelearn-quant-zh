["```py\n/// Order side\ntype OrderSide =\n    Buy | Sell | Sellshort\n```", "```py\n/// Order type\ntype OrderType = \n    Market | Limit | Stop | StopLimit\n```", "```py\ntype OrderStatus = \n    Created | New | Filled | PartiallyFilled | DoneForDay | Cancelled| Replaced | PendingCancel | Stopped | Rejected | Suspended | PendingNew | Calculated | Expired\n```", "```py\ntype Tif = \n    GoodForDay | GoodTilCancelled | ImmediateOrCancel | FillorKill\n```", "```py\n/// Validation result, ok or failed with message\ntype Result = Valid of Order | Error of string\n```", "```py\n/// Order class\ntype Order(side: OrderSide, t: OrderType, p: float, tif: Tif, q: int, i: string, sp: float) =\n    // Init order with status created\n    let mutable St = OrderStatus.Created\n    let mutable S = side\n    member private this.Ts = System.DateTime.Now\n    member private this.T = t\n    member private this.P = p\n    member private this.tif = tif\n    member private this.Q = q\n    member private this.I = i\n    member private this.Sp = sp\n\n    member this.Status\n        with get() = St\n        and set(st) = St <- st\n\n    member this.Side\n        with get() = S\n        and set(s) = S <- s\n\n    member this.Timestamp\n        with get() = this.Ts\n\n    member this.Type\n        with get() = this.T\n\n    member this.Qty\n        with get() = this.Q\n\n    member this.Price\n        with get() = this.P\n\n    member this.Tif\n        with get() = this.tif\n\n    member this.Instrument\n        with get() = this.I\n\n    member this.StopPrice\n        with get() = this.Sp\n\n    member this.toggleOrderSide() =\n        S <- this.toggleOrderSide(S)\n\n    member private this.toggleOrderSide(s: OrderSide) =\n        match s with\n        | Buy -> Sell\n        | Sell -> Buy\n        | Sellshort -> Sellshort\n\n    static member (~-) (o : Order) =\n        Order(o.toggleOrderSide(o.Side), o.Type, o.Price, o.tif, o.Q,o.I, o.Sp)\n```", "```py\n      // Limit buy order\nlet buyOrder = Order(OrderSide.Buy, OrderType.Limit, 54.50, Tif.FillorKill, 100, \"MSFT\", 0.0)       \n```", "```py\nval it : Order = FSI_0050+Order {Instrument = \"MSFT\";\n                                 Price = 54.5;\n                                 Qty = 100;\n                                 Side = Buy;\n                                 Status = Created;\n                                 StopPrice = 0.0;\n                                 Tif = FillorKill;\n                                 Timestamp = 2013-09-14 12:01:57;\n                                 Type = Limit;}\n```", "```py\n/// Validates an order for illustrative purposes\nlet validateOrder (result:Result) : Result= \n    match resultwith\n    | Error s -> Error s\n    | Valid order ->\n        let orderType = order.Type\n        let orderPrice = order.Price\n        let stopPrice = order.StopPrice    \n        match orderType with\n        | OrderType.Limit -> \n            match orderPrice with       \n            | p when p > 0.0 -> Valid order\n            | _ -> Error \"Limit orders must have a price > 0\"\n        | OrderType.Market -> Valid order\n        | OrderType.Stop -> \n            match stopPrice with        \n            | p when p > 0.0 -> Valid order\n            | _ -> Error \"Stop orders must have price > 0\"\n        | OrderType.StopLimit ->\n            match stopPrice with\n            | p when p > 0.0 && orderPrice > 0.0 -> Valid order\n            | _ -> Error \"Stop limit orders must both price > 0 and stop price > 0\"\n```", "```py\n    // Limit buy order\n    let buyOrder = Order(OrderSide.Buy, OrderType.Limit, 54.50, Tif.FillorKill, 100, \"MSFT\", 0.0)\n\n    // Limit buy order, no price\n    let buyOrderNoPrice = Order(OrderSide.Buy, OrderType.Limit, 0.0, Tif.FillorKill, 100, \"MSFT\", 0.0)\n\n    // Stop order that will be converted to limit order, no limit price\n    let stopLimitNoPrice = Order(OrderSide.Buy, OrderType.StopLimit, 0.0, Tif.FillorKill, 100, \"MSFT\", 45.50)\n\n    // Stop order that will be converted to market order\n    let stopNoPrice = Order(OrderSide.Buy, OrderType.Stop, 0.0, Tif.FillorKill, 100, \"MSFT\", 45.50)\n    ```", "```py\n    // Validate sample orders\n    validateOrder (Valid buyOrder) // Ok\n    validateOrder (Valid buyOrderNoPrice) // Failed\n    validateOrder (Valid stopLimitNoPrice) // Failed\n    validateOrder (Valid stopNoPrice) // Ok\n    ```", "```py\n    let validateInstrument (result:Result) : Result =\n        match result with\n        | Error l -> Error l\n        | Valid order ->\n            let orderInstrument = order.Instrument\n            match orderInstrument.Length with\n            | l when l > 0 -> Valid order \n            | _ -> Error \"Must specify order Instrument\"\n    ```", "```py\n    > validateInstrument (Valid stopNoPriceNoInstrument);;\n    val it : Result = Error \"Must specify order Instrument\"\n    ```", "```py\n    /// Composite validator\n    let validateOrderAndInstrument = validateOrder >> validateInstrument\n    ```", "```py\n    // Stop order that will be converted to market order\n    let stopNoPriceNoInstrument = Order(OrderSide.Buy, OrderType.Stop, 0.0, Tif.FillorKill, 100, \"\", 45.50)\n\n    validateOrderAndInstrument (Valid stopNoPriceNoInstrument)\n    ```", "```py\ntype OrderStatus = \n    Created | New | Filled | PartiallyFilled | DoneForDay | Cancelled | Replaced | PendingCancel | Stopped | Rejected | Suspended | PendingNew | Calculated | Expired\n```", "```py\nType Quote =\n{ \n   bid : float\n   ask : float\n} member this.midpoint() = (this.bid + this.ask) / 2.0\n```", "```py\nlet q = {bid = 1.40; ask = 1.45} : Quote\n```", "```py\n> q.midpoint();;\nval it : float = 1.425\n```", "```py\ntype Quote =\n    {\n        bid : float\n        ask : float\n    }\n    member this.midpoint() = (this.bid + this.ask) / 2.0\n    member this.spread() = abs(this.bid - this.ask)\n\nlet q2 = {bid = 1.42; ask = 1.48} : Quote\n\n> q2.midpoint();;\nval it : float = 1.45\n> q2.spread();;\nval it : float = 0.06\n```", "```py\n// Often data is just sent from the feed handler, as bid or ask\ntype LightQuote = \n    | Bid of float | Ask of float\n\nlet lqb = Bid 1.31\nlet lqa = Ask 1.32\n```", "```py\nlet orderValueMax = 25000.0; // Order value max of $25,000\n\n/// A simple pre trade risk rule\nlet preTradeRiskRuleOne (result:Result) : Result =\n    match result with\n    | Error l -> Error l\n    | Valid order ->\n        let orderValue = (float order.Qty) * order.Price\n        match orderValue with\n        | v when orderValue > orderValueMax -> Error \"Order value exceeded limit\"\n        | _ -> Valid order\n```", "```py\n// Using currying\nlet preTradeRiskRuleTwo (marketPrice:float) (result:Result) : Result =\n    match result with\n    | Error l -> Error l\n    | Valid order ->\n        let orderLimit = (float order.Qty) * order.Price\n        match orderLimit with\n        | v when orderLimit < marketPrice && order.Side = OrderSide.Buy -> Error \"Order limit price below market price\"\n        | v when orderLimit > marketPrice && order.Side = OrderSide.Sell -> Error \"Order limit price above market price\"\n        | _ -> Valid order\n```", "```py\nlet validateOrderAndInstrumentAndPreTradeRisk = validateOrderAndInstrument >> preTradeRiskRuleOne\n\nlet validateOrderAndInstrumentAndPreTradeRisk2 marketPrice = validateOrderAndInstrument >> preTradeRiskRuleOne >> (preTradeRiskRuleTwo marketPrice)\n\nvalidateOrderAndInstrumentAndPreTradeRisk (Valid stopNoPriceNoInstrument)\nvalidateOrderAndInstrumentAndPreTradeRisk (Valid buyOrderExceetsPreTradeRisk)\nvalidateOrderAndInstrumentAndPreTradeRisk2 25.0 (Valid buyOrderBelowPricePreTradeRisk)\n```", "```py\n/// Chain using List.reduce\nlet preTradeRiskRules marketPrice = [\n    preTradeRiskRuleOne\n    (preTradeRiskRuleTwo marketPrice)\n    ]\n\n/// Create function composition using reduce, >>, composite operator\nlet preTradeComposite = List.reduce (>>) (preTradeRiskRules 25.0)\n\npreTradeComposite (Valid buyOrderExceetsPreTradeRisk)\npreTradeComposite (Valid buyOrderBelowPricePreTradeRisk)\n```", "```py\n[DEFAULT]\nConnectionType=initiator\nReconnectInterval=60\nSenderCompID=TRADINGSYSTEM\n\n[SESSION]\nBeginString=FIX.4.2\nTargetCompID=FIXIMULATOR\nStartTime=00:00:00\nEndTime=00:00:00\nHeartBtInt=30\nReconnectInterval=10\nSocketConnectPort=9878\nSocketConnectHost=192.168.0.25\nFileStorePath=temp\nValidateUserDefinedFields=N\n\nResetOnLogon=Y \nResetOnLogout=Y \nResetOnDisconnect=Y\n```", "```py\nnamespace FIX\n\n    open Systemopen System.Globalization\n    open QuickFix\n    open QuickFix.Transport\n    open QuickFix.FIX42\n    open QuickFix.Fields\n```", "```py\nmodule FIX =\n    type ClientInitiator() =\n        interface IApplication with\n            member this.OnCreate(sessionID : SessionID) : unit = printfn \"OnCreate\"\n            member this.ToAdmin(msg : QuickFix.Message, sessionID : SessionID) : unit = printf \"ToAdmin\"\n            member this.FromAdmin(msg : QuickFix.Message, sessionID : SessionID) : unit = printf \"FromAdmin\"\n            member this.ToApp(msg : QuickFix.Message, sessionID : SessionID) : unit = printf \"ToApp\"\n            member this.FromApp(msg : QuickFix.Message, sessionID : QuickFix.SessionID) : unit = printfn\"FromApp -- %A\" msg\n            member this.OnLogout(sessionID : SessionID) : unit = printf \"OnLogout\"\n            member this.OnLogon(sessionID : SessionID) : unit = printf \"OnLogon\"\n```", "```py\ntype ConsoleLog() =\n    interface ILog with\t\n        member this.Clear() : unit = printf \"hello\"\n        member this.OnEvent(str : string) : unit = printfn \"%s\" str\n        member this.OnIncoming(str : string) : unit = printfn \"%s\" str\n        member this.OnOutgoing(str : string) : unit = printfn \"%s\" str\n\ntype ConsoleLogFactory(settings : SessionSettings) =\n    interface ILogFactory with\n        member this.Create(sessionID : SessionID) : ILog = new NullLog() :> ILog\n```", "```py\ntype FIXEngine() =\n    let settings = new SessionSettings(@\"conf\\config.cfg\")\n    let application = new ClientInitiator()\n    let storeFactory = FileStoreFactory(settings)\n    let logFactory = new ConsoleLogFactory(settings)\n    let messageFactory = new MessageFactory()\n    let initiator = new SocketInitiator(application, storeFactory, settings)\n    let currentID = initiator.GetSessionIDs() |> Seq.head\n        member this.init() : unit =\n            ()\n        member this.start() : unit =\n            initiator.Start()\n        member this.stop() : unit =\n            initiator.Stop()\n```", "```py\nlet fixEngine = new FIX.FIXEngine()\nfixEngine.init()\nfixEngine.start()\n```", "```py\nmember this.sendTestLimitOrder() : unit =\n   let fixOrder = new NewOrderSingle()\n   fixOrder.Symbol <- new Symbol(\"ERICB4A115\")\n   fixOrder.ClOrdID <- new ClOrdID(DateTime.Now.Ticks.ToString())fixOrder.OrderQty <- new OrderQty(decimal 50)\n   fixOrder.OrdType <- new OrdType('2'); // Limit order\n   fixOrder.Side <- new Side('1');\n   fixOrder.Price <- new Price(decimal 25.0);\n   fixOrder.TransactTime <- new TransactTime();\n   fixOrder.HandlInst <- new HandlInst('2');\n   fixOrder.SecurityType <- new SecurityType(\"OPT\"); // Option                \n   fixOrder.Currency <- new Currency(\"USD\");                \n   // Send order to target\nSession.SendToTarget(fixOrder, currentID) |> ignore\n```", "```py\nlet fixEngine = new FIX.FIXEngine()\nfixEngine.init()\nfixEngine.start()\nfixEngine.sendTestLimitOrder()\n```", "```py\nmember this.FromApp(msg : QuickFix.Message, sessionID : QuickFix.SessionID) : unit =\n   match msg with\n   | :? ExecutionReport as report ->\n          match report.OrdStatus.getValue() with\n          | OrdStatus.NEW -> printfn \"ExecutionReport (NEW) %A\" report\n          | OrdStatus.FILLED -> printfn \"ExecutionReport (FILLED) %A\" report\n          | OrdStatus.PARTIALLY_FILLED -> printfn \"ExecutionReport (PARTIALLY_FILLED) %A\" report\n          | OrdStatus.CANCELED -> printfn \"ExecutionReport (CANCELED) %A\" report\n          | OrdStatus.REJECTED -> printfn \"ExecutionReport (REJECTED) %A\" report\n          | OrdStatus.EXPIRED -> printfn \"ExecutionReport (EXPIRED) %A\" report\n          | _ -> printfn \"ExecutionReport (other) %A\" report\n   | _ -> ()\n```", "```py\n    ExecutionReport (NEW) seq [[6, 0]; [11, 1]; [14, 0]; [17, E1385238452777]; ...]\n    ```", "```py\n    ExecutionReport (CANCELED) seq [[6, 0]; [11, 1]; [14, 0]; [17, E1385238572409]; ...]\n    ```", "```py\nExecutionReport (PARTIALLY_FILLED) seq [[6, 25]; [11, 1]; [14, 50]; [17, E1385238734808]; ...]\nExecutionReport (FILLED) seq [[6, 24.5]; [11, 1]; [14, 100]; [17, E1385238882881]; ...]\n```", "```py\n| OrdStatus.NEW -> \n   printfn \"ExecutionReport (NEW) %A\" report\n   orders |> Seq.find (fun order -> order.Timestamp.ToString() = report.ClOrdID.getValue()) |> (fun order -> order.Status <- OrderStatus.New)\n```", "```py\n/// Use a list of NewOrderSingle as first step\nlet orders = new BindingList<Order>()\nlet fixEngine = new FIX.FIXEngine(orders)\nfixEngine.init()\nfixEngine.start()\nlet buyOrder1 = Order(OrderSide.Buy, OrderType.Limit, 24.50, Tif.GoodForDay, 100, \"ERICB4A115\", 0.0)\nlet buyOrder2 = Order(OrderSide.Buy, OrderType.Limit, 34.50, Tif.GoodForDay, 100, \"ERICB4A116\", 0.0)\nlet buyOrder3 = Order(OrderSide.Buy, OrderType.Limit, 44.50, Tif.GoodForDay, 100, \"ERICB4A117\", 0.0)\nfixEngine.sendOrder(buyOrder1)\nfixEngine.sendOrder(buyOrder2)\nfixEngine.sendOrder(buyOrder3)\n```", "```py\nmember this.sendOrder(order:Order) : unit =                \n   let fixOrder = new NewOrderSingle()\n   /// Convert to Order to NewOrderSingle\n   fixOrder.Symbol <- new Symbol(order.Instrument)\n   fixOrder.ClOrdID <- new ClOrdID(order.Timestamp.ToString())\n   fixOrder.OrderQty <- new OrderQty(decimal order.Qty)\n   fixOrder.OrdType <- new OrdType('2'); /// TODO\n   fixOrder.Side <- new Side('1');\n   fixOrder.Price <- new Price(decimal order.Price);\n   fixOrder.TransactTime <- new TransactTime();\n   fixOrder.HandlInst <- new HandlInst('2');\n   fixOrder.SecurityType <- new SecurityType(\"OPT\"); /// TODO      \n   fixOrder.Currency <- new Currency(\"USD\"); /// TODO\n   /// Add to OMS\n   orders.Add(order)\n   /// Send order to target\n   Session.SendToTarget(fixOrder, currentID) |> ignore\n```", "```py\n{Instrument = \"ERICB4A115\";\n OrderId = \"635208412525809991\";\n Price = 24.5;\n Qty = 100;\n Side = Buy;\n Status = Created;\n StopPrice = 0.0;\n Tif = GoodForDay;\n Timestamp = 2013-11-23 22:09:31;\n Type = Limit;}\n…\n```", "```py\n{Instrument = \"ERICB4A115\";\nOrderId = \"635208412525809991\";\nPrice = 24.5;\nQty = 100;\nSide = Buy;\nStatus = New;\nStopPrice = 0.0;\nTif = GoodForDay;\nTimestamp = 2013-11-23 22:09:31;\nType = Limit;}\n```", "```py\nmember this.findOrder str = \n   try \n      Some (orders |> Seq.find (fun o -> o.Timestamp = str))\n   with | _ as ex -> printfn \"Exception: %A\" ex.Message; None\n\nmember this.FromApp(msg : QuickFix.Message, sessionID : QuickFix.SessionID) : unit =\nmatch msg with\n| :? ExecutionReport as report ->\n   let qty = report.CumQty\n   let avg = report.AvgPx\n   let sta = report.OrdStatus\n   let oid = report.ClOrdID\n   let lqty = report.LeavesQty\n   let eqty = report.CumQty\n\nlet debug = fun str -> printfn \"ExecutionReport (%s) # avg price: %s | qty: %s | status: %s | orderId: %s\" str (avg.ToString()) (qty.ToString()) (sta.ToString()) (oid.ToString())\n\n   match sta.getValue() with\n   | OrdStatus.NEW ->                            \n         match this.findOrder(oid.ToString()) with\n         | Some(o) ->\n               o.Status <- OrderStatus.New\n         | _ -> printfn \"ERROR: The order was not found in OMS\"\n         debug \"NEW\"\n```", "```py\n   | OrdStatus.FILLED ->\n         /// Update avg price, open price, ex price\n         match this.findOrder(oid.ToString()) with\n         | Some(o) ->\n                o.Status <- OrderStatus.Filled\n                o.AveragePrice <- double (avg.getValue())\n                o.OpenQty <- int (lqty.getValue())\n                o.ExecutedQty <- int (eqty.getValue())\n          | _ -> printfn \"ERROR: The order was not found in OMS\"\n          debug \"FILLED\"\n```", "```py\n   | OrdStatus.PARTIALLY_FILLED ->                   \n         /// Update avg price, open price, ex price\n         match this.findOrder(oid.ToString()) with\n         | Some(o) ->\n               o.Status <- OrderStatus.PartiallyFilled\n               o.AveragePrice <- double (avg.getValue())\n               o.OpenQty <- int (lqty.getValue())\n               o.ExecutedQty <- int (eqty.getValue())\n         | _ -> printfn \"ERROR: The order was not found in OMS\"\n         debug \"PARTIALLY_FILLED\"\n```", "```py\n   | OrdStatus.CANCELED ->\n          match this.findOrder(oid.ToString()) with\n          | Some(o) ->\n                o.Status <- OrderStatus.Cancelled\n         | _ -> printfn \"ERROR: The order was not found in OMS\"\n         debug \"CANCELED\"\n   | OrdStatus.REJECTED ->                             \n         match this.findOrder(oid.ToString()) with\n         | Some(o) ->\n                o.Status <- OrderStatus.Rejected\n         | _ -> printfn \"ERROR: The order was not found in OMS\"\n         debug \"REJECTED\"\n   | OrdStatus.REPLACED ->\n         match this.findOrder(oid.ToString()) with\n         | Some(o) ->\n               o.Status <- OrderStatus.Replaced                                \n         | _ -> printfn \"ERROR: The order was not found in OMS\"\n         debug \"REPLACED\"\n   | OrdStatus.EXPIRED -> \n         printfn \"ExecutionReport (EXPIRED) %A\" report\n   | _ -> printfn \"ExecutionReport (other) %A\" report\n| _ -> ()\n```", "```py\n{AveragePrice = 0.0;\nExecutedQty = 0;\nInstrument = \"ERICB4A115\";\nOpenQty = 0;\nPrice = 24.5;\nQty = 100;\nSide = Buy;\nStatus = Cancelled;\n...\n\n{AveragePrice = 23.0;\nExecutedQty = 100;\nInstrument = \"ERICB4A116\";\nOpenQty = 0;\nPrice = 34.5;\nQty = 100;\nSide = Buy;\nStatus = Filled;\n...\n\n{AveragePrice = 24.5;\nExecutedQty = 100;\nInstrument = \"ERICB4A117\";\nOpenQty = 0;\nPrice = 44.5;\nQty = 100;\nSide = Buy;\nStatus = Filled;\n...\n```"]