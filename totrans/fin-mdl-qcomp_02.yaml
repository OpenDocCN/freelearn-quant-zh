- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Derivative Valuation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Derivatives pricing is one of the most crucial aspects of quantitative finance.
    The gross market value of derivatives contracts stood at $12.4 trillion (*OTC
    derivatives statistics at end-December 2021* – [bis.org](http://bis.org)), making
    it one of the most lucrative and challenging problems to simulate and optimize.
    Although many aspects of derivative pricing can be computed using classical computing,
    gate-based quantum computers can be an efficient resource when multiple computations
    are required, due to their ability to parallelize and handle multiple assets.
    This chapter looks into the theoretical aspects of derivatives pricing and examines
    its real-time applications through classical computing and gate-based quantum
    computers.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter addresses the need to explain option pricing from a layman’s point
    of view. Various aspects of option pricing will be described in an easy-to-understand
    manner. Different case studies and anecdotes will be incorporated to make the
    explanation more comprehensive and detailed. The first part covers the theoretical
    aspects of derivatives pricing, while the practical aspects of transitioning to
    more complicated **Quantum Machine Learning** (**QML**) models are also introduced.
  prefs: []
  type: TYPE_NORMAL
- en: In subsequent sections, we will see a demo example of implementing options pricing
    using classical and quantum computing. The valuation of a plain vanilla option
    will be derived using the classical Monte Carlo simulation method. Afterward,
    a comprehensive case study with code snippets will help you understand the implementation
    of mathematical modeling of derivatives pricing on quantum computing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Derivatives pricing – the theoretical aspects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classical implementation of the Monte Carlo simulation for derivatives valuation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quantum computing algorithm for derivatives valuation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derivatives pricing – the theoretical aspects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning the factors that go into setting derivatives pricing is crucial. An
    in-depth knowledge of financial product pricing is essential to make sound investing
    decisions, whether you’re on the buying or selling side of the market. After all,
    knowing how a product’s attributes interact to produce value is necessary to decide
    what to offer or bid for a financial product. It is crucial to comprehend the
    price of financial assets. The capital asset pricing model and its variants, based
    on discounted cash flow, help establish values for financial assets. However,
    unlike traditional assets such as stocks and bonds, derivatives have their challenges,
    but they also have several unexpectedly straightforward properties. In the next
    section, we will discuss the important concept of money’s time value, which forms
    the basis for securities pricing.
  prefs: []
  type: TYPE_NORMAL
- en: The time value of money
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The value of money fluctuates over time. What does this imply in detail? If
    you had the choice between getting $100 now or $100 a year from now, which would
    you choose? The majority would probably get the $100 as quickly as feasible (today).
    The further a cash flow is in the future, the less valuable it becomes. A similar
    approach may be extended to compare the values of cash flows at various times.
    Let’s say we want to get $100 one year instead of two years from now. Mathematically,
    a risk-free interest rate is to blame for the temporal variation in the value
    of money. The quicker funds are received, the quicker interest may be collected.
    Calculating the present value of the cash flows and comparing them makes it possible
    to compare various amounts of money at different dates.
  prefs: []
  type: TYPE_NORMAL
- en: Case study one
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The time value of money is a key concept in finance that refers to the idea
    that money today is worth more than the same amount in the future, due to its
    earning potential. This concept is important in many financial decisions, including
    investments, loans, and other transactions. In this essay, we will explore an
    example of the time value of money in the context of a future discounted price,
    with a $450 cash flow for three years at a 10% discount rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming a discount rate of 10%, the present value of a $450 cash flow in three
    years can be calculated using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: PV =  FV _ (1 + r) n
  prefs: []
  type: TYPE_NORMAL
- en: where r represents the discount rate, n refers to the number of periods, and
    PV and FV represent the present and future values respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this formula, we can calculate the present value of a $450 cash flow
    in three years as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: PV =  $450 _ (1 + 0.1) 3
  prefs: []
  type: TYPE_NORMAL
- en: PV = $300.30
  prefs: []
  type: TYPE_NORMAL
- en: This means that the present value of a $450 cash flow in three years at a 10%
    discount rate is $300.30\. In other words, if we were to receive $450 in three
    years and wanted to know how much that cash flow is worth today, we would discount
    it back to its present value of $300.30.
  prefs: []
  type: TYPE_NORMAL
- en: 'The time value of money can also be applied to investments. For example, let’s
    say we can invest $1,000 today in a fund that promises to pay a 10% annual return
    for three years. Using the formula to calculate the future value of a lump sum
    investment, we can calculate the future value of this investment as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: FV = PV × (1 + r) n
  prefs: []
  type: TYPE_NORMAL
- en: FV = $1,000 × (1 + 0.1) 3
  prefs: []
  type: TYPE_NORMAL
- en: FV = $1,331
  prefs: []
  type: TYPE_NORMAL
- en: If we were to invest $1,000 today at a 10% annual return for three years, the
    investment would be worth $1,331 at the end of the third year.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, the time value of money is a fundamental concept in finance that plays
    a crucial role in many financial decisions. Whether calculating the present value
    of future cash flows or the future value of investments, understanding the time
    value of money is essential to make informed financial decisions and manage risk
    effectively. By applying the formulas and concepts discussed in this essay, investors
    can make better financial decisions and achieve their financial goals. The following
    passage will discuss a fundamental concept of securities pricing.
  prefs: []
  type: TYPE_NORMAL
- en: Securities pricing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Securities pricing refers to determining the value of financial instruments
    such as stocks, bonds, options, and other investment products. The price of a
    security reflects the supply and demand for that security in the market, which
    is affected by a wide range of factors, including company performance, economic
    conditions, and investor sentiment.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the price of a security is determined through the interaction of
    buyers and sellers in the market. When there are more buyers than sellers, the
    security price goes up, and when there are more sellers than buyers, the price
    goes down.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several methods used to determine the price of securities, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Market-based pricing**: This is the most common method of pricing securities,
    where the price of a security is determined based on its current market value.
    Market-based pricing is often used for publicly traded securities, where prices
    are determined through bidding and trading on an exchange.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fundamental analysis**: This method involves analyzing a company’s financial
    statements and other relevant information to determine its intrinsic value. Fundamental
    analysis considers revenue, earnings, assets, liabilities, and growth potential
    to determine whether a security is undervalued or overvalued.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technical analysis**: This method involves analyzing price and volume data
    to identify patterns and trends that can be used to predict future price movements.
    Technical analysis is often used with fundamental analysis to make investment
    decisions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Options pricing models**: These models use mathematical formulas to determine
    the fair value of options contracts, based on factors such as the underlying asset
    price, the time to expiration, and the underlying asset’s volatility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these methods, market participants also consider other factors,
    such as interest rates, inflation, geopolitical events, and market sentiment when
    determining the price of securities.
  prefs: []
  type: TYPE_NORMAL
- en: Case study two
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Securities pricing values financial assets such as stocks, bonds, and other
    securities. Market demand, economic conditions, and company performance influence
    securities pricing. Let’s consider an example of securities pricing for a company,
    ABC, that issued a bond with a face value of $1,000 and a coupon rate of 5%, payable
    annually for ten years.
  prefs: []
  type: TYPE_NORMAL
- en: Step one – determine the market interest rate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The market interest rate is the rate of return that investors expect to earn
    on similar securities. Let’s assume that the market interest rate for bonds with
    similar characteristics as ABC’s bond is 6%.
  prefs: []
  type: TYPE_NORMAL
- en: Step two – calculate the present value of the bond
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the market interest rate of 6%, we can calculate the present value of
    the bond using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: PV =  C _ (1 + r) n  +  FV _ (1 + r) n
  prefs: []
  type: TYPE_NORMAL
- en: 'For ABC’s bond, the annual coupon payment is $50 (5% of $1,000 at face value),
    and the bond matures in 10 years. Using these values and the market interest rate
    of 6%, we can calculate the present value of the bond as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: PV =  $50 _ (1 + 0.06) 1  +  $50 _ (1 + 0.06) 2  + … +  $50 _ (1 + 0.06) 10 
    +  $1,000 _ (1 + 0.06) 10
  prefs: []
  type: TYPE_NORMAL
- en: PV =  $50 _ 1.06  +  $50 _ 1.236  + … +  $50 _ 1.791  + $385.54
  prefs: []
  type: TYPE_NORMAL
- en: PV = $850.31
  prefs: []
  type: TYPE_NORMAL
- en: Step three – determine the market price of the bond
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The bond’s market price is the present value of the expected cash flows from
    the bond. In this case, the market price of ABC’s bond is $850.31, which is the
    present value of the annual coupon payments and the face value discounted at the
    market interest rate of 6%.
  prefs: []
  type: TYPE_NORMAL
- en: Step four – compare the market price with the face value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the market price is lower than the face value, the bond sells at a discount,
    and if the market price is higher than the face value, the bond sells at a premium.
    In this case, the market price of ABC’s bond is lower than the face value of $1,000,
    which means the bond sells at a discount.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, securities pricing is a complex process, involving analyzing various factors
    that influence the value of financial assets. By understanding the principles
    of securities pricing and using the appropriate valuation methods, investors can
    make informed decisions about buying and selling securities to maximize their
    returns and manage risk. The following section will discuss the process and methodology
    involving derivatives pricing.
  prefs: []
  type: TYPE_NORMAL
- en: Derivatives pricing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Derivatives pricing is a vital aspect of financial portfolio management. Within
    the vast realm of financial instruments, derivatives, as their name suggests,
    derive value from the asset they are represented by. These assets or securities
    may be represented by stocks, bonds, commodities, or currencies. Derivatives pricing
    involves determining the fair value of these instruments, which can be used for
    trading, hedging, or speculation purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Factors that affect derivatives pricing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Several factors may affect the price of a given derivative. Relevant drivers
    are the price of the underlying asset, the time to expiration, the volatility
    of the underlying asset, and the interest rate. For example, if the price of the
    underlying asset increases, the price of a call option on that asset will also
    increase, while the price of a put option will decrease. Similarly, if the time
    to expiration increases, the price of an option will also increase. The underlying
    asset’s volatility is also a significant factor in pricing derivatives, as higher
    volatility implies a greater chance of the asset moving in the desired direction.
    Finally, the interest rate can affect the price of a derivative, as it can influence
    the cost of borrowing and the opportunity cost of holding the underlying asset.
  prefs: []
  type: TYPE_NORMAL
- en: The methods of derivatives pricing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several types of pricing derivatives, including the Black-Scholes
    model, the binomial option pricing model, and the Monte Carlo simulation. The
    Black-Scholes model is a mathematical model used to price European-style options,
    which assumes that an underlying asset’s price follows a lognormal distribution.
    The binomial option pricing model is a discrete-time model that uses a tree structure
    to represent the possible outcomes of the underlying asset’s price. The Monte
    Carlo simulation is a stochastic model that uses random sampling to simulate the
    underlying asset’s price path and calculate the derivative’s expected value.
  prefs: []
  type: TYPE_NORMAL
- en: The risks involved in derivatives pricing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Derivatives pricing involves several risks, including market, credit, and operational
    risks. Market risk arises from changes in an underlying asset’s price, which can
    affect the value of the derivative. Credit risk arises when one party fails to
    fulfill its obligation to the other party, which can lead to default. Operational
    risk arises from errors in the trading, settlement, or accounting of derivatives,
    which can result in financial losses.
  prefs: []
  type: TYPE_NORMAL
- en: Derivatives pricing is a crucial aspect of financial portfolio management, as
    it allows investors to hedge their risks, speculate on market movements, and create
    customized investment strategies. There are several methods to calculate the price
    of derivatives, including the Black-Scholes model, the binomial option pricing
    model, and the Monte Carlo simulation. However, derivatives pricing also involves
    several risks, including market, credit, and operational risks. Therefore, it
    is essential to thoroughly understand these risks and use appropriate risk management
    strategies to minimize their impact on financial portfolios.
  prefs: []
  type: TYPE_NORMAL
- en: Case study three
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One example of securities pricing is the pricing of a stock option. A stock
    option is a derivative that, without the obligation for it, gives the holder the
    right to buy or sell a specific number of shares of a stock. This is done at a
    contract-binding price (known as the strike price) within a specific time frame.
    The price of a stock, as mentioned, may be affected by a number of factors.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s consider a call option for 100 shares of XYZ Corporation,
    with a strike price of $50 and an expiration date of three months from now. If
    the current market price of XYZ Corporation’s stock is $55, the option would have
    an intrinsic value of $5 per share (the difference between the market price and
    the strike price). However, the option’s price would also be influenced by factors
    such as the time to expiration, the volatility of the stock, and the interest
    rate.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose the stock’s volatility is high, indicating a higher likelihood of significant
    price swings, and the interest rate is low, making it cheaper to borrow money.
    In that case, the option’s price would be higher, due to the increased likelihood
    of the stock price moving in the desired direction, making the option more valuable.
    Conversely, if the stock’s volatility is low and the interest rate is high, the
    option’s price would be lower, since the likelihood of the stock price moving
    in the desired direction is lower. The cost of borrowing money is higher. Overall,
    pricing securities, such as options, involves assessing multiple factors and using
    various pricing models to determine a fair value. The pricing process helps investors
    make informed investment decisions and manage risk effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of securities pricing involves several steps, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identifying the security**: The first step in pricing securities is to identify
    the specific security being priced. This could be a stock, bond, option, or another
    financial instrument.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Gathering information**: Gather all relevant information about the security,
    including its current market price, historical price trends, any news or events
    that may affect its value, and any associated risks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Determining pricing factors**: The price of a security is influenced by several
    factors, including supply and demand, interest rates, economic conditions, and
    market sentiment. Identify the most relevant factors likely to affect the security’s
    price.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Choosing a pricing model**: There are several pricing models used to determine
    the fair value of securities, including the **discounted cash flow** (**DCF**)
    model, the **dividend discount model** (**DDM**), and the Black-Scholes model
    for options. Choose the most appropriate model, based on the type of security
    being priced and the available information.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Calculating the price**: Once the pricing model is chosen, calculate the
    security’s fair value, using the relevant pricing factors and any assumptions
    required by the model. This may involve complex mathematical calculations, especially
    for options and other derivatives.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Evaluating the results**: Evaluate the results of the pricing model and ensure
    that the calculated price is reasonable and consistent with market conditions
    and other available information.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Updating pricing regularly**: Securities pricing is an ongoing process, and
    prices can change rapidly based on new information and market conditions. Regularly
    update the pricing model, and recalculate the security’s price as needed to ensure
    that the investment portfolio is up to date and accurately reflects the value
    of the securities.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This shows that securities pricing is a complex process that involves multiple
    steps, including identifying the security, gathering information, determining
    pricing factors, choosing a pricing model, calculating the price, evaluating the
    results, and updating pricing regularly. By following these steps, investors can
    make informed investment decisions and manage risk effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Derivatives pricing – theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Black-Scholes model is widely used for pricing derivatives such as options.
    Fischer Black and Myron Scholes came up with this formalism in 1973, which has
    since become a cornerstone of modern finance. The model considers various factors
    that influence the value of an option, including the underlying asset price, the
    option’s strike price, the time to expiration, volatility, and the risk-free interest
    rate. Let’s consider an example of the Black-Scholes model when setting the price
    a call option could pose on a stock.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that a call option on the XYZ stock with a strike price of $50
    is set to expire in six months. The current stock price is $52, and the volatility
    of the stock is 20%, while the risk-free interest rate is 3%.
  prefs: []
  type: TYPE_NORMAL
- en: Step one – calculate the d1 and d2 values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: d 1 =  [ln  S _ K + (r + σ 2 _ 2 )t ]  ____________ (σ √ _ t )
  prefs: []
  type: TYPE_NORMAL
- en: d 2 = d 1 − σ √ _ t
  prefs: []
  type: TYPE_NORMAL
- en: where S is the current stock price, K is the option’s strike price, r is the
    risk-free interest rate, σ is the volatility of the stock, and t is the time to
    expire in years.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the given values, we can calculate d1 and d2 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: d 1 = [ln 52 _ 50 + (0.03 + 0.2 2 _ 2 )0.5 ] ___________ (0.2 √ _ 0.5 )  = 0.
  prefs: []
  type: TYPE_NORMAL
- en: d 2 = 0.5601 − 0.2 √ _ 0.5  = 0.4187
  prefs: []
  type: TYPE_NORMAL
- en: Step two – calculate the option price
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the following formula, we can calculate the theoretical price of the
    call option:'
  prefs: []
  type: TYPE_NORMAL
- en: C = S × N(d 1) − K e −rt N( d 2)
  prefs: []
  type: TYPE_NORMAL
- en: Where C is the theoretical price of the call option, S is the current stock
    price, K is the option’s strike price, r is the risk-free interest rate, t is
    the time to expiration in years, N() is the cumulative distribution function of
    the standard normal distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the given values, we can calculate the theoretical price of the call
    option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: C = 52 × N(0.5601) − 50 e −0.03*0.5 N(0.4187) = $4.42
  prefs: []
  type: TYPE_NORMAL
- en: Step three – analyze the results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The calculated theoretical price of the call option is $4.42, which means that
    an investor can purchase the option for $4.42 and has the right to buy the XYZ
    stock for $50 before the expiration date in six months. If the stock price goes
    above $54.42 (the strike price plus the option price), the investor can exercise
    the option and make a profit. On the other hand, if the stock price stays below
    the strike price, the investor can let the option expire and only lose the premium
    paid for the option.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the Black-Scholes model is an important tool for pricing derivatives such
    as options. By taking into account various factors that influence the value of
    an option, investors can make informed decisions about buying and selling options
    to manage risk and maximize returns. However, it’s important to note that the
    model has some limitations and assumptions, such as constant volatility and no
    transaction costs, which may only sometimes be true in real-world situations.
  prefs: []
  type: TYPE_NORMAL
- en: The Black-Scholes-Merton (BSM) model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The BSM model is widely regarded as one of the most important breakthroughs
    in modern finance, and its widespread use has made options trading more efficient
    and accessible to investors.
  prefs: []
  type: TYPE_NORMAL
- en: The BSM model uses six variables to determine the fair value of an option. These
    variables include volatility, the type, the stock price, the strike price, time,
    and the risk-free rate. Volatility refers to the degree of fluctuation in the
    underlying asset’s price. In contrast, the type refers to whether the option is
    a call or a put option. A call option refers to the buying action as opposed to
    a put option, which refers to the selling right. The stock price and strike price
    refer to the current market price and the predetermined price at which the underlying
    asset can be bought or sold. Time refers to the length of time until the option
    expires. The risk-free rate is the theoretical rate of return on a risk-free investment,
    such as a government bond.
  prefs: []
  type: TYPE_NORMAL
- en: The BSM model is often used to determine the fair value of options based on
    these six variables. To illustrate the BSM model, let us consider an example of
    an investor who holds a call option with a strike price of $100, which will expire
    in six months. We will assume that the current market price of the underlying
    asset is $110, the risk-free rate is 3%, and the underlying asset’s volatility
    is 20%.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the BSM model, we can calculate the fair value of the call option. The
    formula to calculate the fair value of a call option using the BSM model is:'
  prefs: []
  type: TYPE_NORMAL
- en: C = S × N(d 1) − K e −rt N( d 2)
  prefs: []
  type: TYPE_NORMAL
- en: where C is the fair value of the call option, S is the current market price
    of the underlying asset, K is the strike price of the option, r is the risk-free
    rate, t is the time until expiration, and N(d 1) and N(d 2) are cumulative standard
    normal distribution functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying the formula to the given example, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: d 1 =  [ln 110 _ 100 + (0.03 + 0.2 2 _ 2 )0.5 ]  _________________  (0.2 √ _ 0.5 ) 
    = 0.9568
  prefs: []
  type: TYPE_NORMAL
- en: d 2 = 0.9568 − 0.2 √ _ 0.5  = 0.8154
  prefs: []
  type: TYPE_NORMAL
- en: N(d 1) = 0.831
  prefs: []
  type: TYPE_NORMAL
- en: N(d 2) = 0.7926
  prefs: []
  type: TYPE_NORMAL
- en: C = 110 × 0.831 − 100 × e −0.03×0.5 × 0.7926 = $13.29
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the fair value of the call option is $13.29\. This means that if
    the investor were to sell the option at this price, it would be a fair price based
    on the BSM model.
  prefs: []
  type: TYPE_NORMAL
- en: The BSM model is a widely used formula that allows investors to determine the
    fair value of options based on six variables – volatility, type, the stock price,
    the strike price, time, and the risk-free rate. The model has revolutionized the
    options market by making pricing more efficient and transparent. The example presented
    here illustrates the application of the BSM model and highlights its importance
    in modern finance.
  prefs: []
  type: TYPE_NORMAL
- en: Assumptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The BSM model is a widely used options pricing model that assumes several factors.
    These assumptions are critical in determining the fair value of an underlying
    asset for either of the two options – put or call. Here are some of the significant
    assumptions of the BSM model:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Efficient markets**: The model assumes that markets are efficient, meaning
    all available information is immediately reflected in the asset’s price'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No dividends**: The model assumes that the underlying asset does not pay
    dividends during the option’s life'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No transaction costs**: The model assumes no transaction costs are associated
    with buying or selling the underlying asset or option'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No arbitrage**: The model assumes that there are no arbitrage opportunities,
    which means it is impossible to make a riskless profit by simultaneously buying
    and selling the underlying asset and option'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lognormal distribution**: The model assumes that the underlying asset’s price
    follows a lognormal distribution, which means that the price changes are proportional
    to the current price and a random variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constant volatility**: The model assumes that the underlying asset’s volatility
    is constant over the option’s life'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These assumptions may be false, but they provide a useful framework to understand
    the factors influencing price options.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The BSM model is one of the most widely used models for options pricing. However,
    despite its popularity, the model has several limitations that make it less suitable
    for certain options and market conditions. Some of the limitations of the BSM
    model include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**An assumption of continuous trading**: The BSM model assumes that trading
    in the underlying asset is continuous, which means that the stock price can change
    by an infinite number of small amounts. In reality, trading is not continuous,
    and stock prices can experience sudden and large changes due to news events, market
    shocks, and other factors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No consideration of market frictions**: The BSM model assumes that no transaction
    costs, taxes, or other market frictions affect the price of the underlying asset.
    In reality, these frictions can significantly impact the value of options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An assumption of constant volatility**: The BSM model assumes that volatility
    is constant over the option’s life. In reality, volatility can be highly variable
    and change significantly over short periods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited applicability to specific options**: The BSM model is most suitable
    for pricing European options, which can only be exercised at expiration. The model
    is less suitable for pricing American options, which can be exercised before expiration,
    and other exotic options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited applicability to specific market conditions**: The BSM assumes specific
    behavior distribution on both the asset and markets. This limits the normal case
    where they can show all types of distributions, ranging from skewed to normal
    distributions as observed in reality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use of the risk-neutral approach**: The BSM model uses a risk-neutral approach
    to pricing options, which assumes that investors are indifferent to the risk and
    that the expected return on the option is equal to the risk-free rate. This assumption
    may not apply, especially for highly risky or illiquid options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Despite these limitations, the BSM model remains a valuable tool for options
    pricing and has been used extensively by traders, investors, and academics since
    its introduction in 1973\. However, it is essential to recognize the model’s limitations
    and use it appropriately in the context of specific market conditions and types
    of options. These limitations can be overcome with the help of computational modeling.
  prefs: []
  type: TYPE_NORMAL
- en: Computational models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The BSM model is a popular mathematical formula used to calculate the price
    of European-style options. However, the traditional BSM model has limitations,
    such as the assumption of constant volatility and risk-neutral pricing, which
    can lead to inaccurate pricing predictions. In recent years, machine learning
    algorithms have been applied to enhance the BSM model and improve its predictive
    power. In this subsection, we will explore the implementation of the BSM model
    using machine learning algorithms, its benefits, and its limitations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The BSM assumes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The price of an underlying asset exhibits a random behavior characterized by
    a stochastic process known as Geometric Brownian motion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The volatility of the asset’s returns is constant over the option’s life
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The risk-free rate is known and constant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The option can only be exercised at the expiration date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement the BSM model using machine learning algorithms, you can use historical
    data to train the model and learn from past market behavior. The model can then
    use this learned information to predict future prices. Machine learning algorithms,
    such as neural networks and decision trees, can help overcome the limitations
    of the traditional BSM model by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Accounting for non-constant volatility in asset returns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporating new market data in real time to update pricing predictions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering non-normal distributions of asset returns and incorporating skewness
    and kurtosis into pricing calculations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using machine learning algorithms to enhance the BSM model has several benefits,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Improved accuracy in predicting option prices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased flexibility in modeling complex financial instruments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faster pricing calculations, allowing for more timely trading decisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, there are also limitations to using machine learning algorithms in
    conjunction with the BSM model, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Increased complexity and the need for specialized technical expertise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The potential to overfit the model with historical data, leading to inaccurate
    pricing predictions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A large amount of high-quality data is needed to train the model effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Despite these limitations, implementing the BSM model using machine learning
    algorithms represents a promising approach to pricing financial instruments. Incorporating
    new market data in real time and accounting for non-constant volatility can improve
    accuracy, helping traders to make more informed decisions. Implementing the BSM
    model using machine learning algorithms significantly advances financial modeling.
    By incorporating new data and accounting for non-constant volatility, this approach
    can improve the accuracy of pricing predictions and allow for more informed trading
    decisions. However, it is essential to recognize this approach’s limitations and
    use it with other financial models and analysis techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Machine learning in derivative pricing employs complex algorithms to predict
    future derivative prices, drawing from a vast dataset of historical trading data.
    By modeling market dynamics and identifying patterns, it provides more accurate
    price forecasts than traditional models. This not only reduces financial risk
    but also optimizes trading strategies. Furthermore, it provides insights into
    market behavior, assisting in the development of more resilient financial systems.
  prefs: []
  type: TYPE_NORMAL
- en: Geometric Brownian motion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We must model the underlying equities before estimating the price of derivative
    instruments based on their value. The **geometric Brownian motion** (**GBM**),
    also called the Wiener process, is the method often uses to model the stochastic
    process of a Brownian motion, driving the future values of an asset. It helps
    create trajectories that the asset price of the underlying stock may take in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: 'A stochastic or random process, here defined as the time-dependent function
    S(t), is said to follow GBM if it can be expressed as the following SDE:'
  prefs: []
  type: TYPE_NORMAL
- en: d S t = μ S t dt + σ S t d W t
  prefs: []
  type: TYPE_NORMAL
- en: 'where:'
  prefs: []
  type: TYPE_NORMAL
- en: St – the stock price at time t
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dSt – the change in stock price from time t
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: μ – the drift term
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: σ – the volatility term
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dt – the change in time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dWt – the Brownian motion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wt notation belongs to the Wiener process or Brownian motion, μ is the percentage
    drift, and σ is the percentage volatility. Itô’s lemma (reference), the following
    analytical solution can be derived:'
  prefs: []
  type: TYPE_NORMAL
- en: S(t) = S 0 exp((r −  1 _ 2  σ 2)t + σ √ _ t  z)
  prefs: []
  type: TYPE_NORMAL
- en: Where S 0 is the initial stock index level, t the time to maturity when the
    stock will be acted on, r a constant representing the risk-less short rate, σ
    the constant volatility (often computed as the standard deviation of the stock),
    and z a normally distributed random variable. Thus, S(t) can easily be estimated
    for a given stock at time t.
  prefs: []
  type: TYPE_NORMAL
- en: One key feature of GBM is that the projected distribution of the asset follows
    a log-normal distribution. This is convenient given that, as we saw before, we
    expect certain skewness for the value to be lower.
  prefs: []
  type: TYPE_NORMAL
- en: 'By setting *I* random numbers for z i i ∈ 1, … , I, and computing the associated
    S i(t) for each sample, we can generate said future price distribution. Let’s
    create a hypothetical case to prove that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With those parameters set, we can simply code our St for future stock prices
    at the projected time t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It is interesting to plot the trajectories behind those numbers so that we
    know where they come from. We will place the trajectories for the future by one
    year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This iterative process will create sufficient samples of future scenarios projecting
    to our target time T, based on each time step preceding the value (t-1). The final
    code is the coded representation of the formulation described previously for the
    stochastic process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This should yield a graph like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – GBM trajectories generated for a given asset price and 12 month
    projection (image generated by the preceding code)](img/B19146_04_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – GBM trajectories generated for a given asset price and 12 month
    projection (image generated by the preceding code)
  prefs: []
  type: TYPE_NORMAL
- en: 'It may look chaotic but it is, in fact, the representation of the underlying
    stochastic process we described before. We can see how all trajectories start
    from the same point (the price today) and evolve in different directions, according
    to previously described equations, broadening the range as we move forward in
    time. If we plot the distribution at time *T* (one year in our case), we can see
    that the potential evolution meets the criteria previously explained, and by showcasing
    the price distribution, we are able to make assumptions about the likelihood of
    some of those specific trajectories, some of which are more plausible than others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 4.2 – Distribution of the price](img/B19146_04_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Distribution of the price
  prefs: []
  type: TYPE_NORMAL
- en: This distribution is one that will drive all our calculations associated with
    the call and put prices of a stock option. Also, it is skewed toward a lower-value
    bet than the high valuations, which are plausible but less probable.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous section, in order to estimate the future price of
    an equity, many iterations over potential future prices need to be run. However,
    what if we could establish a way to load those potential distributions into quantum
    states and evaluate them using quantum devices? The following subsection will
    dig into different ways to load those future price distributions into quantum
    states using existing solutions for direct loading, such as Qiskit functionalities
    and adversarial training using PennyLane, which might be better suited for ML
    tasks due to its differentiable programming approach (similar to TensorFlow or
    PyTorch in the classical ML domain).
  prefs: []
  type: TYPE_NORMAL
- en: Implementation in Qiskit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in [*Chapter 2*](B19146_02.xhtml#_idTextAnchor032), Qiskit is one
    of the most mature quantum computing frameworks available and counts with higher-level
    modules so that specific applications can be easily translated to the quantum
    regime. This is the case with Qiskit Finance, which we will explore in detail
    while translating previous exercises to a quantum approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we already know, classical data must be converted into a quantum state to
    work with it on a quantum device. In the case of price valuation, that means representing
    our target distribution as a quantum state. Therefore, we should build a quantum
    state like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ψ⟩ n = ∑ 0 2 n−1 √ _ p i  |i⟩ n,'
  prefs: []
  type: TYPE_NORMAL
- en: where *p**ᵢ*is the probability associated with the truncated distribution, and
    i is the mapping between our discrete bins, representing each value range of our
    target distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quantum hardware may face some challenges, which is one of the first to affect
    us. We need to truncate our distribution into discrete bins, as possible prices
    can fall into infinite bins, depending on the numerical precision we want to achieve.
    Thus, |i⟩ will be associated with a range of values sufficiently precise to encode
    a probability associated with that range. The truncation for i qubits is placed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '{0, … , 2 n − 1} ∈ i ⟶  high − low _ 2 n − 1  × i + low'
  prefs: []
  type: TYPE_NORMAL
- en: 'By setting the number of qubits of our algorithm, we also limit the response
    resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to embed our target distribution into the quantum state explained
    before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the truncated target distribution is ready, we must generate a circuit
    encoding the quantum state. It is a manageable task and can take time to learn
    how to do it properly. Luckily for us, Qiskit Finance is here to help. It already
    provides this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This circuit we just created encodes the distribution of our assets. We can
    print it if we like, but it will look like a big box at our working level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 4.3 – Logical circuit generated by the code above encapsulating the
    target distribution into a quantum state](img/B19146_04_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Logical circuit generated by the code above encapsulating the target
    distribution into a quantum state
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we look at the distribution it encodes, we can check whether it
    fits our expectations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 4.4 – Discretized distribution generated by the previous circuit in
    Figure 4.3](img/B19146_04_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Discretized distribution generated by the previous circuit in Figure
    4.3
  prefs: []
  type: TYPE_NORMAL
- en: This target distribution shows an additional limitation we will face when encoding
    the problem into quantum states. Given that they encode the bin representation
    of our probability distribution, the truncation we might decide on could cut some
    of the values at each end. Therefore, an important initial assessment needs to
    be done in order to properly characterize the distribution we aim to fit into
    our quantum states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our target distribution is loaded, it is just a matter of evaluating
    the call and put options within the quantum regime. For that, we might need to
    encode a linear piecewise function that will do this price calculation according
    to the probability, encoded as state amplitudes of our *|i>*. It is able to estimate
    these prices for each of our bins, simultaneously leveraging the parallelism that
    quantum states provide:'
  prefs: []
  type: TYPE_NORMAL
- en: F|x⟩|0⟩ = √ _ 1 − f(x)  |x⟩|0⟩ + √ _ f(x) |x⟩|1⟩
  prefs: []
  type: TYPE_NORMAL
- en: 'for a function f:{0,...,2^n-1} →[0,1] mapping the option function and x being
    a n qubit state mapping the option price bin. This encoded function will flag
    price buckets in the distribution, with the positive probability amplitude associated
    with their likelihood:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be our call objective function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compose a European call circuit by adding this amplitude estimation
    block to our previous circuit. This is mostly provided by Qiskit, thanks to its
    high-level module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 4.5 – Probability distribution generation block (P) followed by linear
    amplitude function block (f)](img/B19146_04_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Probability distribution generation block (P) followed by linear
    amplitude function block (f)
  prefs: []
  type: TYPE_NORMAL
- en: 'First, block (P) will add the price distribution we loaded into quantum states
    as the second block (F), as shown in the preceding diagram, evaluates their potential
    outcome. Given that amplitudes have been encoded already after the F block in
    the preceding figure, the last step is to extract from the quantum state into
    classical values the probabilities for our equity to fall into different bins
    of future pricing. Different methods exist for **Quantum Amplitude Estimation**
    (**QAE**); this technique allows you to extract the amplitudes on a given quantum
    state. Formally, we would pose it as the ability to estimate amplitude *a* for
    state ψ, defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: a = |⟨ψ | ψ⟩|²
  prefs: []
  type: TYPE_NORMAL
- en: 'It is often used as the quantum counterpart of the classical Monte Carlo simulation.
    We will here use an iterative QAE variant that has proven better error rates compared
    to other approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that the whole process is quite systematic, Qiskit already provides all
    these steps in a single piece of code, so we do not have to worry about each specific
    step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using qGANs for price distribution loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have encoded the uncertainty model of a given stock based on previously
    discussed statistical models, but could we exploit empirical knowledge from data
    instead of using statistical knowledge? We have retrieved information from Binance
    to get the market behaviors. We want our model to exploit the fact that each option
    does not behave in an isolated environment but depends on the evolutions of the
    rest of the stocks.
  prefs: []
  type: TYPE_NORMAL
- en: When data is available, ML techniques can have a field day, particularly generative
    models. Models that are once trained can create samples from a distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our particular case, we are interested in obtaining a generator model G
    such that:'
  prefs: []
  type: TYPE_NORMAL
- en: G θ| ψ⟩ n = ∑ 0 2 n−1 √ _ p i  |i⟩ n,
  prefs: []
  type: TYPE_NORMAL
- en: where the square root of p i represents the probability amplitude of the |i⟩
    quantum bin to be measured. In this case, the same quantum state we have been
    manually loading, the state that encodes future prices as discretized probable
    values, will be created, based on data samples extracted from our market data
    through a learning process that will iterate, making G map the preceding equation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Generative Adversarial Networks** (**GANs**) have been successful in realistic
    image and video generation, as you may be aware of, due to the success in the
    media of deepfakes. However, GANs can be exploited in many other regimes, from
    tabular data to time series data, which is quite a common case in the financial
    sector. Their quantum version was proposed by Zoufal et al. in 2019\. It is based
    on opposing two models, one quantum generator and one classical discriminator
    (a classical neural network), that are trained with opposing objectives so that
    we end up in a Nash equilibrium.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – A pictorial representation of the two models used in qGAN, the
    quantum generator G and classical discriminator D, as presented by Zoufal et al.](img/B19146_04_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – A pictorial representation of the two models used in qGAN, the
    quantum generator G and classical discriminator D, as presented by Zoufal et al.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a dataset loaded from Binance, where we can select the stocks to be used,
    we can select a subset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As we already know, a discretized and truncated version of the data must be
    delivered to the quantum device to fit our data into the quantum regime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to map our samples to discrete values. This means depending on the
    qubit resolution we choose. Each sample will need to be placed in a discrete bin
    as before. Choosing a 3-qubit representation means our data should fit into 2 3
    = 8 bins. This is something that needs to be considered, as it affects the resolution
    of our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can plot our discrete distribution for the three assets to learn which distributions
    we can effectively encode in our quantum resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 4.7 – Discretized distribution of three targeted stocks](img/B19146_04_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Discretized distribution of three targeted stocks
  prefs: []
  type: TYPE_NORMAL
- en: 'The original paper by Zoufal et al. proposed a specific parameterized quantum
    circuit as the generator circuit, using a sequence of *Y* rotations parameterized
    per qubit and a cycle of CZ gates circularly entangling all qubits (called an
    entangling block). We will try to mimic a similar approach in PennyLane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'That way we can easily use this setup for different repetitions and data dimensions
    we might be looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The output circuit should look like the one in *Figure 4**.8*. Even though it
    does not show a detailed view in the ansatz, this circuit is parameterized by
    the weights or parameters provided to the generator function. To know which parameters
    will output our expected distribution, we need to find them by following the techniques
    described in [*Chapter 2*](B19146_02.xhtml#_idTextAnchor032) for ansatz training.
    GANs offer a different approach to how these parameters are adapted, opposing
    the discriminator as the cost function for the training of the generator.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – The generator ansatz composed of Hadamard gates, the parameterized
    Y rotations, and the CZ gate cycle by the nearest neighbor coupling](img/B19146_04_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – The generator ansatz composed of Hadamard gates, the parameterized
    Y rotations, and the CZ gate cycle by the nearest neighbor coupling
  prefs: []
  type: TYPE_NORMAL
- en: 'GANs need a counterpart for the discriminator trying to assess whether samples
    come from the real dataset or the data faked by the generator, as depicted in
    *Figure 4**.8*. For this discriminator, a simple neural network will be defined,
    whose binary output should establish the sample source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This choice for the classical discriminator and its architecture of layers can
    be as complex as you want, and a big effort has been made by the community to
    identify the best-performing quantum and classical model designs for specific
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The key now resides in opposing the loss functions associated with training
    both models, quantum and classical. The loss is opposed, so you can see how variations
    on the parameters associated with our generator (G) are also considered in the
    discriminators’ loss function.
  prefs: []
  type: TYPE_NORMAL
- en: L G(ϕ, θ) = −  1 _ m  ∑ i=1 m log D ψ( g i)
  prefs: []
  type: TYPE_NORMAL
- en: L D(ϕ, θ) = −  1 _ m  ∑ i=1 m log D ψ(x i) + log(1 − D ψ( g i))
  prefs: []
  type: TYPE_NORMAL
- en: 'In both cases, the Adam optimization method (*Kingma et al., 2014*) will be
    used to train the model. This is enabled due to the fact that both frameworks,
    PennyLane for the quantum model and PyTorch for the classical one, provide this
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all pieces are set, it is just a matter of iteration, looking for the
    Nash equilibrium between the G and D models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: By plotting the evolution of both loss functions (appended to `generator_loss_values`
    and `discriminator_loss_values` arrays), we can see how both models try to adapt
    to one another so that the generator will ultimately be the best version of a
    synthetic data generator we can achieve.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Loss evolution while training both models reaching the equilibrium
    point at the end of the iterations](img/B19146_04_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Loss evolution while training both models reaching the equilibrium
    point at the end of the iterations
  prefs: []
  type: TYPE_NORMAL
- en: With this, we obtain a P block, as shown when manually loading the distribution
    using Qiskit, but trained to mimic the price distribution, as seen in the historic
    dataset we used to train the generator in our qGAN. Therefore, by adding this
    trained generator as the probability and appending the linear amplitude function
    and QAE blocks a purely data-driven quantum approach for the pricing of our stocks
    would be created. It would take quite a big block of code with different frameworks
    to perform such a task, so the technical complexity to implement this may be too
    high, but we definitely recommend going through the three blocks to understand
    how these interfaces between different frameworks can be achieved (PennyLane for
    a trainable parameterized quantum circuit and Qiskit Finance to avoid implementing
    the already available functionalities).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored a complex use case to forecast the future, the
    future of how markets will evolve, how stock prices will evolve, and so on a non-trivial
    task indeed. We showed how classical statistics extensively used in the field
    can be used in a quantum regime. This brings some benefits but also, given its
    current status and the limitations of the devices themselves, poses other impediments
    we would need to work around.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding a probability distribution on a gate-based quantum device entails some
    resolution loss. Probability distributions may need to be truncated, and value
    ranges will be rendered as the same discrete bin that the future price of an option
    may be placed. This limitation will probably change when bigger devices are made
    available so that larger distributions can be encoded. However, it is indeed a
    limitation we should have present in our minds when adopting these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are benefits, as quantum devices are capable of native parallelization
    of many calculations, which are done sequentially or require large classical setups
    to perform fast enough. Thanks to QML setups and qGANs in particular, we can even
    compose a piece of machinery that does this distribution encoding, based on an
    asset’s past evolution, which might not be entirely accurate but at least is based
    on evidence. So far, simulators have been used in this section to ease the complexity
    of using real devices, as we will explain in the following chapters. Dealing with
    device specifics could be quite challenging as well and add more complexity to
    the already complex procedure we showed here. Even though we will cover use cases
    that better fit the current status of quantum devices, being the growing field
    that it is and with its relevance in the financial sector, we must keep an eye
    on advances toward better price forecasting in the literature. There are really
    relevant research initiatives that could give us a breakthrough not far from now.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A quintessential part of what we have discussed in this chapter relates to some
    of the foundational algorithms in quantum computing. Grover’s algorithm (Jozsa
    1999) and QAE (Rao et al. 2020) are not only key contenders for financial use
    cases but also for numerous applications pertaining to quantum algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: More and more, QML is gaining relevance, as it allows the exploitation of existing
    data to create those embeddings or dynamics that quantum algorithms often require.
    [*Chapter 6*](B19146_06.xhtml#_idTextAnchor124) will examine in more detail these
    techniques. However, for those already knowledgeable about classical generative
    models such as GANs, variational autoencoders, and neural networks in general,
    there is plenty of literature that can be found to help their adaptation to the
    Quantum regime (Lloyd and Weedbrook, 2018). New ways that QNNs can be exploited
    for financial applications (Tapia et al. 2022) or different perspectives on how
    a price projection can be tackled constantly appear in the literature (Singh 2021).
  prefs: []
  type: TYPE_NORMAL
- en: On a more practical note, even though understanding the basics of how these
    algorithms are designed and implemented can be crucial at this stage, higher and
    higher abstraction enablers such as Qiskit Finance or ML will boost your ability
    to try and test some of the cutting-edge discoveries, offering a faster-paced
    transition from research to corporate innovation (Moguel et al. 2020).
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Glasserman, P. (2004). Monte Carlo methods in financial engineering (Vol.
    53, pp. xiv+-596). New* *York: Springer.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Jozsa, R. (1999). Searching in Grover’s algorithm. arXiv* *preprint quant-ph/9901021.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kingma, D. P., & Ba, J. (2014). Adam: A method for stochastic optimization.
    arXiv* *preprint arXiv:1412.6980.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Lloyd, S., & Weedbrook, C. (2018). Quantum generative adversarial learning.
    Physical review letters,* *121(4), 040502.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*MacBeth, J. D., & Merville, L. J. (1979). An empirical examination of the
    Black-Scholes call option pricing model. The journal of finance,* *34(5), 1173-1186.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Moguel, E., Berrocal, J., García-Alonso, J., & Murillo, J. M. (2020, October).
    A Roadmap for Quantum Software Engineering: Applying the Lessons Learned from
    the Classics. In Q-SET@ QCE (**pp. 5-13).*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Singh, P. (2021). FQTSFM: A fuzzy-quantum time series forecasting model. Information
    Sciences,* *566, 57-79.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Stojkoski, V., Sandev, T., Basnarkov, L., Kocarev, L., & Metzler, R. (2020).
    Generalised geometric Brownian motion: Theory and applications to option pricing.
    Entropy,* *22(12), 1432.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tapia, E. P., Scarpa, G., & Pozas-Kerstjens, A. (2022). Fraud detection with
    a single-qubit quantum neural network. arXiv* *preprint arXiv:2211.13191.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Rao, P., Yu, K., Lim, H., Jin, D., & Choi, D. (2020, August). Quantum amplitude
    estimation algorithms on IBM quantum devices. In Quantum Communications and Quantum
    Imaging XVIII (Vol. 11507, pp.* *49-60). SPIE.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ross, S. M., Kelly, J. J., Sullivan, R. J., Perry, W. J., Mercer, D., Davis,
    R. M., ... & Bristow, V. L. (1996). Stochastic processes (Vol. 2). New* *York:
    Wiley.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Zoufal, C., Lucchi, A., & Woerner, S. (2019). Quantum generative adversarial
    networks for learning and loading random distributions. npj Quantum Information,*
    *5(1), 103.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
