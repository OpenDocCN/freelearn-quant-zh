["```py\ndef exec_trades(data, assets, target_percent):\n    \"\"\"Place orders for assets using target portfolio percentage\"\"\"\n    for asset in assets:\n        if data.can_trade(asset) and not get_open_orders(asset):\n            order_target_percent(asset, target_percent)\n\ndef rebalance(context, data):\n    \"\"\"Compute long, short and obsolete holdings; place trade orders\"\"\"\n    factor_data = context.factor_data\n    assets = factor_data.index\n\n    longs = assets[factor_data.longs]\n    shorts = assets[factor_data.shorts]\n    divest = context.portfolio.positions.keys() - longs.union(shorts)\n\n    exec_trades(data, assets=divest, target_percent=0)\n    exec_trades(data, assets=longs, target_percent=1 / N_LONGS)\n    exec_trades(data, assets=shorts, target_percent=-1 / N_SHORTS)\n```", "```py\ndef initialize(context):\n    \"\"\"Setup: register pipeline, schedule rebalancing,\n        and set trading params\"\"\"\n    attach_pipeline(compute_factors(), 'factor_pipeline')\n    schedule_function(rebalance,\n                      date_rules.week_start(),\n                      time_rules.market_open(),\n                      calendar=calendars.US_EQUITIES)\n\n    set_commission(us_equities=commission.PerShare(cost=0.00075, min_trade_cost=.01))\n    set_slippage(us_equities=slippage.VolumeShareSlippage(volume_limit=0.0025, price_impact=0.01))\n```", "```py\nfrom alphalens.performance import create_pyfolio_input\n\nqmin, qmax = factor_data.factor_quantile.min(), \n             factor_data.factor_quantile.max()\ninput_data = create_pyfolio_input(alphalens_data,   \n                                  period='1D',\n                                  capital=100000,\n                                  long_short=False,\n                                  equal_weight=False,\n                                  quantiles=[1, 5],\n                                  benchmark_period='1D')\nreturns, positions, benchmark = input_data\n```", "```py\nreturns, positions, transactions = \n         extract_rets_pos_txn_from_zipline(backtest)\n```", "```py\nfrom pyfolio.plotting import plot_rolling_returns\nplot_rolling_returns(returns=returns,\n                     factor_returns=benchmark_rets,\n                     live_start_date='2017-01-01',\n                     cone_std=(1.0, 1.5, 2.0))\n```", "```py\nfrom pyfolio.timeseries import perf_stats\nperf_stats(returns=returns, \n           factor_returns=benchmark_rets, \n           positions=positions, \n           transactions=transactions)\n```", "```py\nfig, ax = plt.subplots(nrows=2, ncols=2, figsize=(16, 10))\naxes = ax.flatten()\n\nplot_drawdown_periods(returns=returns, ax=axes[0])\nplot_rolling_beta(returns=returns, factor_returns=benchmark_rets, \n                  ax=axes[1])\nplot_drawdown_underwater(returns=returns, ax=axes[2])\nplot_rolling_sharpe(returns=returns)\n```", "```py\ninteresting_times = extract_interesting_date_ranges(returns=returns)\ninteresting_times['Fall2015'].to_frame('pf') \\\n .join(benchmark_rets) \\\n .add(1).cumprod().sub(1) \\\n .plot(lw=2, figsize=(14, 6), title='Post-Brexit Turmoil')\n```", "```py\ndef simulate_portfolios(mean_ret, cov, rf_rate=rf_rate, short=True):\n    alpha = np.full(shape=n_assets, fill_value=.01)\n    weights = dirichlet(alpha=alpha, size=NUM_PF)\n    weights *= choice([-1, 1], size=weights.shape)\n\n    returns = weights @ mean_ret.values + 1\n    returns = returns ** periods_per_year - 1\n    std = (weights @ monthly_returns.T).std(1)\n    std *= np.sqrt(periods_per_year)\n    sharpe = (returns - rf_rate) / std\n\n    return pd.DataFrame({'Annualized Standard Deviation': std,\n                         'Annualized Returns': returns,\n                         'Sharpe Ratio': sharpe}), weights\n```", "```py\ndef portfolio_std(wt, rt=None, cov=None):\n    \"\"\"Annualized PF standard deviation\"\"\"\n    return np.sqrt(wt @ cov @ wt * periods_per_year)\n\ndef portfolio_returns(wt, rt=None, cov=None):\n    \"\"\"Annualized PF returns\"\"\"\n    return (wt @ rt + 1) ** periods_per_year - 1\n\ndef portfolio_performance(wt, rt, cov):\n    \"\"\"Annualized PF returns & standard deviation\"\"\"\n    r = portfolio_returns(wt, rt=rt)\n    sd = portfolio_std(wt, cov=cov)\n    return r, sd \n```", "```py\ndef neg_sharpe_ratio(weights, mean_ret, cov):\n    r, sd = portfolio_performance(weights, mean_ret, cov)\n    return -(r - rf_rate) / sd\n\nweight_constraint = {'type': 'eq',\n                     'fun': lambda x: np.sum(np.abs(x)) - 1}\n\ndef max_sharpe_ratio(mean_ret, cov, short=True):\n    return minimize(fun=neg_sharpe_ratio,\n                    x0=x0,\n                    args=(mean_ret, cov),\n                    method='SLSQP',\n                    bounds=((-1 if short else 0, 1),) * n_assets,\n                    constraints=weight_constraint,\n                    options={'tol':1e-10, 'maxiter':1e4})\n```", "```py\ndef neg_sharpe_ratio(weights, mean_ret, cov):\n    r, sd = pf_performance(weights, mean_ret, cov)\n    return -(r - RF_RATE) / sd\n\ndef pf_volatility(w, r, c):\n    return pf_performance(w, r, c)[1]\n\ndef efficient_return(mean_ret, cov, target):\n    args = (mean_ret, cov)\n    def ret_(weights):\n        return pf_ret(weights, mean_ret)\n\n    constraints = [{'type': 'eq', 'fun': lambda x: ret_(x) - \n                     target},\n                   {'type': 'eq', 'fun': lambda x: np.sum(x) - 1}]\n    bounds = ((0.0, 1.0),) * n_assets\n    return minimize(pf_volatility,\n                    x0=x0,\n                    args=args, method='SLSQP',\n                    bounds=bounds,\n                    constraints=constraints)\n```", "```py\ndef min_vol_target(mean_ret, cov, target, short=True):\n\n    def ret_(wt):\n        return portfolio_returns(wt, mean_ret)\n\n    constraints = [{'type': 'eq', 'fun': lambda x: ret_(x) - target},\n                     weight_constraint]\n\n    bounds = ((-1 if short else 0, 1),) * n_assets\n    return minimize(portfolio_std, x0=x0, args=(mean_ret, cov),\n                    method='SLSQP', bounds=bounds,\n                    constraints=constraints,\n                    options={'tol': 1e-10, 'maxiter': 1e4})\n\ndef efficient_frontier(mean_ret, cov, ret_range):\n    return [min_vol_target(mean_ret, cov, ret) for ret in ret_range]\n```", "```py\ndef min_vol(mean_ret, cov, short=True):\n    return minimize(fun=portfolio_std,\n                    x0=x0,\n                    args=(mean_ret, cov),\n                    method='SLSQP',\n                    bounds=bounds = ((-1 if short else 0, 1),) * \n                          n_assets,\n                          constraints=weight_constraint,\n                          options={'tol': 1e-10, 'maxiter': 1e4})\n```", "```py\nfrom sympy import symbols, solve, log, diff\n\nshare, odds, probability = symbols('share odds probability')\nValue = probability * log(1 + odds * share) + (1 - probability) * log(1 \n        - share)\nsolve(diff(Value, share), share)\n\n[(odds*probability + probability - 1)/odds]\n```", "```py\ndef norm_integral(f, m, st):\n    val, er = quad(lambda s: np.log(1+f*s)*norm.pdf(s, m, st), m-3*st, \n                   m+3*st)\n    return -val\n\ndef norm_dev_integral(f, m, st):\n    val, er = quad(lambda s: (s/(1+f*s))*norm.pdf(s, m, st), m-3*st, \n                   m+3*st)\n    return val\n\nm = .058\ns = .216\n# Option 1: minimize the expectation integral\nsol = minimize_scalar(norm_integral, args=(\n                m, s), bounds=[0., 2.], method='bounded')\nprint('Optimal Kelly fraction: {:.4f}'.format(sol.x))\n```", "```py\nmean_returns = monthly_returns.mean()\ncov_matrix = monthly_returns.cov()\nprecision_matrix = pd.DataFrame(inv(cov_matrix), index=stocks, columns=stocks)\nkelly_wt = precision_matrix.dot(mean_returns).values\n```", "```py\nvar = monthly_returns.var()\nrisk_parity_weights = var / var.sum()\n```"]