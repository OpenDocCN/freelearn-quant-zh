- en: Chapter 8. Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimization is a way of selecting the best solution out of all feasible solutions.
    So, the first part of optimization is to formulate the problem according to given
    constraints, and to apply an advanced analytical method to get the best solution
    and help in making better decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization models play a pivotal role in quant and computational finance by
    solving complex problems more efficiently and accurately. Problems associated
    with asset allocation, risk management, option pricing, volatility estimation,
    portfolio optimization, and construction of index funds can be solved using optimization
    techniques such as nonlinear optimization models, quadratic programming formulations,
    and integer programming models. There is a variety of commercial and open source
    software available in the analytical space to solve these problems, and R is one
    of the preferred choices as it is open source and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be discussing some of the optimization techniques and
    how to solve them using R.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic rebalancing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walk forward testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grid testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Genetic algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic rebalancing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic rebalancing is a process of keeping one's portfolio closer to your allocated
    target using the natural cash inflows and outflows to your portfolio. Rebalancing
    involves periodically buying or selling assets in a portfolio to maintain an original
    desired level of asset allocation, realigning the weightings of a portfolio of
    assets.
  prefs: []
  type: TYPE_NORMAL
- en: Let us consider an example. In a portfolio, the target asset allocation was
    40% stocks and 60% bonds. If the bonds performed well during the period, the weights
    of bonds in the portfolio could result to 70%. Then, the investor will decide
    to sell some bonds and buy some stocks to get the portfolio back to the original
    target allocation of 40% stock and 60% bonds.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us see how to do rebalancing of the portfolio in R.
  prefs: []
  type: TYPE_NORMAL
- en: Periodic rebalancing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us consider data sourced from R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It gives the following dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Periodic rebalancing](img/00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Dataset used for rebalancing analysis'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us assume that on `1998-12-31`, the weights of the portfolio consisting
    of the above instruments are given as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It gives the weights as follows at the end of the year 1998:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Periodic rebalancing](img/00117.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Initial weights assigned'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we want to balance the weights on a monthly basis then it can be done
    by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, `data` is the input data; `weights` is the defined weights for the components
    of the portfolio; `rebalance_on = True` means weighted rebalanced monthly portfolio
    returns; and `verbose = True` returns additional information.
  prefs: []
  type: TYPE_NORMAL
- en: When we execute the preceding code, it generates an output list which includes
    portfolio returns after adjustment for each interval, monthly contribution by
    each asset, before and after weights of assets after each interval, and before
    and after portfolio values for each interval. Thus it gives a complete picture
    of how rebalancing happens during a given time span.
  prefs: []
  type: TYPE_NORMAL
- en: 'The monthly rebalanced portfolio returns are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Periodic rebalancing](img/00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Portfolio returns at different time periods'
  prefs: []
  type: TYPE_NORMAL
- en: 'Monthly contribution by each asset is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Periodic rebalancing](img/00119.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Monthly contribution by each asset'
  prefs: []
  type: TYPE_NORMAL
- en: 'Beginning-of-period weights are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Periodic rebalancing](img/00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Summary of weights at the beginning of each period'
  prefs: []
  type: TYPE_NORMAL
- en: 'End-of-period weights are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Periodic rebalancing](img/00121.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Summary of weights at the end of each period'
  prefs: []
  type: TYPE_NORMAL
- en: 'Beginning-of-period portfolio value is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Periodic rebalancing](img/00122.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Portfolio value at the beginning of each period'
  prefs: []
  type: TYPE_NORMAL
- en: 'End-of-period portfolio value is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Periodic rebalancing](img/00123.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: Portfolio value at the end of each period'
  prefs: []
  type: TYPE_NORMAL
- en: Walk forward testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Walk forward testing is used in quant finance for identifying the best parameters
    to be used in a trading strategy. The trading strategy is optimized on a subset
    of sample data for a specific time window. The rest of the unused data is kept
    separate for testing purposes. The testing is done on a small window of unused
    data with the recorded results. Now, the training window is shifted forward to
    include the testing window and the process is repeated again and again till the
    testing window is not available.
  prefs: []
  type: TYPE_NORMAL
- en: Walk forward optimization is a method used in finance for determining the best
    parameters to use in a trading strategy. The trading strategy is optimized with
    in-sample data for a time window in a data series. The remainder of the data is
    reserved for out-of-sample testing. A small portion of the reserved data following
    the in-sample data is tested with the results recorded. The in-sample time window
    is shifted forward by the period covered by the out-of-sample test, and the process
    repeated. At the end, all of the recorded results are used to assess the trading
    strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Grid testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us consider a typical classification problem. Assume you have a dataset
    and you divide it into training (T) and validating (V) datasets. Here you are
    trying to solve an optimization problem, let's say P, in which one is trying to
    reduce the training error in addition to regularization terms, where the optimization
    problem is a function of model parameter *m*, training sample *T*, and some hyperparameters
    ![Grid testing](img/00032.jpeg) and ![Grid testing](img/00033.jpeg). Solving for
    given ![Grid testing](img/00032.jpeg) and ![Grid testing](img/00033.jpeg) gives
    you the value of parameter *m*. Now one can apply the estimated parameters on
    the validation sample to get the validation error function, and optimize it to
    get the set of ![Grid testing](img/00032.jpeg) and ![Grid testing](img/00033.jpeg) to
    minimize the error function. But this optimization problem will be very expensive
    as, for each set of ![Grid testing](img/00032.jpeg) and ![Grid testing](img/00033.jpeg),
    you need to optimize the objective function, which might not be a convex, concave,
    or smooth function.
  prefs: []
  type: TYPE_NORMAL
- en: So we subset the set of ![Grid testing](img/00032.jpeg) and ![Grid testing](img/00033.jpeg) and,
    for each pair of selected ![Grid testing](img/00032.jpeg) and ![Grid testing](img/00033.jpeg),
    we solve the optimization problem. This looks like a grid in space so we call
    it a grid search. So, a grid search is mostly used to tune the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us consider a classification example using the random forest technique.
    Now, construct first a base line model by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It generates the summary output of the random forest model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Grid testing](img/00124.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: Summary output for random forest'
  prefs: []
  type: TYPE_NORMAL
- en: A grid search means you have given a pool of models which are different from
    each other in their parameter values, which lie on grids. Train each of the models
    and evaluate them using cross-validation to select the best model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us try to apply the grid search method and check the accuracy. This
    can be done by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It gives the following output with better estimates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Grid testing](img/00125.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: Grid search output for random forest'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us plot the accuracy for different random forest models for different
    sets of attributes, which can be done by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives tuned random forest parameters in R using grid search:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Grid testing](img/00126.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: Accuracy plot for different random forest models'
  prefs: []
  type: TYPE_NORMAL
- en: It compares the pool of models in terms of accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Genetic algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Genetic algorithm** (**GA**) is a search-based optimization technique whose
    fundamentals come from the theory of genetics and natural selection. It is used
    to solve optimization problems in research and machine learning areas which are
    very difficult and time-consuming solutions by alternative methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Optimization is the process of finding a solution which is better when compared
    to all other alternative solutions. It takes the space of all the possible solutions
    as search space, and then finds a solution which is most suited to the problem.
  prefs: []
  type: TYPE_NORMAL
- en: In GA, possible candidate solutions constitute the population and they recombine
    and mutate to produce new children, and this process is repeated over various
    generations. Each possible candidate solution is given a fitness value based upon
    the objective function. The fitter probable candidates are given preference for
    recombination and mutation to yield fitter candidate solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most important terminology associated with GA is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Population**: It is a subset of all the possible candidate solutions of the
    existing problem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chromosomes**: A chromosome is one solution to the given problem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gene**: A gene is one element position of a chromosome'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, let us assume that the last year of the portfolio with the following
    stocks, contributes with the returns mentioned if invested with the same proportion
    as mentioned here. Then we need to please maximize the performance of the portfolio
    by limiting the total weight to one:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Stocks** | **Returns** | **Weights** |'
  prefs: []
  type: TYPE_TB
- en: '| `Stock1` | `10` | `.1` |'
  prefs: []
  type: TYPE_TB
- en: '| `Stock2` | `11` | `.2` |'
  prefs: []
  type: TYPE_TB
- en: '| `Stock3` | `15` | `.1` |'
  prefs: []
  type: TYPE_TB
- en: '| `Stock4` | `20` | `.2` |'
  prefs: []
  type: TYPE_TB
- en: '| `Stock5` | `12` | `.2` |'
  prefs: []
  type: TYPE_TB
- en: '| `Stock6` | `13` | `.3` |'
  prefs: []
  type: TYPE_TB
- en: Let us try to solve it using GA in R.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let us define the input data requirement, which can be done by executing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Genetic algorithm](img/00127.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: Input dataset for GA'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us set the evaluation function as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let us design the model and execute it. This can be done by executing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`size` is the number of genes in the chromosome'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`popsize` is the population size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iters` is the number of iterations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mutationChance` is the chance that the chromosome mutates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`elitism` is the number of chromosomes that are kept for the next generation;
    by default, it is 20%'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`evalFunc` is the user-supplied evaluation function for given chromosomes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This, upon execution, gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Genetic algorithm](img/00128.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.13: Summary output for GA model'
  prefs: []
  type: TYPE_NORMAL
- en: It says to retain all the stocks apart from `Stock2` to obtain the optimal portfolio.
  prefs: []
  type: TYPE_NORMAL
- en: Let us consider another example of genetic algorithm. Here, we will try to estimate
    the coefficients by genetic algorithm and the traditional OLS method.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let us consider a dataset using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Genetic algorithm](img/00129.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.14: Input sample for parameter estimates by GA'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us try to estimate `pce` in terms of `pop` and `psavert` by GA. Let
    us now create a function to evaluate linear regression, which is given by the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let us try to estimate the coefficients by GA, which can be done by executing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Genetic algorithm](img/00130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.15: Summary output parameter estimates by GA'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the significance of optimization in quant finance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the dynamic rebalancing optimization method? Give an example of how
    to execute it in R.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can a grid search be used to fine-tune a classification model? Please provide
    an example in R.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can genetic algorithm be used in R for optimizing a trading algorithm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can genetic algorithm be used in R for estimating a model coefficient in
    R? Provide an example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed various optimization techniques used in trading
    algorithms and parameter estimation. The covered optimization techniques were
    dynamic rebalancing, walk forward testing, grid testing, and genetic algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, the topics covered are using `foptions`, `termstrc`, `CreditMetrics`,
    `credule`, `GUIDE`, and `fExoticOptions` to price options, bond, credit spreads,
    credit default swaps, interest rate derivatives, and different types of exotic
    options.
  prefs: []
  type: TYPE_NORMAL
