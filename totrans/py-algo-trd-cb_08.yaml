- en: Algorithmic Trading Strategies - Coding Step by Step
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步编码算法交易策略
- en: It is a complex task to build your own algorithmic trading strategies. A trading
    platform with numerous components is required to test and run your strategy. Some
    of these components are the compute engine, real-time data feeds, broker connectivity,
    blotter, fund manager, clocks, a virtual order-management system, and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自己的算法交易策略是一项复杂的任务。需要一个具有许多组件的交易平台来测试和运行您的策略。其中一些组件包括计算引擎、实时数据源、经纪人连接、交易记录、基金经理、时钟、虚拟订单管理系统等等。
- en: In this chapter, you will be using the services provided by AlgoBulls, an algorithmic
    trading platform ([https://algobulls.com](https://algobulls.com)). This platform
    provides a Python package called `pyalgotrading` ([https://github.com/algobulls/pyalgotrading](https://github.com/algobulls/pyalgotrading)).
    You will code your strategy as a Python class by subclassing the `StrategyBase`
    abstract class provided in the package. The abstract class acts as a template
    for developing and validating new strategies quickly with minimal effort. You
    can use the AlgoBulls platform to perform backtesting, paper trading, and real
    trading on your strategy. The `pyalgotrading` package helps us focus on developing
    the strategy and takes care of talking to the AlgoBulls platform for execution
    purposes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用由 AlgoBulls 提供的服务，这是一个算法交易平台（[https://algobulls.com](https://algobulls.com)）。该平台提供了一个名为`pyalgotrading`的
    Python 包（[https://github.com/algobulls/pyalgotrading](https://github.com/algobulls/pyalgotrading)）。您将通过继承该包中提供的`StrategyBase`抽象类来编写您的策略作为
    Python 类。该抽象类充当了以最小的努力快速开发和验证新策略的模板。您可以使用 AlgoBulls 平台来执行您的策略的回测、纸上交易和实盘交易。`pyalgotrading`包帮助我们专注于开发策略，并负责与
    AlgoBulls 平台进行通信以执行目的。
- en: 'This chapter introduces two strategies:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了两种策略：
- en: '**EMA-Regular-Order strategy**: This strategy is based on the technical indicator
    exponential moving average. It uses regular orders.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EMA-Regular-Order 策略**：该策略基于技术指标指数移动平均线。它使用常规订单。'
- en: '**MACD-Bracket-Order strategy**: This strategy is based on the technical indicator
    moving average convergence divergence. It uses bracket orders.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MACD-Bracket-Order 策略**：该策略基于技术指标移动平均线收敛与发散。它使用括号订单。'
- en: Initially, you may find strategy coding a daunting task. Therefore, the coding
    part is divided into five recipes. Each recipe demonstrates one or more methods
    enforced by the `StrategyBase` class. The sixth recipe demonstrates how to upload
    the strategy to the AlgoBulls platform.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，您可能会发现策略编码是一项艰巨的任务。因此，编码部分被分为五个步骤。每个步骤演示了`StrategyBase`类强制执行的一个或多个方法。第六个步骤演示了如何将策略上传到
    AlgoBulls 平台。
- en: 'The skeleton for a strategy looks as shown:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 策略的框架如下所示：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The AlgoBulls core engine is the trading engine powering the AlgoBulls platform.
    It is responsible for reading your strategies and executing them for backtesting,
    paper trading, and real trading. The AlgoBulls core engine uses the following
    flowchart for executing your strategy successfully:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: AlgoBulls 核心引擎是推动 AlgoBulls 平台的交易引擎。它负责读取您的策略并对其进行回测、纸上交易和实盘交易执行。AlgoBulls 核心引擎使用以下流程图成功执行您的策略：
- en: '![](img/cb26ef36-c0ba-4d61-b223-d6224f210f67.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb26ef36-c0ba-4d61-b223-d6224f210f67.png)'
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将介绍以下几个步骤：
- en: EMA-Regular-Order strategy – coding the __init__, initialize, name, and versions_supported methods
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMA-Regular-Order 策略 – 编写 __init__、initialize、name 和 versions_supported 方法
- en: EMA-Regular-Order strategy – coding the strategy_select_instruments_for_entry
    method
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMA-Regular-Order 策略 – 编写 strategy_select_instruments_for_entry 方法
- en: EMA-Regular-Order strategy – coding the strategy_enter_position method
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMA-Regular-Order 策略 – 编写 strategy_enter_position 方法
- en: EMA-Regular-Order strategy – coding the strategy_select_instruments_for_exit
    method
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMA-Regular-Order 策略 – 编写 strategy_select_instruments_for_exit 方法
- en: EMA-Regular-Order strategy – coding the strategy_exit_position method
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMA-Regular-Order 策略 – 编写 strategy_exit_position 方法
- en: EMA-Regular-Order strategy – uploading the strategy onto the AlgoBulls trading
    platform
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMA-Regular-Order 策略 – 将策略上传到 AlgoBulls 交易平台
- en: MACD-Bracket-Order strategy – coding the __init__, initialize, name, and versions_supported methods
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order 策略 – 编写 __init__、initialize、name 和 versions_supported 方法
- en: MACD-Bracket-Order strategy – coding the strategy_select_instruments_for_entry
    method
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order 策略 – 编写 strategy_select_instruments_for_entry 方法
- en: MACD-Bracket-Order strategy – coding the strategy_enter_position method
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order 策略 – 编写 strategy_enter_position 方法
- en: MACD-Bracket-Order strategy – coding the strategy_select_instruments_for_exit
    method
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order 策略 – 编写 strategy_select_instruments_for_exit 方法
- en: MACD-Bracket-Order strategy – coding the strategy_exit_position method
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order 策略 – 编写 strategy_exit_position 方法
- en: MACD-Bracket-Order strategy – uploading the strategy onto AlgoBulls trading
    platform
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order 策略 – 将策略上传到 AlgoBulls 交易平台
- en: Technical requirements
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following to execute the recipes in this chapter:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要以下内容来执行本章中的配方：
- en: Python 3.7+
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.7+
- en: 'Python packages:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 包：
- en: '`pyalgotrading` (`$ pip install pyalgotrading`)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pyalgotrading` (`$ pip install pyalgotrading`)'
- en: '`pyalgostrategypool` (`$ pip install pyalgostrategypool`)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pyalgostrategypool` (`$ pip install pyalgostrategypool`)'
- en: '`TA-Lib` (`$ pip install TA-Lib`)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TA-Lib` (`$ pip install TA-Lib`)'
- en: 'If you face errors while installing `TA-Lib`, it will mostly be due to missing
    dependencies. You can follow these instructions to fix the issue:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在安装 `TA-Lib` 时遇到错误，大多数情况下是由于缺少依赖项。您可以按照以下说明解决问题：
- en: '**For Mac OS X, use the following**:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于 Mac OS X，请使用以下**：'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**For Windows, use the following instructions**:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于 Windows，请使用以下说明**：'
- en: You can install the latest `TA-Lib` binary from [https://www.lfd.uci.edu/~gohlke/pythonlibs/#ta-lib](https://www.lfd.uci.edu/~gohlke/pythonlibs/#ta-lib)
    based on your Windows build (32 bit/64 bit) and Python version. So, for example,
    this link on the site, [TA_Lib‑0.4.18‑cp38‑cp38‑win_amd64.whl](https://download.lfd.uci.edu/pythonlibs/w3jqiv8s/TA_Lib-0.4.18-cp39-cp39-win_amd64.whl),
    is for `TA-Lib` version 0.4.18 (`TA_Lib-0.4.18`) and Python version 3.8 (`cp38`),
    and is Windows 64-bit-compatible (`win_amd64`).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据您的 Windows 构建（32 位/64 位）和 Python 版本从 [https://www.lfd.uci.edu/~gohlke/pythonlibs/#ta-lib](https://www.lfd.uci.edu/~gohlke/pythonlibs/#ta-lib)
    安装最新的 `TA-Lib` 二进制文件。例如，该网站上的此链接 [TA_Lib‑0.4.18‑cp38‑cp38‑win_amd64.whl](https://download.lfd.uci.edu/pythonlibs/w3jqiv8s/TA_Lib-0.4.18-cp39-cp39-win_amd64.whl)
    是 `TA-Lib` 版本 0.4.18 (`TA_Lib-0.4.18`) 和 Python 版本 3.8 (`cp38`) 的链接，且适用于 Windows
    64 位 (`win_amd64`)。
- en: '**For Linux, take the following steps**:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于 Linux，请执行以下步骤**：'
- en: 'Download this `gzip` file—[http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz](http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz)—and
    run the following commands from your Linux Terminal:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下载此`gzip`文件—[http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz](http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz)—并从您的
    Linux 终端运行以下命令：
- en: 'Extract the downloaded `gzip` file containing the source code for `TA-Lib`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取下载的包含 `TA-Lib` 源代码的 `gzip` 文件：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Change your current working directory to the extracted folder:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前工作目录更改为提取的文件夹：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the `configure` command to configure `TA-Lib` for your machine:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`configure`命令以配置 `TA-Lib` 适合您的计算机：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the `make` command to build `TA-Lib` from the downloaded source code:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`make`命令以从下载的源代码构建 `TA-Lib`：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the `install` command to install built executables and libraries to specific
    directories on your machine:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`install`命令以将构建的可执行文件和库安装到您的计算机上的特定目录：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If this doesn't help and you still get errors, please refer to the official
    `TA-Lib` GitHub page at [https://github.com/mrjbq7/ta-lib#dependencies](https://github.com/mrjbq7/ta-lib#dependencies).
    The latest Jupyter notebook for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Python-Algorithmic-Trading-Cookbook/tree/master/Chapter08](https://github.com/PacktPublishing/Python-Algorithmic-Trading-Cookbook/tree/master/Chapter08).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不起作用并且您仍然遇到错误，请参考官方 `TA-Lib` GitHub 页面 [https://github.com/mrjbq7/ta-lib#dependencies](https://github.com/mrjbq7/ta-lib#dependencies)。本章的最新
    Jupyter 笔记本可以在 GitHub 上找到 [https://github.com/PacktPublishing/Python-Algorithmic-Trading-Cookbook/tree/master/Chapter08](https://github.com/PacktPublishing/Python-Algorithmic-Trading-Cookbook/tree/master/Chapter08)。
- en: 'The following code will help you import the necessary modules that are used
    by all the recipes in this chapter. Please make sure you have followed this step
    before trying out any of the recipes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将帮助您导入本章中所有配方使用的必要模块。请确保在尝试任何配方之前已执行此步骤：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the first five recipes, you will create a complete algorithmic trading strategy
    based on the EMA technical indicator. This strategy is called the **EMA-Regular-Order**
    strategy and is described as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前五个配方中，您将基于 EMA 技术指标创建一个完整的算法交易策略。此策略称为 **EMA-Regular-Order** 策略，并描述如下：
- en: '**Technical indicators**:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术指标**：'
- en: '`EMA(timeperiod=4)` or `EMA4`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMA(timeperiod=4)` 或 `EMA4`'
- en: '`EMA(timeperiod=9)` or `EMA9`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMA(timeperiod=9)` 或 `EMA9`'
- en: While the typical values of the time periods are `4` and `9`, both of the time
    periods are taken as parameters, so they can be changed at runtime without having
    to recreate the strategy again. This is discussed more in the first recipe of
    this chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然时间周期的典型值为`4`和`9`，但两个时间周期都作为参数，因此可以在运行时进行更改，而无需重新创建策略。这在本章的第一个配方中进行了更多讨论。
- en: '**Order attributes**:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订单属性**：'
- en: 'Order transaction type: `BUY` and `SELL`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单交易类型：`BUY`和`SELL`
- en: 'Order type: `Regular`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单类型：`Regular`
- en: 'Order code: `INTRADAY`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单代码：`INTRADAY`
- en: 'Order variety: `Market`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单品种：`Market`
- en: '**Strategy algorithm**:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略算法**：'
- en: 'Whenever `EMA4` crosses `EMA9` upward, note the following:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当`EMA4`向上穿越`EMA9`时，请注意以下内容：
- en: The previous `SHORT` position, if present, should be exited.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有的话，应退出之前的`SHORT`头寸。
- en: A `BUY` signal is generated by the strategy and a new `LONG` position should
    be entered.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略生成了一个`BUY`信号，应输入一个新的`LONG`头寸。
- en: 'Whenever `EMA4` crosses `EMA9` downward, note the following:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当`EMA4`向下穿越`EMA9`时，请注意以下内容：
- en: The previous `LONG` position, if present, should be exited.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有的话，应退出之前的`LONG`头寸。
- en: A `SELL` signal is generated by the strategy and a new `SHORT` position should
    be entered.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略生成了一个`SELL`信号，应输入一个新的`SHORT`头寸。
- en: You will code the entire logic as a single Python class called `StrategyEMARegularOrder`.
    This class will be a subclass of `StrategyBase` from the `pyalgotrading` package.
    After uploading `StrategyEMARegularOrder` on the AlgoBulls platform, you can backtest
    (refer to the first six recipes of [Chapter 9](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml),
    *Backtesting Strategies*), paper trade (refer to the first five recipes of [Chapter
    10](0f869a6e-bb6b-4f5f-828e-33ca477c509d.xhtml), *Paper Trading*), and real trade
    (refer to the first five recipes of [Chapter 11](725b5f38-fffb-46ae-8b5b-8a4667419e3a.xhtml),
    *Real Trading*) on this strategy.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您将把整个逻辑编码为一个名为`StrategyEMARegularOrder`的Python类。这个类将是`pyalgotrading`包中`StrategyBase`的子类。在AlgoBulls平台上上传`StrategyEMARegularOrder`后，您可以在该策略上进行回测（参考[第9章](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml)的前六个配方，*回测策略*）、模拟交易（参考[第10章](0f869a6e-bb6b-4f5f-828e-33ca477c509d.xhtml)的前五个配方，*模拟交易*）和实际交易（参考[第11章](725b5f38-fffb-46ae-8b5b-8a4667419e3a.xhtml)的前五个配方，*实际交易*）。
- en: 'In the seventh to eleventh recipes, you will create a complete algorithmic
    trading strategy based on the MACD technical indicator. This strategy is called
    as the **MACD-Bracket-Order** strategy and is described as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在第七至第十一个配方中，您将基于MACD技术指标创建一个完整的算法交易策略。这个策略称为**MACD-Bracket-Order**策略，描述如下：
- en: '**Technical indicators**:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术指标**：'
- en: 'MACD: This technical indicator has three components: the MACD line, MACD signal,
    and MACD histogram. We are concerned only with the MACD line and MACD signal components
    for this strategy.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD：这个技术指标有三个组成部分：MACD线、MACD信号和MACD柱状图。对于这个策略，我们只关注MACD线和MACD信号组件。
- en: '**Order attributes**:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订单属性**：'
- en: 'Order transaction type: `BUY` and `SELL`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单交易类型：`BUY`和`SELL`
- en: 'Order type: `Bracket`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单类型：`Bracket`
- en: 'Order code: `INTRADAY`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单代码：`INTRADAY`
- en: 'Order variety: `Limit`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单品种：`Limit`
- en: '**Strategy algorithm**:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略算法**：'
- en: 'Whenever the MACD line crosses the MACD signal upward, note the following:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当MACD线向上穿越MACD信号时，请注意以下内容：
- en: The previous `SHORT` position, if present, should be exited.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有的话，应退出之前的`SHORT`头寸。
- en: A `BUY` signal is generated by the strategy and a new `LONG` position should
    be entered.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略生成了一个`BUY`信号，应输入一个新的`LONG`头寸。
- en: 'Whenever the MACD line crosses the MACD signal downward, note the following:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当MACD线向下穿越MACD信号时，请注意以下内容：
- en: The previous `LONG` position, if present, should be exited.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有的话，应退出之前的`LONG`头寸。
- en: A `SELL` signal is generated by the strategy and a new `SHORT` position should
    be entered.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略生成了一个`SELL`信号，应输入一个新的`SHORT`头寸。
- en: You will code the entire logic as a single Python class, called `StrategyMACDBracketOrder`.
    This class will be a subclass of `StrategyBase` from the `pyalgotrading` package.
    After uploading `StrategyMACDBracketOrder` onto the AlgoBulls platform, you can
    backtest (refer to the seventh to twelfth recipes of [Chapter 9](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml),
    *Algorithmic Trading – Backtesting*), paper trade (refer to the seventh to twelfth
    recipes of [Chapter 10](0f869a6e-bb6b-4f5f-828e-33ca477c509d.xhtml), *Algorithmic
    Trading – **Paper Trading*), and real trade (refer to the seventh to eleventh
    recipes of [Chapter 11](725b5f38-fffb-46ae-8b5b-8a4667419e3a.xhtml), *Algorithmic
    Trading – **Real Trading*) on this strategy.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on these topics, please refer to the following corresponding
    chapters:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '**Technical indicators**: [Chapter 5](16529fe4-d3ea-4017-a6f9-bad85a41d8a0.xhtml),
    *Computing and Plotting Technical Indicators*'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Order attributes**: [Chapter 6](077b54a1-c9c4-424c-912a-11f28db3797f.xhtml),
    *Placing Regular Orders on the Exchange* and [Chapter 7](d5760c5d-fa09-4008-ab45-5d7d69c4bde9.xhtml),
    *Placing Bracket and Cover Orders on the Exchange*.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to set up your account on the AlgoBulls platform ([https://algobulls.com](https://algobulls.com))
    to get your API token. Setting up an account is free. Using its services might
    incur charges depending on your usage. You can start with free packages on the
    site. Refer to *Appendix II* for more details.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: EMA-Regular-Order strategy – coding the __init__, initialize, name, and versions_supported
    methods
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe demonstrates the initial coding of the `StrategyEMARegularOrder`
    class. The complete class will be coded by the end of the *EMA-Regular-Order strategy
    – coding the strategy_exit_position method* recipe of this chapter. In this recipe,
    you will code the following methods:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__()`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initialize()`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name()`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`versions_supported()`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn more about the EMA technical indicator, please refer to the *Trend
    indicator – exponential moving average* recipe of [Chapter 5](16529fe4-d3ea-4017-a6f9-bad85a41d8a0.xhtml), *Computing
    and Plotting Technical Indicators*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how the AlgoBulls core engine calls the `__init__()` and `initialize()` methods
    during strategy execution.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have the `StrategyBase` and `pyalgotrading` constants in your
    Python namespace. Refer to the *Technical requirements* section of this chapter
    to set it up.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new class named `StrategyEMARegularOrder`, which will be a subclass
    from `StrategyBase` and then define the required four methods:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we create the `StrategyEMARegularOrder` class, subclassed from
    `StrategyBase`. We define four methods for this class and describe them as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__init__()` method: This is the first thing to do when you create a new
    strategy. First, you create this method and call the parent class `__init__()`
    method using `super()`. This helps the AlgoBulls core engine create the necessary
    data structures needed for further development of the strategy. Next, you create
    two new attributes from `self.strategy_parameters`—`self.timeperiod1` and `self.timeperiod2`.
    `self.strategy_parameters` is a dictionary object available for every strategy
    subclassed from `StrategyBase`. (The second recipe of [Chapter 8](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml),
    *Backtesting Strategies*, discusses how these values are passed at runtime to
    `self.strategy_parameters`.) You will use these parameters as time periods of
    both the EMAs in the next recipe.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()` 方法：这是创建新策略时要做的第一件事情。首先，你需要创建这个方法，并使用`super()`调用父类的`__init__()`方法。这有助于
    AlgoBulls 核心引擎创建进一步开发策略所需的必要数据结构。接下来，你从`self.strategy_parameters`中创建两个新属性——`self.timeperiod1`和`self.timeperiod2`。`self.strategy_parameters`是从`StrategyBase`派生的每个策略子类都可用的字典对象。（第8章的第二个配方讨论了这些值如何在运行时传递给`self.strategy_parameters`。）你将使用这些参数作为下一个配方中两个
    EMA 的时间段。'
- en: Lastly, you create a new attribute, `self.main_order`, which is an empty dictionary.
    We will use this to save the handles to all the open orders placed during the
    execution of this strategy.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你创建一个新属性，`self.main_order`，它是一个空字典。我们将用它来保存在执行此策略期间放置的所有未完成订单的句柄。
- en: 'The `initialize()` method: This method is called at the beginning of every
    market day to initialize any internal variables to their default state. For real
    trading and paper trading, this method is called once. For multi-day backtesting,
    this method is called multiple times, once at the beginning of every new trading
    day. In this method, you initialize `self.main_order` to an empty dictionary.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize()` 方法：这个方法在每个交易日的开头被调用，用于将任何内部变量初始化为它们的默认状态。对于实际交易和模拟交易，这个方法只调用一次。对于多日回测，这个方法会被多次调用，在每个新的交易日的开头调用一次。在这个方法中，你将`self.main_order`初始化为空字典。'
- en: 'The `name()` method: This is a static method, which returns the name of this
    strategy. This is used while availing backtesting, paper trading, and real trading
    services on this strategy. In this method, you simply return a string, `Exponential
    Moving Average Regular Order`. You can return any string of your choice.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name()` 方法：这是一个静态方法，返回此策略的名称。在使用此策略进行回测、模拟交易和实际交易时会用到。在这个方法中，你只需返回一个字符串，`指数移动平均线常规委托`。你可以返回任何你选择的字符串。'
- en: 'The `versions_supported()` method: This static method is used for returning
    the AlgoBulls core engine version for which this strategy has been created. Often,
    as new upgrades come to the AlgoBulls core engine, some backward-incompatible
    changes may get introduced. This method helps to ensure this strategy is run on
    the correct version of the AlgoBulls core engine at all times. In this method,
    you return the highest available version from the constants module, which at the
    time of writing this chapter is VERSION_3_2_0.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`versions_supported()` 方法：这个静态方法用于返回创建此策略的 AlgoBulls 核心引擎版本。通常情况下，随着 AlgoBulls
    核心引擎的新升级，可能会引入一些不兼容的变化。这个方法有助于确保此策略始终在正确的 AlgoBulls 核心引擎版本上运行。在这个方法中，你需要从常量模块中返回最高可用版本，目前写这一章时的版本是
    VERSION_3_2_0。'
- en: These four methods are mandatory; they are enforced by the `StrategyBase` base
    class and cannot be skipped.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个方法是强制性的；它们由`StrategyBase`基类强制执行，不能被跳过。
- en: EMA-Regular-Order strategy – coding the strategy_select_instruments_for_entry
    method
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EMA-Regular-Order 策略 - 编写 strategy_select_instruments_for_entry 方法
- en: In this recipe, you continue coding the `StrategyEMARegularOrder` class. Here,
    you code the `strategy_select_instruments_for_entry()` method, a mandatory method
    enforced by the `StrategyBase` base class. This method is called by the AlgoBulls
    core engine on every new candle for backtesting, paper trading, and real trading
    services.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，你将继续编写`StrategyEMARegularOrder`类。在这里，你将编写`strategy_select_instruments_for_entry()`方法，这是由`StrategyBase`基类强制执行的强制性方法。AlgoBulls
    核心引擎会在每个新的蜡烛上调用此方法，用于回测、模拟交易和实际交易服务。
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how the AlgoBulls core engine calls the `strategy_select_instruments_for_entry()`
    method during strategy execution.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章介绍中的流程图，了解 AlgoBulls 核心引擎在策略执行期间如何调用`strategy_select_instruments_for_entry()`方法。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have followed the preceding recipe to create the `StrategyEMARegularOrder`
    class before starting this recipe.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您在开始此配方之前已经按照前面的配方创建了`StrategyEMARegularOrder`类。
- en: How to do it…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Continue coding the `StrategyEMARegularOrder` class. We need to define two
    new methods—a method for getting the crossover value between the MACD line and
    MACD history signals and a method for selecting instruments from `instruments_bucket`
    for entering a new position based on the computed crossover value:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写`StrategyEMARegularOrder`类。我们需要定义两个新方法——一个用于获取MACD线和MACD历史信号之间的交叉值，另一个用于根据计算的交叉值从`instruments_bucket`中选择金融工具以进入新仓位：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, we continue coding the `StrategyEMARegularOrder` class. We
    define two new methods for this class, described as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们继续编写`StrategyEMARegularOrder`类的代码。我们为这个类定义了两个新方法，描述如下：
- en: 'The `get_crossover_value()` method: This method takes `instrument` as an argument
    (along with `self`). This is the financial instrument for which the crossover
    value has to be computed. You fetch the latest historical data using the `self.get_historical_data()`
    method and assign it to a new attribute, `hist_data`. We pass `instrument` as
    the argument to this method. The `hist_data` attribute is a `pandas.DataFrame`
    object with `timestamp`, `open`, `high`, `low`, `close`, and `volume` columns.
    The default duration of the fetched historical data is the last 15 days.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_crossover_value()`方法：这个方法以`instrument`作为参数（以及`self`）。这是需要计算交叉值的金融工具。您使用`self.get_historical_data()`方法获取最新的历史数据，并将其赋值给一个新属性`hist_data`。我们将`instrument`作为这个方法的参数。`hist_data`属性是一个`pandas.DataFrame`对象，具有`timestamp`、`open`、`high`、`low`、`close`和`volume`列。获取的历史数据的默认持续时间是最近的15天。'
- en: You compute EMA on the close of `hist_data` using the `talib.EMA` function,
    for a time period of `self.timeperiod1`, and assign it to `ema_x`. This data is
    a `pandas.Series` object. (Refer to the second recipe of [Chapter 5](16529fe4-d3ea-4017-a6f9-bad85a41d8a0.xhtml), *Computing
    and Plotting of Technical Indicators*, for more details on the computation of
    EMA.) Similarly, you compute EMA on the close of `hist_data` for a time period
    of `self.timeperiod2` and assign it to `ema_y`. This return data is again a `pandas.Series`
    object.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用`talib.EMA`函数在`hist_data`的收盘价上计算EMA，时间周期为`self.timeperiod1`，并将其赋值给`ema_x`。这个数据是一个`pandas.Series`对象。（更多关于EMA计算的细节，请参考[第五章](16529fe4-d3ea-4017-a6f9-bad85a41d8a0.xhtml)的第二个配方，*计算和绘制技术指标*。）类似地，您使用`self.timeperiod2`的时间周期在`hist_data`的收盘价上计算EMA，并将其赋值给`ema_y`。这个返回数据也是一个`pandas.Series`对象。
- en: 'You compute the crossover value between `ema_x` and `ema_y` using `self.utils.crossover(ema_x,
    ema_y)` and assign it to a new attribute, `crossover_value`. The `crossover()`
    function call works as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用`self.utils.crossover(ema_x, ema_y)`计算`ema_x`和`ema_y`之间的交叉值，并将其赋值给一个新属性`crossover_value`。`crossover()`函数调用如下：
- en: It takes two iterables as input. We pass `ema_x` and `ema_y` here.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它以两个可迭代对象作为输入。我们在这里传递`ema_x`和`ema_y`。
- en: If `ema_x` crosses `ema_y` upward, the crossover function returns `1`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`ema_x`向上穿越`ema_y`，交叉函数返回`1`。
- en: If `ema_x` crosses `ema_y` downward, the crossover function returns `-1`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`ema_x`向下穿越`ema_y`，交叉函数返回`-1`。
- en: If there is no crossover between `ema_x` and `ema_y`, then the crossover function
    returns `0`.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`ema_x`和`ema_y`之间没有交叉，则交叉函数返回`0`。
- en: Finally, you return `crossover_value`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您返回`crossover_value`。
- en: 'The `strategy_select_instruments_for_entry()` method: This method takes two
    arguments, other than `self`—`candle`, an object of the `CandleTime` type that
    contains the timestamp of the current candle, and `instruments_bucket`, an object
    of the `SetInstruments` type that contains all the financial instruments available
    for creating a new position. We pass this data at the time of strategy execution.
    You create two empty lists, `selected_instruments_bucket` and `sideband_info_bucket`.
    Then you run a `for` loop over `instruments_bucket`, and for each instrument,
    you call `self.get_crossover_value()` and save its value to a new attribute, `crossover_value`.
    Based on the value of `crossover_value`, you make a decision, as follows:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strategy_select_instruments_for_entry()`方法：这个方法除了`self`之外，还接受两个参数——`candle`，`CandleTime`类型的对象，其中包含当前蜡烛的时间戳，以及`instruments_bucket`，`SetInstruments`类型的对象，其中包含用于创建新仓位的所有金融工具。我们在策略执行时传递这些数据。您创建两个空列表，`selected_instruments_bucket`和`sideband_info_bucket`。然后您在`instruments_bucket`上运行一个`for`循环，并且对于每个金融工具，您调用`self.get_crossover_value()`并将其值保存到一个新属性`crossover_value`。根据`crossover_value`的值，您做出决定，如下所示：'
- en: 'If `crossover_value` is `1`, it means the strategy is giving a `BUY` signal.
    You do the following:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`crossover_value`为`1`，这意味着策略正在发出`BUY`信号。你需要执行以下操作：
- en: Append `instrument` to `selected_instruments_bucket`.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`instrument`附加到`selected_instruments_bucket`。
- en: 'Append an `{''action'': ''BUY''}` dictionary to the `sideband_info_bucket`
    attribute.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '向`sideband_info_bucket`属性附加一个`{''action'': ''BUY''}`字典。'
- en: 'If `crossover_value` is `-1`, it means the strategy is giving a `SELL` signal.
    You do the following:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`crossover_value`为`-1`，这意味着策略正在发出`SELL`信号。你需要执行以下操作：
- en: Append `instrument` to `selected_instruments_bucket`.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`instrument`附加到`selected_instruments_bucket`。
- en: 'Append an `{''action'': ''SELL''}` dictionary to the `sideband_info_bucket`
    attribute.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '向`sideband_info_bucket`属性附加一个`{''action'': ''SELL''}`字典。'
- en: If `crossover_value` is neither `1` nor `-1`, it means the strategy is not giving
    any signals. You do nothing here.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`crossover_value`既不是`1`也不是`-1`，这意味着策略没有发出任何信号。在这里你什么也不做。
- en: Finally, you return both the attributes: `selected_instruments_bucket` and `sideband_info_bucket`.
    These attributes may have been populated or may remain as empty lists.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要返回两个属性：`selected_instruments_bucket`和`sideband_info_bucket`。这些属性可能已经被填充，也可能保持为空列表。
- en: Recall that the `strategy_select_instruments_for_entry()` method is called for
    every candle, so the preceding steps are repeated for every new candle. In the
    appropriate candle, you would get a `BUY` or a `SELL` signal, and in the others,
    you won't get any signal. Based on the signal, you can place the appropriate order,
    which is discussed in the next recipe.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请回忆`strategy_select_instruments_for_entry()`方法是为每个蜡烛调用的，因此前面的步骤会针对每个新蜡烛重复执行。在适当的蜡烛中，你会得到一个`BUY`或`SELL`信号，而在其他蜡烛中，你将不会得到任何信号。根据信号，你可以下达适当的订单，这将在下一个示例中讨论。
- en: The `strategy_select_instruments_for_entry()` method is enforced by the `StrategyBase`
    base class and has to be defined for every strategy.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`strategy_select_instruments_for_entry()`方法是由`StrategyBase`基类强制执行的，每个策略都必须定义该方法。'
- en: The `get_crossover_value()` method is a helper method, meaning it is not enforced
    by the `StrategyBase` base class. You may choose not to define this or to define
    multiple of these helper functions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_crossover_value()`方法是一个辅助方法，意味着它不受`StrategyBase`基类的强制。你可以选择不定义这个方法，或者定义多个这样的辅助函数。'
- en: EMA-Regular-Order strategy – coding the strategy_enter_position method
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EMA-Regular-Order策略 - 编写strategy_enter_position方法
- en: In this recipe, you continue with the coding of the `StrategyEMARegularOrder`
    class. Here, you code the `strategy_enter_position()` method, a mandatory method
    enforced by the `StrategyBase` base class. This method is called by the AlgoBulls
    core engine every time the `strategy_select_instruments_for_entry` method returns
    non-empty data. This method may not be called for every new candle for backtesting,
    paper trading, and real trading services.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将继续编写`StrategyEMARegularOrder`类的代码。在这里，你将编写`strategy_enter_position()`方法，这是`StrategyBase`基类强制执行的一个必需方法。这个方法由AlgoBulls核心引擎在每次`strategy_select_instruments_for_entry`方法返回非空数据时调用。这个方法在回测、模拟交易和实际交易服务中可能不会为每个新蜡烛调用。
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how the AlgoBulls core engine calls the `strategy_enter_position()` method during
    strategy execution.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章介绍中的流程图，了解AlgoBulls核心引擎在策略执行期间如何调用`strategy_enter_position()`方法。
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Make sure you have followed the preceding recipe before starting this recipe.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在开始本示例之前已经按照前面的示例操作。
- en: How to do it…
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Continue coding the `StrategyEMARegularOrder` class. We need to define a method
    to punch new orders for a given instrument and enter a new position:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写`StrategyEMARegularOrder`类的代码。我们需要定义一个方法为给定的工具打新订单并进入一个新的头寸：
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we continue coding the `StrategyEMARegularOrder` class. We
    define a new method for this class, `strategy_enter_position()`, described as
    follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将继续编写`StrategyEMARegularOrder`类的代码。我们为该类定义了一个新方法，`strategy_enter_position()`，如下所述：
- en: 'This method takes three arguments, other than `self`:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法除了`self`之外还接受三个参数：
- en: '`candle`: An object of the `CandleTime` type that contains the timestamp of
    the current candle.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`candle`：包含当前蜡烛时间戳的`CandleTime`类型的对象。'
- en: '`instrument`: An object of the `Instrument` type that represents a financial
    instrument.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instrument`：代表金融工具的`Instrument`类型的对象。'
- en: '`sideband_info`: A dictionary object that holds information on trades to be
    placed for the `instrument` attribute. This object looks like `{''action'': [action_value]}`,
    where `[action_value]` can be either `''BUY''` or `''SELL''`.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sideband_info`：一个字典对象，保存了与`instrument`属性相关的交易信息。这个对象看起来像`{''action'': [action_value]}`，其中`[action_value]`可以是`''BUY''`或`''SELL''`。'
- en: You calculate the quantity for order to be placed by multiplying `self.number_of_lots`
    with `instrument.lot_size` and assign it to a new attribute `qty`. The `self.number_of_lots`
    attribute holds information on the number of lots to trade, which you can pass
    while executing this strategy. The `instrument.lot_size` attribute holds `lot_size`
    for `instrument`, which is a positive integer. For example, if number of lots
    is passed as 2 and lot size for instrument is 10, then the quantity for the order
    would be 2 * 10 = 20.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将`self.number_of_lots`与`instrument.lot_size`相乘，并将结果赋值给一个新属性`qty`来计算下单数量。`self.number_of_lots`属性保存了交易的手数信息，你可以在执行这个策略时传递它。`instrument.lot_size`属性保存了`instrument`的手数大小，它是一个正整数。例如，如果手数数为2，而instrument的手数大小为10，那么订单的数量将是2
    * 10 = 20。
- en: 'If `sideband_info` is `{''action'': ''BUY''}`, you place a `Regular` order
    of the `BUY` transaction type by creating an instance of the `self.broker.BuyOrderRegular`
    class (the first recipe of [Chapter 6](077b54a1-c9c4-424c-912a-11f28db3797f.xhtml), *Placing
    Regular Orders on the Exchange*) and assigning its value to `self.main_order[instrument]`.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果`sideband_info`是`{''action'': ''BUY''}`，则通过创建`self.broker.BuyOrderRegular`类的实例（[第6章](077b54a1-c9c4-424c-912a-11f28db3797f.xhtml)的第一个配方，*在交易所上放置常规订单*）并将其值赋给`self.main_order[instrument]`，来下达`BUY`交易类型的`Regular`订单。'
- en: 'If `sideband_info` is `{''action'': ''SELL''}`, you place a `Regular` order
    of the `SELL` transaction type by creating an instance of the `self.broker.SellOrderRegular`
    class (the first recipe of [Chapter 6](077b54a1-c9c4-424c-912a-11f28db3797f.xhtml),
    *Placing Regular Orders on the Exchange*) and assigning its value to `self.main_order[instrument]`.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果`sideband_info`是`{''action'': ''SELL''}`，则通过创建`self.broker.SellOrderRegular`类的实例（[第6章](077b54a1-c9c4-424c-912a-11f28db3797f.xhtml)的第一个配方，*在交易所上放置常规订单*）并将其值赋给`self.main_order[instrument]`，来下达`SELL`交易类型的`Regular`订单。'
- en: In both cases, the `self.main_order dictionary` object holds the `instrument`
    and `order` instances as a key-value pair. This will be useful later (in the *EMA-Regular-Order
    strategy – coding the strategy_exit_position method* recipe) for exiting positions
    created by this method.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`self.main_order`字典对象将`instrument`和`order`实例作为键值对保存。这将在稍后（在*EMA-Regular-Order策略
    - 编写strategy_exit_position方法*配方中）对通过此方法创建的头寸进行退出时非常有用。
- en: The `self.broker` attribute is replaced by the appropriate broker instance at
    runtime by the AlgoBulls core engine. So, the same code can work across all the
    brokers supported by the AlgoBulls platform.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.broker`属性在运行时由AlgoBulls核心引擎替换为适当的经纪人实例。因此，相同的代码可以在AlgoBulls平台支持的所有经纪人上运行。'
- en: EMA-Regular-Order strategy – coding the strategy_select_instruments_for_exit
    method
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EMA-Regular-Order策略 - 编写strategy_select_instruments_for_exit方法
- en: In this recipe, you continue with the coding of the `StrategyEMARegularOrder`
    class. Here, you code the `strategy_select_instruments_for_exit()` method, a mandatory
    method enforced by the `StrategyBase` base class. This method is called by the
    AlgoBulls core engine for every new candle for backtesting, paper trading, and
    real trading services if there are any open positions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你将继续编写`StrategyEMARegularOrder`类的代码。在这里，你编写`strategy_select_instruments_for_exit()`方法，这是`StrategyBase`基类强制执行的一个必需方法。如果有任何未平仓头寸，AlgoBulls核心引擎将为每个新的蜡烛进行回测、纸上交易和真实交易服务调用此方法。
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how the AlgoBulls core engine calls the `strategy_select_instruments_for_exit()`
    method during strategy execution.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章介绍中的流程图，了解AlgoBulls核心引擎在策略执行期间如何调用`strategy_select_instruments_for_exit()`方法。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have followed the preceding recipe before starting this recipe.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本配方之前，请确保您已经按照前面的配方进行了操作。
- en: How to do it…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Continue coding the `StrategyEMARegularOrder` class. We need to define a new
    method for selecting instruments from `instruments_bucket` for exiting an existing
    position based on the computation of the crossover value:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写`StrategyEMARegularOrder`类。我们需要定义一个新的方法，根据交叉值的计算从`instruments_bucket`中选择工具以退出现有头寸：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we continue coding the `StrategyEMARegularOrder` class. We
    define a new method for this class, `strategy_select_instruments_for_exit()`,
    described as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们继续编写`StrategyEMARegularOrder`类。我们为此类定义一个新方法，`strategy_select_instruments_for_exit()`，如下所述：
- en: 'This method takes two arguments, other than `self`:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了`self`之外，此方法还接受两个参数：
- en: '`candle`: An object of the `CandleTime` type that contains the timestamp of
    the current candle.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`candle`：`CandleTime`类型的对象，包含当前蜡烛的时间戳。'
- en: '`instruments_bucket`: An object of the `SetInstruments` type. This object holds
    financial instruments that have been entered into a position earlier by the `strategy_enter_position()`
    method.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instruments_bucket`：`SetInstruments`类型的对象。该对象保存了之前通过`strategy_enter_position()`方法输入仓位的金融工具。'
- en: You create two empty lists, `selected_instruments_bucket` and `sideband_info_bucket`.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建两个空列表，`selected_instruments_bucket`和`sideband_info_bucket`。
- en: You run a `for` loop over `instruments_bucket`. For each instrument, you check
    whether there is a position entered for the given instrument using the `'if self.main_order.get(instrument)
    is not None:'` line. You proceed only if a position exists already.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`instruments_bucket`进行`for`循环。对于每个工具，使用`'if self.main_order.get(instrument)
    is not None:'`行检查是否已输入给定工具的仓位。只有在已存在仓位的情况下才继续。
- en: 'You call `self.get_crossover_value()` and save its value to a new attribute,
    `crossover_value`. Based on the value of `crossover_value`, you make a decision,
    as follows:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您调用`self.get_crossover_value()`并将其值保存到一个新属性`crossover_value`中。根据`crossover_value`的值，您做出决定，如下所示：
- en: 'If `crossover_value` is either `1` or `-1`, it means there has been a crossover.
    You do the following:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`crossover_value`为`1`或`-1`，则表示发生了交叉。你执行以下操作：
- en: Append the `instrument` attribute to `selected_instruments_bucket`.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`instrument`属性追加到`selected_instruments_bucket`。
- en: 'Append an `{''action'': ''EXIT''}` dictionary to the `sideband_info_bucket`
    attribute.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将`{''action'': ''EXIT''}`字典追加到`sideband_info_bucket`属性。'
- en: If `crossover_value` is neither `1` nor `-1`, it means the strategy is not giving
    any signal. You do nothing here.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`crossover_value`既不是`1`也不是`-1`，则表示策略未发出任何信号。这里不做任何操作。
- en: Finally, you return both the attributes: `selected_instruments_bucket` and `sideband_info_bucket`.
    These attributes may have gotten populated or may remain as empty lists.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，您返回两个属性：`selected_instruments_bucket`和`sideband_info_bucket`。这些属性可能已填充，也可能保持为空列表。
- en: Recall that the `strategy_select_instruments_for_exit()` method is called for
    every candle, so the preceding steps are repeated for every new candle. In the
    appropriate candle, if there is a position, you may get an `EXIT` signal, and
    in the others, you won't get any signal. Based on the signal, you can exit the
    position by placing an appropriate order, which is discussed in the next recipe.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`strategy_select_instruments_for_exit()`方法将针对每个蜡烛调用，因此前述步骤将针对每个新蜡烛重复。在适当的蜡烛中，如果存在仓位，您可能会收到`EXIT`信号，在其他情况下，您将不会收到任何信号。根据信号，您可以通过放置适当的订单退出仓位，这将在下一个配方中讨论。
- en: EMA-Regular-Order strategy – coding the strategy_exit_position method
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EMA-Regular-Order策略 - 编写`strategy_exit_position`方法
- en: In this recipe, you will continue with the coding of the `StrategyEMARegularOrder`
    class. Here, you will code the `strategy_exit_position()` method, the last mandatory
    method enforced by the `StrategyBase` base class. This method is called by the
    AlgoBulls core engine every time the `strategy_select_instruments_for_exit` method
    returns non-empty data. By the end of this recipe, you will have completed coding
    the `StrategyEMARegularOrder` class.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，您将继续编写`StrategyEMARegularOrder`类的代码。在这里，您将编写`strategy_exit_position()`方法，这是`StrategyBase`基类强制执行的最后一个必需方法。此方法由AlgoBulls核心引擎在每次`strategy_select_instruments_for_exit`方法返回非空数据时调用。完成本配方后，您将完成编写`StrategyEMARegularOrder`类。
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how AlgoBulls core engine calls the `strategy_select_instruments_for_exit()` method
    during strategy execution.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章介绍中的流程图，了解AlgoBulls核心引擎在策略执行期间如何调用`strategy_select_instruments_for_exit()`方法。
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Make sure you have followed the previous recipe before starting this recipe.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本配方之前，请确保您已按照上一个配方进行了操作。
- en: How to do it…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Continue coding the `StrategyEMARegularOrder` class. Define a method to the
    exit position for a given instrument based on `sideband_info`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写`StrategyEMARegularOrder`类。为给定工具基于`sideband_info`定义一个退出仓位的方法：
- en: '[PRE12]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, we continue coding the `StrategyEMARegularOrder` class. We
    define a new method for this class, `strategy_exit_position()`, described as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们继续编写`StrategyEMARegularOrder`类。我们为此类定义一个新方法，`strategy_exit_position()`，如下所述：
- en: 'This method takes three arguments, other than `self`:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法除了`self`之外还接受三个参数：
- en: '`candle`: An object of `CandleTime` type that contains the timestamp of the
    current candle.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`candle`：一个包含当前蜡烛时间戳的`CandleTime`类型的对象。'
- en: '`instrument`: An object of `Instrument` type that represents a financial instrument.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instrument`：一个表示金融工具的`Instrument`类型的对象。'
- en: '`sideband_info`: A dictionary object that holds information on trades to be
    placed for the `instrument` attribute. This object looks like `{''action'': ''EXIT''}`.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sideband_info`：一个包含有关要为`instrument`属性放置交易的信息的字典对象。此对象类似于`{''action'': ''EXIT''}`。'
- en: 'If `sideband_info` is `{''action'': ''EXIT''}`, do the following:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果`sideband_info`是`{''action'': ''EXIT''}`，则执行以下操作：'
- en: You fetch the order using `self.main_order[instrument]` (recall that `self.main_order`
    is a dictionary that holds instruments and corresponding order instances as key-value
    pairs.)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您使用`self.main_order[instrument]`获取订单（请回想一下，`self.main_order`是一个将工具和相应订单实例作为键值对保存的字典）。
- en: You exit the position for this order by calling its `exit_position()` method.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您通过调用其`exit_position()`方法退出此订单的持仓。
- en: You reset the value corresponding to the key `instrument` in `self.main_order`
    as `None`. This indicates that there is no longer a position open corresponding
    to `instrument`.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将`self.main_order`中对应于键`instrument`的值重置为`None`。这表明不再存在与`instrument`相对应的持仓。
- en: You return `True`, signaling to the AlgoBulls core engine that a position has
    been exited for `instrument` in this call.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`True`，向 AlgoBulls 核心引擎表明此次调用中已经退出了`instrument`的持仓。
- en: 'If `sideband_info` is not `{''action'': ''EXIT''}`, you return `False`, signaling
    to the AlgoBulls core engine that no position was not exited for `instrument`
    in this call.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果`sideband_info`不是`{''action'': ''EXIT''}`，则返回`False`，向 AlgoBulls 核心引擎表明在此调用中未退出`instrument`的持仓。'
- en: The `self.broker` attribute is replaced by the appropriate broker instance at
    runtime by the AlgoBulls core engine. So, the same code can work across all the
    brokers supported by the AlgoBulls platform.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.broker` 属性会在 AlgoBulls 核心引擎运行时被适当的经纪人实例替换。因此，相同的代码可以在 AlgoBulls 平台支持的所有经纪人上运行。'
- en: You have now completed the coding for the `StrategyEMARegularOrder` class.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经完成了`StrategyEMARegularOrder`类的编码。
- en: EMA-Regular-Order strategy – uploading the strategy on the AlgoBulls trading
    platform
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EMA-Regular-Order 策略 – 在 AlgoBulls 交易平台上上传策略
- en: In this recipe, you will upload the strategy class, `StrategyEMARegularOrder`,
    which you created in the preceding recipes, on the AlgoBulls trading platform.
    Once it is uploaded, you can perform backtesting, paper trading, and real trading
    on the same code base.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您将在 AlgoBulls 交易平台上上传策略类`StrategyEMARegularOrder`，该类是您在前面的示例中创建的。一旦上传完成，您可以在相同的代码库上进行回测、模拟交易和真实交易。
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Make sure you have set up your account on the AlgoBulls platform ([https://algobulls.com](https://algobulls.com))
    to get your API token. Setting up an account is free. Using its services might
    incur charges depending on your usage. You can start with free packages on the
    site. Refer to *Appendix II* for more details.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '确保您已在 AlgoBulls 平台（[https://algobulls.com](https://algobulls.com)）上设置了您的帐户以获取您的
    API 令牌。设置帐户是免费的。使用其服务可能会产生费用，具体取决于您的使用情况。您可以从网站上的免费套餐开始。有关更多详细信息，请参阅*附录 II*。 '
- en: How to do it…
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行…
- en: 'We execute the following steps for this recipe:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为此示例执行以下步骤：
- en: 'Import the necessary modules:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的模块：
- en: '[PRE13]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a new AlgoBulls connection object:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 AlgoBulls 连接对象：
- en: '[PRE14]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Fetch the authorization URL:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取授权 URL：
- en: '[PRE15]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We get the following output:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Log in to the preceding link with your AlgoBulls credentials, fetch your token,
    and set it here (refer to *Appendix II* for more details):'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的 AlgoBulls 凭据登录到上述链接，获取您的令牌，并在此处设置它（有关更多详细信息，请参阅*附录 II*）：
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Before uploading your strategy, you can inspect your strategy code to ensure
    you are uploading the right strategy:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上传策略之前，您可以检查您的策略代码，以确保您上传了正确的策略：
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We get the following output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE19]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The complete output is not shown here. Please visit the following link to read
    the complete output:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有显示完整的输出。请访问以下链接以阅读完整的输出：
- en: '[https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_ema_regular_order.py](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_ema_regular_order.py).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_ema_regular_order.py](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_ema_regular_order.py)。'
- en: 'Upload `StrategyEMARegularOrder` onto the AlgoBulls platform. This creates
    a new strategy for your AlgoBulls account:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`StrategyEMARegularOrder`上传到AlgoBulls平台。 这将为您的AlgoBulls帐户创建一个新策略：
- en: '[PRE20]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We get the following output (your output may differ):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得以下输出（您的输出可能会有所不同）：
- en: '[PRE21]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理如下...
- en: We import the necessary modules in *step 1*. In *step 2*, an instance of the
    `AlgoBullsConnection` class is created, named `algobulls_connection`. In *step
    3*, you get the authorization URL using the `get_authorization_url()` method of
    the `algobulls_connection` object. You should visit this URL from your web browser
    to sign in to the AlgoBulls platform and fetch your developer access token. (You
    can find more details with screenshots in *Appendix II* on fetching the developer
    access token from the AlgoBulls platform.) You copy the access token and set it
    in *step 4* using the `set_access_token()` method of `algobulls_connection`. If
    the token is accepted, a successful connection is set up with the AlgoBulls platform.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*步骤1*中导入所需的模块。 在*步骤2*中，创建了`AlgoBullsConnection`类的实例，命名为`algobulls_connection`。
    在*步骤3*中，使用`algobulls_connection`对象的`get_authorization_url()`方法获取授权URL。 您应该从Web浏览器访问此URL以登录到AlgoBulls平台并获取您的开发者访问令牌。
    （您可以在AlgoBulls平台上的*附录II*中找到有关从AlgoBulls平台获取开发者访问令牌的详细信息和截图。） 您复制访问令牌并在*步骤4*中使用`algobulls_connection`的`set_access_token()`方法设置它。
    如果令牌被接受，则与AlgoBulls平台建立了成功的连接。
- en: The `StrategyEMARegularOrder` strategy class that we coded in *steps 1* to *5* is
    also available in the `pyalgostrategypool` package. We import this class in *step
    1*. Alternatively, you can also save your strategy class in a separate Python
    module and import it in *step 1* instead of importing it from `pyalgostrategypool`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*步骤1*到*5*中编写的`StrategyEMARegularOrder`策略类也在`pyalgostrategypool`包中可用。 我们在*步骤1*中导入此类。
    或者，您也可以将您的策略类保存在单独的Python模块中，并在*步骤1*中导入它，而不是从`pyalgostrategypool`导入它。
- en: You upload the `StrategyEMARegularOrder` strategy class using the `upload_strategy()`
    method of `algobulls_connection` by passing it as a parameter. If the upload is
    successful, you will get a success message with `strategy_code`, which is a unique
    string. `strategy_code` can be used later to do everything related to the strategy—for
    example, editing the strategy, performing backtesting ([Chapter 9](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml),
    *Algorithmic Trading – Backtesting*), performing paper trading ([Chapter 10](0f869a6e-bb6b-4f5f-828e-33ca477c509d.xhtml),* Algorithmic
    Trading – **Paper Trading*), and performing real trading ([Chapter 11](725b5f38-fffb-46ae-8b5b-8a4667419e3a.xhtml),* Algorithmic
    Trading – **Real Trading*).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用`algobulls_connection`的`upload_strategy()`方法将`StrategyEMARegularOrder`策略类作为参数上传。
    如果上传成功，您将收到带有`strategy_code`的成功消息，这是一个唯一的字符串。 `strategy_code`可以稍后用于执行与策略相关的所有操作，例如编辑策略，执行回测（[第9章](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml)，*算法交易
    - 回测*），执行模拟交易（[第10章](0f869a6e-bb6b-4f5f-828e-33ca477c509d.xhtml)，*算法交易 - 模拟交易*），以及执行实际交易（[第11章](725b5f38-fffb-46ae-8b5b-8a4667419e3a.xhtml)，*算法交易
    - 实际交易*）。
- en: There's more…
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If there are changes done to a strategy after uploading, you can update the
    strategy on the AlgoBulls platform using the `upload_strategy()` method of `algobulls_connection`
    with the updated class and `overwrite=True` as arguments. If the changes are uploaded
    successfully, you will get a success message.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在上传后对策略进行了更改，您可以使用`algobulls_connection`的`upload_strategy()`方法将更新后的类和`overwrite=True`作为参数更新AlgoBulls平台上的策略。
    如果更改成功上传，您将收到成功消息。
- en: 'Modify an already-uploaded strategy:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 修改已上传的策略：
- en: '[PRE22]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We get the following output:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得以下输出：
- en: '[PRE23]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Multiple strategies with the same name (returned by the `name()` method) are
    not allowed by the AlgoBulls platform. The `overwrite=True` parameter updates
    an existing strategy with the same name if present. If `overwrite=True` is not
    passed to the `create_strategy()` method, the default value is `False`, which
    means it tries to create a new strategy on the AlgoBulls platform.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: AlgoBulls平台不允许具有相同名称（由`name()`方法返回）的多个策略。 如果存在具有相同名称的现有策略，则`overwrite=True`参数将更新该策略。
    如果未将`overwrite=True`传递给`create_strategy()`方法，则默认值为`False`，这意味着它尝试在AlgoBulls平台上创建一个新策略。
- en: MACD-Bracket-Order strategy – coding the __init__, initialize, name, and versions_supported
    methods
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'MACD-Bracket-Order 策略 – 编码 `__init__`、`initialize`、`name` 和 `versions_supported`
    方法  '
- en: 'This recipe demonstrates the initial coding of the `StrategyMACDBracketOrder`
    class. The complete class will be coded by the end of the eleventh recipe of this
    chapter. In this recipe, you will code the following methods:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '本配方演示了 `StrategyMACDBracketOrder` 类的初始编码。完整的类将在本章的第十一个配方结束时编码。在本配方中，您将编写以下方法：  '
- en: '`__init__()`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()`  '
- en: '`initialize()`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize()`  '
- en: '`name()`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name()`  '
- en: '`versions_supported()`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`versions_supported()`  '
- en: To learn more about the MACD technical indicator, please refer to the *Trend
    indicator – moving average convergence divergence* recipe of [Chapter 5](16529fe4-d3ea-4017-a6f9-bad85a41d8a0.xhtml),
    *Computing and Plotting Technical Indicators*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '要了解更多关于 MACD 技术指标的信息，请参考 [Chapter 5](16529fe4-d3ea-4017-a6f9-bad85a41d8a0.xhtml)
    中的*Trend indicator – moving average convergence divergence*配方，*计算和绘制技术指标*。  '
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how the AlgoBulls core engine calls the `__init__()` and `initialize()` methods
    during strategy execution.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '请参考本章介绍中的流程图，了解 AlgoBulls 核心引擎在策略执行过程中如何调用 `__init__()` 和 `initialize()` 方法。  '
- en: Getting ready
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '准备工作  '
- en: Make sure you have the `StrategyBase` and `pyalgotrading` constants in your
    Python namespace. Refer to the *Technical requirements* section of this chapter
    to set it up.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '确保你的 Python 命名空间中有 `StrategyBase` 和 `pyalgotrading` 常量。请参考本章的*技术要求*部分进行设置。  '
- en: How to do it…
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '如何做…  '
- en: 'Create a new class named `StrategyMACDBracketOrder`. Subclass it from `StrategyBase`.
    Define the required four methods:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '创建一个名为 `StrategyMACDBracketOrder` 的新类。从 `StrategyBase` 派生它。定义所需的四种方法：  '
- en: '[PRE24]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works…
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '工作原理…  '
- en: 'In this recipe, we will create the `StrategyEMARegularOrder` class, subclassed
    from `StrategyBase`. We will define four methods for this class, described as
    follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '在本配方中，我们将创建 `StrategyEMARegularOrder` 类，它是从 `StrategyBase` 派生的子类。我们将为该类定义四种方法，如下所述：  '
- en: 'The `__init__()` method: This is the first thing you do when you create a new
    strategy. First, you create this method and call the parent class `__init__()`
    method using `super()`. This helps the AlgoBulls core engine create the necessary
    data structures needed for the further development of the strategy. Next, you
    create six attributes from `self.strategy_parameters`:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()` 方法：这是创建新策略时的第一步。首先，您创建此方法并使用 `super()` 调用父类 `__init__()` 方法。这有助于
    AlgoBulls 核心引擎创建进一步开发策略所需的必要数据结构。接下来，您从 `self.strategy_parameters` 创建六个属性：  '
- en: '`self.fastMA_period`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.fastMA_period`  '
- en: '`self.slowMA_period`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.slowMA_period`  '
- en: '`self.signal_period`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.signal_period`  '
- en: '`self.stoploss`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.stoploss`  '
- en: '`self.target`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.target`  '
- en: '`self.trailing_stoploss`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.trailing_stoploss`  '
- en: '`self.strategy_parameters` is a dictionary object available for every strategy
    subclassed from `StrategyBase`. (The seventh recipe of [Chapter 9](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml),* Algorithmic
    Trading – **Backtesting*, discusses how these values are passed at runtime to
    `self.strategy_parameters`.) These parameters will be used in the next recipe
    of this chapter as parameters to the MACD technical indicator. Lastly, you create
    a new attribute, `self.main_order`, an empty dictionary. We will use this for
    saving the handles to all the open orders placed during the execution of this
    strategy.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.strategy_parameters` 是从 `StrategyBase` 派生的每个策略的字典对象。 (第九章的第七个配方 [Chapter
    9](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml)，*算法交易 – **回测*，讨论了这些值如何在运行时传递给 `self.strategy_parameters`。)
    这些参数将在本章的下一个配方中作为 MACD 技术指标的参数使用。最后，创建一个新属性，`self.main_order`，为空字典。我们将用它来保存在执行此策略期间放置的所有挂单的句柄。  '
- en: 'The `initialize()` method: This method is called at the beginning of every
    market day to initialize any internal variables to their default state. For real
    trading and paper trading, this method is called once. For multi-day backtesting,
    this method is called multiple times, once at the beginning of every new trading
    day. In this method, you initialize `self.main_order` to an empty dictionary.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize()` 方法：这个方法在每个交易日的开始时调用，将内部变量初始化为它们的默认状态。对于实盘交易和模拟交易，此方法只调用一次。对于多日回测，此方法会多次调用，每个交易日开始时调用一次。在这个方法中，您将
    `self.main_order` 初始化为空字典。  '
- en: 'The `name()` method: This is a static method that returns the name of this
    strategy. This is used while utilizing backtesting, paper trading, and real trading
    services on this strategy. In this method, you simply return a string, `MACD Bracket
    Order`. You can return any string of your choice in this method.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name()` 方法：这是一个静态方法，返回此策略的名称。在使用此策略进行回测、模拟交易和实盘交易服务时使用。在此方法中，你简单地返回一个字符串，`MACD
    Bracket Order`。你可以在此方法中返回任何你选择的字符串。'
- en: 'The `versions_supported()` method: This static method is used for returning
    the AlgoBulls core engine version for which this strategy has been created. Often,
    as new upgrades come to the AlgoBulls core engine, some backward-incompatible
    changes may get introduced. This method helps to ensure this strategy is run on
    the correct version of the AlgoBulls core engine at all times. In this method,
    you return the highest available version from the constants module, which at the
    time of writing this chapter is VERSION_3_2_0.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`versions_supported()` 方法：此静态方法用于返回此策略已创建的AlgoBulls核心引擎版本。通常，随着AlgoBulls核心引擎的新升级，可能会引入一些向后不兼容的更改。此方法有助于确保此策略始终在AlgoBulls核心引擎的正确版本上运行。在此方法中，你从常量模块中返回最高可用版本，即在编写本章时为VERSION_3_2_0。'
- en: These four methods are mandatory; they are enforced by the `StrategyBase` base
    class and cannot be skipped.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个方法是强制性的；它们由`StrategyBase`基类强制执行，不能跳过。
- en: MACD-Bracket-Order strategy – coding the strategy_select_instruments_for_entry
    method
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order 策略 - 编写 strategy_select_instruments_for_entry 方法
- en: In this recipe, you will continue coding the `StrategyMACDBracketOrder` class.
    Here, you will code the `strategy_select_instruments_for_entry()` method, a mandatory
    method enforced by the `StrategyBase` base class. This method is called by the
    AlgoBulls core engine on every new candle for backtesting, paper trading, and
    real trading services.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将继续编写`StrategyMACDBracketOrder`类。在这里，你将编写`strategy_select_instruments_for_entry()`方法，这是`StrategyBase`基类强制执行的一个必要方法。此方法由AlgoBulls核心引擎在每个新蜡烛上调用，用于回测、模拟交易和实盘交易服务。
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how the AlgoBulls core engine calls the `strategy_select_instruments_for_entry()`
    method during strategy execution.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章介绍中的流程图，了解AlgoBulls核心引擎在策略执行期间如何调用`strategy_select_instruments_for_entry()`方法。
- en: Getting ready
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have followed the previous recipe to create the `StrategyMACDBracketOrder`
    class before starting this recipe.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这个示例之前，请确保你已经按照上一个示例创建了`StrategyMACDBracketOrder`类。
- en: How to do it…
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Continue coding the `StrategyMACDBracketOrder` class. Define two new methods—a method
    for getting the crossover value between the MACD line and MACD history signals
    and a method for selecting instruments from `instruments_bucket` for entering
    a new position based on the computed crossover value:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写`StrategyMACDBracketOrder`类。定义两个新方法——一个用于获取MACD线和MACD历史信号之间的交叉值的方法，另一个用于根据计算的交叉值从`instruments_bucket`中选择进入新仓位的工具：
- en: '[PRE25]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, we continue coding the `StrategyMACDBracketOrder` class. We
    define two new methods for this class, described as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们继续编写`StrategyMACDBracketOrder`类。我们为这个类定义了两个新方法，描述如下：
- en: 'The `get_crossover_value()` method: This is a helper method. It takes `instrument`
    as an argument (along with `self`). This is the financial instrument for which
    the crossover value has to be computed. You fetch the latest historical data using
    the `self.get_historical_data()` method and assign it to a new attribute, `hist_data`.
    We pass `instrument` as the argument to this method. The `hist_data` attribute
    is a `pandas.DataFrame` object with `timestamp`, `open`, `high`, `low`, `close`,
    and `volume` columns.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_crossover_value()` 方法：这是一个辅助方法。它以`instrument`作为参数（以及`self`）。这是需要计算交叉值的金融工具。你使用`self.get_historical_data()`方法获取最新的历史数据，并将其赋值给一个新属性`hist_data`。我们将`instrument`作为此方法的参数传递。`hist_data`属性是一个`pandas.DataFrame`对象，具有`timestamp`、`open`、`high`、`low`、`close`和`volume`列。'
- en: 'The default duration of the fetched historical data is the last 15 days. You
    compute MACD on the close of `hist_data` using the `talib.MACD` function. It takes
    the following additional arguments:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 获取的历史数据的默认持续时间是过去的15天。你使用`talib.MACD`函数在`hist_data`的收盘价上计算MACD。它接受以下附加参数：
- en: '`fastperiod`: We pass `self.fastMA_period` here.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fastperiod`：我们在这里传递了`self.fastMA_period`。'
- en: '`slowperiod`: We pass `self.slowMA_period` here.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slowperiod`：我们在这里传递了`self.slowMA_period`。'
- en: '`signalperiod:` We pass `self.signal_period` here.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signalperiod:`我们在这里传递`self.signal_period`。'
- en: 'This computed MACD data is a tuple of the `pandas.Series` object, which you
    assign to `macdline`, `macdsignal`, and `_` (the last object in the tuple is assigned
    to `_` because it is not required). (Refer to the third recipe in [Chapter 5](16529fe4-d3ea-4017-a6f9-bad85a41d8a0.xhtml),
    *Computing and Plotting Technical Indicators*, for more details on computation
    of MACD.) You compute the crossover value between `macdline` and `macdsignal`
    using `self.utils.crossover(macdline, macdsignal)` and assign it to a new attribute,
    `crossover_value`. The `crossover()` function call works as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 此计算得到的MACD数据是一个`pandas.Series`对象的元组，你将其分配给`macdline`、`macdsignal`和`_`（最后一个对象分配给`_`，因为它不需要）。（有关MACD计算的更多详细信息，请参阅[第5章](16529fe4-d3ea-4017-a6f9-bad85a41d8a0.xhtml)的第三篇，*计算和绘制技术指标*。）你使用`self.utils.crossover(macdline,
    macdsignal)`计算`macdline`和`macdsignal`之间的交叉值，并将其分配给一个新属性`crossover_value`。`crossover()`函数调用如下：
- en: It takes two iterables as input. We pass `macdline` and `macdsignal` here.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要两个可迭代对象作为输入。我们在这里传递`macdline`和`macdsignal`。
- en: If `macdline` crosses `macdsignal` upward, the crossover function returns `1`.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`macdline`向上穿过`macdsignal`，交叉函数返回`1`。
- en: If `macdline` crosses the `macdsignal` downward, the crossover function returns
    `-1`.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`macdline`向下穿过`macdsignal`，交叉函数返回`-1`。
- en: If there is no crossover between `macdline` and `macdsignal`, then the crossover
    function returns `0`.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`macdline`和`macdsignal`之间没有交叉，则交叉函数返回`0`。
- en: Finally, you return `crossover_value`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你返回`crossover_value`。
- en: '`strategy_select_instruments_for_entry()` method: This method takes two arguments,
    other than `self`:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strategy_select_instruments_for_entry()`方法：此方法除了`self`之外，还接受两个参数：'
- en: '`candle`:  An object of the `CandleTime` type that contains the timestamp of
    the current candle.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`candle`：一个`CandleTime`类型的对象，其中包含当前蜡烛的时间戳。'
- en: '`instruments_bucket`: An object of the `SetInstruments` type that contains
    all the financial instruments available for creating a new position. We pass this
    data at the time of strategy execution (the second recipe of [Chapter 8](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml),
    *Backtesting Strategies*).'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instruments_bucket`：一个`SetInstruments`类型的对象，其中包含用于创建新头寸的所有可用金融工具。我们在策略执行时（[第8章](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml)的第二篇）传递此数据，*回测策略*。'
- en: 'You create two empty lists, `selected_instruments_bucket` and `sideband_info_bucket`.
    You run a `for` loop over `instruments_bucket`. For each instrument, you call
    `self.get_crossover_value()` and save its value to a new attribute, `crossover_value`.
    Based on the value of `crossover_value`, you make a decision, as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建两个空列表，`selected_instruments_bucket`和`sideband_info_bucket`。你对`instruments_bucket`运行一个`for`循环。对于每个工具，你调用`self.get_crossover_value()`并将其值保存到一个新属性`crossover_value`中。根据`crossover_value`的值，你做出以下决定：
- en: 'If `crossover_value` is `1`, it means the strategy is giving a `BUY` signal.
    You do the following:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`crossover_value`是`1`，表示策略发出了`BUY`信号。你执行以下操作：
- en: Append `instrument` to `selected_instruments_bucket`.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`instrument`附加到`selected_instruments_bucket`。
- en: 'Append an `{''action'': ''BUY''}` dictionary to the `sideband_info_bucket`
    attribute.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将一个`{''action'': ''BUY''}`字典附加到`sideband_info_bucket`属性。'
- en: 'If `crossover_value` is `-1`, it means the strategy is giving a `SELL` signal.
    You do the following:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`crossover_value`是`-1`，表示策略发出了`SELL`信号。你执行以下操作：
- en: Append `instrument` to `selected_instruments_bucket`.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`instrument`附加到`selected_instruments_bucket`。
- en: 'Append an `{''action'': ''SELL''}` dictionary to the `sideband_info_bucket`
    attribute.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将一个`{''action'': ''SELL''}`字典附加到`sideband_info_bucket`属性。'
- en: If `crossover_value` is neither `1` nor `-1`, it means the strategy is not giving
    a signal. You do nothing here.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`crossover_value`既不是`1`也不是`-1`，表示策略没有发出信号。你在这里不做任何操作。
- en: Finally, you return both the attributes: `selected_instruments_bucket` and `sideband_info_bucket`.
    These attributes may have been populated or may remain as empty lists.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，你返回这两个属性：`selected_instruments_bucket`和`sideband_info_bucket`。这些属性可能已被填充，也可能保持为空列表。
- en: Recall that the `strategy_select_instruments_for_entry()` method is called for
    every candle, so the preceding steps are repeated for every new candle. In the
    appropriate candle, you will get a `BUY` or `SELL` signal, and in the others,
    you won't get any signal. Based on the signal, you can place the appropriate order,
    which is discussed in the next recipe.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`strategy_select_instruments_for_entry()`方法是为每个蜡烛调用的，因此前面的步骤对于每个新蜡烛都会重复。在适当的蜡烛上，你会得到一个`BUY`或`SELL`信号，在其他蜡烛上，你不会得到任何信号。根据信号，你可以下达适当的订单，这在下一篇中有所讨论。
- en: The `strategy_select_instruments_for_entry()` method is enforced by the `StrategyBase`
    base class and has to be defined for every strategy. The `get_crossover_value()`
    method is a helper method, meaning it is not enforced by the `StrategyBase` base
    class. You may choose not to define this or to define multiple of these helper
    functions.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`strategy_select_instruments_for_entry()`方法是由`StrategyBase`基类强制执行的，必须为每个策略定义。`get_crossover_value()`方法是一个辅助方法，意味着它不是由`StrategyBase`基类强制执行的。您可以选择不定义或定义多个这样的辅助函数。'
- en: MACD-Bracket-Order strategy – coding the strategy_enter_position method
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order策略 - 编写`strategy_enter_position`方法的代码
- en: In this recipe, you will continue with the coding of the `StrategyMACDBracketOrder`
    class. Here, you will code the `strategy_enter_position()` method, a mandatory
    method enforced by the `StrategyBase` base class. This method is called by the
    AlgoBulls core engine every time the `strategy_select_instruments_for_entry()`
    method returns non-empty data. This method may not be called for every new candle
    for backtesting, paper trading, and real trading services.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将继续编写`StrategyMACDBracketOrder`类的代码。在这里，您将编写`strategy_enter_position()`方法，这是由`StrategyBase`基类强制执行的必需方法。该方法由AlgoBulls核心引擎在每次`strategy_select_instruments_for_entry()`方法返回非空数据时调用。对于每个新的蜡烛，这个方法可能不会被调用，用于回测、模拟交易和实盘交易服务。
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how the AlgoBulls core engine calls the `strategy_enter_position()` method during
    strategy execution.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章介绍中的流程图，了解AlgoBulls核心引擎在执行策略时如何调用`strategy_enter_position()`方法。
- en: Getting ready
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have followed the previous recipe before starting this recipe.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这个示例之前，请确保您已经按照上一个示例进行了操作。
- en: How to do it…
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Continue coding the `StrategyMACDBracketOrder` class. Define a method to punch
    new orders for a given instrument and enter a new position:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写`StrategyMACDBracketOrder`类。定义一个方法，为给定的金融工具下新订单并进入新头寸：
- en: '[PRE26]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, we continue coding the `StrategyMACDBracketOrder` class. We
    define a new method for this class, `strategy_enter_position()`, described as
    follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们继续编写`StrategyMACDBracketOrder`类的代码。我们为这个类定义一个新方法，`strategy_enter_position()`，如下所述：
- en: 'This method takes three arguments, other than `self`:'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法除了`self`之外，还需要三个参数：
- en: '`candle`:  An object of the `CandleTime` type that contains the timestamp of
    the current candle.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`candle`: 一个`CandleTime`类型的对象，包含当前蜡烛的时间戳。'
- en: '`instrument`: An object of the `Instrument` type that represents a financial
    instrument.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instrument`: 一个`Instrument`类型的对象，表示一个金融工具。'
- en: '`sideband_info`: A dictionary object that holds information on trades to be
    placed for the `instrument` attribute. This object looks like `{''action'': [action_value]}`,
    where `[action_value]` can be either `''BUY''` or `''SELL''`.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sideband_info`: 一个字典对象，保存了`instrument`属性的交易信息。该对象的格式如下：`{''action'': [action_value]}`，其中`[action_value]`可以是`''BUY''`或`''SELL''`。'
- en: You calculate the quantity for order to be placed by multiplying `self.number_of_lots`
    with `instrument.lot_size` and assign it to a new attribute qty. The `self.number_of_lots`
    attribute holds information on the number of lots to trade, which you can pass
    while executing this strategy. The `instrument.lot_size` attribute holds `lot_size`
    for `instrument`, which is a positive integer. For example, if number of lots
    is passed as 2 and lot size for instrument is 10, then the quantity for the order
    would be 2 * 10 = 20.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您通过将`self.number_of_lots`乘以`instrument.lot_size`来计算要下单的数量，并将其分配给一个新属性qty。`self.number_of_lots`属性保存了要交易的手数信息，您可以在执行此策略时传递。`instrument.lot_size`属性保存了`instrument`的`lot_size`，它是一个正整数。例如，如果手数数为2，而instrument的手数为10，则订单的数量将为2
    * 10 = 20。
- en: 'If `sideband_info` is `{''action'': ''BUY''}`, you place a `Bracket` order
    of the `BUY` transaction type by creating an instance of the `self.broker.BuyOrderBracket` class
    (refer to the first recipe of [Chapter 7](d5760c5d-fa09-4008-ab45-5d7d69c4bde9.xhtml),
    *Placing Bracket and Cover Orders on the Exchange*) and assigning its value to
    `self.main_order[instrument]`.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果`sideband_info`是`{''action'': ''BUY''}`，则通过创建`self.broker.BuyOrderBracket`类的实例（参考[第7章](d5760c5d-fa09-4008-ab45-5d7d69c4bde9.xhtml)的第一个示例，*在交易所上放置Bracket和Cover订单*）并将其赋值给`self.main_order[instrument]`来下一个`Bracket`买单。'
- en: 'Similarly, if `sideband_info` is `{''action'': ''SELL''}`, you place a `Bracket` order
    of the `BUY` transaction type by creating an instance of the `self.broker.SellOrderBracket`
    class (refer to the first recipe of [Chapter 7](d5760c5d-fa09-4008-ab45-5d7d69c4bde9.xhtml), *Placing
    Bracket and Cover Orders on the Exchange*) and assigning its value to `self.main_order[instrument]`.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '类似地，如果`sideband_info`是`{''action'': ''SELL''}`，你通过创建`self.broker.SellOrderBracket`类的实例（参考[第7章](d5760c5d-fa09-4008-ab45-5d7d69c4bde9.xhtml)的第一个示例，*在交易所上放置Bracket和Cover订单*）并将其值赋给`self.main_order[instrument]`来放置一个`BUY`交易类型的`Bracket`订单。'
- en: In both cases, the `self.main_order` dictionary object holds the `instrument`
    and `order` instances as a key-value pair. This will be useful later (in the *MACD-Bracket-Order
    strategy – coding the strategy_exit_position method* recipe) for exiting positions
    created by this method.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种情况下，`self.main_order`字典对象都保存了`instrument`和`order`实例作为键值对。这对于稍后（在*MACD-Bracket-Order
    strategy – coding the strategy_exit_position method*一章中）退出由该方法创建的头寸非常有用。
- en: The `self.broker` attribute is replaced by the appropriate broker instance at
    runtime by the AlgoBulls core engine. So, the same code can work across all the
    brokers supported by the AlgoBulls platform.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.broker`属性在AlgoBulls核心引擎运行时被适当的经纪人实例替换。因此，相同的代码可以在AlgoBulls平台支持的所有经纪人上工作。'
- en: MACD-Bracket-Order strategy – coding the strategy_select_instruments_for_exit
    method
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order策略 – 编写`strategy_select_instruments_for_exit`方法
- en: In this recipe, you will continue with the coding of the `StrategyMACDBracketOrder`
    class. Here, you will code the `strategy_select_instruments_for_exit()` method,
    a mandatory method enforced by the `StrategyBase` base class. This method is called
    by the AlgoBulls core engine for every new candle for backtesting, paper trading,
    and real trading services.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将继续编写`StrategyMACDBracketOrder`类的代码。在这里，您将编写`strategy_select_instruments_for_exit()`方法，这是`StrategyBase`基类强制执行的一个必需方法。这个方法由AlgoBulls核心引擎在每个新蜡烛时调用，用于回测、纸张交易和真实交易服务。
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how the AlgoBulls core engine calls the `strategy_select_instruments_for_exit()`
    method during strategy execution.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章介绍中的流程图，了解AlgoBulls核心引擎在策略执行期间如何调用`strategy_select_instruments_for_exit()`方法。
- en: Getting ready
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Make sure you have followed the previous recipe before starting this recipe.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本示例之前，请确保您已经按照上一个示例的步骤进行了操作。
- en: How to do it…
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Continue coding the `StrategyMACDBracketOrder` class. Define a new method for
    selecting instruments from `instruments_bucket` for exiting an existing position
    based on the computation of the crossover value:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写`StrategyMACDBracketOrder`类。定义一个新方法，根据交叉值的计算从`instruments_bucket`中选择仪器以退出现有头寸：
- en: '[PRE27]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works…
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, we continue coding the `StrategyMACDBracketOrder` class. We
    define a new method for this class, `strategy_select_instruments_for_exit()`,
    described as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们继续编写`StrategyMACDBracketOrder`类的代码。我们为这个类定义一个新的方法，`strategy_select_instruments_for_exit()`，描述如下：
- en: 'This method takes two arguments, other than `self`:'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个方法除了`self`之外还接受两个参数：
- en: '`candle`:  An object of `CandleTime` type that contains the timestamp of the
    current candle.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`candle`：`CandleTime`类型的对象，包含当前蜡烛的时间戳。'
- en: '`instruments_bucket`: An object of `SetInstruments` type. This object holds
    financial instruments that have been entered into a position earlier by the `strategy_enter_position()`
    method.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instruments_bucket`：`SetInstruments`类型的对象。该对象保存了通过`strategy_enter_position()`方法早些时候输入头寸的金融工具。'
- en: You create two empty lists, `selected_instruments_bucket` and `sideband_info_bucket`.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你创建了两个空列表，`selected_instruments_bucket`和`sideband_info_bucket`。
- en: You run a `for` loop over `instruments_bucket`. For each instrument, you check
    whether there is a position entered for the given instrument using the `'if self.main_order.get(instrument)
    is not None:'` line. You proceed only if a position exists already.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你对`instruments_bucket`运行了一个`for`循环。对于每个仪器，你使用`'if self.main_order.get(instrument)
    is not None:'`这一行检查给定仪器是否已输入头寸。只有在已有头寸的情况下才继续进行。
- en: 'You call `self.get_crossover_value()` and save its value to a new attribute,
    `crossover_value`. Based on the value of `crossover_value`, you make a decision,
    as follows:'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你调用了`self.get_crossover_value()`并将其值保存到一个新属性`crossover_value`中。基于`crossover_value`的值，你做出如下决定：
- en: 'If `crossover_value` is either `1` or `-1`, it means there has been a crossover.
    You do the following:'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`crossover_value`是`1`或`-1`，这意味着发生了交叉。你要做如下操作：
- en: Append the `instrument` attribute to `selected_instruments_bucket`.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Append a `{''action'': ''EXIT''}` dictionary to the `sideband_info_bucket`
    attribute.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `crossover_value` is neither `1` nor `-1`, it means the strategy is not giving
    a signal. You do nothing here.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, you return both the attributes, `selected_instruments_bucket` and `sideband_info_bucket`.
    These attributes may have been populated or may remain as empty lists.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recall that the `strategy_select_instruments_for_exit()` method is called for
    every candle, so the preceding steps are repeated for every new candle. In the
    appropriate candle, if there is a position, you may get an `EXIT` signal, and
    in the others, you won't get any signal. Based on the signal, you can exit the
    position by placing an appropriate order, which is discussed in the next recipe.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: MACD-Bracket-Order strategy – coding the strategy_exit_position method
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will continue with the coding of the `StrategyMACDBracketOrder`
    class. Here, you will code the `strategy_exit_position()` method, the last mandatory
    method enforced by the `StrategyBase` base class. This method is called by the
    AlgoBulls core engine every time the `strategy_select_instruments_for_exit` method
    returns non-empty data. By the end of this recipe, you will have completed coding
    the `StrategyMACDBracketOrder` class.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how the AlgoBulls core engine calls the `strategy_select_instruments_for_exit()`
    method during strategy execution.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have followed the previous recipe before starting this recipe.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Continue coding the `StrategyMACDBracketOrder` class. Define a method to the
    exit position for a given instrument based on `sideband_info`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works…
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we continue coding the `StrategyMACDBracketOrder` class. We
    define a new method for this class, `strategy_exit_position()`, described as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'This method takes three arguments, other than `self`:'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`candle`:  An object of the `CandleTime` type that contains the timestamp of
    the current candle.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`instrument`: An object of the `Instrument` type that represents a financial
    instrument.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sideband_info`: A dictionary object that holds information on trades to be
    placed for the `instrument` attribute. This object looks like `{''action'': `EXIT`}`.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If `sideband_info` is `{''action'': ''EXIT''}`, do the following:'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You fetch the order using `self.main_order[instrument]`. (Recall that `self.main_order`
    is a dictionary that holds instruments and corresponding order instances as key-value
    pairs.)
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You exit the position for this order by calling its `exit_position()` method.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since it''s a `Bracket` order strategy, there is the possibility for the `target`
    or `stoploss` order to hit and the position to exit without our strategy knowing
    it. You can still use the `exit_position()` method to handle these scenarios.
    The `exit_position()` method works for both of the following exit scenarios:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: The position is open and you want to exit it yourself.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The position is already exited by the broker due to the completion of either
    the `stoploss` order or the `target` order and there is nothing to be done.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You reset the value corresponding to the key `instrument` in `self.main_order`
    as `None`. This indicates there is no longer a position open corresponding to
    `instrument`.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You return `True`, signaling to the AlgoBulls core engine that a position has
    been exited for `instrument` in this call.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If `sideband_info` is not `{''action'': ''EXIT''}`, you return `False`, signaling
    to the AlgoBulls core engine that no position was exited for `instrument` in this
    call.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `self.broker` attribute is replaced by the appropriate broker instance at
    runtime by the AlgoBulls core engine. So, the same code can work across all the
    brokers supported by the AlgoBulls platform.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: You have now completed the coding for the `StrategyMACDBracketOrder` class.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: MACD-Bracket-Order strategy — uploading the strategy on the AlgoBulls trading
    platform
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will upload the strategy class, `StrategyMACDBracketOrder`,
    which you created in the preceding five recipes, on the AlgoBulls trading platform.
    Once it is uploaded, you can perform backtesting, paper trading, and real trading
    on the same code base.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have set up your account on the AlgoBulls platform ([https://algobulls.com](https://algobulls.com))
    to get your API token. Setting up an account is free. Using its services might
    incur charges depending on your usage. You can start with the free packages on
    the site. Refer to *Appendix II* for more details.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We execute the following steps for this recipe:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary modules:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a new AlgoBulls connection object:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Fetch the authorization URL:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We get the following output:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Log in to the preceding link with your AlgoBulls credentials, fetch your token,
    and set it here (refer to *Appendix II* for more details):'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Before uploading your strategy, you can inspect your strategy code to ensure
    you are uploading the right strategy:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We get the following output:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The complete output is not shown here. Please visit the following link to read
    the complete output:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_macd_bracket_order.py](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_macd_bracket_order.py).'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'Upload `StrategyMACDBracketOrder` onto the AlgoBulls platform. This creates
    a new strategy for your AlgoBulls account:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We get the following output (your output may differ):'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works…
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We import the necessary modules in *step 1*. In *step 2*, an instance of the
    `AlgoBullsConnection` class is created, named `algobulls_connection`. In *step
    3*, you get the authorization URL using the `get_authorization_url()` method of
    the `algobulls_connection` object. You should visit this URL from your web browser
    to sign in to the AlgoBulls platform and fetch your developer access token. (You
    can find more details with screenshots in *Appendix II* on fetching the developer
    access token from the AlgoBulls platform.) You copy the access token and set it
    in *step 4* using the `set_access_token()` method of `algobulls_connection`. If
    the token is accepted, a successful connection is set up with the AlgoBulls platform.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: The `StrategyMACDBracketOrder` strategy class, which we coded in *step 5*, is
    also available in the `pyalgostrategypool` package. We import this class in *step
    1*. Alternatively, you can also save your strategy class in a separate Python
    module and import it in *step 1* instead of importing it from `pyalgostrategypool`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: You upload the `StrategyMACDBracketOrder` strategy class using the `upload_strategy()`
    method of `algobulls_connection` by passing it as a parameter. If the upload is
    successful, you will get a success message with `strategy_code`, which is a unique
    string. `strategy_code` can be used in later chapters to do everything related
    to the strategy—for example, editing the strategy, performing backtesting, performing
    paper trading, and performing real trading.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If there are changes made to a strategy after uploading, you can update the
    strategy on the AlgoBulls platform using the `upload_strategy()` method of `algobulls_connection`
    with the updated class and `overwrite=True` as arguments. If the changes are uploaded
    successfully, you will get a success message.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'You can modify an already-uploaded strategy as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We get the following output:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Multiple strategies with the same name (returned by the `name()` method) are
    not allowed by the AlgoBulls platform. The `overwrite=True` parameter updates
    an existing strategy with the same name if present. If `overwrite=True` is not
    passed to the `create_strategy()` method, the default value is `False`, which
    means it tries to create a new strategy on the AlgoBulls platform.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
